// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_lower.isle
// - src/isa/riscv64/inst.isle
// - src/isa/riscv64/lower.isle
// - /Users/xiangyiz/workspace/near/nearcore_fork/master_epoch_len_300/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_lower.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> Option<u32>;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_as_u32(&mut self, arg0: u8) -> Option<u32>;
    fn u8_as_u64(&mut self, arg0: u8) -> Option<u64>;
    fn u16_as_u64(&mut self, arg0: u16) -> Option<u64>;
    fn u32_as_u64(&mut self, arg0: u32) -> Option<u64>;
    fn i64_as_u64(&mut self, arg0: i64) -> Option<u64>;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_not(&mut self, arg0: u64) -> Option<u64>;
    fn u64_sextend_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u64_uextend_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> Option<bool>;
    fn ty_bits(&mut self, arg0: Type) -> Option<u8>;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Option<Imm64>;
    fn u64_from_ieee32(&mut self, arg0: Ieee32) -> u64;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    fn value_reg(&mut self, arg0: Reg) -> ValueRegs;
    fn value_regs(&mut self, arg0: Reg, arg1: Reg) -> ValueRegs;
    fn value_regs_invalid(&mut self) -> ValueRegs;
    fn output_none(&mut self) -> InstOutput;
    fn output(&mut self, arg0: ValueRegs) -> InstOutput;
    fn output_pair(&mut self, arg0: ValueRegs, arg1: ValueRegs) -> InstOutput;
    fn output_builder_new(&mut self) -> InstOutputBuilder;
    fn output_builder_push(&mut self, arg0: &InstOutputBuilder, arg1: ValueRegs) -> Unit;
    fn output_builder_finish(&mut self, arg0: &InstOutputBuilder) -> InstOutput;
    fn temp_writable_reg(&mut self, arg0: Type) -> WritableReg;
    fn is_valid_reg(&mut self, arg0: Reg) -> bool;
    fn invalid_reg(&mut self) -> Reg;
    fn mark_value_used(&mut self, arg0: Value) -> Unit;
    fn put_in_reg(&mut self, arg0: Value) -> Reg;
    fn put_in_regs(&mut self, arg0: Value) -> ValueRegs;
    fn ensure_in_vreg(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn value_regs_get(&mut self, arg0: ValueRegs, arg1: usize) -> Reg;
    fn value_regs_len(&mut self, arg0: ValueRegs) -> usize;
    fn preg_to_reg(&mut self, arg0: PReg) -> Reg;
    fn value_list_slice(&mut self, arg0: ValueList) -> ValueSlice;
    fn value_slice_empty(&mut self, arg0: ValueSlice) -> Option<()>;
    fn value_slice_unwrap(&mut self, arg0: ValueSlice) -> Option<(Value, ValueSlice)>;
    fn value_slice_len(&mut self, arg0: ValueSlice) -> usize;
    fn value_slice_get(&mut self, arg0: ValueSlice, arg1: usize) -> Value;
    fn same_value(&mut self, arg0: Value, arg1: Value) -> Option<Value>;
    fn writable_reg_to_reg(&mut self, arg0: WritableReg) -> Reg;
    fn inst_results(&mut self, arg0: Inst) -> ValueSlice;
    fn first_result(&mut self, arg0: Inst) -> Option<Value>;
    fn inst_data(&mut self, arg0: Inst) -> InstructionData;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn def_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn zero_value(&mut self, arg0: Value) -> Option<Value>;
    fn is_sinkable_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn emit(&mut self, arg0: &MInst) -> Unit;
    fn sink_inst(&mut self, arg0: Inst) -> Unit;
    fn emit_u64_le_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u128_le_const(&mut self, arg0: u128) -> VCodeConstant;
    fn const_to_vconst(&mut self, arg0: Constant) -> VCodeConstant;
    fn intcc_reverse(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_inverse(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_reverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_inverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn avoid_div_traps(&mut self, arg0: Type) -> Option<()>;
    fn tls_model(&mut self, arg0: Type) -> TlsModel;
    fn tls_model_is_elf_gd(&mut self) -> Option<Unit>;
    fn tls_model_is_macho(&mut self) -> Option<Unit>;
    fn tls_model_is_coff(&mut self) -> Option<Unit>;
    fn preserve_frame_pointers(&mut self) -> Option<Unit>;
    fn box_external_name(&mut self, arg0: ExternalName) -> BoxExternalName;
    fn func_ref_data(&mut self, arg0: FuncRef) -> (SigRef, ExternalName, RelocDistance);
    fn symbol_value_data(
        &mut self,
        arg0: GlobalValue,
    ) -> Option<(ExternalName, RelocDistance, i64)>;
    fn reloc_distance_near(&mut self, arg0: RelocDistance) -> Option<()>;
    fn vec_mask_from_immediate(&mut self, arg0: Immediate) -> Option<VecMask>;
    fn u128_from_immediate(&mut self, arg0: Immediate) -> Option<u128>;
    fn u128_from_constant(&mut self, arg0: Constant) -> Option<u128>;
    fn u64_from_constant(&mut self, arg0: Constant) -> Option<u64>;
    fn only_writable_reg(&mut self, arg0: WritableValueRegs) -> Option<WritableReg>;
    fn writable_regs_get(&mut self, arg0: WritableValueRegs, arg1: usize) -> WritableReg;
    fn abi_num_args(&mut self, arg0: &Sig) -> usize;
    fn abi_get_arg(&mut self, arg0: &Sig, arg1: usize) -> ABIArg;
    fn abi_num_rets(&mut self, arg0: &Sig) -> usize;
    fn abi_get_ret(&mut self, arg0: &Sig, arg1: usize) -> ABIArg;
    fn abi_ret_arg(&mut self, arg0: &Sig) -> Option<ABIArg>;
    fn abi_no_ret_arg(&mut self, arg0: &Sig) -> Option<()>;
    fn abi_sized_stack_arg_space(&mut self, arg0: &Sig) -> i64;
    fn abi_sized_stack_ret_space(&mut self, arg0: &Sig) -> i64;
    fn abi_stackslot_addr(&mut self, arg0: WritableReg, arg1: StackSlot, arg2: Offset32) -> MInst;
    fn abi_dynamic_stackslot_addr(&mut self, arg0: WritableReg, arg1: DynamicStackSlot) -> MInst;
    fn abi_arg_only_slot(&mut self, arg0: &ABIArg) -> Option<ABIArgSlot>;
    fn abi_arg_struct_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, u64)>;
    fn abi_arg_implicit_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, Type)>;
    fn real_reg_to_reg(&mut self, arg0: RealReg) -> Reg;
    fn real_reg_to_writable_reg(&mut self, arg0: RealReg) -> WritableReg;
    fn gen_move(&mut self, arg0: Type, arg1: WritableReg, arg2: Reg) -> MInst;
    fn gen_return(&mut self, arg0: ValueSlice) -> Unit;
    fn zero_reg(&mut self) -> Reg;
    fn imm(&mut self, arg0: Type, arg1: u64) -> Reg;
    fn imm_from_bits(&mut self, arg0: u64) -> Imm12;
    fn imm_from_neg_bits(&mut self, arg0: i64) -> Imm12;
    fn imm12_from_u64(&mut self, arg0: u64) -> Option<Imm12>;
    fn writable_zero_reg(&mut self) -> WritableReg;
    fn gen_default_frm(&mut self) -> OptionFloatRoundingMode;
    fn pack_float_rounding_mode(&mut self, arg0: &FRM) -> OptionFloatRoundingMode;
    fn neg_imm12(&mut self, arg0: Imm12) -> Imm12;
    fn u8_as_i32(&mut self, arg0: u8) -> i32;
    fn gen_select_reg(&mut self, arg0: &IntCC, arg1: Reg, arg2: Reg, arg3: Reg, arg4: Reg) -> Reg;
    fn load_u64_constant(&mut self, arg0: u64) -> Reg;
    fn ext_sign_bit(&mut self, arg0: Type, arg1: Reg) -> Reg;
    fn has_b(&mut self) -> Option<bool>;
    fn gen_shamt(&mut self, arg0: Type, arg1: Reg) -> ValueRegs;
    fn valueregs_2_reg(&mut self, arg0: Value) -> Reg;
    fn imm12_const(&mut self, arg0: i32) -> Imm12;
    fn imm12_const_add(&mut self, arg0: i32, arg1: i32) -> Imm12;
    fn imm12_and(&mut self, arg0: Imm12, arg1: i32) -> Imm12;
    fn gen_amode(&mut self, arg0: Reg, arg1: Offset32, arg2: Type) -> AMode;
    fn offset32_imm(&mut self, arg0: i32) -> Offset32;
    fn default_memflags(&mut self) -> MemFlags;
    fn offset32_add(&mut self, arg0: Offset32, arg1: i64) -> Offset32;
    fn valid_atomic_transaction(&mut self, arg0: Type) -> Option<Type>;
    fn atomic_amo(&mut self) -> AMO;
    fn move_f_to_x(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn move_x_to_f(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn gen_stack_addr(&mut self, arg0: StackSlot, arg1: Offset32) -> Reg;
    fn gen_move2(&mut self, arg0: Reg, arg1: Type, arg2: Type) -> Reg;
    fn gen_moves(&mut self, arg0: ValueRegs, arg1: Type, arg2: Type) -> ValueRegs;
    fn vec_writable_clone(&mut self, arg0: &VecWritableReg) -> VecWritableReg;
    fn vec_writable_to_regs(&mut self, arg0: &VecWritableReg) -> ValueRegs;
    fn alloc_vec_writable(&mut self, arg0: Type) -> VecWritableReg;
    fn load_op(&mut self, arg0: Type) -> LoadOP;
    fn store_op(&mut self, arg0: Type) -> StoreOP;
    fn load_ext_name(&mut self, arg0: ExternalName, arg1: i64) -> Reg;
    fn int_convert_2_float_op(&mut self, arg0: Type, arg1: bool, arg2: Type) -> FpuOPRR;
    fn intcc_is_gt_etc(&mut self, arg0: &IntCC) -> Option<(IntCC, bool)>;
    fn intcc_is_eq_or_ne(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn inst_output_get(&mut self, arg0: InstOutput, arg1: u8) -> ValueRegs;
    fn label_to_br_target(&mut self, arg0: MachLabel) -> BranchTarget;
    fn vec_label_get(&mut self, arg0: &VecMachLabel, arg1: u8) -> MachLabel;
    fn lower_br_icmp(
        &mut self,
        arg0: &IntCC,
        arg1: ValueRegs,
        arg2: ValueRegs,
        arg3: &VecMachLabel,
        arg4: Type,
    ) -> InstOutput;
    fn lower_br_fcmp(
        &mut self,
        arg0: &FloatCC,
        arg1: Reg,
        arg2: Reg,
        arg3: &VecMachLabel,
        arg4: Type,
    ) -> InstOutput;
    fn int_zero_reg(&mut self, arg0: Type) -> ValueRegs;
    fn lower_brz_or_nz(
        &mut self,
        arg0: &IntCC,
        arg1: ValueRegs,
        arg2: &VecMachLabel,
        arg3: Type,
    ) -> InstOutput;
    fn lower_br_table(&mut self, arg0: Reg, arg1: &VecMachLabel) -> InstOutput;
    fn x_reg(&mut self, arg0: u8) -> Reg;
    fn load_ra(&mut self) -> Reg;
    fn has_zbkb(&mut self) -> Option<bool>;
    fn shift_int_to_most_significant(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn gen_call(
        &mut self,
        arg0: SigRef,
        arg1: ExternalName,
        arg2: RelocDistance,
        arg3: ValueSlice,
    ) -> InstOutput;
    fn gen_call_indirect(&mut self, arg0: SigRef, arg1: Value, arg2: ValueSlice) -> InstOutput;
    fn is_atomic_rmw_max_etc(&mut self, arg0: &AtomicRmwOp) -> Option<(AtomicRmwOp, bool)>;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

/// Internal type SideEffectNoResult: defined at src/prelude_lower.isle line 290.
#[derive(Clone, Debug)]
pub enum SideEffectNoResult {
    Inst {
        inst: MInst,
    },
    Inst2 {
        inst1: MInst,
        inst2: MInst,
    },
    Inst3 {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
    },
}

/// Internal type ProducesFlags: defined at src/prelude_lower.isle line 346.
#[derive(Clone, Debug)]
pub enum ProducesFlags {
    AlreadyExistingFlags,
    ProducesFlagsSideEffect { inst: MInst },
    ProducesFlagsTwiceSideEffect { inst1: MInst, inst2: MInst },
    ProducesFlagsReturnsReg { inst: MInst, result: Reg },
    ProducesFlagsReturnsResultWithConsumer { inst: MInst, result: Reg },
}

/// Internal type ConsumesFlags: defined at src/prelude_lower.isle line 368.
#[derive(Clone, Debug)]
pub enum ConsumesFlags {
    ConsumesFlagsSideEffect {
        inst: MInst,
    },
    ConsumesFlagsSideEffect2 {
        inst1: MInst,
        inst2: MInst,
    },
    ConsumesFlagsReturnsResultWithProducer {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsTwiceReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        result: ValueRegs,
    },
    ConsumesFlagsFourTimesReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
        inst4: MInst,
        result: ValueRegs,
    },
}

/// Internal type MInst: defined at src/isa/riscv64/inst.isle line 2.
#[derive(Clone, Debug)]
pub enum MInst {
    Nop0,
    Nop4,
    Lui {
        rd: WritableReg,
        imm: Imm20,
    },
    Auipc {
        rd: WritableReg,
        imm: Imm20,
    },
    FpuRR {
        alu_op: FpuOPRR,
        frm: OptionFloatRoundingMode,
        rd: WritableReg,
        rs: Reg,
    },
    AluRRR {
        alu_op: AluOPRRR,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
    },
    FpuRRR {
        alu_op: FpuOPRRR,
        frm: OptionFloatRoundingMode,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
    },
    FpuRRRR {
        alu_op: FpuOPRRRR,
        frm: OptionFloatRoundingMode,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
        rs3: Reg,
    },
    AluRRImm12 {
        alu_op: AluOPRRI,
        rd: WritableReg,
        rs: Reg,
        imm12: Imm12,
    },
    Load {
        rd: WritableReg,
        op: LoadOP,
        flags: MemFlags,
        from: AMode,
    },
    Store {
        to: AMode,
        op: StoreOP,
        flags: MemFlags,
        src: Reg,
    },
    Args {
        args: VecArgPair,
    },
    Ret {
        rets: VecRetPair,
    },
    Extend {
        rd: WritableReg,
        rn: Reg,
        signed: bool,
        from_bits: u8,
        to_bits: u8,
    },
    AjustSp {
        amount: i64,
    },
    Call {
        info: BoxCallInfo,
    },
    CallInd {
        info: BoxCallIndInfo,
    },
    TrapIf {
        test: Reg,
        trap_code: TrapCode,
    },
    TrapIfC {
        rs1: Reg,
        rs2: Reg,
        cc: IntCC,
        trap_code: TrapCode,
    },
    TrapFf {
        cc: FloatCC,
        x: Reg,
        y: Reg,
        ty: Type,
        tmp: WritableReg,
        trap_code: TrapCode,
    },
    Jal {
        dest: BranchTarget,
    },
    CondBr {
        taken: BranchTarget,
        not_taken: BranchTarget,
        kind: IntegerCompare,
    },
    LoadExtName {
        rd: WritableReg,
        name: BoxExternalName,
        offset: i64,
    },
    LoadAddr {
        rd: WritableReg,
        mem: AMode,
    },
    VirtualSPOffsetAdj {
        amount: i64,
    },
    Mov {
        rd: WritableReg,
        rm: Reg,
        ty: Type,
    },
    Fence {
        pred: u8,
        succ: u8,
    },
    FenceI,
    ECall,
    EBreak,
    Udf {
        trap_code: TrapCode,
    },
    Jalr {
        rd: WritableReg,
        base: Reg,
        offset: Imm12,
    },
    Atomic {
        op: AtomicOP,
        rd: WritableReg,
        addr: Reg,
        src: Reg,
        amo: AMO,
    },
    AtomicStore {
        src: Reg,
        ty: Type,
        p: Reg,
    },
    AtomicLoad {
        rd: WritableReg,
        ty: Type,
        p: Reg,
    },
    AtomicRmwLoop {
        offset: Reg,
        op: AtomicRmwOp,
        dst: WritableReg,
        ty: Type,
        p: Reg,
        x: Reg,
        t0: WritableReg,
    },
    Fcmp {
        cc: FloatCC,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
        ty: Type,
    },
    Select {
        dst: VecWritableReg,
        ty: Type,
        condition: Reg,
        x: ValueRegs,
        y: ValueRegs,
    },
    ReferenceCheck {
        rd: WritableReg,
        op: ReferenceCheckOP,
        x: Reg,
    },
    BrTableCheck {
        index: Reg,
        targets_len: i32,
        default_: BranchTarget,
    },
    BrTable {
        index: Reg,
        tmp1: WritableReg,
        targets: VecBranchTarget,
    },
    AtomicCas {
        offset: Reg,
        t0: WritableReg,
        dst: WritableReg,
        e: Reg,
        addr: Reg,
        v: Reg,
        ty: Type,
    },
    IntSelect {
        op: IntSelectOP,
        dst: VecWritableReg,
        x: ValueRegs,
        y: ValueRegs,
        ty: Type,
    },
    Csr {
        csr_op: CsrOP,
        rd: WritableReg,
        rs: OptionReg,
        imm: OptionUimm5,
        csr: CsrAddress,
    },
    Icmp {
        cc: IntCC,
        rd: WritableReg,
        a: ValueRegs,
        b: ValueRegs,
        ty: Type,
    },
    SelectReg {
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
        condition: IntegerCompare,
    },
    FcvtToInt {
        is_sat: bool,
        rd: WritableReg,
        tmp: WritableReg,
        rs: Reg,
        is_signed: bool,
        in_type: Type,
        out_type: Type,
    },
    SelectIf {
        if_spectre_guard: bool,
        rd: VecWritableReg,
        test: Reg,
        x: ValueRegs,
        y: ValueRegs,
    },
    RawData {
        data: VecU8,
    },
    Unwind {
        inst: UnwindInst,
    },
    DummyUse {
        reg: Reg,
    },
    FloatRound {
        op: FloatRoundOP,
        rd: WritableReg,
        int_tmp: WritableReg,
        f_tmp: WritableReg,
        rs: Reg,
        ty: Type,
    },
    FloatSelect {
        op: FloatSelectOP,
        rd: WritableReg,
        tmp: WritableReg,
        rs1: Reg,
        rs2: Reg,
        ty: Type,
    },
    FloatSelectPseudo {
        op: FloatSelectOP,
        rd: WritableReg,
        tmp: WritableReg,
        rs1: Reg,
        rs2: Reg,
        ty: Type,
    },
    Popcnt {
        sum: WritableReg,
        step: WritableReg,
        tmp: WritableReg,
        rs: Reg,
        ty: Type,
    },
    Cltz {
        leading: bool,
        sum: WritableReg,
        step: WritableReg,
        tmp: WritableReg,
        rs: Reg,
        ty: Type,
    },
    Rev8 {
        rs: Reg,
        step: WritableReg,
        tmp: WritableReg,
        rd: WritableReg,
    },
    Brev8 {
        rs: Reg,
        ty: Type,
        step: WritableReg,
        tmp: WritableReg,
        tmp2: WritableReg,
        rd: WritableReg,
    },
    StackProbeLoop {
        guard_size: u32,
        probe_count: u32,
        tmp: WritableReg,
    },
}

/// Internal type FloatSelectOP: defined at src/isa/riscv64/inst.isle line 348.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FloatSelectOP {
    Max,
    Min,
}

/// Internal type FloatRoundOP: defined at src/isa/riscv64/inst.isle line 353.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FloatRoundOP {
    Nearest,
    Ceil,
    Floor,
    Trunc,
}

/// Internal type CsrOP: defined at src/isa/riscv64/inst.isle line 360.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum CsrOP {
    Csrrw,
    Csrrs,
    Csrrc,
    Csrrwi,
    Csrrsi,
    Csrrci,
}

/// Internal type IntSelectOP: defined at src/isa/riscv64/inst.isle line 369.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum IntSelectOP {
    Smax,
    Umax,
    Smin,
    Umin,
}

/// Internal type ReferenceCheckOP: defined at src/isa/riscv64/inst.isle line 376.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ReferenceCheckOP {
    IsNull,
    IsInvalid,
}

/// Internal type AtomicOP: defined at src/isa/riscv64/inst.isle line 381.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AtomicOP {
    LrW,
    ScW,
    AmoswapW,
    AmoaddW,
    AmoxorW,
    AmoandW,
    AmoorW,
    AmominW,
    AmomaxW,
    AmominuW,
    AmomaxuW,
    LrD,
    ScD,
    AmoswapD,
    AmoaddD,
    AmoxorD,
    AmoandD,
    AmoorD,
    AmominD,
    AmomaxD,
    AmominuD,
    AmomaxuD,
}

/// Internal type FpuOPRRRR: defined at src/isa/riscv64/inst.isle line 406.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FpuOPRRRR {
    FmaddS,
    FmsubS,
    FnmsubS,
    FnmaddS,
    FmaddD,
    FmsubD,
    FnmsubD,
    FnmaddD,
}

/// Internal type FClassResult: defined at src/isa/riscv64/inst.isle line 419.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FClassResult {
    NegInfinite,
    NegNormal,
    NegSubNormal,
    NegZero,
    PosZero,
    PosSubNormal,
    PosNormal,
    PosInfinite,
    SNaN,
    QNaN,
}

/// Internal type FpuOPRR: defined at src/isa/riscv64/inst.isle line 442.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FpuOPRR {
    FsqrtS,
    FcvtWS,
    FcvtWuS,
    FmvXW,
    FclassS,
    FcvtSw,
    FcvtSwU,
    FmvWX,
    FcvtLS,
    FcvtLuS,
    FcvtSL,
    FcvtSLU,
    FcvtLD,
    FcvtLuD,
    FmvXD,
    FcvtDL,
    FcvtDLu,
    FmvDX,
    FsqrtD,
    FcvtSD,
    FcvtDS,
    FclassD,
    FcvtWD,
    FcvtWuD,
    FcvtDW,
    FcvtDWU,
}

/// Internal type LoadOP: defined at src/isa/riscv64/inst.isle line 482.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum LoadOP {
    Lb,
    Lh,
    Lw,
    Lbu,
    Lhu,
    Lwu,
    Ld,
    Flw,
    Fld,
}

/// Internal type StoreOP: defined at src/isa/riscv64/inst.isle line 494.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum StoreOP {
    Sb,
    Sh,
    Sw,
    Sd,
    Fsw,
    Fsd,
}

/// Internal type AluOPRRR: defined at src/isa/riscv64/inst.isle line 503.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AluOPRRR {
    Add,
    Sub,
    Sll,
    Slt,
    SltU,
    Sgt,
    Sgtu,
    Xor,
    Srl,
    Sra,
    Or,
    And,
    Addw,
    Subw,
    Sllw,
    Srlw,
    Sraw,
    Mul,
    Mulh,
    Mulhsu,
    Mulhu,
    Div,
    DivU,
    Rem,
    RemU,
    Mulw,
    Divw,
    Divuw,
    Remw,
    Remuw,
    Adduw,
    Andn,
    Bclr,
    Bext,
    Binv,
    Bset,
    Clmul,
    Clmulh,
    Clmulr,
    Max,
    Maxu,
    Min,
    Minu,
    Orn,
    Rol,
    Rolw,
    Ror,
    Rorw,
    Sh1add,
    Sh1adduw,
    Sh2add,
    Sh2adduw,
    Sh3add,
    Sh3adduw,
    Xnor,
}

/// Internal type FpuOPRRR: defined at src/isa/riscv64/inst.isle line 573.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FpuOPRRR {
    FaddS,
    FsubS,
    FmulS,
    FdivS,
    FsgnjS,
    FsgnjnS,
    FsgnjxS,
    FminS,
    FmaxS,
    FeqS,
    FltS,
    FleS,
    FaddD,
    FsubD,
    FmulD,
    FdivD,
    FsgnjD,
    FsgnjnD,
    FsgnjxD,
    FminD,
    FmaxD,
    FeqD,
    FltD,
    FleD,
}

/// Internal type AluOPRRI: defined at src/isa/riscv64/inst.isle line 606.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AluOPRRI {
    Addi,
    Slti,
    SltiU,
    Xori,
    Ori,
    Andi,
    Slli,
    Srli,
    Srai,
    Addiw,
    Slliw,
    SrliW,
    Sraiw,
    Bclri,
    Bexti,
    Binvi,
    Bseti,
    Rori,
    Roriw,
    SlliUw,
    Clz,
    Clzw,
    Cpop,
    Cpopw,
    Ctz,
    Ctzw,
    Rev8,
    Sextb,
    Sexth,
    Zexth,
    Orcb,
    Brev8,
}

/// Internal type FRM: defined at src/isa/riscv64/inst.isle line 642.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FRM {
    RNE,
    RTZ,
    RDN,
    RUP,
    RMM,
    Fcsr,
}

/// Internal type FFlagsException: defined at src/isa/riscv64/inst.isle line 658.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FFlagsException {
    NV,
    DZ,
    OF,
    UF,
    NX,
}

/// Internal type FenceFm: defined at src/isa/riscv64/inst.isle line 677.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FenceFm {
    None,
    Tso,
}

// Generated as internal constructor for term output_reg.
pub fn constructor_output_reg<C: Context>(ctx: &mut C, arg0: Reg) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 60.
    let expr0_0 = C::value_reg(ctx, pattern0_0);
    let expr1_0 = C::output(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term output_value.
pub fn constructor_output_value<C: Context>(ctx: &mut C, arg0: Value) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 64.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0 = C::output(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term temp_reg.
pub fn constructor_temp_reg<C: Context>(ctx: &mut C, arg0: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 84.
    let expr0_0 = C::temp_writable_reg(ctx, pattern0_0);
    let expr1_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term value_regs_range.
pub fn constructor_value_regs_range<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Option<Range> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 133.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_len(ctx, pattern0_0);
    let expr2_0 = C::range(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term lo_reg.
pub fn constructor_lo_reg<C: Context>(ctx: &mut C, arg0: Value) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 144.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term side_effect.
pub fn constructor_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &SideEffectNoResult::Inst {
            inst: ref pattern1_0,
        } => {
            // Rule at src/prelude_lower.isle line 301.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::output_none(ctx);
            return Some(expr1_0);
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            // Rule at src/prelude_lower.isle line 304.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::emit(ctx, pattern1_1);
            let expr2_0 = C::output_none(ctx);
            return Some(expr2_0);
        }
        &SideEffectNoResult::Inst3 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
            inst3: ref pattern1_2,
        } => {
            // Rule at src/prelude_lower.isle line 308.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::emit(ctx, pattern1_1);
            let expr2_0 = C::emit(ctx, pattern1_2);
            let expr3_0 = C::output_none(ctx);
            return Some(expr3_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term side_effect_concat.
pub fn constructor_side_effect_concat<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
    arg1: &SideEffectNoResult,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &SideEffectNoResult::Inst {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &SideEffectNoResult::Inst {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 315.
                    let expr0_0 = SideEffectNoResult::Inst2 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                    };
                    return Some(expr0_0);
                }
                &SideEffectNoResult::Inst2 {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 317.
                    let expr0_0 = SideEffectNoResult::Inst3 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                        inst3: pattern3_1.clone(),
                    };
                    return Some(expr0_0);
                }
                _ => {}
            }
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &SideEffectNoResult::Inst {
                inst: ref pattern3_0,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 319.
                let expr0_0 = SideEffectNoResult::Inst3 {
                    inst1: pattern1_0.clone(),
                    inst2: pattern1_1.clone(),
                    inst3: pattern3_0.clone(),
                };
                return Some(expr0_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term produces_flags_append.
pub fn constructor_produces_flags_append<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &MInst,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    if let &ProducesFlags::ProducesFlagsSideEffect {
        inst: ref pattern1_0,
    } = pattern0_0
    {
        let pattern2_0 = arg1;
        // Rule at src/prelude_lower.isle line 361.
        let expr0_0 = ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: pattern1_0.clone(),
            inst2: pattern2_0.clone(),
        };
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term produces_flags_get_reg.
pub fn constructor_produces_flags_get_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    if let &ProducesFlags::ProducesFlagsReturnsReg {
        inst: ref pattern1_0,
        result: pattern1_1,
    } = pattern0_0
    {
        // Rule at src/prelude_lower.isle line 386.
        return Some(pattern1_1);
    }
    return None;
}

// Generated as internal constructor for term produces_flags_ignore.
pub fn constructor_produces_flags_ignore<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            // Rule at src/prelude_lower.isle line 391.
            let expr0_0 = ProducesFlags::ProducesFlagsSideEffect {
                inst: pattern1_0.clone(),
            };
            return Some(expr0_0);
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            // Rule at src/prelude_lower.isle line 393.
            let expr0_0 = ProducesFlags::ProducesFlagsSideEffect {
                inst: pattern1_0.clone(),
            };
            return Some(expr0_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term consumes_flags_concat.
pub fn constructor_consumes_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
    arg1: &ConsumesFlags,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ConsumesFlags::ConsumesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref pattern3_0,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 406.
                let expr0_0 = ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: pattern1_0.clone(),
                    inst2: pattern3_0.clone(),
                };
                return Some(expr0_0);
            }
        }
        &ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: ref pattern3_0,
                result: pattern3_1,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 400.
                let expr0_0 = C::value_regs(ctx, pattern1_1, pattern3_1);
                let expr1_0 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: pattern1_0.clone(),
                    inst2: pattern3_0.clone(),
                    result: expr0_0,
                };
                return Some(expr1_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term with_flags.
pub fn constructor_with_flags<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 437.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_reg(ctx, pattern3_1);
                    return Some(expr2_0);
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    result: pattern3_2,
                } => {
                    // Rule at src/prelude_lower.isle line 443.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::emit(ctx, pattern3_1);
                    return Some(pattern3_2);
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    inst3: ref pattern3_2,
                    inst4: ref pattern3_3,
                    result: pattern3_4,
                } => {
                    // Rule at src/prelude_lower.isle line 455.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::emit(ctx, pattern3_1);
                    let expr3_0 = C::emit(ctx, pattern3_2);
                    let expr4_0 = C::emit(ctx, pattern3_3);
                    return Some(pattern3_4);
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 431.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_reg(ctx, pattern1_1);
                    return Some(expr2_0);
                }
                &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 423.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_regs(ctx, pattern1_1, pattern3_1);
                    return Some(expr2_0);
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 471.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern1_1);
                    let expr2_0 = C::emit(ctx, pattern3_0);
                    let expr3_0 = C::value_reg(ctx, pattern3_1);
                    return Some(expr3_0);
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    result: pattern3_2,
                } => {
                    // Rule at src/prelude_lower.isle line 478.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern1_1);
                    let expr2_0 = C::emit(ctx, pattern3_0);
                    let expr3_0 = C::emit(ctx, pattern3_1);
                    return Some(pattern3_2);
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    inst3: ref pattern3_2,
                    inst4: ref pattern3_3,
                    result: pattern3_4,
                } => {
                    // Rule at src/prelude_lower.isle line 491.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern1_1);
                    let expr2_0 = C::emit(ctx, pattern3_0);
                    let expr3_0 = C::emit(ctx, pattern3_1);
                    let expr4_0 = C::emit(ctx, pattern3_2);
                    let expr5_0 = C::emit(ctx, pattern3_3);
                    return Some(pattern3_4);
                }
                _ => {}
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term with_flags_reg.
pub fn constructor_with_flags_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/prelude_lower.isle line 509.
    let expr0_0 = constructor_with_flags(ctx, pattern0_0, pattern1_0)?;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term flags_to_producesflags.
pub fn constructor_flags_to_producesflags<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 516.
    let expr0_0 = C::mark_value_used(ctx, pattern0_0);
    let expr1_0 = ProducesFlags::AlreadyExistingFlags;
    return Some(expr1_0);
}

// Generated as internal constructor for term with_flags_side_effect.
pub fn constructor_with_flags_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::AlreadyExistingFlags => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 527.
                    let expr0_0 = SideEffectNoResult::Inst {
                        inst: pattern3_0.clone(),
                    };
                    return Some(expr0_0);
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 532.
                    let expr0_0 = SideEffectNoResult::Inst2 {
                        inst1: pattern3_0.clone(),
                        inst2: pattern3_1.clone(),
                    };
                    return Some(expr0_0);
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 537.
                    let expr0_0 = SideEffectNoResult::Inst2 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                    };
                    return Some(expr0_0);
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 542.
                    let expr0_0 = SideEffectNoResult::Inst3 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                        inst3: pattern3_1.clone(),
                    };
                    return Some(expr0_0);
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref pattern3_0,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 547.
                let expr0_0 = SideEffectNoResult::Inst3 {
                    inst1: pattern1_0.clone(),
                    inst2: pattern1_1.clone(),
                    inst3: pattern3_0.clone(),
                };
                return Some(expr0_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term lower_return.
pub fn constructor_lower_return<C: Context>(
    ctx: &mut C,
    arg0: Range,
    arg1: ValueSlice,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/prelude_lower.isle line 727.
    let expr0_0 = C::gen_return(ctx, pattern1_0);
    let expr1_0 = C::output_none(ctx);
    return Some(expr1_0);
}

// Generated as internal constructor for term value_regs_zero.
pub fn constructor_value_regs_zero<C: Context>(ctx: &mut C) -> Option<ValueRegs> {
    // Rule at src/isa/riscv64/inst.isle line 707.
    let expr0_0: Type = I64;
    let expr1_0: u64 = 0i128 as u64;
    let expr2_0 = C::imm(ctx, expr0_0, expr1_0);
    let expr3_0: Type = I64;
    let expr4_0: u64 = 0i128 as u64;
    let expr5_0 = C::imm(ctx, expr3_0, expr4_0);
    let expr6_0 = C::value_regs(ctx, expr2_0, expr5_0);
    return Some(expr6_0);
}

// Generated as internal constructor for term gen_float_round.
pub fn constructor_gen_float_round<C: Context>(
    ctx: &mut C,
    arg0: &FloatRoundOP,
    arg1: Reg,
    arg2: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 712.
    let expr0_0 = C::temp_writable_reg(ctx, pattern2_0);
    let expr1_0: Type = I64;
    let expr2_0 = C::temp_writable_reg(ctx, expr1_0);
    let expr3_0: Type = F64;
    let expr4_0 = C::temp_writable_reg(ctx, expr3_0);
    let expr5_0 = MInst::FloatRound {
        op: pattern0_0.clone(),
        rd: expr0_0,
        int_tmp: expr2_0,
        f_tmp: expr4_0,
        rs: pattern1_0,
        ty: pattern2_0,
    };
    let expr6_0 = C::emit(ctx, &expr5_0);
    let expr7_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr7_0);
}

// Generated as internal constructor for term gen_float_select_pseudo.
pub fn constructor_gen_float_select_pseudo<C: Context>(
    ctx: &mut C,
    arg0: &FloatSelectOP,
    arg1: Reg,
    arg2: Reg,
    arg3: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 722.
    let expr0_0 = C::temp_writable_reg(ctx, pattern3_0);
    let expr1_0: Type = I64;
    let expr2_0 = C::temp_writable_reg(ctx, expr1_0);
    let expr3_0 = MInst::FloatSelectPseudo {
        op: pattern0_0.clone(),
        rd: expr0_0,
        tmp: expr2_0,
        rs1: pattern1_0,
        rs2: pattern2_0,
        ty: pattern3_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term gen_float_select.
pub fn constructor_gen_float_select<C: Context>(
    ctx: &mut C,
    arg0: &FloatSelectOP,
    arg1: Reg,
    arg2: Reg,
    arg3: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 731.
    let expr0_0 = C::temp_writable_reg(ctx, pattern3_0);
    let expr1_0: Type = I64;
    let expr2_0 = C::temp_writable_reg(ctx, expr1_0);
    let expr3_0 = MInst::FloatSelect {
        op: pattern0_0.clone(),
        rd: expr0_0,
        tmp: expr2_0,
        rs1: pattern1_0,
        rs2: pattern2_0,
        ty: pattern3_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term fpu_rr.
pub fn constructor_fpu_rr<C: Context>(
    ctx: &mut C,
    arg0: &FpuOPRR,
    arg1: Type,
    arg2: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 760.
    let expr0_0 = C::temp_writable_reg(ctx, pattern1_0);
    let expr1_0 = C::gen_default_frm(ctx);
    let expr2_0 = MInst::FpuRR {
        alu_op: pattern0_0.clone(),
        frm: expr1_0,
        rd: expr0_0,
        rs: pattern2_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term alu_rrr.
pub fn constructor_alu_rrr<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRR,
    arg1: Reg,
    arg2: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 767.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AluRRR {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs1: pattern1_0,
        rs2: pattern2_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term alu_add.
pub fn constructor_alu_add<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 775.
    let expr0_0 = AluOPRRR::Add;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term alu_and.
pub fn constructor_alu_and<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 780.
    let expr0_0 = AluOPRRR::And;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term alu_sub.
pub fn constructor_alu_sub<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 787.
    let expr0_0 = AluOPRRR::Sub;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term fpu_rrr.
pub fn constructor_fpu_rrr<C: Context>(
    ctx: &mut C,
    arg0: &FpuOPRRR,
    arg1: Type,
    arg2: Reg,
    arg3: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 795.
    let expr0_0 = C::temp_writable_reg(ctx, pattern1_0);
    let expr1_0 = C::gen_default_frm(ctx);
    let expr2_0 = MInst::FpuRRR {
        alu_op: pattern0_0.clone(),
        frm: expr1_0,
        rd: expr0_0,
        rs1: pattern2_0,
        rs2: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term fpu_rrrr.
pub fn constructor_fpu_rrrr<C: Context>(
    ctx: &mut C,
    arg0: &FpuOPRRRR,
    arg1: Type,
    arg2: Reg,
    arg3: Reg,
    arg4: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 803.
    let expr0_0 = C::temp_writable_reg(ctx, pattern1_0);
    let expr1_0 = C::gen_default_frm(ctx);
    let expr2_0 = MInst::FpuRRRR {
        alu_op: pattern0_0.clone(),
        frm: expr1_0,
        rd: expr0_0,
        rs1: pattern2_0,
        rs2: pattern3_0,
        rs3: pattern4_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term alu_rr_imm12.
pub fn constructor_alu_rr_imm12<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRI,
    arg1: Reg,
    arg2: Imm12,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 811.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AluRRImm12 {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs: pattern1_0,
        imm12: pattern2_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term alu_andi.
pub fn constructor_alu_andi<C: Context>(ctx: &mut C, arg0: Reg, arg1: i32) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 817.
    let expr0_0 = AluOPRRI::Andi;
    let expr1_0 = C::imm12_const(ctx, pattern1_0);
    let expr2_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern0_0, expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term alu_slli.
pub fn constructor_alu_slli<C: Context>(ctx: &mut C, arg0: Reg, arg1: i32) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 822.
    let expr0_0 = AluOPRRI::Slli;
    let expr1_0 = C::imm12_const(ctx, pattern1_0);
    let expr2_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern0_0, expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term alu_srli.
pub fn constructor_alu_srli<C: Context>(ctx: &mut C, arg0: Reg, arg1: i32) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 825.
    let expr0_0 = AluOPRRI::Srli;
    let expr1_0 = C::imm12_const(ctx, pattern1_0);
    let expr2_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern0_0, expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term alu_rr_funct12.
pub fn constructor_alu_rr_funct12<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRI,
    arg1: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 831.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = constructor_imm12_zero(ctx)?;
    let expr3_0 = MInst::AluRRImm12 {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs: pattern1_0,
        imm12: expr2_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term ext_int_if_need.
pub fn constructor_ext_int_if_need<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: ValueRegs,
    arg2: Type,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if pattern2_0 == I64 {
        // Rule at src/isa/riscv64/inst.isle line 845.
        return Some(pattern1_0);
    }
    if pattern2_0 == I128 {
        // Rule at src/isa/riscv64/inst.isle line 848.
        return Some(pattern1_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if let Some(pattern3_0) = C::fits_in_32(ctx, pattern2_0) {
        // Rule at src/isa/riscv64/inst.isle line 839.
        let expr0_0 = constructor_convert_valueregs_reg(ctx, pattern1_0)?;
        let expr1_0 = C::ty_bits(ctx, pattern3_0)?;
        let expr2_0: u8 = 64i128 as u8;
        let expr3_0 = constructor_gen_extend(ctx, expr0_0, pattern0_0, expr1_0, expr2_0)?;
        let expr4_0 = C::value_reg(ctx, expr3_0);
        return Some(expr4_0);
    }
    return None;
}

// Generated as internal constructor for term select_addi.
pub fn constructor_select_addi<C: Context>(ctx: &mut C, arg0: Type) -> Option<AluOPRRI> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_32(ctx, pattern0_0) {
        // Rule at src/isa/riscv64/inst.isle line 864.
        let expr0_0 = AluOPRRI::Addiw;
        return Some(expr0_0);
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        // Rule at src/isa/riscv64/inst.isle line 865.
        let expr0_0 = AluOPRRI::Addi;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term bnot_128.
pub fn constructor_bnot_128<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 870.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_get(ctx, pattern0_0, expr0_0);
    let expr2_0 = constructor_gen_bit_not(ctx, expr1_0)?;
    let expr3_0: usize = 1i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, pattern0_0, expr3_0);
    let expr5_0 = constructor_gen_bit_not(ctx, expr4_0)?;
    let expr6_0 = C::value_regs(ctx, expr2_0, expr5_0);
    return Some(expr6_0);
}

// Generated as internal constructor for term lower_bit_reverse.
pub fn constructor_lower_bit_reverse<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if pattern1_0 == I8 {
        // Rule at src/isa/riscv64/inst.isle line 881.
        let expr0_0: Type = I8;
        let expr1_0 = constructor_gen_brev8(ctx, pattern0_0, expr0_0)?;
        return Some(expr1_0);
    }
    if pattern1_0 == I16 {
        // Rule at src/isa/riscv64/inst.isle line 885.
        let expr0_0: Type = I16;
        let expr1_0 = constructor_gen_brev8(ctx, pattern0_0, expr0_0)?;
        let expr2_0 = constructor_gen_rev8(ctx, expr1_0)?;
        let expr3_0 = AluOPRRI::Srli;
        let expr4_0: i32 = 48i128 as i32;
        let expr5_0 = C::imm12_const(ctx, expr4_0);
        let expr6_0 = constructor_alu_rr_imm12(ctx, &expr3_0, expr2_0, expr5_0)?;
        return Some(expr6_0);
    }
    if pattern1_0 == I32 {
        // Rule at src/isa/riscv64/inst.isle line 893.
        let expr0_0: Type = I32;
        let expr1_0 = constructor_gen_brev8(ctx, pattern0_0, expr0_0)?;
        let expr2_0 = constructor_gen_rev8(ctx, expr1_0)?;
        let expr3_0 = AluOPRRI::Srli;
        let expr4_0: i32 = 32i128 as i32;
        let expr5_0 = C::imm12_const(ctx, expr4_0);
        let expr6_0 = constructor_alu_rr_imm12(ctx, &expr3_0, expr2_0, expr5_0)?;
        return Some(expr6_0);
    }
    if pattern1_0 == I64 {
        // Rule at src/isa/riscv64/inst.isle line 901.
        let expr0_0 = constructor_gen_rev8(ctx, pattern0_0)?;
        let expr1_0: Type = I64;
        let expr2_0 = constructor_gen_brev8(ctx, expr0_0, expr1_0)?;
        return Some(expr2_0);
    }
    return None;
}

// Generated as internal constructor for term imm12_zero.
pub fn constructor_imm12_zero<C: Context>(ctx: &mut C) -> Option<Imm12> {
    // Rule at src/isa/riscv64/inst.isle line 909.
    let expr0_0: i32 = 0i128 as i32;
    let expr1_0 = C::imm12_const(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term lower_ctz.
pub fn constructor_lower_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let mut closure3 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern3_0) = closure3() {
            if pattern3_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 923.
                let expr0_0 = AluOPRRI::Ctzw;
                let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern2_0)?;
                return Some(expr1_0);
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let mut closure3 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern3_0) = closure3() {
            if pattern3_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 918.
                let expr0_0 = AluOPRRI::Ctz;
                let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern2_0)?;
                return Some(expr1_0);
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 928.
            let expr0_0 = AluOPRRI::Bseti;
            let expr1_0 = C::ty_bits(ctx, pattern0_0)?;
            let expr2_0 = C::u8_as_i32(ctx, expr1_0);
            let expr3_0 = C::imm12_const(ctx, expr2_0);
            let expr4_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern1_0, expr3_0)?;
            let expr5_0 = AluOPRRI::Ctzw;
            let expr6_0 = constructor_alu_rr_funct12(ctx, &expr5_0, pattern1_0)?;
            return Some(expr6_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 914.
            let expr0_0: bool = false;
            let expr1_0 = constructor_gen_cltz(ctx, expr0_0, pattern1_0, pattern0_0)?;
            return Some(expr1_0);
        }
    }
    return None;
}

// Generated as internal constructor for term lower_ctz_128.
pub fn constructor_lower_ctz_128<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 938.
    let expr0_0: Type = I64;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
    let expr3_0 = constructor_lower_ctz(ctx, expr0_0, expr2_0)?;
    let expr4_0: Type = I64;
    let expr5_0: usize = 1i128 as usize;
    let expr6_0 = C::value_regs_get(ctx, pattern0_0, expr5_0);
    let expr7_0 = constructor_lower_ctz(ctx, expr4_0, expr6_0)?;
    let expr8_0: u64 = 64i128 as u64;
    let expr9_0 = C::load_u64_constant(ctx, expr8_0);
    let expr10_0 = IntCC::Equal;
    let expr11_0 = C::zero_reg(ctx);
    let expr12_0 = C::gen_select_reg(ctx, &expr10_0, expr9_0, expr3_0, expr7_0, expr11_0);
    let expr13_0 = constructor_alu_add(ctx, expr3_0, expr12_0)?;
    let expr14_0: u64 = 0i128 as u64;
    let expr15_0 = C::load_u64_constant(ctx, expr14_0);
    let expr16_0 = C::value_regs(ctx, expr13_0, expr15_0);
    return Some(expr16_0);
}

// Generated as internal constructor for term lower_clz.
pub fn constructor_lower_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let mut closure3 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern3_0) = closure3() {
            if pattern3_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 967.
                let expr0_0 = AluOPRRI::Clzw;
                let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern2_0)?;
                return Some(expr1_0);
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let mut closure3 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern3_0) = closure3() {
            if pattern3_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 963.
                let expr0_0 = AluOPRRI::Clz;
                let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern2_0)?;
                return Some(expr1_0);
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 973.
            let expr0_0: bool = false;
            let expr1_0 = C::value_reg(ctx, pattern1_0);
            let expr2_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern0_0)?;
            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
            let expr4_0 = AluOPRRI::Clz;
            let expr5_0 = constructor_alu_rr_funct12(ctx, &expr4_0, expr3_0)?;
            let expr6_0 = AluOPRRI::Addi;
            let expr7_0 = C::ty_bits(ctx, pattern0_0)?;
            let expr8_0 = C::u8_as_i32(ctx, expr7_0);
            let expr9_0: i32 = -64i128 as i32;
            let expr10_0 = C::imm12_const_add(ctx, expr8_0, expr9_0);
            let expr11_0 = constructor_alu_rr_imm12(ctx, &expr6_0, expr5_0, expr10_0)?;
            return Some(expr11_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 960.
            let expr0_0: bool = true;
            let expr1_0 = constructor_gen_cltz(ctx, expr0_0, pattern1_0, pattern0_0)?;
            return Some(expr1_0);
        }
    }
    return None;
}

// Generated as internal constructor for term lower_clz_i128.
pub fn constructor_lower_clz_i128<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 995.
    let expr0_0: Type = I64;
    let expr1_0: usize = 1i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
    let expr3_0 = constructor_lower_clz(ctx, expr0_0, expr2_0)?;
    let expr4_0: Type = I64;
    let expr5_0: usize = 0i128 as usize;
    let expr6_0 = C::value_regs_get(ctx, pattern0_0, expr5_0);
    let expr7_0 = constructor_lower_clz(ctx, expr4_0, expr6_0)?;
    let expr8_0: u64 = 64i128 as u64;
    let expr9_0 = C::load_u64_constant(ctx, expr8_0);
    let expr10_0 = IntCC::Equal;
    let expr11_0 = C::zero_reg(ctx);
    let expr12_0 = C::gen_select_reg(ctx, &expr10_0, expr9_0, expr3_0, expr7_0, expr11_0);
    let expr13_0 = constructor_alu_add(ctx, expr3_0, expr12_0)?;
    let expr14_0: u64 = 0i128 as u64;
    let expr15_0 = C::load_u64_constant(ctx, expr14_0);
    let expr16_0 = C::value_regs(ctx, expr13_0, expr15_0);
    return Some(expr16_0);
}

// Generated as internal constructor for term gen_extend.
pub fn constructor_gen_extend<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: bool,
    arg2: u8,
    arg3: u8,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1010.
    let expr0_0: Type = I16;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::Extend {
        rd: expr1_0,
        rn: pattern0_0,
        signed: pattern1_0,
        from_bits: pattern2_0,
        to_bits: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term lower_extend.
pub fn constructor_lower_extend<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: bool,
    arg2: u8,
    arg3: u8,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if pattern1_0 == true {
        let pattern3_0 = arg2;
        if pattern3_0 == 64i128 as u8 {
            let pattern5_0 = arg3;
            if pattern5_0 == 128i128 as u8 {
                // Rule at src/isa/riscv64/inst.isle line 1023.
                let expr0_0 = AluOPRRR::Slt;
                let expr1_0 = C::zero_reg(ctx);
                let expr2_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, expr1_0)?;
                let expr3_0: bool = true;
                let expr4_0: u8 = 1i128 as u8;
                let expr5_0: u8 = 64i128 as u8;
                let expr6_0 = constructor_gen_extend(ctx, expr2_0, expr3_0, expr4_0, expr5_0)?;
                let expr7_0: Type = I64;
                let expr8_0: Type = I64;
                let expr9_0 = C::gen_move2(ctx, pattern0_0, expr7_0, expr8_0);
                let expr10_0 = C::value_regs(ctx, expr9_0, expr6_0);
                return Some(expr10_0);
            }
        }
    }
    if pattern1_0 == false {
        let pattern3_0 = arg2;
        if pattern3_0 == 64i128 as u8 {
            let pattern5_0 = arg3;
            if pattern5_0 == 128i128 as u8 {
                // Rule at src/isa/riscv64/inst.isle line 1040.
                let expr0_0: Type = I64;
                let expr1_0: Type = I64;
                let expr2_0 = C::gen_move2(ctx, pattern0_0, expr0_0, expr1_0);
                let expr3_0: u64 = 0i128 as u64;
                let expr4_0 = C::load_u64_constant(ctx, expr3_0);
                let expr5_0 = C::value_regs(ctx, expr2_0, expr4_0);
                return Some(expr5_0);
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if pattern1_0 == true {
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        if pattern4_0 == 128i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1031.
            let expr0_0: bool = true;
            let expr1_0: u8 = 64i128 as u8;
            let expr2_0 = constructor_gen_extend(ctx, pattern0_0, expr0_0, pattern3_0, expr1_0)?;
            let expr3_0 = AluOPRRR::Slt;
            let expr4_0 = C::zero_reg(ctx);
            let expr5_0 = constructor_alu_rrr(ctx, &expr3_0, expr2_0, expr4_0)?;
            let expr6_0: bool = true;
            let expr7_0: u8 = 1i128 as u8;
            let expr8_0: u8 = 64i128 as u8;
            let expr9_0 = constructor_gen_extend(ctx, expr5_0, expr6_0, expr7_0, expr8_0)?;
            let expr10_0: Type = I64;
            let expr11_0: Type = I64;
            let expr12_0 = C::gen_move2(ctx, pattern0_0, expr10_0, expr11_0);
            let expr13_0 = C::value_regs(ctx, expr12_0, expr9_0);
            return Some(expr13_0);
        }
    }
    if pattern1_0 == false {
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        if pattern4_0 == 128i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1045.
            let expr0_0: bool = false;
            let expr1_0: u8 = 64i128 as u8;
            let expr2_0 = constructor_gen_extend(ctx, pattern0_0, expr0_0, pattern3_0, expr1_0)?;
            let expr3_0: u64 = 0i128 as u64;
            let expr4_0 = C::load_u64_constant(ctx, expr3_0);
            let expr5_0 = C::value_regs(ctx, expr2_0, expr4_0);
            return Some(expr5_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1018.
    let expr0_0 = constructor_gen_extend(ctx, pattern0_0, pattern1_0, pattern2_0, pattern3_0)?;
    let expr1_0 = C::value_reg(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term lower_b128_binary.
pub fn constructor_lower_b128_binary<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRR,
    arg1: ValueRegs,
    arg2: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1054.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_get(ctx, pattern1_0, expr0_0);
    let expr2_0: usize = 0i128 as usize;
    let expr3_0 = C::value_regs_get(ctx, pattern2_0, expr2_0);
    let expr4_0 = constructor_alu_rrr(ctx, pattern0_0, expr1_0, expr3_0)?;
    let expr5_0: usize = 1i128 as usize;
    let expr6_0 = C::value_regs_get(ctx, pattern1_0, expr5_0);
    let expr7_0: usize = 1i128 as usize;
    let expr8_0 = C::value_regs_get(ctx, pattern2_0, expr7_0);
    let expr9_0 = constructor_alu_rrr(ctx, pattern0_0, expr6_0, expr8_0)?;
    let expr10_0 = C::value_regs(ctx, expr4_0, expr9_0);
    return Some(expr10_0);
}

// Generated as internal constructor for term lower_umlhi.
pub fn constructor_lower_umlhi<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/riscv64/inst.isle line 1063.
        let expr0_0 = AluOPRRR::Mulhu;
        let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0)?;
        return Some(expr1_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1068.
    let expr0_0 = AluOPRRR::Mul;
    let expr1_0: bool = false;
    let expr2_0 = C::value_reg(ctx, pattern1_0);
    let expr3_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern0_0)?;
    let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0)?;
    let expr5_0: bool = false;
    let expr6_0 = C::value_reg(ctx, pattern2_0);
    let expr7_0 = constructor_ext_int_if_need(ctx, expr5_0, expr6_0, pattern0_0)?;
    let expr8_0 = constructor_convert_valueregs_reg(ctx, expr7_0)?;
    let expr9_0 = constructor_alu_rrr(ctx, &expr0_0, expr4_0, expr8_0)?;
    let expr10_0 = AluOPRRI::Srli;
    let expr11_0 = C::ty_bits(ctx, pattern0_0)?;
    let expr12_0 = C::u8_as_i32(ctx, expr11_0);
    let expr13_0 = C::imm12_const(ctx, expr12_0);
    let expr14_0 = constructor_alu_rr_imm12(ctx, &expr10_0, expr9_0, expr13_0)?;
    return Some(expr14_0);
}

// Generated as internal constructor for term lower_smlhi.
pub fn constructor_lower_smlhi<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/riscv64/inst.isle line 1074.
        let expr0_0 = AluOPRRR::Mulh;
        let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0)?;
        return Some(expr1_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1079.
    let expr0_0 = AluOPRRR::Mul;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern1_0, pattern2_0)?;
    let expr2_0 = AluOPRRI::Srli;
    let expr3_0 = C::ty_bits(ctx, pattern0_0)?;
    let expr4_0 = C::u8_as_i32(ctx, expr3_0);
    let expr5_0 = C::imm12_const(ctx, expr4_0);
    let expr6_0 = constructor_alu_rr_imm12(ctx, &expr2_0, expr1_0, expr5_0)?;
    return Some(expr6_0);
}

// Generated as internal constructor for term lower_rotl.
pub fn constructor_lower_rotl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 1101.
                let expr0_0 = AluOPRRR::Rolw;
                let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0)?;
                return Some(expr1_0);
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 1091.
                let expr0_0 = AluOPRRR::Rol;
                let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0)?;
                return Some(expr1_0);
            }
        }
    }
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == false {
                // Rule at src/isa/riscv64/inst.isle line 1107.
                let expr0_0: Type = I32;
                let expr1_0 = constructor_lower_rotl_shift(ctx, expr0_0, pattern2_0, pattern3_0)?;
                return Some(expr1_0);
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == false {
                // Rule at src/isa/riscv64/inst.isle line 1097.
                let expr0_0: Type = I64;
                let expr1_0 = constructor_lower_rotl_shift(ctx, expr0_0, pattern2_0, pattern3_0)?;
                return Some(expr1_0);
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1111.
    let expr0_0 = constructor_lower_rotl_shift(ctx, pattern0_0, pattern1_0, pattern2_0)?;
    return Some(expr0_0);
}

// Generated as internal constructor for term lower_rotl_shift.
pub fn constructor_lower_rotl_shift<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1120.
    let expr0_0 = C::gen_shamt(ctx, pattern0_0, pattern2_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    let expr3_0: usize = 1i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, expr0_0, expr3_0);
    let expr5_0 = AluOPRRR::Sll;
    let expr6_0 = constructor_alu_rrr(ctx, &expr5_0, pattern1_0, expr2_0)?;
    let expr7_0 = AluOPRRR::Srl;
    let expr8_0 = constructor_alu_rrr(ctx, &expr7_0, pattern1_0, expr4_0)?;
    let expr9_0 = IntCC::Equal;
    let expr10_0 = C::zero_reg(ctx);
    let expr11_0 = C::zero_reg(ctx);
    let expr12_0 = C::gen_select_reg(ctx, &expr9_0, expr2_0, expr10_0, expr11_0, expr8_0);
    let expr13_0 = AluOPRRR::Or;
    let expr14_0 = constructor_alu_rrr(ctx, &expr13_0, expr6_0, expr12_0)?;
    return Some(expr14_0);
}

// Generated as internal constructor for term lower_rotr.
pub fn constructor_lower_rotr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 1149.
                let expr0_0 = AluOPRRR::Rorw;
                let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0)?;
                return Some(expr1_0);
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 1140.
                let expr0_0 = AluOPRRR::Ror;
                let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0)?;
                return Some(expr1_0);
            }
        }
    }
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == false {
                // Rule at src/isa/riscv64/inst.isle line 1155.
                let expr0_0: Type = I32;
                let expr1_0 = constructor_lower_rotr_shift(ctx, expr0_0, pattern2_0, pattern3_0)?;
                return Some(expr1_0);
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx)?;
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == false {
                // Rule at src/isa/riscv64/inst.isle line 1145.
                let expr0_0: Type = I64;
                let expr1_0 = constructor_lower_rotr_shift(ctx, expr0_0, pattern2_0, pattern3_0)?;
                return Some(expr1_0);
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1159.
    let expr0_0 = constructor_lower_rotr_shift(ctx, pattern0_0, pattern1_0, pattern2_0)?;
    return Some(expr0_0);
}

// Generated as internal constructor for term lower_rotr_shift.
pub fn constructor_lower_rotr_shift<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1167.
    let expr0_0 = C::gen_shamt(ctx, pattern0_0, pattern2_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    let expr3_0: usize = 1i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, expr0_0, expr3_0);
    let expr5_0 = AluOPRRR::Srl;
    let expr6_0 = constructor_alu_rrr(ctx, &expr5_0, pattern1_0, expr2_0)?;
    let expr7_0 = AluOPRRR::Sll;
    let expr8_0 = constructor_alu_rrr(ctx, &expr7_0, pattern1_0, expr4_0)?;
    let expr9_0 = IntCC::Equal;
    let expr10_0 = C::zero_reg(ctx);
    let expr11_0 = C::zero_reg(ctx);
    let expr12_0 = C::gen_select_reg(ctx, &expr9_0, expr2_0, expr10_0, expr11_0, expr8_0);
    let expr13_0 = AluOPRRR::Or;
    let expr14_0 = constructor_alu_rrr(ctx, &expr13_0, expr6_0, expr12_0)?;
    return Some(expr14_0);
}

// Generated as internal constructor for term lower_cls.
pub fn constructor_lower_cls<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1182.
    let expr0_0: bool = true;
    let expr1_0 = C::value_reg(ctx, pattern0_0);
    let expr2_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern1_0)?;
    let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
    let expr4_0 = IntCC::SignedLessThan;
    let expr5_0 = C::zero_reg(ctx);
    let expr6_0 = constructor_gen_bit_not(ctx, pattern0_0)?;
    let expr7_0 = C::gen_select_reg(ctx, &expr4_0, expr3_0, expr5_0, expr6_0, pattern0_0);
    let expr8_0 = constructor_lower_clz(ctx, pattern1_0, expr7_0)?;
    let expr9_0 = AluOPRRI::Addi;
    let expr10_0: i32 = -1i128 as i32;
    let expr11_0 = C::imm12_const(ctx, expr10_0);
    let expr12_0 = constructor_alu_rr_imm12(ctx, &expr9_0, expr8_0, expr11_0)?;
    return Some(expr12_0);
}

// Generated as internal constructor for term gen_cltz.
pub fn constructor_gen_cltz<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: Reg,
    arg2: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1194.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0: Type = I64;
    let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
    let expr4_0: Type = I64;
    let expr5_0 = C::temp_writable_reg(ctx, expr4_0);
    let expr6_0 = MInst::Cltz {
        leading: pattern0_0,
        sum: expr5_0,
        step: expr3_0,
        tmp: expr1_0,
        rs: pattern1_0,
        ty: pattern2_0,
    };
    let expr7_0 = C::emit(ctx, &expr6_0);
    let expr8_0 = C::writable_reg_to_reg(ctx, expr5_0);
    return Some(expr8_0);
}

// Generated as internal constructor for term gen_popcnt.
pub fn constructor_gen_popcnt<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1204.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0: Type = I64;
    let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
    let expr4_0: Type = I64;
    let expr5_0 = C::temp_writable_reg(ctx, expr4_0);
    let expr6_0 = MInst::Popcnt {
        sum: expr5_0,
        step: expr3_0,
        tmp: expr1_0,
        rs: pattern0_0,
        ty: pattern1_0,
    };
    let expr7_0 = C::emit(ctx, &expr6_0);
    let expr8_0 = C::writable_reg_to_reg(ctx, expr5_0);
    return Some(expr8_0);
}

// Generated as internal constructor for term lower_popcnt.
pub fn constructor_lower_popcnt<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 1213.
            let expr0_0 = AluOPRRI::Cpop;
            let expr1_0: bool = false;
            let expr2_0 = C::value_reg(ctx, pattern0_0);
            let expr3_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern1_0)?;
            let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0)?;
            let expr5_0 = constructor_alu_rr_funct12(ctx, &expr0_0, expr4_0)?;
            return Some(expr5_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 1216.
            let expr0_0 = constructor_gen_popcnt(ctx, pattern0_0, pattern1_0)?;
            return Some(expr0_0);
        }
    }
    return None;
}

// Generated as internal constructor for term lower_popcnt_i128.
pub fn constructor_lower_popcnt_i128<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1222.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_get(ctx, pattern0_0, expr0_0);
    let expr2_0: Type = I64;
    let expr3_0 = constructor_lower_popcnt(ctx, expr1_0, expr2_0)?;
    let expr4_0: usize = 1i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, pattern0_0, expr4_0);
    let expr6_0: Type = I64;
    let expr7_0 = constructor_lower_popcnt(ctx, expr5_0, expr6_0)?;
    let expr8_0 = constructor_alu_add(ctx, expr3_0, expr7_0)?;
    let expr9_0: u64 = 0i128 as u64;
    let expr10_0 = C::load_u64_constant(ctx, expr9_0);
    let expr11_0 = C::value_regs(ctx, expr8_0, expr10_0);
    return Some(expr11_0);
}

// Generated as internal constructor for term lower_i128_rotl.
pub fn constructor_lower_i128_rotl<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1234.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Sll;
    let expr9_0: usize = 0i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr5_0)?;
    let expr12_0 = AluOPRRR::Srl;
    let expr13_0: usize = 1i128 as usize;
    let expr14_0 = C::value_regs_get(ctx, pattern0_0, expr13_0);
    let expr15_0 = constructor_alu_rrr(ctx, &expr12_0, expr14_0, expr7_0)?;
    let expr16_0 = IntCC::Equal;
    let expr17_0 = C::zero_reg(ctx);
    let expr18_0 = C::zero_reg(ctx);
    let expr19_0 = C::gen_select_reg(ctx, &expr16_0, expr5_0, expr17_0, expr18_0, expr15_0);
    let expr20_0 = AluOPRRR::Or;
    let expr21_0 = constructor_alu_rrr(ctx, &expr20_0, expr11_0, expr19_0)?;
    let expr22_0 = AluOPRRR::Sll;
    let expr23_0: usize = 1i128 as usize;
    let expr24_0 = C::value_regs_get(ctx, pattern0_0, expr23_0);
    let expr25_0 = constructor_alu_rrr(ctx, &expr22_0, expr24_0, expr5_0)?;
    let expr26_0 = AluOPRRR::Srl;
    let expr27_0: usize = 0i128 as usize;
    let expr28_0 = C::value_regs_get(ctx, pattern0_0, expr27_0);
    let expr29_0 = constructor_alu_rrr(ctx, &expr26_0, expr28_0, expr7_0)?;
    let expr30_0 = IntCC::Equal;
    let expr31_0 = C::zero_reg(ctx);
    let expr32_0 = C::zero_reg(ctx);
    let expr33_0 = C::gen_select_reg(ctx, &expr30_0, expr5_0, expr31_0, expr32_0, expr29_0);
    let expr34_0 = AluOPRRR::Or;
    let expr35_0 = constructor_alu_rrr(ctx, &expr34_0, expr25_0, expr33_0)?;
    let expr36_0: u64 = 64i128 as u64;
    let expr37_0 = C::load_u64_constant(ctx, expr36_0);
    let expr38_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr39_0 = C::gen_select_reg(ctx, &expr38_0, expr5_0, expr37_0, expr35_0, expr21_0);
    let expr40_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr41_0 = C::gen_select_reg(ctx, &expr40_0, expr5_0, expr37_0, expr21_0, expr35_0);
    let expr42_0 = C::value_regs(ctx, expr39_0, expr41_0);
    return Some(expr42_0);
}

// Generated as internal constructor for term lower_i128_rotr.
pub fn constructor_lower_i128_rotr<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1262.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Srl;
    let expr9_0: usize = 0i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr5_0)?;
    let expr12_0 = AluOPRRR::Sll;
    let expr13_0: usize = 1i128 as usize;
    let expr14_0 = C::value_regs_get(ctx, pattern0_0, expr13_0);
    let expr15_0 = constructor_alu_rrr(ctx, &expr12_0, expr14_0, expr7_0)?;
    let expr16_0 = IntCC::Equal;
    let expr17_0 = C::zero_reg(ctx);
    let expr18_0 = C::zero_reg(ctx);
    let expr19_0 = C::gen_select_reg(ctx, &expr16_0, expr5_0, expr17_0, expr18_0, expr15_0);
    let expr20_0 = AluOPRRR::Or;
    let expr21_0 = constructor_alu_rrr(ctx, &expr20_0, expr11_0, expr19_0)?;
    let expr22_0 = AluOPRRR::Srl;
    let expr23_0: usize = 1i128 as usize;
    let expr24_0 = C::value_regs_get(ctx, pattern0_0, expr23_0);
    let expr25_0 = constructor_alu_rrr(ctx, &expr22_0, expr24_0, expr5_0)?;
    let expr26_0 = AluOPRRR::Sll;
    let expr27_0: usize = 0i128 as usize;
    let expr28_0 = C::value_regs_get(ctx, pattern0_0, expr27_0);
    let expr29_0 = constructor_alu_rrr(ctx, &expr26_0, expr28_0, expr7_0)?;
    let expr30_0 = IntCC::Equal;
    let expr31_0 = C::zero_reg(ctx);
    let expr32_0 = C::zero_reg(ctx);
    let expr33_0 = C::gen_select_reg(ctx, &expr30_0, expr5_0, expr31_0, expr32_0, expr29_0);
    let expr34_0 = AluOPRRR::Or;
    let expr35_0 = constructor_alu_rrr(ctx, &expr34_0, expr25_0, expr33_0)?;
    let expr36_0: u64 = 64i128 as u64;
    let expr37_0 = C::load_u64_constant(ctx, expr36_0);
    let expr38_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr39_0 = C::gen_select_reg(ctx, &expr38_0, expr5_0, expr37_0, expr35_0, expr21_0);
    let expr40_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr41_0 = C::gen_select_reg(ctx, &expr40_0, expr5_0, expr37_0, expr21_0, expr35_0);
    let expr42_0 = C::value_regs(ctx, expr39_0, expr41_0);
    return Some(expr42_0);
}

// Generated as internal constructor for term lower_i128_ishl.
pub fn constructor_lower_i128_ishl<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1291.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Sll;
    let expr9_0: usize = 0i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr5_0)?;
    let expr12_0 = AluOPRRR::Srl;
    let expr13_0: usize = 0i128 as usize;
    let expr14_0 = C::value_regs_get(ctx, pattern0_0, expr13_0);
    let expr15_0 = constructor_alu_rrr(ctx, &expr12_0, expr14_0, expr7_0)?;
    let expr16_0 = IntCC::Equal;
    let expr17_0 = C::zero_reg(ctx);
    let expr18_0 = C::zero_reg(ctx);
    let expr19_0 = C::gen_select_reg(ctx, &expr16_0, expr5_0, expr17_0, expr18_0, expr15_0);
    let expr20_0 = AluOPRRR::Sll;
    let expr21_0: usize = 1i128 as usize;
    let expr22_0 = C::value_regs_get(ctx, pattern0_0, expr21_0);
    let expr23_0 = constructor_alu_rrr(ctx, &expr20_0, expr22_0, expr5_0)?;
    let expr24_0 = AluOPRRR::Or;
    let expr25_0 = constructor_alu_rrr(ctx, &expr24_0, expr19_0, expr23_0)?;
    let expr26_0: u64 = 64i128 as u64;
    let expr27_0 = C::load_u64_constant(ctx, expr26_0);
    let expr28_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr29_0 = C::zero_reg(ctx);
    let expr30_0 = C::gen_select_reg(ctx, &expr28_0, expr5_0, expr27_0, expr29_0, expr11_0);
    let expr31_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr32_0 = C::gen_select_reg(ctx, &expr31_0, expr5_0, expr27_0, expr11_0, expr25_0);
    let expr33_0 = C::value_regs(ctx, expr30_0, expr32_0);
    return Some(expr33_0);
}

// Generated as internal constructor for term lower_i128_ushr.
pub fn constructor_lower_i128_ushr<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1312.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Sll;
    let expr9_0: usize = 1i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr7_0)?;
    let expr12_0 = IntCC::Equal;
    let expr13_0 = C::zero_reg(ctx);
    let expr14_0 = C::zero_reg(ctx);
    let expr15_0 = C::gen_select_reg(ctx, &expr12_0, expr5_0, expr13_0, expr14_0, expr11_0);
    let expr16_0 = AluOPRRR::Srl;
    let expr17_0: usize = 0i128 as usize;
    let expr18_0 = C::value_regs_get(ctx, pattern0_0, expr17_0);
    let expr19_0 = constructor_alu_rrr(ctx, &expr16_0, expr18_0, expr5_0)?;
    let expr20_0 = AluOPRRR::Or;
    let expr21_0 = constructor_alu_rrr(ctx, &expr20_0, expr15_0, expr19_0)?;
    let expr22_0: u64 = 64i128 as u64;
    let expr23_0 = C::load_u64_constant(ctx, expr22_0);
    let expr24_0 = AluOPRRR::Srl;
    let expr25_0: usize = 1i128 as usize;
    let expr26_0 = C::value_regs_get(ctx, pattern0_0, expr25_0);
    let expr27_0 = constructor_alu_rrr(ctx, &expr24_0, expr26_0, expr5_0)?;
    let expr28_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr29_0 = C::gen_select_reg(ctx, &expr28_0, expr5_0, expr23_0, expr27_0, expr21_0);
    let expr30_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr31_0 = C::zero_reg(ctx);
    let expr32_0 = C::gen_select_reg(ctx, &expr30_0, expr5_0, expr23_0, expr31_0, expr27_0);
    let expr33_0 = C::value_regs(ctx, expr29_0, expr32_0);
    return Some(expr33_0);
}

// Generated as internal constructor for term lower_i128_sshr.
pub fn constructor_lower_i128_sshr<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1336.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Sll;
    let expr9_0: usize = 1i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr7_0)?;
    let expr12_0 = IntCC::Equal;
    let expr13_0 = C::zero_reg(ctx);
    let expr14_0 = C::zero_reg(ctx);
    let expr15_0 = C::gen_select_reg(ctx, &expr12_0, expr5_0, expr13_0, expr14_0, expr11_0);
    let expr16_0 = AluOPRRR::Srl;
    let expr17_0: usize = 0i128 as usize;
    let expr18_0 = C::value_regs_get(ctx, pattern0_0, expr17_0);
    let expr19_0 = constructor_alu_rrr(ctx, &expr16_0, expr18_0, expr5_0)?;
    let expr20_0 = AluOPRRR::Or;
    let expr21_0 = constructor_alu_rrr(ctx, &expr20_0, expr15_0, expr19_0)?;
    let expr22_0: u64 = 64i128 as u64;
    let expr23_0 = C::load_u64_constant(ctx, expr22_0);
    let expr24_0 = AluOPRRR::Sra;
    let expr25_0: usize = 1i128 as usize;
    let expr26_0 = C::value_regs_get(ctx, pattern0_0, expr25_0);
    let expr27_0 = constructor_alu_rrr(ctx, &expr24_0, expr26_0, expr5_0)?;
    let expr28_0: i32 = -1i128 as i32;
    let expr29_0 = constructor_load_imm12(ctx, expr28_0)?;
    let expr30_0 = IntCC::SignedLessThan;
    let expr31_0: usize = 1i128 as usize;
    let expr32_0 = C::value_regs_get(ctx, pattern0_0, expr31_0);
    let expr33_0 = C::zero_reg(ctx);
    let expr34_0 = C::zero_reg(ctx);
    let expr35_0 = C::gen_select_reg(ctx, &expr30_0, expr32_0, expr33_0, expr29_0, expr34_0);
    let expr36_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr37_0 = C::gen_select_reg(ctx, &expr36_0, expr5_0, expr23_0, expr27_0, expr21_0);
    let expr38_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr39_0 = C::gen_select_reg(ctx, &expr38_0, expr5_0, expr23_0, expr35_0, expr27_0);
    let expr40_0 = C::value_regs(ctx, expr37_0, expr39_0);
    return Some(expr40_0);
}

// Generated as internal constructor for term load_imm12.
pub fn constructor_load_imm12<C: Context>(ctx: &mut C, arg0: i32) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1362.
    let expr0_0 = AluOPRRI::Addi;
    let expr1_0 = C::zero_reg(ctx);
    let expr2_0 = C::imm12_const(ctx, pattern0_0);
    let expr3_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr1_0, expr2_0)?;
    return Some(expr3_0);
}

// Generated as internal constructor for term lower_cls_i128.
pub fn constructor_lower_cls_i128<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1372.
    let expr0_0 = IntCC::SignedLessThan;
    let expr1_0: usize = 1i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
    let expr3_0 = C::zero_reg(ctx);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, pattern0_0, expr4_0);
    let expr6_0 = constructor_gen_bit_not(ctx, expr5_0)?;
    let expr7_0: usize = 0i128 as usize;
    let expr8_0 = C::value_regs_get(ctx, pattern0_0, expr7_0);
    let expr9_0 = C::gen_select_reg(ctx, &expr0_0, expr2_0, expr3_0, expr6_0, expr8_0);
    let expr10_0 = IntCC::SignedLessThan;
    let expr11_0: usize = 1i128 as usize;
    let expr12_0 = C::value_regs_get(ctx, pattern0_0, expr11_0);
    let expr13_0 = C::zero_reg(ctx);
    let expr14_0: usize = 1i128 as usize;
    let expr15_0 = C::value_regs_get(ctx, pattern0_0, expr14_0);
    let expr16_0 = constructor_gen_bit_not(ctx, expr15_0)?;
    let expr17_0: usize = 1i128 as usize;
    let expr18_0 = C::value_regs_get(ctx, pattern0_0, expr17_0);
    let expr19_0 = C::gen_select_reg(ctx, &expr10_0, expr12_0, expr13_0, expr16_0, expr18_0);
    let expr20_0 = C::value_regs(ctx, expr9_0, expr19_0);
    let expr21_0 = constructor_lower_clz_i128(ctx, expr20_0)?;
    let expr22_0: usize = 0i128 as usize;
    let expr23_0 = C::value_regs_get(ctx, expr21_0, expr22_0);
    let expr24_0 = AluOPRRI::Addi;
    let expr25_0: i32 = -1i128 as i32;
    let expr26_0 = C::imm12_const(ctx, expr25_0);
    let expr27_0 = constructor_alu_rr_imm12(ctx, &expr24_0, expr23_0, expr26_0)?;
    let expr28_0: u64 = 0i128 as u64;
    let expr29_0 = C::load_u64_constant(ctx, expr28_0);
    let expr30_0 = C::value_regs(ctx, expr27_0, expr29_0);
    return Some(expr30_0);
}

// Generated as internal constructor for term gen_load.
pub fn constructor_gen_load<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Offset32,
    arg2: &LoadOP,
    arg3: MemFlags,
    arg4: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 1407.
    let expr0_0 = C::temp_writable_reg(ctx, pattern4_0);
    let expr1_0: Type = I64;
    let expr2_0 = C::gen_amode(ctx, pattern0_0, pattern1_0, expr1_0);
    let expr3_0 = MInst::Load {
        rd: expr0_0,
        op: pattern2_0.clone(),
        flags: pattern3_0,
        from: expr2_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term gen_load_128.
pub fn constructor_gen_load_128<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Offset32,
    arg2: MemFlags,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1415.
    let expr0_0 = LoadOP::Ld;
    let expr1_0: Type = I64;
    let expr2_0 = constructor_gen_load(ctx, pattern0_0, pattern1_0, &expr0_0, pattern2_0, expr1_0)?;
    let expr3_0: i64 = 8i128 as i64;
    let expr4_0 = C::offset32_add(ctx, pattern1_0, expr3_0);
    let expr5_0 = LoadOP::Ld;
    let expr6_0: Type = I64;
    let expr7_0 = constructor_gen_load(ctx, pattern0_0, expr4_0, &expr5_0, pattern2_0, expr6_0)?;
    let expr8_0 = C::value_regs(ctx, expr2_0, expr7_0);
    return Some(expr8_0);
}

// Generated as internal constructor for term gen_store.
pub fn constructor_gen_store<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Offset32,
    arg2: &StoreOP,
    arg3: MemFlags,
    arg4: Reg,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 1430.
    let expr0_0: Type = I64;
    let expr1_0 = C::gen_amode(ctx, pattern0_0, pattern1_0, expr0_0);
    let expr2_0 = MInst::Store {
        to: expr1_0,
        op: pattern2_0.clone(),
        flags: pattern3_0,
        src: pattern4_0,
    };
    let expr3_0 = SideEffectNoResult::Inst { inst: expr2_0 };
    let expr4_0 = constructor_side_effect(ctx, &expr3_0)?;
    return Some(expr4_0);
}

// Generated as internal constructor for term gen_store_128.
pub fn constructor_gen_store_128<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: ValueRegs,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1436.
    let expr0_0: Type = I64;
    let expr1_0 = C::gen_amode(ctx, pattern0_0, pattern1_0, expr0_0);
    let expr2_0 = StoreOP::Sd;
    let expr3_0: usize = 0i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, pattern3_0, expr3_0);
    let expr5_0 = MInst::Store {
        to: expr1_0,
        op: expr2_0,
        flags: pattern2_0,
        src: expr4_0,
    };
    let expr6_0: i64 = 8i128 as i64;
    let expr7_0 = C::offset32_add(ctx, pattern1_0, expr6_0);
    let expr8_0: Type = I64;
    let expr9_0 = C::gen_amode(ctx, pattern0_0, expr7_0, expr8_0);
    let expr10_0 = StoreOP::Sd;
    let expr11_0: usize = 1i128 as usize;
    let expr12_0 = C::value_regs_get(ctx, pattern3_0, expr11_0);
    let expr13_0 = MInst::Store {
        to: expr9_0,
        op: expr10_0,
        flags: pattern2_0,
        src: expr12_0,
    };
    let expr14_0 = SideEffectNoResult::Inst2 {
        inst1: expr5_0,
        inst2: expr13_0,
    };
    let expr15_0 = constructor_side_effect(ctx, &expr14_0)?;
    return Some(expr15_0);
}

// Generated as internal constructor for term gen_atomic.
pub fn constructor_gen_atomic<C: Context>(
    ctx: &mut C,
    arg0: &AtomicOP,
    arg1: Reg,
    arg2: Reg,
    arg3: AMO,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1449.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::Atomic {
        op: pattern0_0.clone(),
        rd: expr1_0,
        addr: pattern1_0,
        src: pattern2_0,
        amo: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term get_atomic_rmw_op.
pub fn constructor_get_atomic_rmw_op<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &AtomicRmwOp,
) -> Option<AtomicOP> {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        match pattern2_0 {
            &AtomicRmwOp::Add => {
                // Rule at src/isa/riscv64/inst.isle line 1458.
                let expr0_0 = AtomicOP::AmoaddW;
                return Some(expr0_0);
            }
            &AtomicRmwOp::And => {
                // Rule at src/isa/riscv64/inst.isle line 1465.
                let expr0_0 = AtomicOP::AmoandW;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Or => {
                // Rule at src/isa/riscv64/inst.isle line 1473.
                let expr0_0 = AtomicOP::AmoorW;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Smax => {
                // Rule at src/isa/riscv64/inst.isle line 1481.
                let expr0_0 = AtomicOP::AmomaxW;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Smin => {
                // Rule at src/isa/riscv64/inst.isle line 1489.
                let expr0_0 = AtomicOP::AmominW;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Umax => {
                // Rule at src/isa/riscv64/inst.isle line 1497.
                let expr0_0 = AtomicOP::AmomaxuW;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Umin => {
                // Rule at src/isa/riscv64/inst.isle line 1506.
                let expr0_0 = AtomicOP::AmominuW;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Xchg => {
                // Rule at src/isa/riscv64/inst.isle line 1514.
                let expr0_0 = AtomicOP::AmoswapW;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Xor => {
                // Rule at src/isa/riscv64/inst.isle line 1522.
                let expr0_0 = AtomicOP::AmoxorW;
                return Some(expr0_0);
            }
            _ => {}
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        match pattern2_0 {
            &AtomicRmwOp::Add => {
                // Rule at src/isa/riscv64/inst.isle line 1461.
                let expr0_0 = AtomicOP::AmoaddD;
                return Some(expr0_0);
            }
            &AtomicRmwOp::And => {
                // Rule at src/isa/riscv64/inst.isle line 1469.
                let expr0_0 = AtomicOP::AmoandD;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Or => {
                // Rule at src/isa/riscv64/inst.isle line 1477.
                let expr0_0 = AtomicOP::AmoorD;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Smax => {
                // Rule at src/isa/riscv64/inst.isle line 1485.
                let expr0_0 = AtomicOP::AmomaxD;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Smin => {
                // Rule at src/isa/riscv64/inst.isle line 1493.
                let expr0_0 = AtomicOP::AmominD;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Umax => {
                // Rule at src/isa/riscv64/inst.isle line 1502.
                let expr0_0 = AtomicOP::AmomaxuD;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Umin => {
                // Rule at src/isa/riscv64/inst.isle line 1510.
                let expr0_0 = AtomicOP::AmominuD;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Xchg => {
                // Rule at src/isa/riscv64/inst.isle line 1518.
                let expr0_0 = AtomicOP::AmoswapD;
                return Some(expr0_0);
            }
            &AtomicRmwOp::Xor => {
                // Rule at src/isa/riscv64/inst.isle line 1526.
                let expr0_0 = AtomicOP::AmoxorD;
                return Some(expr0_0);
            }
            _ => {}
        }
    }
    return None;
}

// Generated as internal constructor for term gen_atomic_load.
pub fn constructor_gen_atomic_load<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1535.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AtomicLoad {
        rd: expr1_0,
        ty: pattern1_0,
        p: pattern0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term gen_atomic_store.
pub fn constructor_gen_atomic_store<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Type,
    arg2: Reg,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1544.
    let expr0_0 = MInst::AtomicStore {
        src: pattern2_0,
        ty: pattern1_0,
        p: pattern0_0,
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    let expr2_0 = constructor_side_effect(ctx, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term gen_bit_not.
pub fn constructor_gen_bit_not<C: Context>(ctx: &mut C, arg0: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1550.
    let expr0_0 = AluOPRRI::Xori;
    let expr1_0: i32 = -1i128 as i32;
    let expr2_0 = C::imm12_const(ctx, expr1_0);
    let expr3_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern0_0, expr2_0)?;
    return Some(expr3_0);
}

// Generated as internal constructor for term f_arithmatic_op.
pub fn constructor_f_arithmatic_op<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Opcode,
) -> Option<FpuOPRRR> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        let pattern2_0 = arg1;
        match pattern2_0 {
            &Opcode::Fadd => {
                // Rule at src/isa/riscv64/inst.isle line 1557.
                let expr0_0 = FpuOPRRR::FaddS;
                return Some(expr0_0);
            }
            &Opcode::Fsub => {
                // Rule at src/isa/riscv64/inst.isle line 1565.
                let expr0_0 = FpuOPRRR::FsubS;
                return Some(expr0_0);
            }
            &Opcode::Fmul => {
                // Rule at src/isa/riscv64/inst.isle line 1572.
                let expr0_0 = FpuOPRRR::FmulS;
                return Some(expr0_0);
            }
            &Opcode::Fdiv => {
                // Rule at src/isa/riscv64/inst.isle line 1580.
                let expr0_0 = FpuOPRRR::FdivS;
                return Some(expr0_0);
            }
            _ => {}
        }
    }
    if pattern0_0 == F64 {
        let pattern2_0 = arg1;
        match pattern2_0 {
            &Opcode::Fadd => {
                // Rule at src/isa/riscv64/inst.isle line 1561.
                let expr0_0 = FpuOPRRR::FaddD;
                return Some(expr0_0);
            }
            &Opcode::Fsub => {
                // Rule at src/isa/riscv64/inst.isle line 1568.
                let expr0_0 = FpuOPRRR::FsubD;
                return Some(expr0_0);
            }
            &Opcode::Fmul => {
                // Rule at src/isa/riscv64/inst.isle line 1576.
                let expr0_0 = FpuOPRRR::FmulD;
                return Some(expr0_0);
            }
            &Opcode::Fdiv => {
                // Rule at src/isa/riscv64/inst.isle line 1584.
                let expr0_0 = FpuOPRRR::FdivD;
                return Some(expr0_0);
            }
            _ => {}
        }
    }
    return None;
}

// Generated as internal constructor for term f_copysign_op.
pub fn constructor_f_copysign_op<C: Context>(ctx: &mut C, arg0: Type) -> Option<FpuOPRRR> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        // Rule at src/isa/riscv64/inst.isle line 1597.
        let expr0_0 = FpuOPRRR::FsgnjS;
        return Some(expr0_0);
    }
    if pattern0_0 == F64 {
        // Rule at src/isa/riscv64/inst.isle line 1598.
        let expr0_0 = FpuOPRRR::FsgnjD;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term f_copy_neg_sign_op.
pub fn constructor_f_copy_neg_sign_op<C: Context>(ctx: &mut C, arg0: Type) -> Option<FpuOPRRR> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        // Rule at src/isa/riscv64/inst.isle line 1602.
        let expr0_0 = FpuOPRRR::FsgnjnS;
        return Some(expr0_0);
    }
    if pattern0_0 == F64 {
        // Rule at src/isa/riscv64/inst.isle line 1603.
        let expr0_0 = FpuOPRRR::FsgnjnD;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term fabs_copy_sign.
pub fn constructor_fabs_copy_sign<C: Context>(ctx: &mut C, arg0: Type) -> Option<FpuOPRRR> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        // Rule at src/isa/riscv64/inst.isle line 1606.
        let expr0_0 = FpuOPRRR::FsgnjxS;
        return Some(expr0_0);
    }
    if pattern0_0 == F64 {
        // Rule at src/isa/riscv64/inst.isle line 1607.
        let expr0_0 = FpuOPRRR::FsgnjxD;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term gen_reference_check.
pub fn constructor_gen_reference_check<C: Context>(
    ctx: &mut C,
    arg0: &ReferenceCheckOP,
    arg1: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1625.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::ReferenceCheck {
        rd: expr1_0,
        op: pattern0_0.clone(),
        x: pattern1_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term gen_select.
pub fn constructor_gen_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: ValueRegs,
    arg3: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1634.
    let expr0_0 = C::alloc_vec_writable(ctx, pattern0_0);
    let expr1_0 = C::vec_writable_clone(ctx, &expr0_0);
    let expr2_0 = MInst::Select {
        dst: expr0_0,
        ty: pattern0_0,
        condition: pattern1_0,
        x: pattern2_0,
        y: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::vec_writable_to_regs(ctx, &expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term gen_bitselect.
pub fn constructor_gen_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
    arg3: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1655.
    let expr0_0 = AluOPRRR::And;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern1_0, pattern2_0)?;
    let expr2_0 = constructor_gen_bit_not(ctx, pattern1_0)?;
    let expr3_0 = AluOPRRR::And;
    let expr4_0 = constructor_alu_rrr(ctx, &expr3_0, expr2_0, pattern3_0)?;
    let expr5_0 = AluOPRRR::Or;
    let expr6_0 = constructor_alu_rrr(ctx, &expr5_0, expr1_0, expr4_0)?;
    return Some(expr6_0);
}

// Generated as internal constructor for term gen_int_select.
pub fn constructor_gen_int_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntSelectOP,
    arg2: ValueRegs,
    arg3: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1668.
    let expr0_0 = C::alloc_vec_writable(ctx, pattern0_0);
    let expr1_0 = C::vec_writable_clone(ctx, &expr0_0);
    let expr2_0 = MInst::IntSelect {
        op: pattern1_0.clone(),
        dst: expr1_0,
        x: pattern2_0,
        y: pattern3_0,
        ty: pattern0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::vec_writable_to_regs(ctx, &expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term udf.
pub fn constructor_udf<C: Context>(ctx: &mut C, arg0: &TrapCode) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1678.
    let expr0_0 = MInst::Udf {
        trap_code: pattern0_0.clone(),
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    let expr2_0 = constructor_side_effect(ctx, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term int_load_op.
pub fn constructor_int_load_op<C: Context>(ctx: &mut C, arg0: bool, arg1: u8) -> Option<LoadOP> {
    let pattern0_0 = arg0;
    if pattern0_0 == true {
        let pattern2_0 = arg1;
        if pattern2_0 == 8i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1694.
            let expr0_0 = LoadOP::Lb;
            return Some(expr0_0);
        }
        if pattern2_0 == 16i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1701.
            let expr0_0 = LoadOP::Lh;
            return Some(expr0_0);
        }
        if pattern2_0 == 32i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1707.
            let expr0_0 = LoadOP::Lw;
            return Some(expr0_0);
        }
    }
    if pattern0_0 == false {
        let pattern2_0 = arg1;
        if pattern2_0 == 8i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1690.
            let expr0_0 = LoadOP::Lbu;
            return Some(expr0_0);
        }
        if pattern2_0 == 16i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1698.
            let expr0_0 = LoadOP::Lhu;
            return Some(expr0_0);
        }
        if pattern2_0 == 32i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1704.
            let expr0_0 = LoadOP::Lwu;
            return Some(expr0_0);
        }
    }
    let pattern1_0 = arg1;
    if pattern1_0 == 64i128 as u8 {
        // Rule at src/isa/riscv64/inst.isle line 1711.
        let expr0_0 = LoadOP::Ld;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term gen_fcvt_int.
pub fn constructor_gen_fcvt_int<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: Reg,
    arg2: bool,
    arg3: Type,
    arg4: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 1724.
    let expr0_0 = C::temp_writable_reg(ctx, pattern4_0);
    let expr1_0: Type = F64;
    let expr2_0 = C::temp_writable_reg(ctx, expr1_0);
    let expr3_0 = MInst::FcvtToInt {
        is_sat: pattern0_0,
        rd: expr0_0,
        tmp: expr2_0,
        rs: pattern1_0,
        is_signed: pattern2_0,
        in_type: pattern3_0,
        out_type: pattern4_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term lower_float_binary.
pub fn constructor_lower_float_binary<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRR,
    arg1: Reg,
    arg2: Reg,
    arg3: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1737.
    let expr0_0 = C::move_f_to_x(ctx, pattern1_0, pattern3_0);
    let expr1_0 = C::move_f_to_x(ctx, pattern2_0, pattern3_0);
    let expr2_0 = constructor_alu_rrr(ctx, pattern0_0, expr0_0, expr1_0)?;
    let expr3_0 = C::move_x_to_f(ctx, expr2_0, pattern3_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term lower_float_bnot.
pub fn constructor_lower_float_bnot<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1749.
    let expr0_0 = C::move_f_to_x(ctx, pattern0_0, pattern1_0);
    let expr1_0 = constructor_gen_bit_not(ctx, expr0_0)?;
    let expr2_0 = C::move_x_to_f(ctx, expr1_0, pattern1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term convert_valueregs_reg.
pub fn constructor_convert_valueregs_reg<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1761.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_get(ctx, pattern0_0, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term lower_icmp.
pub fn constructor_lower_icmp<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: ValueRegs,
    arg2: ValueRegs,
    arg3: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::intcc_is_gt_etc(ctx, pattern0_0) {
        if pattern1_1 == true {
            let pattern3_0 = arg1;
            let pattern4_0 = arg2;
            let pattern5_0 = arg3;
            // Rule at src/isa/riscv64/inst.isle line 1782.
            let expr0_0: bool = true;
            let expr1_0 = constructor_ext_int_if_need(ctx, expr0_0, pattern3_0, pattern5_0)?;
            let expr2_0: bool = true;
            let expr3_0 = constructor_ext_int_if_need(ctx, expr2_0, pattern4_0, pattern5_0)?;
            let expr4_0 = constructor_gen_icmp(ctx, &pattern1_0, expr1_0, expr3_0, pattern5_0)?;
            return Some(expr4_0);
        }
        if pattern1_1 == false {
            let pattern3_0 = arg1;
            let pattern4_0 = arg2;
            let pattern5_0 = arg3;
            // Rule at src/isa/riscv64/inst.isle line 1786.
            let expr0_0: bool = false;
            let expr1_0 = constructor_ext_int_if_need(ctx, expr0_0, pattern3_0, pattern5_0)?;
            let expr2_0: bool = false;
            let expr3_0 = constructor_ext_int_if_need(ctx, expr2_0, pattern4_0, pattern5_0)?;
            let expr4_0 = constructor_gen_icmp(ctx, &pattern1_0, expr1_0, expr3_0, pattern5_0)?;
            return Some(expr4_0);
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::intcc_is_eq_or_ne(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        // Rule at src/isa/riscv64/inst.isle line 1777.
        let expr0_0: bool = false;
        let expr1_0 = constructor_ext_int_if_need(ctx, expr0_0, pattern2_0, pattern4_0)?;
        let expr2_0: bool = false;
        let expr3_0 = constructor_ext_int_if_need(ctx, expr2_0, pattern3_0, pattern4_0)?;
        let expr4_0 = constructor_gen_icmp(ctx, &pattern1_0, expr1_0, expr3_0, pattern4_0)?;
        return Some(expr4_0);
    }
    return None;
}

// Generated as internal constructor for term lower_icmp_over_flow.
pub fn constructor_lower_icmp_over_flow<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
    arg2: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if pattern2_0 == I64 {
        // Rule at src/isa/riscv64/inst.isle line 1801.
        let expr0_0 = AluOPRRR::Sgt;
        let expr1_0 = constructor_convert_valueregs_reg(ctx, pattern1_0)?;
        let expr2_0 = C::zero_reg(ctx);
        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
        let expr4_0 = constructor_convert_valueregs_reg(ctx, pattern0_0)?;
        let expr5_0 = constructor_convert_valueregs_reg(ctx, pattern1_0)?;
        let expr6_0 = constructor_alu_sub(ctx, expr4_0, expr5_0)?;
        let expr7_0 = AluOPRRR::Slt;
        let expr8_0 = constructor_convert_valueregs_reg(ctx, pattern0_0)?;
        let expr9_0 = constructor_alu_rrr(ctx, &expr7_0, expr6_0, expr8_0)?;
        let expr10_0 = IntCC::NotEqual;
        let expr11_0 = C::value_reg(ctx, expr3_0);
        let expr12_0 = C::value_reg(ctx, expr9_0);
        let expr13_0: Type = I64;
        let expr14_0 = constructor_gen_icmp(ctx, &expr10_0, expr11_0, expr12_0, expr13_0)?;
        return Some(expr14_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if pattern2_0 == I128 {
        // Rule at src/isa/riscv64/inst.isle line 1810.
        let expr0_0 = AluOPRRI::Srli;
        let expr1_0: usize = 1i128 as usize;
        let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
        let expr3_0: i32 = 63i128 as i32;
        let expr4_0 = C::imm12_const(ctx, expr3_0);
        let expr5_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr2_0, expr4_0)?;
        let expr6_0 = AluOPRRI::Srli;
        let expr7_0: usize = 1i128 as usize;
        let expr8_0 = C::value_regs_get(ctx, pattern1_0, expr7_0);
        let expr9_0: i32 = 63i128 as i32;
        let expr10_0 = C::imm12_const(ctx, expr9_0);
        let expr11_0 = constructor_alu_rr_imm12(ctx, &expr6_0, expr8_0, expr10_0)?;
        let expr12_0 = constructor_i128_sub(ctx, pattern0_0, pattern1_0)?;
        let expr13_0 = AluOPRRI::Srli;
        let expr14_0: usize = 1i128 as usize;
        let expr15_0 = C::value_regs_get(ctx, expr12_0, expr14_0);
        let expr16_0: i32 = 63i128 as i32;
        let expr17_0 = C::imm12_const(ctx, expr16_0);
        let expr18_0 = constructor_alu_rr_imm12(ctx, &expr13_0, expr15_0, expr17_0)?;
        let expr19_0 = constructor_gen_bit_not(ctx, expr11_0)?;
        let expr20_0 = constructor_gen_bit_not(ctx, expr18_0)?;
        let expr21_0 = constructor_alu_and(ctx, expr19_0, expr20_0)?;
        let expr22_0 = constructor_alu_and(ctx, expr5_0, expr21_0)?;
        let expr23_0 = constructor_gen_bit_not(ctx, expr5_0)?;
        let expr24_0 = constructor_alu_and(ctx, expr11_0, expr18_0)?;
        let expr25_0 = constructor_alu_and(ctx, expr23_0, expr24_0)?;
        let expr26_0 = AluOPRRR::Or;
        let expr27_0 = constructor_alu_rrr(ctx, &expr26_0, expr22_0, expr25_0)?;
        let expr28_0: bool = true;
        let expr29_0: u8 = 1i128 as u8;
        let expr30_0: u8 = 64i128 as u8;
        let expr31_0 = constructor_gen_extend(ctx, expr27_0, expr28_0, expr29_0, expr30_0)?;
        return Some(expr31_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1792.
    let expr0_0: bool = true;
    let expr1_0 = constructor_ext_int_if_need(ctx, expr0_0, pattern0_0, pattern2_0)?;
    let expr2_0 = constructor_convert_valueregs_reg(ctx, expr1_0)?;
    let expr3_0: bool = true;
    let expr4_0 = constructor_ext_int_if_need(ctx, expr3_0, pattern1_0, pattern2_0)?;
    let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0)?;
    let expr6_0 = constructor_alu_sub(ctx, expr2_0, expr5_0)?;
    let expr7_0: Type = I64;
    let expr8_0 = C::temp_writable_reg(ctx, expr7_0);
    let expr9_0: bool = true;
    let expr10_0 = C::ty_bits(ctx, pattern2_0)?;
    let expr11_0: u8 = 64i128 as u8;
    let expr12_0 = MInst::Extend {
        rd: expr8_0,
        rn: expr6_0,
        signed: expr9_0,
        from_bits: expr10_0,
        to_bits: expr11_0,
    };
    let expr13_0 = C::emit(ctx, &expr12_0);
    let expr14_0 = IntCC::NotEqual;
    let expr15_0 = C::writable_reg_to_reg(ctx, expr8_0);
    let expr16_0 = C::value_reg(ctx, expr15_0);
    let expr17_0 = C::value_reg(ctx, expr6_0);
    let expr18_0: Type = I64;
    let expr19_0 = constructor_gen_icmp(ctx, &expr14_0, expr16_0, expr17_0, expr18_0)?;
    return Some(expr19_0);
}

// Generated as internal constructor for term i128_sub.
pub fn constructor_i128_sub<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1836.
    let expr0_0 = AluOPRRR::Sub;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
    let expr3_0: usize = 0i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, pattern1_0, expr3_0);
    let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr2_0, expr4_0)?;
    let expr6_0 = AluOPRRR::SltU;
    let expr7_0: usize = 0i128 as usize;
    let expr8_0 = C::value_regs_get(ctx, pattern0_0, expr7_0);
    let expr9_0 = constructor_alu_rrr(ctx, &expr6_0, expr8_0, expr5_0)?;
    let expr10_0 = AluOPRRR::Sub;
    let expr11_0: usize = 1i128 as usize;
    let expr12_0 = C::value_regs_get(ctx, pattern0_0, expr11_0);
    let expr13_0: usize = 1i128 as usize;
    let expr14_0 = C::value_regs_get(ctx, pattern1_0, expr13_0);
    let expr15_0 = constructor_alu_rrr(ctx, &expr10_0, expr12_0, expr14_0)?;
    let expr16_0 = AluOPRRR::Sub;
    let expr17_0 = constructor_alu_rrr(ctx, &expr16_0, expr15_0, expr9_0)?;
    let expr18_0 = C::value_regs(ctx, expr5_0, expr17_0);
    return Some(expr18_0);
}

// Generated as internal constructor for term gen_fabs.
pub fn constructor_gen_fabs<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1851.
    let expr0_0 = constructor_fabs_copy_sign(ctx, pattern1_0)?;
    let expr1_0 = constructor_fpu_rrr(ctx, &expr0_0, pattern1_0, pattern0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term lower_uadd_overflow.
pub fn constructor_lower_uadd_overflow<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
    arg2: Type,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if pattern2_0 == I64 {
        // Rule at src/isa/riscv64/inst.isle line 1857.
        let expr0_0 = constructor_alu_add(ctx, pattern0_0, pattern1_0)?;
        let expr1_0 = IntCC::UnsignedLessThan;
        let expr2_0 = C::value_reg(ctx, expr0_0);
        let expr3_0 = C::value_reg(ctx, pattern0_0);
        let expr4_0: Type = I64;
        let expr5_0 = constructor_gen_icmp(ctx, &expr1_0, expr2_0, expr3_0, expr4_0)?;
        let expr6_0 = C::value_regs(ctx, expr0_0, expr5_0);
        return Some(expr6_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if let Some(pattern3_0) = C::fits_in_32(ctx, pattern2_0) {
        // Rule at src/isa/riscv64/inst.isle line 1864.
        let expr0_0: bool = false;
        let expr1_0 = C::value_reg(ctx, pattern0_0);
        let expr2_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0)?;
        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
        let expr4_0: bool = false;
        let expr5_0 = C::value_reg(ctx, pattern1_0);
        let expr6_0 = constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0)?;
        let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0)?;
        let expr8_0 = constructor_alu_add(ctx, expr3_0, expr7_0)?;
        let expr9_0 = C::ty_bits(ctx, pattern3_0)?;
        let expr10_0 = C::u8_as_i32(ctx, expr9_0);
        let expr11_0 = constructor_alu_srli(ctx, expr8_0, expr10_0)?;
        let expr12_0 = C::value_regs(ctx, expr8_0, expr11_0);
        return Some(expr12_0);
    }
    return None;
}

// Generated as internal constructor for term gen_jump.
pub fn constructor_gen_jump<C: Context>(ctx: &mut C, arg0: MachLabel) -> Option<MInst> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1879.
    let expr0_0 = C::label_to_br_target(ctx, pattern0_0);
    let expr1_0 = MInst::Jal { dest: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term lower_branch.
pub fn constructor_lower_branch<C: Context>(
    ctx: &mut C,
    arg0: Inst,
    arg1: &VecMachLabel,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    if let &InstructionData::Branch {
        opcode: ref pattern2_0,
        args: pattern2_1,
        destination: pattern2_2,
    } = &pattern1_0
    {
        match pattern2_0 {
            &Opcode::Brz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    if let Some(pattern6_0) = C::def_inst(ctx, pattern5_0) {
                        let pattern7_0 = C::inst_data(ctx, pattern6_0);
                        match &pattern7_0 {
                            &InstructionData::FloatCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Fcmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = C::value_type(ctx, pattern10_0);
                                    let pattern12_0 = arg1;
                                    // Rule at src/isa/riscv64/inst.isle line 1928.
                                    let expr0_0 = C::floatcc_inverse(ctx, pattern8_2);
                                    let expr1_0 = C::put_in_reg(ctx, pattern10_0);
                                    let expr2_0 = C::put_in_reg(ctx, pattern10_1);
                                    let expr3_0 = C::lower_br_fcmp(
                                        ctx,
                                        &expr0_0,
                                        expr1_0,
                                        expr2_0,
                                        pattern12_0,
                                        pattern11_0,
                                    );
                                    return Some(expr3_0);
                                }
                            }
                            &InstructionData::IntCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Icmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = C::value_type(ctx, pattern10_0);
                                    let pattern12_0 = arg1;
                                    // Rule at src/isa/riscv64/inst.isle line 1924.
                                    let expr0_0 = C::intcc_inverse(ctx, pattern8_2);
                                    let expr1_0 = C::put_in_regs(ctx, pattern10_0);
                                    let expr2_0 = C::put_in_regs(ctx, pattern10_1);
                                    let expr3_0 = C::lower_br_icmp(
                                        ctx,
                                        &expr0_0,
                                        expr1_0,
                                        expr2_0,
                                        pattern12_0,
                                        pattern11_0,
                                    );
                                    return Some(expr3_0);
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            &Opcode::Brnz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    if let Some(pattern6_0) = C::def_inst(ctx, pattern5_0) {
                        let pattern7_0 = C::inst_data(ctx, pattern6_0);
                        match &pattern7_0 {
                            &InstructionData::FloatCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Fcmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = C::value_type(ctx, pattern10_0);
                                    let pattern12_0 = arg1;
                                    // Rule at src/isa/riscv64/inst.isle line 1941.
                                    let expr0_0 = C::put_in_reg(ctx, pattern10_0);
                                    let expr1_0 = C::put_in_reg(ctx, pattern10_1);
                                    let expr2_0 = C::lower_br_fcmp(
                                        ctx,
                                        pattern8_2,
                                        expr0_0,
                                        expr1_0,
                                        pattern12_0,
                                        pattern11_0,
                                    );
                                    return Some(expr2_0);
                                }
                            }
                            &InstructionData::IntCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Icmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = C::value_type(ctx, pattern10_0);
                                    let pattern12_0 = arg1;
                                    // Rule at src/isa/riscv64/inst.isle line 1937.
                                    let expr0_0 = C::put_in_regs(ctx, pattern10_0);
                                    let expr1_0 = C::put_in_regs(ctx, pattern10_1);
                                    let expr2_0 = C::lower_br_icmp(
                                        ctx,
                                        pattern8_2,
                                        expr0_0,
                                        expr1_0,
                                        pattern12_0,
                                        pattern11_0,
                                    );
                                    return Some(expr2_0);
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::BranchTable {
            opcode: ref pattern2_0,
            arg: pattern2_1,
            destination: pattern2_2,
            table: pattern2_3,
        } => {
            if let &Opcode::BrTable = pattern2_0 {
                let pattern4_0 = arg1;
                // Rule at src/isa/riscv64/inst.isle line 1950.
                let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                let expr1_0 = C::lower_br_table(ctx, expr0_0, pattern4_0);
                return Some(expr1_0);
            }
        }
        &InstructionData::Branch {
            opcode: ref pattern2_0,
            args: pattern2_1,
            destination: pattern2_2,
        } => {
            match pattern2_0 {
                &Opcode::Brz => {
                    let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                    if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                        let pattern6_0 = C::value_type(ctx, pattern5_0);
                        let pattern7_0 = arg1;
                        // Rule at src/isa/riscv64/inst.isle line 1921.
                        let expr0_0 = IntCC::Equal;
                        let expr1_0 = C::put_in_regs(ctx, pattern5_0);
                        let expr2_0 = constructor_normalize_cmp_value(ctx, pattern6_0, expr1_0)?;
                        let expr3_0 =
                            C::lower_brz_or_nz(ctx, &expr0_0, expr2_0, pattern7_0, pattern6_0);
                        return Some(expr3_0);
                    }
                }
                &Opcode::Brnz => {
                    let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                    if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                        let pattern6_0 = C::value_type(ctx, pattern5_0);
                        let pattern7_0 = arg1;
                        // Rule at src/isa/riscv64/inst.isle line 1934.
                        let expr0_0 = IntCC::NotEqual;
                        let expr1_0 = C::put_in_regs(ctx, pattern5_0);
                        let expr2_0 = constructor_normalize_cmp_value(ctx, pattern6_0, expr1_0)?;
                        let expr3_0 =
                            C::lower_brz_or_nz(ctx, &expr0_0, expr2_0, pattern7_0, pattern6_0);
                        return Some(expr3_0);
                    }
                }
                _ => {}
            }
        }
        &InstructionData::Jump {
            opcode: ref pattern2_0,
            args: pattern2_1,
            destination: pattern2_2,
        } => {
            if let &Opcode::Jump = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                let pattern5_0 = arg1;
                // Rule at src/isa/riscv64/inst.isle line 1886.
                let expr0_0: u8 = 0i128 as u8;
                let expr1_0 = C::vec_label_get(ctx, pattern5_0, expr0_0);
                let expr2_0 = constructor_gen_jump(ctx, expr1_0)?;
                let expr3_0 = SideEffectNoResult::Inst { inst: expr2_0 };
                let expr4_0 = constructor_side_effect(ctx, &expr3_0)?;
                return Some(expr4_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term normalize_cmp_value.
pub fn constructor_normalize_cmp_value<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    if pattern0_0 == I8 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1909.
        let expr0_0 = AluOPRRI::Andi;
        let expr1_0 = constructor_convert_valueregs_reg(ctx, pattern2_0)?;
        let expr2_0: i32 = 255i128 as i32;
        let expr3_0 = C::imm12_const(ctx, expr2_0);
        let expr4_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr1_0, expr3_0)?;
        let expr5_0 = C::value_reg(ctx, expr4_0);
        return Some(expr5_0);
    }
    if pattern0_0 == I16 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1911.
        let expr0_0 = AluOPRRR::And;
        let expr1_0 = constructor_convert_valueregs_reg(ctx, pattern2_0)?;
        let expr2_0: Type = I16;
        let expr3_0: u64 = 65535i128 as u64;
        let expr4_0 = C::imm(ctx, expr2_0, expr3_0);
        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr4_0)?;
        let expr6_0 = C::value_reg(ctx, expr5_0);
        return Some(expr6_0);
    }
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1913.
        let expr0_0 = AluOPRRI::Addiw;
        let expr1_0 = constructor_convert_valueregs_reg(ctx, pattern2_0)?;
        let expr2_0: i32 = 0i128 as i32;
        let expr3_0 = C::imm12_const(ctx, expr2_0);
        let expr4_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr1_0, expr3_0)?;
        let expr5_0 = C::value_reg(ctx, expr4_0);
        return Some(expr5_0);
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1916.
        return Some(pattern2_0);
    }
    if pattern0_0 == I128 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1917.
        return Some(pattern2_0);
    }
    return None;
}

// Generated as internal constructor for term gen_andn.
pub fn constructor_gen_andn<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 1961.
            let expr0_0 = AluOPRRR::Andn;
            let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0)?;
            return Some(expr1_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 1967.
            let expr0_0 = constructor_gen_bit_not(ctx, pattern1_0)?;
            let expr1_0 = constructor_alu_and(ctx, pattern0_0, expr0_0)?;
            return Some(expr1_0);
        }
    }
    return None;
}

// Generated as internal constructor for term gen_orn.
pub fn constructor_gen_orn<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 1975.
            let expr0_0 = AluOPRRR::Orn;
            let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0)?;
            return Some(expr1_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 1981.
            let expr0_0 = constructor_gen_bit_not(ctx, pattern1_0)?;
            let expr1_0 = AluOPRRR::Or;
            let expr2_0 = constructor_alu_rrr(ctx, &expr1_0, pattern0_0, expr0_0)?;
            return Some(expr2_0);
        }
    }
    return None;
}

// Generated as internal constructor for term gen_rev8.
pub fn constructor_gen_rev8<C: Context>(ctx: &mut C, arg0: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let mut closure1 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern1_0) = closure1() {
        if pattern1_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 1988.
            let expr0_0 = AluOPRRI::Rev8;
            let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern0_0)?;
            return Some(expr1_0);
        }
    }
    let pattern0_0 = arg0;
    let mut closure1 = || {
        let expr0_0 = C::has_b(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern1_0) = closure1() {
        if pattern1_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 1994.
            let expr0_0: Type = I64;
            let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
            let expr2_0: Type = I64;
            let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
            let expr4_0: Type = I64;
            let expr5_0 = C::temp_writable_reg(ctx, expr4_0);
            let expr6_0 = MInst::Rev8 {
                rs: pattern0_0,
                step: expr5_0,
                tmp: expr3_0,
                rd: expr1_0,
            };
            let expr7_0 = C::emit(ctx, &expr6_0);
            let expr8_0 = C::writable_reg_to_reg(ctx, expr1_0);
            return Some(expr8_0);
        }
    }
    return None;
}

// Generated as internal constructor for term gen_brev8.
pub fn constructor_gen_brev8<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_zbkb(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 2006.
            let expr0_0 = AluOPRRI::Brev8;
            let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern0_0)?;
            return Some(expr1_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_zbkb(ctx)?;
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 2011.
            let expr0_0: Type = I64;
            let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
            let expr2_0: Type = I64;
            let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
            let expr4_0: Type = I64;
            let expr5_0 = C::temp_writable_reg(ctx, expr4_0);
            let expr6_0: Type = I64;
            let expr7_0 = C::temp_writable_reg(ctx, expr6_0);
            let expr8_0 = MInst::Brev8 {
                rs: pattern0_0,
                ty: pattern1_0,
                step: expr5_0,
                tmp: expr1_0,
                tmp2: expr3_0,
                rd: expr7_0,
            };
            let expr9_0 = C::emit(ctx, &expr8_0);
            let expr10_0 = C::writable_reg_to_reg(ctx, expr7_0);
            return Some(expr10_0);
        }
    }
    return None;
}

// Generated as internal constructor for term gen_xor_not.
pub fn constructor_gen_xor_not<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 2024.
    let expr0_0 = constructor_gen_bit_not(ctx, pattern1_0)?;
    let expr1_0 = AluOPRRR::Xor;
    let expr2_0 = constructor_alu_rrr(ctx, &expr1_0, pattern0_0, expr0_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term lower_iabs.
pub fn constructor_lower_iabs<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 2031.
    let expr0_0: bool = true;
    let expr1_0 = C::value_reg(ctx, pattern0_0);
    let expr2_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern1_0)?;
    let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
    let expr4_0 = constructor_gen_bit_not(ctx, pattern0_0)?;
    let expr5_0 = AluOPRRI::Addi;
    let expr6_0: i32 = 1i128 as i32;
    let expr7_0 = C::imm12_const(ctx, expr6_0);
    let expr8_0 = constructor_alu_rr_imm12(ctx, &expr5_0, expr4_0, expr7_0)?;
    let expr9_0 = IntCC::SignedLessThan;
    let expr10_0 = C::zero_reg(ctx);
    let expr11_0 = C::gen_select_reg(ctx, &expr9_0, pattern0_0, expr10_0, expr8_0, pattern0_0);
    return Some(expr11_0);
}

// Generated as internal constructor for term output_ifcout.
pub fn constructor_output_ifcout<C: Context>(ctx: &mut C, arg0: Reg) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 2039.
    let expr0_0 = C::value_reg(ctx, pattern0_0);
    let expr1_0 = C::value_regs_invalid(ctx);
    let expr2_0 = C::output_pair(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term gen_trapff.
pub fn constructor_gen_trapff<C: Context>(
    ctx: &mut C,
    arg0: &FloatCC,
    arg1: Reg,
    arg2: Reg,
    arg3: Type,
    arg4: &TrapCode,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 2044.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::TrapFf {
        cc: pattern0_0.clone(),
        x: pattern1_0,
        y: pattern2_0,
        ty: pattern3_0,
        tmp: expr1_0,
        trap_code: pattern4_0.clone(),
    };
    let expr3_0 = SideEffectNoResult::Inst { inst: expr2_0 };
    let expr4_0 = constructor_side_effect(ctx, &expr3_0)?;
    return Some(expr4_0);
}

// Generated as internal constructor for term gen_trapif.
pub fn constructor_gen_trapif<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &TrapCode,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 2051.
    let expr0_0 = MInst::TrapIf {
        test: pattern0_0,
        trap_code: pattern1_0.clone(),
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    let expr2_0 = constructor_side_effect(ctx, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term gen_trapifc.
pub fn constructor_gen_trapifc<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: Reg,
    arg2: Reg,
    arg3: &TrapCode,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 2056.
    let expr0_0 = MInst::TrapIfC {
        rs1: pattern1_0,
        rs2: pattern2_0,
        cc: pattern0_0.clone(),
        trap_code: pattern3_0.clone(),
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    let expr2_0 = constructor_side_effect(ctx, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term gen_div_overflow.
pub fn constructor_gen_div_overflow<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
    arg2: Type,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 2065.
    let expr0_0: i32 = -1i128 as i32;
    let expr1_0 = constructor_load_imm12(ctx, expr0_0)?;
    let expr2_0: i32 = 1i128 as i32;
    let expr3_0 = constructor_load_imm12(ctx, expr2_0)?;
    let expr4_0: i32 = 63i128 as i32;
    let expr5_0 = constructor_alu_slli(ctx, expr3_0, expr4_0)?;
    let expr6_0 = C::shift_int_to_most_significant(ctx, pattern0_0, pattern2_0);
    let expr7_0 = IntCC::Equal;
    let expr8_0 = C::value_reg(ctx, expr1_0);
    let expr9_0 = C::value_reg(ctx, pattern1_0);
    let expr10_0 = constructor_gen_icmp(ctx, &expr7_0, expr8_0, expr9_0, pattern2_0)?;
    let expr11_0 = IntCC::Equal;
    let expr12_0 = C::value_reg(ctx, expr5_0);
    let expr13_0 = C::value_reg(ctx, expr6_0);
    let expr14_0 = constructor_gen_icmp(ctx, &expr11_0, expr12_0, expr13_0, pattern2_0)?;
    let expr15_0 = constructor_alu_and(ctx, expr10_0, expr14_0)?;
    let expr16_0 = TrapCode::IntegerOverflow;
    let expr17_0 = constructor_gen_trapif(ctx, expr15_0, &expr16_0)?;
    return Some(expr17_0);
}

// Generated as internal constructor for term gen_div_by_zero.
pub fn constructor_gen_div_by_zero<C: Context>(ctx: &mut C, arg0: Reg) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 2077.
    let expr0_0 = IntCC::Equal;
    let expr1_0 = C::zero_reg(ctx);
    let expr2_0 = TrapCode::IntegerDivisionByZero;
    let expr3_0 = constructor_gen_trapifc(ctx, &expr0_0, expr1_0, pattern0_0, &expr2_0)?;
    return Some(expr3_0);
}

// Generated as internal constructor for term madd.
pub fn constructor_madd<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg, arg2: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 2091.
    let expr0_0 = AluOPRRR::Mul;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    let expr2_0 = constructor_alu_add(ctx, expr1_0, pattern2_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term umulh.
pub fn constructor_umulh<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 2097.
    let expr0_0 = AluOPRRR::Mulhu;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term lower_bmask.
pub fn constructor_lower_bmask<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    if pattern0_0 == I128 {
        let pattern2_0 = arg1;
        if pattern2_0 == I128 {
            let pattern4_0 = arg2;
            // Rule at src/isa/riscv64/inst.isle line 2137.
            let expr0_0: Type = I64;
            let expr1_0: Type = I128;
            let expr2_0 = constructor_lower_bmask(ctx, expr0_0, expr1_0, pattern4_0)?;
            let expr3_0: usize = 0i128 as usize;
            let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
            let expr5_0: usize = 0i128 as usize;
            let expr6_0 = C::value_regs_get(ctx, expr2_0, expr5_0);
            let expr7_0 = C::value_regs(ctx, expr4_0, expr6_0);
            return Some(expr7_0);
        }
    }
    let pattern0_0 = arg0;
    if pattern0_0 == I128 {
        let pattern2_0 = arg1;
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = arg2;
            // Rule at src/isa/riscv64/inst.isle line 2128.
            let expr0_0: Type = I64;
            let expr1_0 = constructor_lower_bmask(ctx, expr0_0, pattern3_0, pattern4_0)?;
            let expr2_0: usize = 0i128 as usize;
            let expr3_0 = C::value_regs_get(ctx, expr1_0, expr2_0);
            let expr4_0: usize = 0i128 as usize;
            let expr5_0 = C::value_regs_get(ctx, expr1_0, expr4_0);
            let expr6_0 = C::value_regs(ctx, expr3_0, expr5_0);
            return Some(expr6_0);
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        if pattern2_0 == I128 {
            let pattern4_0 = arg2;
            // Rule at src/isa/riscv64/inst.isle line 2118.
            let expr0_0: usize = 0i128 as usize;
            let expr1_0 = C::value_regs_get(ctx, pattern4_0, expr0_0);
            let expr2_0: usize = 1i128 as usize;
            let expr3_0 = C::value_regs_get(ctx, pattern4_0, expr2_0);
            let expr4_0 = AluOPRRR::Or;
            let expr5_0 = constructor_alu_rrr(ctx, &expr4_0, expr1_0, expr3_0)?;
            let expr6_0: Type = I64;
            let expr7_0 = C::value_reg(ctx, expr5_0);
            let expr8_0 = constructor_lower_bmask(ctx, pattern1_0, expr6_0, expr7_0)?;
            return Some(expr8_0);
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = arg2;
            // Rule at src/isa/riscv64/inst.isle line 2108.
            let expr0_0 = constructor_normalize_cmp_value(ctx, pattern3_0, pattern4_0)?;
            let expr1_0 = constructor_convert_valueregs_reg(ctx, expr0_0)?;
            let expr2_0 = C::zero_reg(ctx);
            let expr3_0: i32 = -1i128 as i32;
            let expr4_0 = constructor_load_imm12(ctx, expr3_0)?;
            let expr5_0 = IntCC::Equal;
            let expr6_0 = C::gen_select_reg(ctx, &expr5_0, expr2_0, expr1_0, expr2_0, expr4_0);
            let expr7_0 = C::value_reg(ctx, expr6_0);
            return Some(expr7_0);
        }
    }
    return None;
}

// Generated as internal constructor for term lower.
pub fn constructor_lower<C: Context>(ctx: &mut C, arg0: Inst) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I8 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 309.
                                        let expr0_0 = AluOPRRI::Slliw;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0: i32 = 7i128 as i32;
                                        let expr3_0 = C::imm12_and(ctx, pattern13_0, expr2_0);
                                        let expr4_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr1_0, expr3_0,
                                        )?;
                                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                                        return Some(expr5_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 335.
                                        let expr0_0 = AluOPRRI::SrliW;
                                        let expr1_0: bool = false;
                                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                                        let expr3_0: Type = I8;
                                        let expr4_0 = constructor_ext_int_if_need(
                                            ctx, expr1_0, expr2_0, expr3_0,
                                        )?;
                                        let expr5_0 =
                                            constructor_convert_valueregs_reg(ctx, expr4_0)?;
                                        let expr6_0: i32 = 7i128 as i32;
                                        let expr7_0 = C::imm12_and(ctx, pattern13_0, expr6_0);
                                        let expr8_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr5_0, expr7_0,
                                        )?;
                                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                                        return Some(expr9_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 362.
                                        let expr0_0 = AluOPRRI::Srai;
                                        let expr1_0: bool = true;
                                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                                        let expr3_0: Type = I8;
                                        let expr4_0 = constructor_ext_int_if_need(
                                            ctx, expr1_0, expr2_0, expr3_0,
                                        )?;
                                        let expr5_0 =
                                            constructor_convert_valueregs_reg(ctx, expr4_0)?;
                                        let expr6_0: i32 = 7i128 as i32;
                                        let expr7_0 = C::imm12_and(ctx, pattern13_0, expr6_0);
                                        let expr8_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr5_0, expr7_0,
                                        )?;
                                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                                        return Some(expr9_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I16 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 315.
                                        let expr0_0 = AluOPRRI::Slliw;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0: i32 = 15i128 as i32;
                                        let expr3_0 = C::imm12_and(ctx, pattern13_0, expr2_0);
                                        let expr4_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr1_0, expr3_0,
                                        )?;
                                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                                        return Some(expr5_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 341.
                                        let expr0_0 = AluOPRRI::SrliW;
                                        let expr1_0: bool = false;
                                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                                        let expr3_0: Type = I16;
                                        let expr4_0 = constructor_ext_int_if_need(
                                            ctx, expr1_0, expr2_0, expr3_0,
                                        )?;
                                        let expr5_0 =
                                            constructor_convert_valueregs_reg(ctx, expr4_0)?;
                                        let expr6_0: i32 = 15i128 as i32;
                                        let expr7_0 = C::imm12_and(ctx, pattern13_0, expr6_0);
                                        let expr8_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr5_0, expr7_0,
                                        )?;
                                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                                        return Some(expr9_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 368.
                                        let expr0_0 = AluOPRRI::Srai;
                                        let expr1_0: bool = true;
                                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                                        let expr3_0: Type = I16;
                                        let expr4_0 = constructor_ext_int_if_need(
                                            ctx, expr1_0, expr2_0, expr3_0,
                                        )?;
                                        let expr5_0 =
                                            constructor_convert_valueregs_reg(ctx, expr4_0)?;
                                        let expr6_0: i32 = 15i128 as i32;
                                        let expr7_0 = C::imm12_and(ctx, pattern13_0, expr6_0);
                                        let expr8_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr5_0, expr7_0,
                                        )?;
                                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                                        return Some(expr9_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 320.
                                        let expr0_0 = AluOPRRI::Slliw;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 346.
                                        let expr0_0 = AluOPRRI::SrliW;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 373.
                                        let expr0_0 = AluOPRRI::Sraiw;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 323.
                                        let expr0_0 = AluOPRRI::Slli;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 349.
                                        let expr0_0 = AluOPRRI::Srli;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 377.
                                        let expr0_0 = AluOPRRI::Srai;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Ineg = pattern5_0 {
                    // Rule at src/isa/riscv64/lower.isle line 77.
                    let expr0_0 = constructor_value_regs_zero(ctx)?;
                    let expr1_0 = C::put_in_regs(ctx, pattern5_1);
                    let expr2_0 = constructor_i128_sub(ctx, expr0_0, expr1_0)?;
                    let expr3_0 = C::output(ctx, expr2_0);
                    return Some(expr3_0);
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 30.
                                        let expr0_0 = constructor_select_addi(ctx, pattern3_0)?;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 191.
                                        let expr0_0 = AluOPRRI::Andi;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 211.
                                        let expr0_0 = AluOPRRI::Ori;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bxor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 229.
                                        let expr0_0 = AluOPRRI::Xori;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        )?;
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::valid_atomic_transaction(ctx, pattern2_0) {
            if let Some(pattern4_0) = C::fits_in_16(ctx, pattern3_0) {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::AtomicRmw {
                    opcode: ref pattern6_0,
                    args: ref pattern6_1,
                    flags: pattern6_2,
                    op: ref pattern6_3,
                } = &pattern5_0
                {
                    if let &Opcode::AtomicRmw = pattern6_0 {
                        let (pattern8_0, pattern8_1) = C::unpack_value_array_2(ctx, pattern6_1);
                        if let Some((pattern9_0, pattern9_1)) =
                            C::is_atomic_rmw_max_etc(ctx, pattern6_3)
                        {
                            if pattern9_1 == true {
                                // Rule at src/isa/riscv64/lower.isle line 472.
                                let expr0_0 = C::put_in_reg(ctx, pattern8_0);
                                let expr1_0: bool = true;
                                let expr2_0 = C::put_in_regs(ctx, pattern8_1);
                                let expr3_0 =
                                    constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern4_0)?;
                                let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0)?;
                                let expr5_0 = constructor_gen_atomic_rmw_loop(
                                    ctx,
                                    &pattern9_0,
                                    pattern4_0,
                                    expr0_0,
                                    expr4_0,
                                )?;
                                let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                                return Some(expr6_0);
                            }
                            if pattern9_1 == false {
                                // Rule at src/isa/riscv64/lower.isle line 478.
                                let expr0_0 = C::put_in_reg(ctx, pattern8_0);
                                let expr1_0: bool = false;
                                let expr2_0 = C::put_in_regs(ctx, pattern8_1);
                                let expr3_0 =
                                    constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern4_0)?;
                                let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0)?;
                                let expr5_0 = constructor_gen_atomic_rmw_loop(
                                    ctx,
                                    &pattern9_0,
                                    pattern4_0,
                                    expr0_0,
                                    expr4_0,
                                )?;
                                let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                                return Some(expr6_0);
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    if let &InstructionData::IntCompare {
        opcode: ref pattern2_0,
        args: ref pattern2_1,
        cond: ref pattern2_2,
    } = &pattern1_0
    {
        if let &Opcode::Icmp = pattern2_0 {
            let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
            if let Some(pattern5_0) = C::def_inst(ctx, pattern4_0) {
                let pattern6_0 = C::inst_data(ctx, pattern5_0);
                if let &InstructionData::Binary {
                    opcode: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::IaddIfcout = pattern7_0 {
                        let (pattern9_0, pattern9_1) = C::unpack_value_array_2(ctx, pattern7_1);
                        let pattern10_0 = C::value_type(ctx, pattern9_0);
                        // Rule at src/isa/riscv64/lower.isle line 751.
                        let expr0_0 = C::put_in_reg(ctx, pattern9_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern9_1);
                        let expr2_0 = constructor_alu_add(ctx, expr0_0, expr1_0)?;
                        let expr3_0 = C::value_reg(ctx, expr2_0);
                        let expr4_0 = C::put_in_regs(ctx, pattern4_1);
                        let expr5_0 =
                            constructor_lower_icmp(ctx, pattern2_2, expr3_0, expr4_0, pattern10_0)?;
                        let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                }
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I8 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 306.
                        let expr0_0 = AluOPRRR::Sllw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0: i32 = 7i128 as i32;
                        let expr3_0 = constructor_alu_andi(ctx, pattern8_0, expr2_0)?;
                        let expr4_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr3_0)?;
                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 332.
                        let expr0_0 = AluOPRRR::Srlw;
                        let expr1_0: bool = false;
                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr3_0: Type = I8;
                        let expr4_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, expr3_0)?;
                        let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0)?;
                        let expr6_0: i32 = 7i128 as i32;
                        let expr7_0 = constructor_alu_andi(ctx, pattern8_0, expr6_0)?;
                        let expr8_0 = constructor_alu_rrr(ctx, &expr0_0, expr5_0, expr7_0)?;
                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                        return Some(expr9_0);
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 359.
                        let expr0_0 = AluOPRRR::Sra;
                        let expr1_0: bool = true;
                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr3_0: Type = I8;
                        let expr4_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, expr3_0)?;
                        let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0)?;
                        let expr6_0: i32 = 7i128 as i32;
                        let expr7_0 = constructor_alu_andi(ctx, pattern8_0, expr6_0)?;
                        let expr8_0 = constructor_alu_rrr(ctx, &expr0_0, expr5_0, expr7_0)?;
                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                        return Some(expr9_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I16 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 312.
                        let expr0_0 = AluOPRRR::Sllw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0: i32 = 15i128 as i32;
                        let expr3_0 = constructor_alu_andi(ctx, pattern8_0, expr2_0)?;
                        let expr4_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr3_0)?;
                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 338.
                        let expr0_0 = AluOPRRR::Srlw;
                        let expr1_0: bool = false;
                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr3_0: Type = I16;
                        let expr4_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, expr3_0)?;
                        let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0)?;
                        let expr6_0: i32 = 15i128 as i32;
                        let expr7_0 = constructor_alu_andi(ctx, pattern8_0, expr6_0)?;
                        let expr8_0 = constructor_alu_rrr(ctx, &expr0_0, expr5_0, expr7_0)?;
                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                        return Some(expr9_0);
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 365.
                        let expr0_0 = AluOPRRR::Sra;
                        let expr1_0: bool = true;
                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr3_0: Type = I16;
                        let expr4_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, expr3_0)?;
                        let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0)?;
                        let expr6_0: i32 = 15i128 as i32;
                        let expr7_0 = constructor_alu_andi(ctx, pattern8_0, expr6_0)?;
                        let expr8_0 = constructor_alu_rrr(ctx, &expr0_0, expr5_0, expr7_0)?;
                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                        return Some(expr9_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 318.
                        let expr0_0 = AluOPRRR::Sllw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, pattern8_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 344.
                        let expr0_0 = AluOPRRR::Srlw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, pattern8_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 371.
                        let expr0_0 = AluOPRRR::Sraw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, pattern8_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 325.
                        let expr0_0 = AluOPRRR::Sll;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, pattern8_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 351.
                        let expr0_0 = AluOPRRR::Srl;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, pattern8_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                        // Rule at src/isa/riscv64/lower.isle line 375.
                        let expr0_0 = AluOPRRR::Sra;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, pattern8_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Bitrev => {
                            // Rule at src/isa/riscv64/lower.isle line 261.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0: Type = I64;
                            let expr4_0 = constructor_lower_bit_reverse(ctx, expr2_0, expr3_0)?;
                            let expr5_0: usize = 1i128 as usize;
                            let expr6_0 = C::value_regs_get(ctx, expr0_0, expr5_0);
                            let expr7_0: Type = I64;
                            let expr8_0 = constructor_lower_bit_reverse(ctx, expr6_0, expr7_0)?;
                            let expr9_0 = C::value_regs(ctx, expr8_0, expr4_0);
                            let expr10_0 = C::output(ctx, expr9_0);
                            return Some(expr10_0);
                        }
                        &Opcode::Clz => {
                            // Rule at src/isa/riscv64/lower.isle line 278.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_clz_i128(ctx, expr0_0)?;
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Cls => {
                            // Rule at src/isa/riscv64/lower.isle line 424.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_cls_i128(ctx, expr0_0)?;
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Ctz => {
                            // Rule at src/isa/riscv64/lower.isle line 272.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_ctz_128(ctx, expr0_0)?;
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Popcnt => {
                            // Rule at src/isa/riscv64/lower.isle line 302.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_popcnt_i128(ctx, expr0_0)?;
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Load {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                    offset: pattern5_3,
                } => {
                    if let &Opcode::Load = pattern5_0 {
                        // Rule at src/isa/riscv64/lower.isle line 710.
                        let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                        let expr1_0 =
                            constructor_gen_load_128(ctx, expr0_0, pattern5_3, pattern5_2)?;
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::BandNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 293.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr4_0: usize = 0i128 as usize;
                            let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
                            let expr6_0 = constructor_gen_andn(ctx, expr2_0, expr5_0)?;
                            let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = C::value_regs_get(ctx, expr7_0, expr8_0);
                            let expr10_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr11_0: usize = 1i128 as usize;
                            let expr12_0 = C::value_regs_get(ctx, expr10_0, expr11_0);
                            let expr13_0 = constructor_gen_andn(ctx, expr9_0, expr12_0)?;
                            let expr14_0 = C::value_regs(ctx, expr6_0, expr13_0);
                            let expr15_0 = C::output(ctx, expr14_0);
                            return Some(expr15_0);
                        }
                        &Opcode::BorNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 414.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr4_0: usize = 0i128 as usize;
                            let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
                            let expr6_0 = constructor_gen_orn(ctx, expr2_0, expr5_0)?;
                            let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = C::value_regs_get(ctx, expr7_0, expr8_0);
                            let expr10_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr11_0: usize = 1i128 as usize;
                            let expr12_0 = C::value_regs_get(ctx, expr10_0, expr11_0);
                            let expr13_0 = constructor_gen_orn(ctx, expr9_0, expr12_0)?;
                            let expr14_0 = C::value_regs(ctx, expr6_0, expr13_0);
                            let expr15_0 = C::output(ctx, expr14_0);
                            return Some(expr15_0);
                        }
                        &Opcode::BxorNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 402.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr4_0: usize = 0i128 as usize;
                            let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
                            let expr6_0 = constructor_gen_xor_not(ctx, expr2_0, expr5_0)?;
                            let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = C::value_regs_get(ctx, expr7_0, expr8_0);
                            let expr10_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr11_0: usize = 1i128 as usize;
                            let expr12_0 = C::value_regs_get(ctx, expr10_0, expr11_0);
                            let expr13_0 = constructor_gen_xor_not(ctx, expr9_0, expr12_0)?;
                            let expr14_0 = C::value_regs(ctx, expr6_0, expr13_0);
                            let expr15_0 = C::output(ctx, expr14_0);
                            return Some(expr15_0);
                        }
                        &Opcode::Rotl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 387.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_lower_i128_rotl(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Rotr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 394.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_lower_i128_rotr(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    if let &Opcode::Ineg = pattern5_0 {
                        // Rule at src/isa/riscv64/lower.isle line 74.
                        let expr0_0 = AluOPRRR::Sub;
                        let expr1_0 = C::zero_reg(ctx);
                        let expr2_0 = C::put_in_reg(ctx, pattern5_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Iadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src/isa/riscv64/lower.isle line 27.
                                            let expr0_0 = constructor_select_addi(ctx, pattern3_0)?;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Band => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src/isa/riscv64/lower.isle line 194.
                                            let expr0_0 = AluOPRRI::Andi;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Bor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src/isa/riscv64/lower.isle line 214.
                                            let expr0_0 = AluOPRRI::Ori;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Bxor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src/isa/riscv64/lower.isle line 232.
                                            let expr0_0 = AluOPRRI::Xori;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::valid_atomic_transaction(ctx, pattern2_0) {
            if let Some(pattern4_0) = C::fits_in_16(ctx, pattern3_0) {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::AtomicRmw {
                    opcode: ref pattern6_0,
                    args: ref pattern6_1,
                    flags: pattern6_2,
                    op: ref pattern6_3,
                } = &pattern5_0
                {
                    if let &Opcode::AtomicRmw = pattern6_0 {
                        let (pattern8_0, pattern8_1) = C::unpack_value_array_2(ctx, pattern6_1);
                        // Rule at src/isa/riscv64/lower.isle line 465.
                        let expr0_0 = C::put_in_reg(ctx, pattern8_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern8_1);
                        let expr2_0 = constructor_gen_atomic_rmw_loop(
                            ctx, pattern6_3, pattern4_0, expr0_0, expr1_0,
                        )?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        if let &InstructionData::Ternary {
            opcode: ref pattern4_0,
            args: ref pattern4_1,
        } = &pattern3_0
        {
            if let &Opcode::Select = pattern4_0 {
                let (pattern6_0, pattern6_1, pattern6_2) = C::unpack_value_array_3(ctx, pattern4_1);
                if let Some(pattern7_0) = C::def_inst(ctx, pattern6_0) {
                    let pattern8_0 = C::inst_data(ctx, pattern7_0);
                    if let &InstructionData::IntCompare {
                        opcode: ref pattern9_0,
                        args: ref pattern9_1,
                        cond: ref pattern9_2,
                    } = &pattern8_0
                    {
                        if let &Opcode::Icmp = pattern9_0 {
                            let (pattern11_0, pattern11_1) =
                                C::unpack_value_array_2(ctx, pattern9_1);
                            // Rule at src/isa/riscv64/lower.isle line 612.
                            let expr0_0 = C::put_in_reg(ctx, pattern11_0);
                            let expr1_0 = C::put_in_reg(ctx, pattern11_1);
                            let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr3_0 = C::put_in_reg(ctx, pattern6_2);
                            let expr4_0 = C::gen_select_reg(
                                ctx, pattern9_2, expr0_0, expr1_0, expr2_0, expr3_0,
                            );
                            let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                    }
                }
            }
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::Store {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            if let &Opcode::Store = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if pattern5_0 == I128 {
                    // Rule at src/isa/riscv64/lower.isle line 734.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = C::put_in_regs(ctx, pattern4_0);
                    let expr2_0 =
                        constructor_gen_store_128(ctx, expr0_0, pattern2_3, pattern2_2, expr1_0)?;
                    return Some(expr2_0);
                }
            }
        }
        &InstructionData::IntCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Icmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::def_inst(ctx, pattern4_1) {
                    let pattern6_0 = C::inst_data(ctx, pattern5_0);
                    if let &InstructionData::Binary {
                        opcode: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &Opcode::IaddIfcout = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_value_array_2(ctx, pattern7_1);
                            let pattern10_0 = C::value_type(ctx, pattern9_0);
                            // Rule at src/isa/riscv64/lower.isle line 755.
                            let expr0_0 = C::put_in_regs(ctx, pattern4_0);
                            let expr1_0 = C::put_in_reg(ctx, pattern9_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern9_1);
                            let expr3_0 = constructor_alu_add(ctx, expr1_0, expr2_0)?;
                            let expr4_0 = C::value_reg(ctx, expr3_0);
                            let expr5_0 = constructor_lower_icmp(
                                ctx,
                                pattern2_2,
                                expr0_0,
                                expr4_0,
                                pattern10_0,
                            )?;
                            let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                    }
                }
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Urem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 170.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0: Type = I32;
                        let expr3_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0)?;
                        let expr5_0 = constructor_gen_div_by_zero(ctx, expr4_0)?;
                        let expr6_0 = AluOPRRR::Remuw;
                        let expr7_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr8_0 = constructor_alu_rrr(ctx, &expr6_0, expr7_0, expr4_0)?;
                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                        return Some(expr9_0);
                    }
                    &Opcode::Srem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 164.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0: Type = I32;
                        let expr3_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0)?;
                        let expr5_0 = constructor_gen_div_by_zero(ctx, expr4_0)?;
                        let expr6_0 = AluOPRRR::Remw;
                        let expr7_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr8_0 = constructor_alu_rrr(ctx, &expr6_0, expr7_0, expr4_0)?;
                        let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                        return Some(expr9_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Udiv => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 145.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr1_0 = constructor_gen_div_by_zero(ctx, expr0_0)?;
                        let expr2_0 = AluOPRRR::DivU;
                        let expr3_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr2_0, expr3_0, expr4_0)?;
                        let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                    &Opcode::Sdiv => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 139.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr2_0: Type = I64;
                        let expr3_0 = constructor_gen_div_overflow(ctx, expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr5_0 = constructor_gen_div_by_zero(ctx, expr4_0)?;
                        let expr6_0 = AluOPRRR::Div;
                        let expr7_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr8_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr9_0 = constructor_alu_rrr(ctx, &expr6_0, expr7_0, expr8_0)?;
                        let expr10_0 = constructor_output_reg(ctx, expr9_0)?;
                        return Some(expr10_0);
                    }
                    &Opcode::Urem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 181.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr1_0 = constructor_gen_div_by_zero(ctx, expr0_0)?;
                        let expr2_0 = AluOPRRR::RemU;
                        let expr3_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr2_0, expr3_0, expr4_0)?;
                        let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                    &Opcode::Srem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 176.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr1_0 = constructor_gen_div_by_zero(ctx, expr0_0)?;
                        let expr2_0 = AluOPRRR::Rem;
                        let expr3_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr2_0, expr3_0, expr4_0)?;
                        let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    if let &Opcode::Bnot = pattern5_0 {
                        // Rule at src/isa/riscv64/lower.isle line 246.
                        let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                        let expr1_0 = constructor_bnot_128(ctx, expr0_0)?;
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Iadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 34.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr4_0: usize = 0i128 as usize;
                            let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
                            let expr6_0 = constructor_alu_add(ctx, expr2_0, expr5_0)?;
                            let expr7_0 = AluOPRRR::SltU;
                            let expr8_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr9_0: usize = 0i128 as usize;
                            let expr10_0 = C::value_regs_get(ctx, expr8_0, expr9_0);
                            let expr11_0 = constructor_alu_rrr(ctx, &expr7_0, expr6_0, expr10_0)?;
                            let expr12_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr13_0: usize = 1i128 as usize;
                            let expr14_0 = C::value_regs_get(ctx, expr12_0, expr13_0);
                            let expr15_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr16_0: usize = 1i128 as usize;
                            let expr17_0 = C::value_regs_get(ctx, expr15_0, expr16_0);
                            let expr18_0 = constructor_alu_add(ctx, expr14_0, expr17_0)?;
                            let expr19_0 = constructor_alu_add(ctx, expr18_0, expr11_0)?;
                            let expr20_0 = C::value_regs(ctx, expr6_0, expr19_0);
                            let expr21_0 = C::output(ctx, expr20_0);
                            return Some(expr21_0);
                        }
                        &Opcode::Isub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 68.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_i128_sub(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Imul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 96.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0: usize = 1i128 as usize;
                            let expr4_0 = C::value_regs_get(ctx, expr0_0, expr3_0);
                            let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr6_0: usize = 0i128 as usize;
                            let expr7_0 = C::value_regs_get(ctx, expr5_0, expr6_0);
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = C::value_regs_get(ctx, expr5_0, expr8_0);
                            let expr10_0 = constructor_umulh(ctx, expr2_0, expr7_0)?;
                            let expr11_0 = constructor_madd(ctx, expr2_0, expr9_0, expr10_0)?;
                            let expr12_0 = constructor_madd(ctx, expr4_0, expr7_0, expr11_0)?;
                            let expr13_0 = C::zero_reg(ctx);
                            let expr14_0 = constructor_madd(ctx, expr2_0, expr7_0, expr13_0)?;
                            let expr15_0 = C::value_regs(ctx, expr14_0, expr12_0);
                            let expr16_0 = C::output(ctx, expr15_0);
                            return Some(expr16_0);
                        }
                        &Opcode::Band => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 197.
                            let expr0_0 = AluOPRRR::And;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr3_0 =
                                constructor_lower_b128_binary(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = C::output(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        &Opcode::Bor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 216.
                            let expr0_0 = AluOPRRR::Or;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr3_0 =
                                constructor_lower_b128_binary(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = C::output(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        &Opcode::Bxor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 234.
                            let expr0_0 = AluOPRRR::Xor;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr3_0 =
                                constructor_lower_b128_binary(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = C::output(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        &Opcode::Ishl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 328.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_lower_i128_ishl(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Ushr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 354.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_lower_i128_ushr(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Sshr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 379.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_lower_i128_sshr(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Iconcat => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 632.
                            let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr1_0: Type = I64;
                            let expr2_0: Type = I64;
                            let expr3_0 = C::gen_move2(ctx, expr0_0, expr1_0, expr2_0);
                            let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr5_0: Type = I64;
                            let expr6_0: Type = I64;
                            let expr7_0 = C::gen_move2(ctx, expr4_0, expr5_0, expr6_0);
                            let expr8_0 = C::value_regs(ctx, expr3_0, expr7_0);
                            let expr9_0 = C::output(ctx, expr8_0);
                            return Some(expr9_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Bnot => {
                            // Rule at src/isa/riscv64/lower.isle line 249.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0: Type = F32;
                            let expr2_0 = constructor_lower_float_bnot(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Sqrt => {
                            // Rule at src/isa/riscv64/lower.isle line 450.
                            let expr0_0 = FpuOPRR::FsqrtS;
                            let expr1_0: Type = F64;
                            let expr2_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr3_0 = constructor_fpu_rr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Band => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 200.
                            let expr0_0 = AluOPRRR::And;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F32;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        &Opcode::Bor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 218.
                            let expr0_0 = AluOPRRR::Or;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F32;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        &Opcode::Bxor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 236.
                            let expr0_0 = AluOPRRR::Xor;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F32;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Ternary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::Fma = pattern5_0 {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 443.
                        let expr0_0 = FpuOPRRRR::FmaddS;
                        let expr1_0: Type = F64;
                        let expr2_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_2);
                        let expr5_0 = constructor_fpu_rrrr(
                            ctx, &expr0_0, expr1_0, expr2_0, expr3_0, expr4_0,
                        )?;
                        let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Bnot => {
                            // Rule at src/isa/riscv64/lower.isle line 253.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0: Type = F64;
                            let expr2_0 = constructor_lower_float_bnot(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Sqrt => {
                            // Rule at src/isa/riscv64/lower.isle line 453.
                            let expr0_0 = FpuOPRR::FsqrtD;
                            let expr1_0: Type = F64;
                            let expr2_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr3_0 = constructor_fpu_rr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Band => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 202.
                            let expr0_0 = AluOPRRR::And;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F64;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        &Opcode::Bor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 220.
                            let expr0_0 = AluOPRRR::Or;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F64;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        &Opcode::Bxor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 238.
                            let expr0_0 = AluOPRRR::Xor;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F64;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Ternary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::Fma = pattern5_0 {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 445.
                        let expr0_0 = FpuOPRRRR::FmaddD;
                        let expr1_0: Type = F64;
                        let expr2_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_2);
                        let expr5_0 = constructor_fpu_rrrr(
                            ctx, &expr0_0, expr1_0, expr2_0, expr3_0, expr4_0,
                        )?;
                        let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Iabs => {
                            // Rule at src/isa/riscv64/lower.isle line 871.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_iabs(ctx, expr0_0, pattern3_0)?;
                            let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        &Opcode::Cls => {
                            // Rule at src/isa/riscv64/lower.isle line 422.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_cls(ctx, expr0_0, pattern3_0)?;
                            let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        &Opcode::Popcnt => {
                            // Rule at src/isa/riscv64/lower.isle line 300.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_popcnt(ctx, expr0_0, pattern3_0)?;
                            let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Umulhi => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 92.
                            let expr0_0: bool = false;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 =
                                constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0)?;
                            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
                            let expr4_0: bool = false;
                            let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr6_0 =
                                constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0)?;
                            let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0)?;
                            let expr8_0 =
                                constructor_lower_umlhi(ctx, pattern3_0, expr3_0, expr7_0)?;
                            let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                            return Some(expr9_0);
                        }
                        &Opcode::Smulhi => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 88.
                            let expr0_0: bool = true;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 =
                                constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0)?;
                            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
                            let expr4_0: bool = true;
                            let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr6_0 =
                                constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0)?;
                            let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0)?;
                            let expr8_0 =
                                constructor_lower_smlhi(ctx, pattern3_0, expr3_0, expr7_0)?;
                            let expr9_0 = constructor_output_reg(ctx, expr8_0)?;
                            return Some(expr9_0);
                        }
                        &Opcode::IaddIfcout => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 48.
                            let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr2_0 = constructor_alu_add(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_ifcout(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::BandNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 291.
                            let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr2_0 = constructor_gen_andn(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::BorNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 411.
                            let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr2_0 = constructor_gen_orn(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::BxorNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 400.
                            let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr2_0 = constructor_gen_xor_not(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Rotl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                            // Rule at src/isa/riscv64/lower.isle line 384.
                            let expr0_0: bool = false;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 =
                                constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0)?;
                            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
                            let expr4_0 =
                                constructor_lower_rotl(ctx, pattern3_0, expr3_0, pattern8_0)?;
                            let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        &Opcode::Rotr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            let pattern8_0 = C::valueregs_2_reg(ctx, pattern7_1);
                            // Rule at src/isa/riscv64/lower.isle line 391.
                            let expr0_0: bool = false;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 =
                                constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0)?;
                            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
                            let expr4_0 =
                                constructor_lower_rotr(ctx, pattern3_0, expr3_0, pattern8_0)?;
                            let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::IntAddTrap {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    code: ref pattern5_2,
                } => {
                    if let &Opcode::UaddOverflowTrap = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 53.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr2_0 =
                            constructor_lower_uadd_overflow(ctx, expr0_0, expr1_0, pattern3_0)?;
                        let expr3_0: usize = 1i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0 = constructor_gen_trapif(ctx, expr4_0, pattern5_2)?;
                        let expr6_0: usize = 0i128 as usize;
                        let expr7_0 = C::value_regs_get(ctx, expr2_0, expr6_0);
                        let expr8_0 = constructor_output_reg(ctx, expr7_0)?;
                        return Some(expr8_0);
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::valid_atomic_transaction(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::LoadNoOffset {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                } => {
                    if let &Opcode::AtomicLoad = pattern5_0 {
                        // Rule at src/isa/riscv64/lower.isle line 514.
                        let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                        let expr1_0 = constructor_gen_atomic_load(ctx, expr0_0, pattern3_0)?;
                        let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
                &InstructionData::AtomicRmw {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    flags: pattern5_2,
                    op: ref pattern5_3,
                } => {
                    if let &Opcode::AtomicRmw = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        match pattern5_3 {
                            &AtomicRmwOp::Nand => {
                                // Rule at src/isa/riscv64/lower.isle line 505.
                                let expr0_0 = AtomicRmwOp::Nand;
                                let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                                let expr3_0 = constructor_gen_atomic_rmw_loop(
                                    ctx, &expr0_0, pattern3_0, expr1_0, expr2_0,
                                )?;
                                let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                                return Some(expr4_0);
                            }
                            &AtomicRmwOp::Sub => {
                                // Rule at src/isa/riscv64/lower.isle line 487.
                                let expr0_0 = C::temp_writable_reg(ctx, pattern3_0);
                                let expr1_0 = AluOPRRR::Sub;
                                let expr2_0 = C::zero_reg(ctx);
                                let expr3_0 = C::put_in_reg(ctx, pattern7_1);
                                let expr4_0 = constructor_alu_rrr(ctx, &expr1_0, expr2_0, expr3_0)?;
                                let expr5_0 = AtomicRmwOp::Add;
                                let expr6_0 =
                                    constructor_get_atomic_rmw_op(ctx, pattern3_0, &expr5_0)?;
                                let expr7_0 = C::put_in_reg(ctx, pattern7_0);
                                let expr8_0 = C::atomic_amo(ctx);
                                let expr9_0 = constructor_gen_atomic(
                                    ctx, &expr6_0, expr7_0, expr4_0, expr8_0,
                                )?;
                                let expr10_0 = constructor_output_reg(ctx, expr9_0)?;
                                return Some(expr10_0);
                            }
                            _ => {}
                        }
                    }
                }
                &InstructionData::AtomicCas {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    flags: pattern5_2,
                } => {
                    if let &Opcode::AtomicCas = pattern5_0 {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 540.
                        let expr0_0 = C::temp_writable_reg(ctx, pattern3_0);
                        let expr1_0 = C::temp_writable_reg(ctx, pattern3_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr3_0 = constructor_gen_atomic_offset(ctx, expr2_0, pattern3_0)?;
                        let expr4_0: bool = false;
                        let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0)?;
                        let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0)?;
                        let expr8_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr9_0 = constructor_gen_atomic_p(ctx, expr8_0, pattern3_0)?;
                        let expr10_0 = C::put_in_reg(ctx, pattern7_2);
                        let expr11_0 = MInst::AtomicCas {
                            offset: expr3_0,
                            t0: expr0_0,
                            dst: expr1_0,
                            e: expr7_0,
                            addr: expr9_0,
                            v: expr10_0,
                            ty: pattern3_0,
                        };
                        let expr12_0 = C::emit(ctx, &expr11_0);
                        let expr13_0 = C::writable_reg_to_reg(ctx, expr1_0);
                        let expr14_0 = constructor_output_reg(ctx, expr13_0)?;
                        return Some(expr14_0);
                    }
                }
                _ => {}
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        match &pattern3_0 {
            &InstructionData::NullAry {
                opcode: ref pattern4_0,
            } => {
                if let &Opcode::Null = pattern4_0 {
                    // Rule at src/isa/riscv64/lower.isle line 14.
                    let expr0_0: u64 = 0i128 as u64;
                    let expr1_0 = C::imm(ctx, pattern2_0, expr0_0);
                    let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
            }
            &InstructionData::Unary {
                opcode: ref pattern4_0,
                arg: pattern4_1,
            } => {
                match pattern4_0 {
                    &Opcode::Bitrev => {
                        // Rule at src/isa/riscv64/lower.isle line 258.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0 = constructor_lower_bit_reverse(ctx, expr0_0, pattern2_0)?;
                        let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                    &Opcode::Clz => {
                        // Rule at src/isa/riscv64/lower.isle line 276.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0 = constructor_lower_clz(ctx, pattern2_0, expr0_0)?;
                        let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                    &Opcode::Ctz => {
                        // Rule at src/isa/riscv64/lower.isle line 269.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0 = constructor_lower_ctz(ctx, pattern2_0, expr0_0)?;
                        let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                    &Opcode::Fneg => {
                        // Rule at src/isa/riscv64/lower.isle line 435.
                        let expr0_0 = constructor_f_copy_neg_sign_op(ctx, pattern2_0)?;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr3_0 =
                            constructor_fpu_rrr(ctx, &expr0_0, pattern2_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Fabs => {
                        // Rule at src/isa/riscv64/lower.isle line 430.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0 = constructor_gen_fabs(ctx, expr0_0, pattern2_0)?;
                        let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                    &Opcode::Ceil => {
                        // Rule at src/isa/riscv64/lower.isle line 819.
                        let expr0_0 = FloatRoundOP::Ceil;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 =
                            constructor_gen_float_round(ctx, &expr0_0, expr1_0, pattern2_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Floor => {
                        // Rule at src/isa/riscv64/lower.isle line 825.
                        let expr0_0 = FloatRoundOP::Floor;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 =
                            constructor_gen_float_round(ctx, &expr0_0, expr1_0, pattern2_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Trunc => {
                        // Rule at src/isa/riscv64/lower.isle line 829.
                        let expr0_0 = FloatRoundOP::Trunc;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 =
                            constructor_gen_float_round(ctx, &expr0_0, expr1_0, pattern2_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Nearest => {
                        // Rule at src/isa/riscv64/lower.isle line 834.
                        let expr0_0 = FloatRoundOP::Nearest;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 =
                            constructor_gen_float_round(ctx, &expr0_0, expr1_0, pattern2_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Bmask => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 850.
                        let expr0_0 = C::put_in_regs(ctx, pattern4_1);
                        let expr1_0 =
                            constructor_lower_bmask(ctx, pattern2_0, pattern6_0, expr0_0)?;
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                    &Opcode::Ireduce => {
                        // Rule at src/isa/riscv64/lower.isle line 549.
                        let expr0_0 = C::put_in_regs(ctx, pattern4_1);
                        let expr1_0: usize = 0i128 as usize;
                        let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                        let expr3_0 = C::gen_move2(ctx, expr2_0, pattern2_0, pattern2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Uextend => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 282.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0: bool = false;
                        let expr2_0 = C::ty_bits(ctx, pattern6_0)?;
                        let expr3_0 = C::ty_bits(ctx, pattern2_0)?;
                        let expr4_0 =
                            constructor_lower_extend(ctx, expr0_0, expr1_0, expr2_0, expr3_0)?;
                        let expr5_0 = C::output(ctx, expr4_0);
                        return Some(expr5_0);
                    }
                    &Opcode::Sextend => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 286.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0: bool = true;
                        let expr2_0 = C::ty_bits(ctx, pattern6_0)?;
                        let expr3_0 = C::ty_bits(ctx, pattern2_0)?;
                        let expr4_0 =
                            constructor_lower_extend(ctx, expr0_0, expr1_0, expr2_0, expr3_0)?;
                        let expr5_0 = C::output(ctx, expr4_0);
                        return Some(expr5_0);
                    }
                    &Opcode::Fpromote => {
                        // Rule at src/isa/riscv64/lower.isle line 554.
                        let expr0_0 = FpuOPRR::FcvtDS;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 = constructor_fpu_rr(ctx, &expr0_0, pattern2_0, expr1_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Fdemote => {
                        // Rule at src/isa/riscv64/lower.isle line 558.
                        let expr0_0 = FpuOPRR::FcvtSD;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 = constructor_fpu_rr(ctx, &expr0_0, pattern2_0, expr1_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::FcvtToUint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 779.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0: bool = false;
                        let expr3_0 = constructor_gen_fcvt_int(
                            ctx, expr0_0, expr1_0, expr2_0, pattern6_0, pattern2_0,
                        )?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtToSint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 784.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0: bool = true;
                        let expr3_0 = constructor_gen_fcvt_int(
                            ctx, expr0_0, expr1_0, expr2_0, pattern6_0, pattern2_0,
                        )?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtToUintSat => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 794.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0: bool = false;
                        let expr3_0 = constructor_gen_fcvt_int(
                            ctx, expr0_0, expr1_0, expr2_0, pattern6_0, pattern2_0,
                        )?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtToSintSat => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 789.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0: bool = true;
                        let expr3_0 = constructor_gen_fcvt_int(
                            ctx, expr0_0, expr1_0, expr2_0, pattern6_0, pattern2_0,
                        )?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtFromUint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 804.
                        let expr0_0: bool = false;
                        let expr1_0 =
                            C::int_convert_2_float_op(ctx, pattern6_0, expr0_0, pattern2_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr3_0 = constructor_fpu_rr(ctx, &expr1_0, pattern2_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtFromSint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 799.
                        let expr0_0: bool = true;
                        let expr1_0 =
                            C::int_convert_2_float_op(ctx, pattern6_0, expr0_0, pattern2_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr3_0 = constructor_fpu_rr(ctx, &expr1_0, pattern2_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
            &InstructionData::LoadNoOffset {
                opcode: ref pattern4_0,
                arg: pattern4_1,
                flags: pattern4_2,
            } => {
                if let &Opcode::Bitcast = pattern4_0 {
                    let pattern6_0 = C::value_type(ctx, pattern4_1);
                    // Rule at src/isa/riscv64/lower.isle line 814.
                    let expr0_0 = C::put_in_regs(ctx, pattern4_1);
                    let expr1_0 = C::gen_moves(ctx, expr0_0, pattern6_0, pattern2_0);
                    let expr2_0 = C::output(ctx, expr1_0);
                    return Some(expr2_0);
                }
            }
            &InstructionData::Load {
                opcode: ref pattern4_0,
                arg: pattern4_1,
                flags: pattern4_2,
                offset: pattern4_3,
            } => {
                if let &Opcode::Load = pattern4_0 {
                    // Rule at src/isa/riscv64/lower.isle line 706.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = C::load_op(ctx, pattern2_0);
                    let expr2_0 = constructor_gen_load(
                        ctx, expr0_0, pattern4_3, &expr1_0, pattern4_2, pattern2_0,
                    )?;
                    let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                    return Some(expr3_0);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref pattern4_0,
                imm: pattern4_1,
            } => {
                if let &Opcode::Iconst = pattern4_0 {
                    let pattern6_0 = C::u64_from_imm64(ctx, pattern4_1);
                    // Rule at src/isa/riscv64/lower.isle line 9.
                    let expr0_0 = C::imm(ctx, pattern2_0, pattern6_0);
                    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                    return Some(expr1_0);
                }
            }
            &InstructionData::Binary {
                opcode: ref pattern4_0,
                args: ref pattern4_1,
            } => {
                match pattern4_0 {
                    &Opcode::Smin => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 645.
                        let expr0_0 = IntSelectOP::Smin;
                        let expr1_0: bool = true;
                        let expr2_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr3_0 =
                            constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern2_0)?;
                        let expr4_0: bool = true;
                        let expr5_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern2_0)?;
                        let expr7_0 = constructor_gen_int_select(
                            ctx, pattern2_0, &expr0_0, expr3_0, expr6_0,
                        )?;
                        let expr8_0 = C::output(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Umin => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 654.
                        let expr0_0 = IntSelectOP::Umin;
                        let expr1_0: bool = false;
                        let expr2_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr3_0 =
                            constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern2_0)?;
                        let expr4_0: bool = false;
                        let expr5_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern2_0)?;
                        let expr7_0 = constructor_gen_int_select(
                            ctx, pattern2_0, &expr0_0, expr3_0, expr6_0,
                        )?;
                        let expr8_0 = C::output(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Smax => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 640.
                        let expr0_0 = IntSelectOP::Smax;
                        let expr1_0: bool = true;
                        let expr2_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr3_0 =
                            constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern2_0)?;
                        let expr4_0: bool = true;
                        let expr5_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern2_0)?;
                        let expr7_0 = constructor_gen_int_select(
                            ctx, pattern2_0, &expr0_0, expr3_0, expr6_0,
                        )?;
                        let expr8_0 = C::output(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Umax => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 649.
                        let expr0_0 = IntSelectOP::Umax;
                        let expr1_0: bool = false;
                        let expr2_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr3_0 =
                            constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern2_0)?;
                        let expr4_0: bool = false;
                        let expr5_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern2_0)?;
                        let expr7_0 = constructor_gen_int_select(
                            ctx, pattern2_0, &expr0_0, expr3_0, expr6_0,
                        )?;
                        let expr8_0 = C::output(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Fadd => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 564.
                        let expr0_0 = Opcode::Fadd;
                        let expr1_0 = constructor_f_arithmatic_op(ctx, pattern2_0, &expr0_0)?;
                        let expr2_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr4_0 =
                            constructor_fpu_rrr(ctx, &expr1_0, pattern2_0, expr2_0, expr3_0)?;
                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                    &Opcode::Fsub => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 567.
                        let expr0_0 = Opcode::Fsub;
                        let expr1_0 = constructor_f_arithmatic_op(ctx, pattern2_0, &expr0_0)?;
                        let expr2_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr4_0 =
                            constructor_fpu_rrr(ctx, &expr1_0, pattern2_0, expr2_0, expr3_0)?;
                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                    &Opcode::Fmul => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 570.
                        let expr0_0 = Opcode::Fmul;
                        let expr1_0 = constructor_f_arithmatic_op(ctx, pattern2_0, &expr0_0)?;
                        let expr2_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr4_0 =
                            constructor_fpu_rrr(ctx, &expr1_0, pattern2_0, expr2_0, expr3_0)?;
                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                    &Opcode::Fdiv => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 573.
                        let expr0_0 = Opcode::Fdiv;
                        let expr1_0 = constructor_f_arithmatic_op(ctx, pattern2_0, &expr0_0)?;
                        let expr2_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr4_0 =
                            constructor_fpu_rrr(ctx, &expr1_0, pattern2_0, expr2_0, expr3_0)?;
                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                    &Opcode::Fcopysign => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 439.
                        let expr0_0 = constructor_f_copysign_op(ctx, pattern2_0)?;
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 =
                            constructor_fpu_rrr(ctx, &expr0_0, pattern2_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Fmin => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 577.
                        let expr0_0 = FloatSelectOP::Min;
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 = constructor_gen_float_select(
                            ctx, &expr0_0, expr1_0, expr2_0, pattern2_0,
                        )?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::FminPseudo => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 581.
                        let expr0_0 = FloatSelectOP::Min;
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 = constructor_gen_float_select_pseudo(
                            ctx, &expr0_0, expr1_0, expr2_0, pattern2_0,
                        )?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Fmax => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 585.
                        let expr0_0 = FloatSelectOP::Max;
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 = constructor_gen_float_select(
                            ctx, &expr0_0, expr1_0, expr2_0, pattern2_0,
                        )?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::FmaxPseudo => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 589.
                        let expr0_0 = FloatSelectOP::Max;
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 = constructor_gen_float_select_pseudo(
                            ctx, &expr0_0, expr1_0, expr2_0, pattern2_0,
                        )?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
            &InstructionData::Ternary {
                opcode: ref pattern4_0,
                args: ref pattern4_1,
            } => {
                match pattern4_0 {
                    &Opcode::Select => {
                        let (pattern6_0, pattern6_1, pattern6_2) =
                            C::unpack_value_array_3(ctx, pattern4_1);
                        let pattern7_0 = C::value_type(ctx, pattern6_0);
                        // Rule at src/isa/riscv64/lower.isle line 609.
                        let expr0_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr1_0 = constructor_normalize_cmp_value(ctx, pattern7_0, expr0_0)?;
                        let expr2_0 = constructor_convert_valueregs_reg(ctx, expr1_0)?;
                        let expr3_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr4_0 = C::put_in_regs(ctx, pattern6_2);
                        let expr5_0 =
                            constructor_gen_select(ctx, pattern2_0, expr2_0, expr3_0, expr4_0)?;
                        let expr6_0 = C::output(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    &Opcode::SelectSpectreGuard => {
                        let (pattern6_0, pattern6_1, pattern6_2) =
                            C::unpack_value_array_3(ctx, pattern4_1);
                        if let Some(pattern7_0) = C::def_inst(ctx, pattern6_0) {
                            let pattern8_0 = C::inst_data(ctx, pattern7_0);
                            if let &InstructionData::IntCompare {
                                opcode: ref pattern9_0,
                                args: ref pattern9_1,
                                cond: ref pattern9_2,
                            } = &pattern8_0
                            {
                                if let &Opcode::Icmp = pattern9_0 {
                                    let (pattern11_0, pattern11_1) =
                                        C::unpack_value_array_2(ctx, pattern9_1);
                                    let pattern12_0 = C::value_type(ctx, pattern11_0);
                                    // Rule at src/isa/riscv64/lower.isle line 840.
                                    let expr0_0 = C::alloc_vec_writable(ctx, pattern2_0);
                                    let expr1_0 = C::put_in_regs(ctx, pattern11_0);
                                    let expr2_0 = C::put_in_regs(ctx, pattern11_1);
                                    let expr3_0 = constructor_lower_icmp(
                                        ctx,
                                        pattern9_2,
                                        expr1_0,
                                        expr2_0,
                                        pattern12_0,
                                    )?;
                                    let expr4_0: bool = true;
                                    let expr5_0 = C::vec_writable_clone(ctx, &expr0_0);
                                    let expr6_0 = C::put_in_regs(ctx, pattern6_1);
                                    let expr7_0 = C::put_in_regs(ctx, pattern6_2);
                                    let expr8_0 = MInst::SelectIf {
                                        if_spectre_guard: expr4_0,
                                        rd: expr5_0,
                                        test: expr3_0,
                                        x: expr6_0,
                                        y: expr7_0,
                                    };
                                    let expr9_0 = C::emit(ctx, &expr8_0);
                                    let expr10_0 = C::vec_writable_to_regs(ctx, &expr0_0);
                                    let expr11_0 = C::output(ctx, expr10_0);
                                    return Some(expr11_0);
                                }
                            }
                        }
                    }
                    &Opcode::Bitselect => {
                        let (pattern6_0, pattern6_1, pattern6_2) =
                            C::unpack_value_array_3(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 619.
                        let expr0_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_2);
                        let expr3_0 =
                            constructor_gen_bitselect(ctx, pattern2_0, expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
            _ => {}
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::NullAry {
            opcode: ref pattern2_0,
        } => {
            match pattern2_0 {
                &Opcode::Debugtrap => {
                    // Rule at src/isa/riscv64/lower.isle line 659.
                    let expr0_0 = MInst::EBreak;
                    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
                    let expr2_0 = constructor_side_effect(ctx, &expr1_0)?;
                    return Some(expr2_0);
                }
                &Opcode::GetFramePointer => {
                    // Rule at src/isa/riscv64/lower.isle line 860.
                    let expr0_0: u8 = 8i128 as u8;
                    let expr1_0 = C::x_reg(ctx, expr0_0);
                    let expr2_0: Type = I64;
                    let expr3_0: Type = I64;
                    let expr4_0 = C::gen_move2(ctx, expr1_0, expr2_0, expr3_0);
                    let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                    return Some(expr5_0);
                }
                &Opcode::GetStackPointer => {
                    // Rule at src/isa/riscv64/lower.isle line 863.
                    let expr0_0: u8 = 2i128 as u8;
                    let expr1_0 = C::x_reg(ctx, expr0_0);
                    let expr2_0: Type = I64;
                    let expr3_0: Type = I64;
                    let expr4_0 = C::gen_move2(ctx, expr1_0, expr2_0, expr3_0);
                    let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                    return Some(expr5_0);
                }
                &Opcode::GetReturnAddress => {
                    // Rule at src/isa/riscv64/lower.isle line 866.
                    let expr0_0 = C::load_ra(ctx);
                    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                    return Some(expr1_0);
                }
                &Opcode::Fence => {
                    // Rule at src/isa/riscv64/lower.isle line 664.
                    let expr0_0: u8 = 15i128 as u8;
                    let expr1_0: u8 = 15i128 as u8;
                    let expr2_0 = MInst::Fence {
                        pred: expr0_0,
                        succ: expr1_0,
                    };
                    let expr3_0 = SideEffectNoResult::Inst { inst: expr2_0 };
                    let expr4_0 = constructor_side_effect(ctx, &expr3_0)?;
                    return Some(expr4_0);
                }
                _ => {}
            }
        }
        &InstructionData::Unary {
            opcode: ref pattern2_0,
            arg: pattern2_1,
        } => {
            match pattern2_0 {
                &Opcode::IsNull => {
                    // Rule at src/isa/riscv64/lower.isle line 599.
                    let expr0_0 = ReferenceCheckOP::IsNull;
                    let expr1_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr2_0 = constructor_gen_reference_check(ctx, &expr0_0, expr1_0)?;
                    let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                    return Some(expr3_0);
                }
                &Opcode::IsInvalid => {
                    // Rule at src/isa/riscv64/lower.isle line 604.
                    let expr0_0 = ReferenceCheckOP::IsInvalid;
                    let expr1_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr2_0 = constructor_gen_reference_check(ctx, &expr0_0, expr1_0)?;
                    let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                    return Some(expr3_0);
                }
                &Opcode::Isplit => {
                    // Rule at src/isa/riscv64/lower.isle line 624.
                    let expr0_0 = C::put_in_regs(ctx, pattern2_1);
                    let expr1_0: usize = 0i128 as usize;
                    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                    let expr3_0: Type = I64;
                    let expr4_0: Type = I64;
                    let expr5_0 = C::gen_move2(ctx, expr2_0, expr3_0, expr4_0);
                    let expr6_0 = C::put_in_regs(ctx, pattern2_1);
                    let expr7_0: usize = 1i128 as usize;
                    let expr8_0 = C::value_regs_get(ctx, expr6_0, expr7_0);
                    let expr9_0: Type = I64;
                    let expr10_0: Type = I64;
                    let expr11_0 = C::gen_move2(ctx, expr8_0, expr9_0, expr10_0);
                    let expr12_0 = C::value_reg(ctx, expr5_0);
                    let expr13_0 = C::value_reg(ctx, expr11_0);
                    let expr14_0 = C::output_pair(ctx, expr12_0, expr13_0);
                    return Some(expr14_0);
                }
                _ => {}
            }
        }
        &InstructionData::Load {
            opcode: ref pattern2_0,
            arg: pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            match pattern2_0 {
                &Opcode::Uload8 => {
                    // Rule at src/isa/riscv64/lower.isle line 679.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = false;
                    let expr2_0: u8 = 8i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0)?;
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    )?;
                    let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                    return Some(expr6_0);
                }
                &Opcode::Sload8 => {
                    // Rule at src/isa/riscv64/lower.isle line 683.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = true;
                    let expr2_0: u8 = 8i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0)?;
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    )?;
                    let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                    return Some(expr6_0);
                }
                &Opcode::Uload16 => {
                    // Rule at src/isa/riscv64/lower.isle line 687.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = false;
                    let expr2_0: u8 = 16i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0)?;
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    )?;
                    let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                    return Some(expr6_0);
                }
                &Opcode::Sload16 => {
                    // Rule at src/isa/riscv64/lower.isle line 692.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = true;
                    let expr2_0: u8 = 16i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0)?;
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    )?;
                    let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                    return Some(expr6_0);
                }
                &Opcode::Uload32 => {
                    // Rule at src/isa/riscv64/lower.isle line 697.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = false;
                    let expr2_0: u8 = 32i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0)?;
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    )?;
                    let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                    return Some(expr6_0);
                }
                &Opcode::Sload32 => {
                    // Rule at src/isa/riscv64/lower.isle line 702.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = true;
                    let expr2_0: u8 = 32i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0)?;
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    )?;
                    let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                    return Some(expr6_0);
                }
                _ => {}
            }
        }
        &InstructionData::MultiAry {
            opcode: ref pattern2_0,
            args: pattern2_1,
        } => {
            if let &Opcode::Return = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                // Rule at src/isa/riscv64/lower.isle line 854.
                let expr0_0: usize = 0i128 as usize;
                let expr1_0 = C::value_slice_len(ctx, pattern4_0);
                let expr2_0 = C::range(ctx, expr0_0, expr1_0);
                let expr3_0 = constructor_lower_return(ctx, expr2_0, pattern4_0)?;
                return Some(expr3_0);
            }
        }
        &InstructionData::Call {
            opcode: ref pattern2_0,
            args: pattern2_1,
            func_ref: pattern2_2,
        } => {
            if let &Opcode::Call = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                let (pattern5_0, pattern5_1, pattern5_2) = C::func_ref_data(ctx, pattern2_2);
                // Rule at src/isa/riscv64/lower.isle line 876.
                let expr0_0 = C::gen_call(ctx, pattern5_0, pattern5_1, pattern5_2, pattern4_0);
                return Some(expr0_0);
            }
        }
        &InstructionData::CallIndirect {
            opcode: ref pattern2_0,
            args: pattern2_1,
            sig_ref: pattern2_2,
        } => {
            if let &Opcode::CallIndirect = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    // Rule at src/isa/riscv64/lower.isle line 879.
                    let expr0_0 = C::gen_call_indirect(ctx, pattern2_2, pattern5_0, pattern5_1);
                    return Some(expr0_0);
                }
            }
        }
        &InstructionData::FuncAddr {
            opcode: ref pattern2_0,
            func_ref: pattern2_1,
        } => {
            if let &Opcode::FuncAddr = pattern2_0 {
                let (pattern4_0, pattern4_1, pattern4_2) = C::func_ref_data(ctx, pattern2_1);
                // Rule at src/isa/riscv64/lower.isle line 774.
                let expr0_0: i64 = 0i128 as i64;
                let expr1_0 = C::load_ext_name(ctx, pattern4_1, expr0_0);
                let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                return Some(expr2_0);
            }
        }
        &InstructionData::UnaryGlobalValue {
            opcode: ref pattern2_0,
            global_value: pattern2_1,
        } => {
            if let &Opcode::SymbolValue = pattern2_0 {
                if let Some((pattern4_0, pattern4_1, pattern4_2)) =
                    C::symbol_value_data(ctx, pattern2_1)
                {
                    // Rule at src/isa/riscv64/lower.isle line 809.
                    let expr0_0 = C::load_ext_name(ctx, pattern4_0, pattern4_2);
                    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                    return Some(expr1_0);
                }
            }
        }
        &InstructionData::StackLoad {
            opcode: ref pattern2_0,
            stack_slot: pattern2_1,
            offset: pattern2_2,
        } => {
            if let &Opcode::StackAddr = pattern2_0 {
                // Rule at src/isa/riscv64/lower.isle line 594.
                let expr0_0 = C::gen_stack_addr(ctx, pattern2_1, pattern2_2);
                let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                return Some(expr1_0);
            }
        }
        &InstructionData::Trap {
            opcode: ref pattern2_0,
            code: ref pattern2_1,
        } => {
            match pattern2_0 {
                &Opcode::Trap => {
                    // Rule at src/isa/riscv64/lower.isle line 669.
                    let expr0_0 = constructor_udf(ctx, pattern2_1)?;
                    return Some(expr0_0);
                }
                &Opcode::ResumableTrap => {
                    // Rule at src/isa/riscv64/lower.isle line 674.
                    let expr0_0 = constructor_udf(ctx, pattern2_1)?;
                    return Some(expr0_0);
                }
                _ => {}
            }
        }
        &InstructionData::StoreNoOffset {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
        } => {
            if let &Opcode::AtomicStore = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if let Some(pattern6_0) = C::valid_atomic_transaction(ctx, pattern5_0) {
                    // Rule at src/isa/riscv64/lower.isle line 520.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr2_0 = constructor_gen_atomic_store(ctx, expr0_0, pattern6_0, expr1_0)?;
                    return Some(expr2_0);
                }
            }
        }
        &InstructionData::Store {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            match pattern2_0 {
                &Opcode::Store => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    // Rule at src/isa/riscv64/lower.isle line 730.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = C::store_op(ctx, pattern5_0);
                    let expr2_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr3_0 = constructor_gen_store(
                        ctx, expr0_0, pattern2_3, &expr1_0, pattern2_2, expr2_0,
                    )?;
                    return Some(expr3_0);
                }
                &Opcode::Istore8 => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/riscv64/lower.isle line 716.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = StoreOP::Sb;
                    let expr2_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr3_0 = constructor_gen_store(
                        ctx, expr0_0, pattern2_3, &expr1_0, pattern2_2, expr2_0,
                    )?;
                    return Some(expr3_0);
                }
                &Opcode::Istore16 => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/riscv64/lower.isle line 720.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = StoreOP::Sh;
                    let expr2_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr3_0 = constructor_gen_store(
                        ctx, expr0_0, pattern2_3, &expr1_0, pattern2_2, expr2_0,
                    )?;
                    return Some(expr3_0);
                }
                &Opcode::Istore32 => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/riscv64/lower.isle line 725.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = StoreOP::Sw;
                    let expr2_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr3_0 = constructor_gen_store(
                        ctx, expr0_0, pattern2_3, &expr1_0, pattern2_2, expr2_0,
                    )?;
                    return Some(expr3_0);
                }
                _ => {}
            }
        }
        &InstructionData::FloatCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Fcmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                // Rule at src/isa/riscv64/lower.isle line 769.
                let expr0_0 =
                    constructor_gen_fcmp(ctx, pattern2_2, pattern4_0, pattern4_1, pattern5_0)?;
                let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                return Some(expr1_0);
            }
        }
        &InstructionData::IntCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Icmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                // Rule at src/isa/riscv64/lower.isle line 748.
                let expr0_0 = C::put_in_regs(ctx, pattern4_0);
                let expr1_0 = C::put_in_regs(ctx, pattern4_1);
                let expr2_0 =
                    constructor_lower_icmp(ctx, pattern2_2, expr0_0, expr1_0, pattern5_0)?;
                let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                return Some(expr3_0);
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some(pattern3_0) = C::fits_in_16(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Urem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 152.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0 =
                            constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0)?;
                        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
                        let expr4_0 = constructor_gen_div_by_zero(ctx, expr3_0)?;
                        let expr5_0 = AluOPRRR::Remuw;
                        let expr6_0: bool = false;
                        let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr8_0 =
                            constructor_ext_int_if_need(ctx, expr6_0, expr7_0, pattern3_0)?;
                        let expr9_0 = constructor_convert_valueregs_reg(ctx, expr8_0)?;
                        let expr10_0 = constructor_alu_rrr(ctx, &expr5_0, expr9_0, expr3_0)?;
                        let expr11_0 = constructor_output_reg(ctx, expr10_0)?;
                        return Some(expr11_0);
                    }
                    &Opcode::Srem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 158.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0 =
                            constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0)?;
                        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
                        let expr4_0 = constructor_gen_div_by_zero(ctx, expr3_0)?;
                        let expr5_0 = AluOPRRR::Remw;
                        let expr6_0: bool = true;
                        let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr8_0 =
                            constructor_ext_int_if_need(ctx, expr6_0, expr7_0, pattern3_0)?;
                        let expr9_0 = constructor_convert_valueregs_reg(ctx, expr8_0)?;
                        let expr10_0 = constructor_alu_rrr(ctx, &expr5_0, expr9_0, expr3_0)?;
                        let expr11_0 = constructor_output_reg(ctx, expr10_0)?;
                        return Some(expr11_0);
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_32(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 19.
                        let expr0_0 = AluOPRRR::Addw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Isub => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 65.
                        let expr0_0 = AluOPRRR::Subw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Imul => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 84.
                        let expr0_0 = AluOPRRR::Mulw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Udiv => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 125.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0 =
                            constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0)?;
                        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
                        let expr4_0 = constructor_gen_div_by_zero(ctx, expr3_0)?;
                        let expr5_0 = AluOPRRR::Divuw;
                        let expr6_0: bool = false;
                        let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr8_0 =
                            constructor_ext_int_if_need(ctx, expr6_0, expr7_0, pattern3_0)?;
                        let expr9_0 = constructor_convert_valueregs_reg(ctx, expr8_0)?;
                        let expr10_0 = constructor_alu_rrr(ctx, &expr5_0, expr9_0, expr3_0)?;
                        let expr11_0 = constructor_output_reg(ctx, expr10_0)?;
                        return Some(expr11_0);
                    }
                    &Opcode::Sdiv => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 131.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr2_0 =
                            constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0)?;
                        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0)?;
                        let expr4_0: bool = true;
                        let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0)?;
                        let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0)?;
                        let expr8_0 =
                            constructor_gen_div_overflow(ctx, expr3_0, expr7_0, pattern3_0)?;
                        let expr9_0 = constructor_gen_div_by_zero(ctx, expr7_0)?;
                        let expr10_0 = AluOPRRR::Divw;
                        let expr11_0 = constructor_alu_rrr(ctx, &expr10_0, expr3_0, expr7_0)?;
                        let expr12_0 = constructor_output_reg(ctx, expr11_0)?;
                        return Some(expr12_0);
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Band => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 187.
                        let expr0_0 = AluOPRRR::And;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Bor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 207.
                        let expr0_0 = AluOPRRR::Or;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Bxor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 225.
                        let expr0_0 = AluOPRRR::Xor;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::valid_atomic_transaction(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::AtomicRmw {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
                flags: pattern5_2,
                op: ref pattern5_3,
            } = &pattern4_0
            {
                if let &Opcode::AtomicRmw = pattern5_0 {
                    let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                    // Rule at src/isa/riscv64/lower.isle line 458.
                    let expr0_0 = constructor_get_atomic_rmw_op(ctx, pattern3_0, pattern5_3)?;
                    let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                    let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                    let expr3_0 = C::atomic_amo(ctx);
                    let expr4_0 = constructor_gen_atomic(ctx, &expr0_0, expr1_0, expr2_0, expr3_0)?;
                    let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                    return Some(expr5_0);
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        if let &InstructionData::Unary {
            opcode: ref pattern4_0,
            arg: pattern4_1,
        } = &pattern3_0
        {
            if let &Opcode::Bnot = pattern4_0 {
                // Rule at src/isa/riscv64/lower.isle line 243.
                let expr0_0 = AluOPRRI::Xori;
                let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                let expr2_0: i64 = -1i128 as i64;
                let expr3_0 = C::imm_from_neg_bits(ctx, expr2_0);
                let expr4_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr1_0, expr3_0)?;
                let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                return Some(expr5_0);
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 23.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr2_0 = constructor_alu_add(ctx, expr0_0, expr1_0)?;
                        let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Isub => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 62.
                        let expr0_0 = AluOPRRR::Sub;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    &Opcode::Imul => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 82.
                        let expr0_0 = AluOPRRR::Mul;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
        }
    }
    return None;
}

// Generated as internal constructor for term gen_atomic_rmw_loop.
pub fn constructor_gen_atomic_rmw_loop<C: Context>(
    ctx: &mut C,
    arg0: &AtomicRmwOp,
    arg1: Type,
    arg2: Reg,
    arg3: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/lower.isle line 496.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0: Type = I64;
    let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
    let expr4_0 = constructor_gen_atomic_offset(ctx, pattern2_0, pattern1_0)?;
    let expr5_0 = constructor_gen_atomic_p(ctx, pattern2_0, pattern1_0)?;
    let expr6_0 = MInst::AtomicRmwLoop {
        offset: expr4_0,
        op: pattern0_0.clone(),
        dst: expr1_0,
        ty: pattern1_0,
        p: expr5_0,
        x: pattern3_0,
        t0: expr3_0,
    };
    let expr7_0 = C::emit(ctx, &expr6_0);
    let expr8_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr8_0);
}

// Generated as internal constructor for term gen_atomic_offset.
pub fn constructor_gen_atomic_offset<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::fits_in_16(ctx, pattern1_0) {
        // Rule at src/isa/riscv64/lower.isle line 524.
        let expr0_0: i32 = 3i128 as i32;
        let expr1_0 = constructor_alu_andi(ctx, pattern0_0, expr0_0)?;
        let expr2_0: i32 = 3i128 as i32;
        let expr3_0 = constructor_alu_slli(ctx, expr1_0, expr2_0)?;
        return Some(expr3_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/lower.isle line 527.
    let expr0_0 = C::zero_reg(ctx);
    return Some(expr0_0);
}

// Generated as internal constructor for term gen_atomic_p.
pub fn constructor_gen_atomic_p<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::fits_in_16(ctx, pattern1_0) {
        // Rule at src/isa/riscv64/lower.isle line 531.
        let expr0_0: i32 = -4i128 as i32;
        let expr1_0 = constructor_alu_andi(ctx, pattern0_0, expr0_0)?;
        return Some(expr1_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/lower.isle line 534.
    return Some(pattern0_0);
}

// Generated as internal constructor for term gen_icmp.
pub fn constructor_gen_icmp<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: ValueRegs,
    arg2: ValueRegs,
    arg3: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/lower.isle line 740.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::Icmp {
        cc: pattern0_0.clone(),
        rd: expr1_0,
        a: pattern1_0,
        b: pattern2_0,
        ty: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term gen_fcmp.
pub fn constructor_gen_fcmp<C: Context>(
    ctx: &mut C,
    arg0: &FloatCC,
    arg1: Value,
    arg2: Value,
    arg3: Type,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/lower.isle line 761.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = C::put_in_reg(ctx, pattern1_0);
    let expr3_0 = C::put_in_reg(ctx, pattern2_0);
    let expr4_0 = MInst::Fcmp {
        cc: pattern0_0.clone(),
        rd: expr1_0,
        rs1: expr2_0,
        rs2: expr3_0,
        ty: pattern3_0,
    };
    let expr5_0 = C::emit(ctx, &expr4_0);
    let expr6_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr6_0);
}
