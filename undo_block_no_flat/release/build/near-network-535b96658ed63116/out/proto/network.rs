// This file is generated by rust-protobuf 3.0.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `network_protocol/network.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_2;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.OwnedAccount)
pub struct OwnedAccount {
    // message fields
    // @@protoc_insertion_point(field:network.OwnedAccount.account_key)
    pub account_key: ::protobuf::MessageField<PublicKey>,
    // @@protoc_insertion_point(field:network.OwnedAccount.peer_id)
    pub peer_id: ::protobuf::MessageField<PublicKey>,
    // @@protoc_insertion_point(field:network.OwnedAccount.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:network.OwnedAccount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OwnedAccount {
    fn default() -> &'a OwnedAccount {
        <OwnedAccount as ::protobuf::Message>::default_instance()
    }
}

impl OwnedAccount {
    pub fn new() -> OwnedAccount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PublicKey>(
            "account_key",
            |m: &OwnedAccount| { &m.account_key },
            |m: &mut OwnedAccount| { &mut m.account_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PublicKey>(
            "peer_id",
            |m: &OwnedAccount| { &m.peer_id },
            |m: &mut OwnedAccount| { &mut m.peer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &OwnedAccount| { &m.timestamp },
            |m: &mut OwnedAccount| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OwnedAccount>(
            "OwnedAccount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OwnedAccount {
    const NAME: &'static str = "OwnedAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_key)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.peer_id)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.peer_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.peer_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OwnedAccount {
        OwnedAccount::new()
    }

    fn clear(&mut self) {
        self.account_key.clear();
        self.peer_id.clear();
        self.timestamp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OwnedAccount {
        static instance: OwnedAccount = OwnedAccount {
            account_key: ::protobuf::MessageField::none(),
            peer_id: ::protobuf::MessageField::none(),
            timestamp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OwnedAccount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OwnedAccount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OwnedAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OwnedAccount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.AccountKeyPayload)
pub struct AccountKeyPayload {
    // message oneof groups
    pub payload_type: ::std::option::Option<account_key_payload::Payload_type>,
    // special fields
    // @@protoc_insertion_point(special_field:network.AccountKeyPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountKeyPayload {
    fn default() -> &'a AccountKeyPayload {
        <AccountKeyPayload as ::protobuf::Message>::default_instance()
    }
}

impl AccountKeyPayload {
    pub fn new() -> AccountKeyPayload {
        ::std::default::Default::default()
    }

    // .network.AccountData account_data = 2;

    pub fn account_data(&self) -> &AccountData {
        match self.payload_type {
            ::std::option::Option::Some(account_key_payload::Payload_type::AccountData(ref v)) => v,
            _ => <AccountData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_account_data(&mut self) {
        self.payload_type = ::std::option::Option::None;
    }

    pub fn has_account_data(&self) -> bool {
        match self.payload_type {
            ::std::option::Option::Some(account_key_payload::Payload_type::AccountData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_account_data(&mut self, v: AccountData) {
        self.payload_type = ::std::option::Option::Some(account_key_payload::Payload_type::AccountData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_account_data(&mut self) -> &mut AccountData {
        if let ::std::option::Option::Some(account_key_payload::Payload_type::AccountData(_)) = self.payload_type {
        } else {
            self.payload_type = ::std::option::Option::Some(account_key_payload::Payload_type::AccountData(AccountData::new()));
        }
        match self.payload_type {
            ::std::option::Option::Some(account_key_payload::Payload_type::AccountData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_account_data(&mut self) -> AccountData {
        if self.has_account_data() {
            match self.payload_type.take() {
                ::std::option::Option::Some(account_key_payload::Payload_type::AccountData(v)) => v,
                _ => panic!(),
            }
        } else {
            AccountData::new()
        }
    }

    // .network.OwnedAccount owned_account = 3;

    pub fn owned_account(&self) -> &OwnedAccount {
        match self.payload_type {
            ::std::option::Option::Some(account_key_payload::Payload_type::OwnedAccount(ref v)) => v,
            _ => <OwnedAccount as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_owned_account(&mut self) {
        self.payload_type = ::std::option::Option::None;
    }

    pub fn has_owned_account(&self) -> bool {
        match self.payload_type {
            ::std::option::Option::Some(account_key_payload::Payload_type::OwnedAccount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_owned_account(&mut self, v: OwnedAccount) {
        self.payload_type = ::std::option::Option::Some(account_key_payload::Payload_type::OwnedAccount(v))
    }

    // Mutable pointer to the field.
    pub fn mut_owned_account(&mut self) -> &mut OwnedAccount {
        if let ::std::option::Option::Some(account_key_payload::Payload_type::OwnedAccount(_)) = self.payload_type {
        } else {
            self.payload_type = ::std::option::Option::Some(account_key_payload::Payload_type::OwnedAccount(OwnedAccount::new()));
        }
        match self.payload_type {
            ::std::option::Option::Some(account_key_payload::Payload_type::OwnedAccount(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_owned_account(&mut self) -> OwnedAccount {
        if self.has_owned_account() {
            match self.payload_type.take() {
                ::std::option::Option::Some(account_key_payload::Payload_type::OwnedAccount(v)) => v,
                _ => panic!(),
            }
        } else {
            OwnedAccount::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AccountData>(
            "account_data",
            AccountKeyPayload::has_account_data,
            AccountKeyPayload::account_data,
            AccountKeyPayload::mut_account_data,
            AccountKeyPayload::set_account_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OwnedAccount>(
            "owned_account",
            AccountKeyPayload::has_owned_account,
            AccountKeyPayload::owned_account,
            AccountKeyPayload::mut_owned_account,
            AccountKeyPayload::set_owned_account,
        ));
        oneofs.push(account_key_payload::Payload_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountKeyPayload>(
            "AccountKeyPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountKeyPayload {
    const NAME: &'static str = "AccountKeyPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.payload_type = ::std::option::Option::Some(account_key_payload::Payload_type::AccountData(is.read_message()?));
                },
                26 => {
                    self.payload_type = ::std::option::Option::Some(account_key_payload::Payload_type::OwnedAccount(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.payload_type {
            match v {
                &account_key_payload::Payload_type::AccountData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &account_key_payload::Payload_type::OwnedAccount(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.payload_type {
            match v {
                &account_key_payload::Payload_type::AccountData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &account_key_payload::Payload_type::OwnedAccount(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountKeyPayload {
        AccountKeyPayload::new()
    }

    fn clear(&mut self) {
        self.payload_type = ::std::option::Option::None;
        self.payload_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountKeyPayload {
        static instance: AccountKeyPayload = AccountKeyPayload {
            payload_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountKeyPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountKeyPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountKeyPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountKeyPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AccountKeyPayload`
pub mod account_key_payload {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:network.AccountKeyPayload.payload_type)
    pub enum Payload_type {
        // @@protoc_insertion_point(oneof_field:network.AccountKeyPayload.account_data)
        AccountData(super::AccountData),
        // @@protoc_insertion_point(oneof_field:network.AccountKeyPayload.owned_account)
        OwnedAccount(super::OwnedAccount),
    }

    impl ::protobuf::Oneof for Payload_type {
    }

    impl ::protobuf::OneofFull for Payload_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AccountKeyPayload as ::protobuf::MessageFull>::descriptor().oneof_by_name("payload_type").unwrap()).clone()
        }
    }

    impl Payload_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Payload_type>("payload_type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.Signature)
pub struct Signature {
    // message fields
    // @@protoc_insertion_point(field:network.Signature.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.Signature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Signature {
    fn default() -> &'a Signature {
        <Signature as ::protobuf::Message>::default_instance()
    }
}

impl Signature {
    pub fn new() -> Signature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &Signature| { &m.borsh },
            |m: &mut Signature| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Signature>(
            "Signature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Signature {
    const NAME: &'static str = "Signature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Signature {
        Signature::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Signature {
        static instance: Signature = Signature {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Signature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Signature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.AccountKeySignedPayload)
pub struct AccountKeySignedPayload {
    // message fields
    // @@protoc_insertion_point(field:network.AccountKeySignedPayload.payload)
    pub payload: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:network.AccountKeySignedPayload.signature)
    pub signature: ::protobuf::MessageField<Signature>,
    // special fields
    // @@protoc_insertion_point(special_field:network.AccountKeySignedPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountKeySignedPayload {
    fn default() -> &'a AccountKeySignedPayload {
        <AccountKeySignedPayload as ::protobuf::Message>::default_instance()
    }
}

impl AccountKeySignedPayload {
    pub fn new() -> AccountKeySignedPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payload",
            |m: &AccountKeySignedPayload| { &m.payload },
            |m: &mut AccountKeySignedPayload| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Signature>(
            "signature",
            |m: &AccountKeySignedPayload| { &m.signature },
            |m: &mut AccountKeySignedPayload| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountKeySignedPayload>(
            "AccountKeySignedPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountKeySignedPayload {
    const NAME: &'static str = "AccountKeySignedPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.payload = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.signature)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(v) = self.signature.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountKeySignedPayload {
        AccountKeySignedPayload::new()
    }

    fn clear(&mut self) {
        self.payload.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountKeySignedPayload {
        static instance: AccountKeySignedPayload = AccountKeySignedPayload {
            payload: ::std::vec::Vec::new(),
            signature: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountKeySignedPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountKeySignedPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountKeySignedPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountKeySignedPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.PublicKey)
pub struct PublicKey {
    // message fields
    // @@protoc_insertion_point(field:network.PublicKey.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.PublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublicKey {
    fn default() -> &'a PublicKey {
        <PublicKey as ::protobuf::Message>::default_instance()
    }
}

impl PublicKey {
    pub fn new() -> PublicKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &PublicKey| { &m.borsh },
            |m: &mut PublicKey| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublicKey>(
            "PublicKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PublicKey {
    const NAME: &'static str = "PublicKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublicKey {
        PublicKey::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublicKey {
        static instance: PublicKey = PublicKey {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PublicKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PublicKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.PeerInfo)
pub struct PeerInfo {
    // message fields
    // @@protoc_insertion_point(field:network.PeerInfo.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.PeerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerInfo {
    fn default() -> &'a PeerInfo {
        <PeerInfo as ::protobuf::Message>::default_instance()
    }
}

impl PeerInfo {
    pub fn new() -> PeerInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &PeerInfo| { &m.borsh },
            |m: &mut PeerInfo| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerInfo>(
            "PeerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerInfo {
    const NAME: &'static str = "PeerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerInfo {
        PeerInfo::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerInfo {
        static instance: PeerInfo = PeerInfo {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.CryptoHash)
pub struct CryptoHash {
    // message fields
    // @@protoc_insertion_point(field:network.CryptoHash.hash)
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.CryptoHash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptoHash {
    fn default() -> &'a CryptoHash {
        <CryptoHash as ::protobuf::Message>::default_instance()
    }
}

impl CryptoHash {
    pub fn new() -> CryptoHash {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &CryptoHash| { &m.hash },
            |m: &mut CryptoHash| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CryptoHash>(
            "CryptoHash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CryptoHash {
    const NAME: &'static str = "CryptoHash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptoHash {
        CryptoHash::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptoHash {
        static instance: CryptoHash = CryptoHash {
            hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CryptoHash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CryptoHash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CryptoHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoHash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.Edge)
pub struct Edge {
    // message fields
    // @@protoc_insertion_point(field:network.Edge.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.Edge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Edge {
    fn default() -> &'a Edge {
        <Edge as ::protobuf::Message>::default_instance()
    }
}

impl Edge {
    pub fn new() -> Edge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &Edge| { &m.borsh },
            |m: &mut Edge| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Edge>(
            "Edge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Edge {
    const NAME: &'static str = "Edge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Edge {
        Edge::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Edge {
        static instance: Edge = Edge {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Edge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Edge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Edge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Edge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.PartialEdgeInfo)
pub struct PartialEdgeInfo {
    // message fields
    // @@protoc_insertion_point(field:network.PartialEdgeInfo.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.PartialEdgeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartialEdgeInfo {
    fn default() -> &'a PartialEdgeInfo {
        <PartialEdgeInfo as ::protobuf::Message>::default_instance()
    }
}

impl PartialEdgeInfo {
    pub fn new() -> PartialEdgeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &PartialEdgeInfo| { &m.borsh },
            |m: &mut PartialEdgeInfo| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartialEdgeInfo>(
            "PartialEdgeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartialEdgeInfo {
    const NAME: &'static str = "PartialEdgeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartialEdgeInfo {
        PartialEdgeInfo::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartialEdgeInfo {
        static instance: PartialEdgeInfo = PartialEdgeInfo {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PartialEdgeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartialEdgeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartialEdgeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartialEdgeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.AnnounceAccount)
pub struct AnnounceAccount {
    // message fields
    // @@protoc_insertion_point(field:network.AnnounceAccount.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.AnnounceAccount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AnnounceAccount {
    fn default() -> &'a AnnounceAccount {
        <AnnounceAccount as ::protobuf::Message>::default_instance()
    }
}

impl AnnounceAccount {
    pub fn new() -> AnnounceAccount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &AnnounceAccount| { &m.borsh },
            |m: &mut AnnounceAccount| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnnounceAccount>(
            "AnnounceAccount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AnnounceAccount {
    const NAME: &'static str = "AnnounceAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AnnounceAccount {
        AnnounceAccount::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AnnounceAccount {
        static instance: AnnounceAccount = AnnounceAccount {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AnnounceAccount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AnnounceAccount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AnnounceAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnounceAccount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.Block)
pub struct Block {
    // message fields
    // @@protoc_insertion_point(field:network.Block.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.Block.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &Block| { &m.borsh },
            |m: &mut Block| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Block>(
            "Block",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Block {
    const NAME: &'static str = "Block";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Block {
        Block::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Block {
        static instance: Block = Block {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Block {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Block").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.BlockHeader)
pub struct BlockHeader {
    // message fields
    // @@protoc_insertion_point(field:network.BlockHeader.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.BlockHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeader {
    fn default() -> &'a BlockHeader {
        <BlockHeader as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader {
    pub fn new() -> BlockHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &BlockHeader| { &m.borsh },
            |m: &mut BlockHeader| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeader>(
            "BlockHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeader {
    const NAME: &'static str = "BlockHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeader {
        BlockHeader::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeader {
        static instance: BlockHeader = BlockHeader {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.GenesisId)
pub struct GenesisId {
    // message fields
    // @@protoc_insertion_point(field:network.GenesisId.chain_id)
    pub chain_id: ::std::string::String,
    // @@protoc_insertion_point(field:network.GenesisId.hash)
    pub hash: ::protobuf::MessageField<CryptoHash>,
    // special fields
    // @@protoc_insertion_point(special_field:network.GenesisId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenesisId {
    fn default() -> &'a GenesisId {
        <GenesisId as ::protobuf::Message>::default_instance()
    }
}

impl GenesisId {
    pub fn new() -> GenesisId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &GenesisId| { &m.chain_id },
            |m: &mut GenesisId| { &mut m.chain_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CryptoHash>(
            "hash",
            |m: &GenesisId| { &m.hash },
            |m: &mut GenesisId| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenesisId>(
            "GenesisId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenesisId {
    const NAME: &'static str = "GenesisId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chain_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hash)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.chain_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.chain_id);
        }
        if let Some(v) = self.hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.chain_id.is_empty() {
            os.write_string(1, &self.chain_id)?;
        }
        if let Some(v) = self.hash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenesisId {
        GenesisId::new()
    }

    fn clear(&mut self) {
        self.chain_id.clear();
        self.hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenesisId {
        static instance: GenesisId = GenesisId {
            chain_id: ::std::string::String::new(),
            hash: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenesisId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenesisId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenesisId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenesisId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.PeerChainInfo)
pub struct PeerChainInfo {
    // message fields
    // @@protoc_insertion_point(field:network.PeerChainInfo.genesis_id)
    pub genesis_id: ::protobuf::MessageField<GenesisId>,
    // @@protoc_insertion_point(field:network.PeerChainInfo.height)
    pub height: u64,
    // @@protoc_insertion_point(field:network.PeerChainInfo.tracked_shards)
    pub tracked_shards: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:network.PeerChainInfo.archival)
    pub archival: bool,
    // special fields
    // @@protoc_insertion_point(special_field:network.PeerChainInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerChainInfo {
    fn default() -> &'a PeerChainInfo {
        <PeerChainInfo as ::protobuf::Message>::default_instance()
    }
}

impl PeerChainInfo {
    pub fn new() -> PeerChainInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GenesisId>(
            "genesis_id",
            |m: &PeerChainInfo| { &m.genesis_id },
            |m: &mut PeerChainInfo| { &mut m.genesis_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &PeerChainInfo| { &m.height },
            |m: &mut PeerChainInfo| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tracked_shards",
            |m: &PeerChainInfo| { &m.tracked_shards },
            |m: &mut PeerChainInfo| { &mut m.tracked_shards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "archival",
            |m: &PeerChainInfo| { &m.archival },
            |m: &mut PeerChainInfo| { &mut m.archival },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerChainInfo>(
            "PeerChainInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerChainInfo {
    const NAME: &'static str = "PeerChainInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.genesis_id)?;
                },
                16 => {
                    self.height = is.read_uint64()?;
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.tracked_shards)?;
                },
                24 => {
                    self.tracked_shards.push(is.read_uint64()?);
                },
                32 => {
                    self.archival = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.genesis_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.height);
        }
        for value in &self.tracked_shards {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        if self.archival != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.genesis_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.height != 0 {
            os.write_uint64(2, self.height)?;
        }
        for v in &self.tracked_shards {
            os.write_uint64(3, *v)?;
        };
        if self.archival != false {
            os.write_bool(4, self.archival)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerChainInfo {
        PeerChainInfo::new()
    }

    fn clear(&mut self) {
        self.genesis_id.clear();
        self.height = 0;
        self.tracked_shards.clear();
        self.archival = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerChainInfo {
        static instance: PeerChainInfo = PeerChainInfo {
            genesis_id: ::protobuf::MessageField::none(),
            height: 0,
            tracked_shards: ::std::vec::Vec::new(),
            archival: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerChainInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerChainInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerChainInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerChainInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.Handshake)
pub struct Handshake {
    // message fields
    // @@protoc_insertion_point(field:network.Handshake.protocol_version)
    pub protocol_version: u32,
    // @@protoc_insertion_point(field:network.Handshake.oldest_supported_version)
    pub oldest_supported_version: u32,
    // @@protoc_insertion_point(field:network.Handshake.sender_peer_id)
    pub sender_peer_id: ::protobuf::MessageField<PublicKey>,
    // @@protoc_insertion_point(field:network.Handshake.target_peer_id)
    pub target_peer_id: ::protobuf::MessageField<PublicKey>,
    // @@protoc_insertion_point(field:network.Handshake.sender_listen_port)
    pub sender_listen_port: u32,
    // @@protoc_insertion_point(field:network.Handshake.sender_chain_info)
    pub sender_chain_info: ::protobuf::MessageField<PeerChainInfo>,
    // @@protoc_insertion_point(field:network.Handshake.partial_edge_info)
    pub partial_edge_info: ::protobuf::MessageField<PartialEdgeInfo>,
    // @@protoc_insertion_point(field:network.Handshake.owned_account)
    pub owned_account: ::protobuf::MessageField<AccountKeySignedPayload>,
    // special fields
    // @@protoc_insertion_point(special_field:network.Handshake.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Handshake {
    fn default() -> &'a Handshake {
        <Handshake as ::protobuf::Message>::default_instance()
    }
}

impl Handshake {
    pub fn new() -> Handshake {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol_version",
            |m: &Handshake| { &m.protocol_version },
            |m: &mut Handshake| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oldest_supported_version",
            |m: &Handshake| { &m.oldest_supported_version },
            |m: &mut Handshake| { &mut m.oldest_supported_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PublicKey>(
            "sender_peer_id",
            |m: &Handshake| { &m.sender_peer_id },
            |m: &mut Handshake| { &mut m.sender_peer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PublicKey>(
            "target_peer_id",
            |m: &Handshake| { &m.target_peer_id },
            |m: &mut Handshake| { &mut m.target_peer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sender_listen_port",
            |m: &Handshake| { &m.sender_listen_port },
            |m: &mut Handshake| { &mut m.sender_listen_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PeerChainInfo>(
            "sender_chain_info",
            |m: &Handshake| { &m.sender_chain_info },
            |m: &mut Handshake| { &mut m.sender_chain_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PartialEdgeInfo>(
            "partial_edge_info",
            |m: &Handshake| { &m.partial_edge_info },
            |m: &mut Handshake| { &mut m.partial_edge_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountKeySignedPayload>(
            "owned_account",
            |m: &Handshake| { &m.owned_account },
            |m: &mut Handshake| { &mut m.owned_account },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Handshake>(
            "Handshake",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Handshake {
    const NAME: &'static str = "Handshake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version = is.read_uint32()?;
                },
                16 => {
                    self.oldest_supported_version = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sender_peer_id)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.target_peer_id)?;
                },
                40 => {
                    self.sender_listen_port = is.read_uint32()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sender_chain_info)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.partial_edge_info)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owned_account)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.protocol_version != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.protocol_version);
        }
        if self.oldest_supported_version != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.oldest_supported_version);
        }
        if let Some(v) = self.sender_peer_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.target_peer_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.sender_listen_port != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.sender_listen_port);
        }
        if let Some(v) = self.sender_chain_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.partial_edge_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.owned_account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.protocol_version != 0 {
            os.write_uint32(1, self.protocol_version)?;
        }
        if self.oldest_supported_version != 0 {
            os.write_uint32(2, self.oldest_supported_version)?;
        }
        if let Some(v) = self.sender_peer_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.target_peer_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.sender_listen_port != 0 {
            os.write_uint32(5, self.sender_listen_port)?;
        }
        if let Some(v) = self.sender_chain_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.partial_edge_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.owned_account.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Handshake {
        Handshake::new()
    }

    fn clear(&mut self) {
        self.protocol_version = 0;
        self.oldest_supported_version = 0;
        self.sender_peer_id.clear();
        self.target_peer_id.clear();
        self.sender_listen_port = 0;
        self.sender_chain_info.clear();
        self.partial_edge_info.clear();
        self.owned_account.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Handshake {
        static instance: Handshake = Handshake {
            protocol_version: 0,
            oldest_supported_version: 0,
            sender_peer_id: ::protobuf::MessageField::none(),
            target_peer_id: ::protobuf::MessageField::none(),
            sender_listen_port: 0,
            sender_chain_info: ::protobuf::MessageField::none(),
            partial_edge_info: ::protobuf::MessageField::none(),
            owned_account: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Handshake {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Handshake").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Handshake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Handshake {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.HandshakeFailure)
pub struct HandshakeFailure {
    // message fields
    // @@protoc_insertion_point(field:network.HandshakeFailure.reason)
    pub reason: ::protobuf::EnumOrUnknown<handshake_failure::Reason>,
    // @@protoc_insertion_point(field:network.HandshakeFailure.peer_info)
    pub peer_info: ::protobuf::MessageField<PeerInfo>,
    // @@protoc_insertion_point(field:network.HandshakeFailure.genesis_id)
    pub genesis_id: ::protobuf::MessageField<GenesisId>,
    // @@protoc_insertion_point(field:network.HandshakeFailure.version)
    pub version: u32,
    // @@protoc_insertion_point(field:network.HandshakeFailure.oldest_supported_version)
    pub oldest_supported_version: u32,
    // special fields
    // @@protoc_insertion_point(special_field:network.HandshakeFailure.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeFailure {
    fn default() -> &'a HandshakeFailure {
        <HandshakeFailure as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeFailure {
    pub fn new() -> HandshakeFailure {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &HandshakeFailure| { &m.reason },
            |m: &mut HandshakeFailure| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PeerInfo>(
            "peer_info",
            |m: &HandshakeFailure| { &m.peer_info },
            |m: &mut HandshakeFailure| { &mut m.peer_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GenesisId>(
            "genesis_id",
            |m: &HandshakeFailure| { &m.genesis_id },
            |m: &mut HandshakeFailure| { &mut m.genesis_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &HandshakeFailure| { &m.version },
            |m: &mut HandshakeFailure| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oldest_supported_version",
            |m: &HandshakeFailure| { &m.oldest_supported_version },
            |m: &mut HandshakeFailure| { &mut m.oldest_supported_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeFailure>(
            "HandshakeFailure",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeFailure {
    const NAME: &'static str = "HandshakeFailure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.peer_info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.genesis_id)?;
                },
                32 => {
                    self.version = is.read_uint32()?;
                },
                40 => {
                    self.oldest_supported_version = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.reason != ::protobuf::EnumOrUnknown::new(handshake_failure::Reason::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.reason.value());
        }
        if let Some(v) = self.peer_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.genesis_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.version);
        }
        if self.oldest_supported_version != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.oldest_supported_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.reason != ::protobuf::EnumOrUnknown::new(handshake_failure::Reason::UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.reason))?;
        }
        if let Some(v) = self.peer_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.genesis_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.version != 0 {
            os.write_uint32(4, self.version)?;
        }
        if self.oldest_supported_version != 0 {
            os.write_uint32(5, self.oldest_supported_version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeFailure {
        HandshakeFailure::new()
    }

    fn clear(&mut self) {
        self.reason = ::protobuf::EnumOrUnknown::new(handshake_failure::Reason::UNKNOWN);
        self.peer_info.clear();
        self.genesis_id.clear();
        self.version = 0;
        self.oldest_supported_version = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeFailure {
        static instance: HandshakeFailure = HandshakeFailure {
            reason: ::protobuf::EnumOrUnknown::from_i32(0),
            peer_info: ::protobuf::MessageField::none(),
            genesis_id: ::protobuf::MessageField::none(),
            version: 0,
            oldest_supported_version: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HandshakeFailure {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeFailure").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeFailure {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HandshakeFailure`
pub mod handshake_failure {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:network.HandshakeFailure.Reason)
    pub enum Reason {
        // @@protoc_insertion_point(enum_value:network.HandshakeFailure.Reason.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:network.HandshakeFailure.Reason.ProtocolVersionMismatch)
        ProtocolVersionMismatch = 1,
        // @@protoc_insertion_point(enum_value:network.HandshakeFailure.Reason.GenesisMismatch)
        GenesisMismatch = 2,
        // @@protoc_insertion_point(enum_value:network.HandshakeFailure.Reason.InvalidTarget)
        InvalidTarget = 3,
    }

    impl ::protobuf::Enum for Reason {
        const NAME: &'static str = "Reason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Reason> {
            match value {
                0 => ::std::option::Option::Some(Reason::UNKNOWN),
                1 => ::std::option::Option::Some(Reason::ProtocolVersionMismatch),
                2 => ::std::option::Option::Some(Reason::GenesisMismatch),
                3 => ::std::option::Option::Some(Reason::InvalidTarget),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Reason] = &[
            Reason::UNKNOWN,
            Reason::ProtocolVersionMismatch,
            Reason::GenesisMismatch,
            Reason::InvalidTarget,
        ];
    }

    impl ::protobuf::EnumFull for Reason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("HandshakeFailure.Reason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Reason {
        fn default() -> Self {
            Reason::UNKNOWN
        }
    }

    impl Reason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Reason>("HandshakeFailure.Reason")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.LastEdge)
pub struct LastEdge {
    // message fields
    // @@protoc_insertion_point(field:network.LastEdge.edge)
    pub edge: ::protobuf::MessageField<Edge>,
    // special fields
    // @@protoc_insertion_point(special_field:network.LastEdge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LastEdge {
    fn default() -> &'a LastEdge {
        <LastEdge as ::protobuf::Message>::default_instance()
    }
}

impl LastEdge {
    pub fn new() -> LastEdge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Edge>(
            "edge",
            |m: &LastEdge| { &m.edge },
            |m: &mut LastEdge| { &mut m.edge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LastEdge>(
            "LastEdge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LastEdge {
    const NAME: &'static str = "LastEdge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.edge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.edge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.edge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LastEdge {
        LastEdge::new()
    }

    fn clear(&mut self) {
        self.edge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LastEdge {
        static instance: LastEdge = LastEdge {
            edge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LastEdge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LastEdge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LastEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LastEdge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.SocketAddr)
pub struct SocketAddr {
    // message fields
    // @@protoc_insertion_point(field:network.SocketAddr.ip)
    pub ip: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:network.SocketAddr.port)
    pub port: u32,
    // special fields
    // @@protoc_insertion_point(special_field:network.SocketAddr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SocketAddr {
    fn default() -> &'a SocketAddr {
        <SocketAddr as ::protobuf::Message>::default_instance()
    }
}

impl SocketAddr {
    pub fn new() -> SocketAddr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ip",
            |m: &SocketAddr| { &m.ip },
            |m: &mut SocketAddr| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &SocketAddr| { &m.port },
            |m: &mut SocketAddr| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SocketAddr>(
            "SocketAddr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SocketAddr {
    const NAME: &'static str = "SocketAddr";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = is.read_bytes()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ip);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.ip.is_empty() {
            os.write_bytes(1, &self.ip)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SocketAddr {
        SocketAddr::new()
    }

    fn clear(&mut self) {
        self.ip.clear();
        self.port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SocketAddr {
        static instance: SocketAddr = SocketAddr {
            ip: ::std::vec::Vec::new(),
            port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SocketAddr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SocketAddr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SocketAddr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SocketAddr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.PeerAddr)
pub struct PeerAddr {
    // message fields
    // @@protoc_insertion_point(field:network.PeerAddr.addr)
    pub addr: ::protobuf::MessageField<SocketAddr>,
    // @@protoc_insertion_point(field:network.PeerAddr.peer_id)
    pub peer_id: ::protobuf::MessageField<PublicKey>,
    // special fields
    // @@protoc_insertion_point(special_field:network.PeerAddr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerAddr {
    fn default() -> &'a PeerAddr {
        <PeerAddr as ::protobuf::Message>::default_instance()
    }
}

impl PeerAddr {
    pub fn new() -> PeerAddr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SocketAddr>(
            "addr",
            |m: &PeerAddr| { &m.addr },
            |m: &mut PeerAddr| { &mut m.addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PublicKey>(
            "peer_id",
            |m: &PeerAddr| { &m.peer_id },
            |m: &mut PeerAddr| { &mut m.peer_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerAddr>(
            "PeerAddr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerAddr {
    const NAME: &'static str = "PeerAddr";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.addr)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.peer_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.peer_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.addr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.peer_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerAddr {
        PeerAddr::new()
    }

    fn clear(&mut self) {
        self.addr.clear();
        self.peer_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerAddr {
        static instance: PeerAddr = PeerAddr {
            addr: ::protobuf::MessageField::none(),
            peer_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerAddr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerAddr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerAddr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerAddr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.AccountData)
pub struct AccountData {
    // message fields
    // @@protoc_insertion_point(field:network.AccountData.peer_id)
    pub peer_id: ::protobuf::MessageField<PublicKey>,
    // @@protoc_insertion_point(field:network.AccountData.account_key)
    pub account_key: ::protobuf::MessageField<PublicKey>,
    // @@protoc_insertion_point(field:network.AccountData.proxies)
    pub proxies: ::std::vec::Vec<PeerAddr>,
    // @@protoc_insertion_point(field:network.AccountData.version)
    pub version: u64,
    // @@protoc_insertion_point(field:network.AccountData.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:network.AccountData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountData {
    fn default() -> &'a AccountData {
        <AccountData as ::protobuf::Message>::default_instance()
    }
}

impl AccountData {
    pub fn new() -> AccountData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PublicKey>(
            "peer_id",
            |m: &AccountData| { &m.peer_id },
            |m: &mut AccountData| { &mut m.peer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PublicKey>(
            "account_key",
            |m: &AccountData| { &m.account_key },
            |m: &mut AccountData| { &mut m.account_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "proxies",
            |m: &AccountData| { &m.proxies },
            |m: &mut AccountData| { &mut m.proxies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &AccountData| { &m.version },
            |m: &mut AccountData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &AccountData| { &m.timestamp },
            |m: &mut AccountData| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountData>(
            "AccountData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountData {
    const NAME: &'static str = "AccountData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.peer_id)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_key)?;
                },
                18 => {
                    self.proxies.push(is.read_message()?);
                },
                56 => {
                    self.version = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.peer_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.account_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.proxies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.version != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.version);
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.peer_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.account_key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.proxies {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.version != 0 {
            os.write_uint64(7, self.version)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountData {
        AccountData::new()
    }

    fn clear(&mut self) {
        self.peer_id.clear();
        self.account_key.clear();
        self.proxies.clear();
        self.version = 0;
        self.timestamp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountData {
        static instance: AccountData = AccountData {
            peer_id: ::protobuf::MessageField::none(),
            account_key: ::protobuf::MessageField::none(),
            proxies: ::std::vec::Vec::new(),
            version: 0,
            timestamp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.RoutingTableUpdate)
pub struct RoutingTableUpdate {
    // message fields
    // @@protoc_insertion_point(field:network.RoutingTableUpdate.edges)
    pub edges: ::std::vec::Vec<Edge>,
    // @@protoc_insertion_point(field:network.RoutingTableUpdate.accounts)
    pub accounts: ::std::vec::Vec<AnnounceAccount>,
    // special fields
    // @@protoc_insertion_point(special_field:network.RoutingTableUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoutingTableUpdate {
    fn default() -> &'a RoutingTableUpdate {
        <RoutingTableUpdate as ::protobuf::Message>::default_instance()
    }
}

impl RoutingTableUpdate {
    pub fn new() -> RoutingTableUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edges",
            |m: &RoutingTableUpdate| { &m.edges },
            |m: &mut RoutingTableUpdate| { &mut m.edges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accounts",
            |m: &RoutingTableUpdate| { &m.accounts },
            |m: &mut RoutingTableUpdate| { &mut m.accounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoutingTableUpdate>(
            "RoutingTableUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoutingTableUpdate {
    const NAME: &'static str = "RoutingTableUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.edges.push(is.read_message()?);
                },
                18 => {
                    self.accounts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.edges {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.accounts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoutingTableUpdate {
        RoutingTableUpdate::new()
    }

    fn clear(&mut self) {
        self.edges.clear();
        self.accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoutingTableUpdate {
        static instance: RoutingTableUpdate = RoutingTableUpdate {
            edges: ::std::vec::Vec::new(),
            accounts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoutingTableUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoutingTableUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoutingTableUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingTableUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.UpdateNonceRequest)
pub struct UpdateNonceRequest {
    // message fields
    // @@protoc_insertion_point(field:network.UpdateNonceRequest.partial_edge_info)
    pub partial_edge_info: ::protobuf::MessageField<PartialEdgeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:network.UpdateNonceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateNonceRequest {
    fn default() -> &'a UpdateNonceRequest {
        <UpdateNonceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNonceRequest {
    pub fn new() -> UpdateNonceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PartialEdgeInfo>(
            "partial_edge_info",
            |m: &UpdateNonceRequest| { &m.partial_edge_info },
            |m: &mut UpdateNonceRequest| { &mut m.partial_edge_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateNonceRequest>(
            "UpdateNonceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateNonceRequest {
    const NAME: &'static str = "UpdateNonceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.partial_edge_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.partial_edge_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.partial_edge_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateNonceRequest {
        UpdateNonceRequest::new()
    }

    fn clear(&mut self) {
        self.partial_edge_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateNonceRequest {
        static instance: UpdateNonceRequest = UpdateNonceRequest {
            partial_edge_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateNonceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateNonceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateNonceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNonceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.UpdateNonceResponse)
pub struct UpdateNonceResponse {
    // message fields
    // @@protoc_insertion_point(field:network.UpdateNonceResponse.edge)
    pub edge: ::protobuf::MessageField<Edge>,
    // special fields
    // @@protoc_insertion_point(special_field:network.UpdateNonceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateNonceResponse {
    fn default() -> &'a UpdateNonceResponse {
        <UpdateNonceResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNonceResponse {
    pub fn new() -> UpdateNonceResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Edge>(
            "edge",
            |m: &UpdateNonceResponse| { &m.edge },
            |m: &mut UpdateNonceResponse| { &mut m.edge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateNonceResponse>(
            "UpdateNonceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateNonceResponse {
    const NAME: &'static str = "UpdateNonceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.edge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.edge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.edge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateNonceResponse {
        UpdateNonceResponse::new()
    }

    fn clear(&mut self) {
        self.edge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateNonceResponse {
        static instance: UpdateNonceResponse = UpdateNonceResponse {
            edge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateNonceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateNonceResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateNonceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNonceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.SyncAccountsData)
pub struct SyncAccountsData {
    // message fields
    // @@protoc_insertion_point(field:network.SyncAccountsData.accounts_data)
    pub accounts_data: ::std::vec::Vec<AccountKeySignedPayload>,
    // @@protoc_insertion_point(field:network.SyncAccountsData.incremental)
    pub incremental: bool,
    // @@protoc_insertion_point(field:network.SyncAccountsData.requesting_full_sync)
    pub requesting_full_sync: bool,
    // special fields
    // @@protoc_insertion_point(special_field:network.SyncAccountsData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncAccountsData {
    fn default() -> &'a SyncAccountsData {
        <SyncAccountsData as ::protobuf::Message>::default_instance()
    }
}

impl SyncAccountsData {
    pub fn new() -> SyncAccountsData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accounts_data",
            |m: &SyncAccountsData| { &m.accounts_data },
            |m: &mut SyncAccountsData| { &mut m.accounts_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "incremental",
            |m: &SyncAccountsData| { &m.incremental },
            |m: &mut SyncAccountsData| { &mut m.incremental },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requesting_full_sync",
            |m: &SyncAccountsData| { &m.requesting_full_sync },
            |m: &mut SyncAccountsData| { &mut m.requesting_full_sync },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncAccountsData>(
            "SyncAccountsData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncAccountsData {
    const NAME: &'static str = "SyncAccountsData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accounts_data.push(is.read_message()?);
                },
                16 => {
                    self.incremental = is.read_bool()?;
                },
                24 => {
                    self.requesting_full_sync = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accounts_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.incremental != false {
            my_size += 1 + 1;
        }
        if self.requesting_full_sync != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.accounts_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.incremental != false {
            os.write_bool(2, self.incremental)?;
        }
        if self.requesting_full_sync != false {
            os.write_bool(3, self.requesting_full_sync)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncAccountsData {
        SyncAccountsData::new()
    }

    fn clear(&mut self) {
        self.accounts_data.clear();
        self.incremental = false;
        self.requesting_full_sync = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncAccountsData {
        static instance: SyncAccountsData = SyncAccountsData {
            accounts_data: ::std::vec::Vec::new(),
            incremental: false,
            requesting_full_sync: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncAccountsData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncAccountsData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncAccountsData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncAccountsData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.PeersRequest)
pub struct PeersRequest {
    // message fields
    // @@protoc_insertion_point(field:network.PeersRequest.max_peers)
    pub max_peers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:network.PeersRequest.max_direct_peers)
    pub max_direct_peers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:network.PeersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeersRequest {
    fn default() -> &'a PeersRequest {
        <PeersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PeersRequest {
    pub fn new() -> PeersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_peers",
            |m: &PeersRequest| { &m.max_peers },
            |m: &mut PeersRequest| { &mut m.max_peers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_direct_peers",
            |m: &PeersRequest| { &m.max_direct_peers },
            |m: &mut PeersRequest| { &mut m.max_direct_peers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeersRequest>(
            "PeersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeersRequest {
    const NAME: &'static str = "PeersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_peers = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.max_direct_peers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.max_peers {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.max_direct_peers {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.max_peers {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_direct_peers {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeersRequest {
        PeersRequest::new()
    }

    fn clear(&mut self) {
        self.max_peers = ::std::option::Option::None;
        self.max_direct_peers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeersRequest {
        static instance: PeersRequest = PeersRequest {
            max_peers: ::std::option::Option::None,
            max_direct_peers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.PeersResponse)
pub struct PeersResponse {
    // message fields
    // @@protoc_insertion_point(field:network.PeersResponse.peers)
    pub peers: ::std::vec::Vec<PeerInfo>,
    // @@protoc_insertion_point(field:network.PeersResponse.direct_peers)
    pub direct_peers: ::std::vec::Vec<PeerInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:network.PeersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeersResponse {
    fn default() -> &'a PeersResponse {
        <PeersResponse as ::protobuf::Message>::default_instance()
    }
}

impl PeersResponse {
    pub fn new() -> PeersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "peers",
            |m: &PeersResponse| { &m.peers },
            |m: &mut PeersResponse| { &mut m.peers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "direct_peers",
            |m: &PeersResponse| { &m.direct_peers },
            |m: &mut PeersResponse| { &mut m.direct_peers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeersResponse>(
            "PeersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeersResponse {
    const NAME: &'static str = "PeersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.peers.push(is.read_message()?);
                },
                18 => {
                    self.direct_peers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.direct_peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.peers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.direct_peers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeersResponse {
        PeersResponse::new()
    }

    fn clear(&mut self) {
        self.peers.clear();
        self.direct_peers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeersResponse {
        static instance: PeersResponse = PeersResponse {
            peers: ::std::vec::Vec::new(),
            direct_peers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.BlockHeadersRequest)
pub struct BlockHeadersRequest {
    // message fields
    // @@protoc_insertion_point(field:network.BlockHeadersRequest.block_hashes)
    pub block_hashes: ::std::vec::Vec<CryptoHash>,
    // special fields
    // @@protoc_insertion_point(special_field:network.BlockHeadersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeadersRequest {
    fn default() -> &'a BlockHeadersRequest {
        <BlockHeadersRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeadersRequest {
    pub fn new() -> BlockHeadersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "block_hashes",
            |m: &BlockHeadersRequest| { &m.block_hashes },
            |m: &mut BlockHeadersRequest| { &mut m.block_hashes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeadersRequest>(
            "BlockHeadersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeadersRequest {
    const NAME: &'static str = "BlockHeadersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.block_hashes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.block_hashes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.block_hashes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeadersRequest {
        BlockHeadersRequest::new()
    }

    fn clear(&mut self) {
        self.block_hashes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeadersRequest {
        static instance: BlockHeadersRequest = BlockHeadersRequest {
            block_hashes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeadersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeadersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeadersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeadersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.BlockHeadersResponse)
pub struct BlockHeadersResponse {
    // message fields
    // @@protoc_insertion_point(field:network.BlockHeadersResponse.block_headers)
    pub block_headers: ::std::vec::Vec<BlockHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:network.BlockHeadersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeadersResponse {
    fn default() -> &'a BlockHeadersResponse {
        <BlockHeadersResponse as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeadersResponse {
    pub fn new() -> BlockHeadersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "block_headers",
            |m: &BlockHeadersResponse| { &m.block_headers },
            |m: &mut BlockHeadersResponse| { &mut m.block_headers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeadersResponse>(
            "BlockHeadersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeadersResponse {
    const NAME: &'static str = "BlockHeadersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.block_headers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.block_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.block_headers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeadersResponse {
        BlockHeadersResponse::new()
    }

    fn clear(&mut self) {
        self.block_headers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeadersResponse {
        static instance: BlockHeadersResponse = BlockHeadersResponse {
            block_headers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeadersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeadersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeadersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeadersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.BlockRequest)
pub struct BlockRequest {
    // message fields
    // @@protoc_insertion_point(field:network.BlockRequest.block_hash)
    pub block_hash: ::protobuf::MessageField<CryptoHash>,
    // special fields
    // @@protoc_insertion_point(special_field:network.BlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockRequest {
    fn default() -> &'a BlockRequest {
        <BlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockRequest {
    pub fn new() -> BlockRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CryptoHash>(
            "block_hash",
            |m: &BlockRequest| { &m.block_hash },
            |m: &mut BlockRequest| { &mut m.block_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockRequest>(
            "BlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockRequest {
    const NAME: &'static str = "BlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_hash)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block_hash.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockRequest {
        BlockRequest::new()
    }

    fn clear(&mut self) {
        self.block_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockRequest {
        static instance: BlockRequest = BlockRequest {
            block_hash: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.BlockResponse)
pub struct BlockResponse {
    // message fields
    // @@protoc_insertion_point(field:network.BlockResponse.block)
    pub block: ::protobuf::MessageField<Block>,
    // special fields
    // @@protoc_insertion_point(special_field:network.BlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockResponse {
    fn default() -> &'a BlockResponse {
        <BlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl BlockResponse {
    pub fn new() -> BlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Block>(
            "block",
            |m: &BlockResponse| { &m.block },
            |m: &mut BlockResponse| { &mut m.block },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockResponse>(
            "BlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockResponse {
    const NAME: &'static str = "BlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockResponse {
        BlockResponse::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockResponse {
        static instance: BlockResponse = BlockResponse {
            block: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.SignedTransaction)
pub struct SignedTransaction {
    // message fields
    // @@protoc_insertion_point(field:network.SignedTransaction.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.SignedTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignedTransaction {
    fn default() -> &'a SignedTransaction {
        <SignedTransaction as ::protobuf::Message>::default_instance()
    }
}

impl SignedTransaction {
    pub fn new() -> SignedTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &SignedTransaction| { &m.borsh },
            |m: &mut SignedTransaction| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignedTransaction>(
            "SignedTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignedTransaction {
    const NAME: &'static str = "SignedTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignedTransaction {
        SignedTransaction::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignedTransaction {
        static instance: SignedTransaction = SignedTransaction {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignedTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignedTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignedTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.RoutedMessage)
pub struct RoutedMessage {
    // message fields
    // @@protoc_insertion_point(field:network.RoutedMessage.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:network.RoutedMessage.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:network.RoutedMessage.num_hops)
    pub num_hops: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:network.RoutedMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoutedMessage {
    fn default() -> &'a RoutedMessage {
        <RoutedMessage as ::protobuf::Message>::default_instance()
    }
}

impl RoutedMessage {
    pub fn new() -> RoutedMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &RoutedMessage| { &m.borsh },
            |m: &mut RoutedMessage| { &mut m.borsh },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &RoutedMessage| { &m.created_at },
            |m: &mut RoutedMessage| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_hops",
            |m: &RoutedMessage| { &m.num_hops },
            |m: &mut RoutedMessage| { &mut m.num_hops },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoutedMessage>(
            "RoutedMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoutedMessage {
    const NAME: &'static str = "RoutedMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                24 => {
                    self.num_hops = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.num_hops {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.num_hops {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoutedMessage {
        RoutedMessage::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.created_at.clear();
        self.num_hops = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoutedMessage {
        static instance: RoutedMessage = RoutedMessage {
            borsh: ::std::vec::Vec::new(),
            created_at: ::protobuf::MessageField::none(),
            num_hops: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoutedMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoutedMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoutedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutedMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.Disconnect)
pub struct Disconnect {
    // message fields
    // @@protoc_insertion_point(field:network.Disconnect.remove_from_connection_store)
    pub remove_from_connection_store: bool,
    // special fields
    // @@protoc_insertion_point(special_field:network.Disconnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Disconnect {
    fn default() -> &'a Disconnect {
        <Disconnect as ::protobuf::Message>::default_instance()
    }
}

impl Disconnect {
    pub fn new() -> Disconnect {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "remove_from_connection_store",
            |m: &Disconnect| { &m.remove_from_connection_store },
            |m: &mut Disconnect| { &mut m.remove_from_connection_store },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Disconnect>(
            "Disconnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Disconnect {
    const NAME: &'static str = "Disconnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.remove_from_connection_store = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.remove_from_connection_store != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.remove_from_connection_store != false {
            os.write_bool(1, self.remove_from_connection_store)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Disconnect {
        Disconnect::new()
    }

    fn clear(&mut self) {
        self.remove_from_connection_store = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Disconnect {
        static instance: Disconnect = Disconnect {
            remove_from_connection_store: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Disconnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Disconnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Disconnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Disconnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.Challenge)
pub struct Challenge {
    // message fields
    // @@protoc_insertion_point(field:network.Challenge.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.Challenge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Challenge {
    fn default() -> &'a Challenge {
        <Challenge as ::protobuf::Message>::default_instance()
    }
}

impl Challenge {
    pub fn new() -> Challenge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &Challenge| { &m.borsh },
            |m: &mut Challenge| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Challenge>(
            "Challenge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Challenge {
    const NAME: &'static str = "Challenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Challenge {
        Challenge::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Challenge {
        static instance: Challenge = Challenge {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Challenge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Challenge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Challenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Challenge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.RoutingSyncV2)
pub struct RoutingSyncV2 {
    // message fields
    // @@protoc_insertion_point(field:network.RoutingSyncV2.borsh)
    pub borsh: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:network.RoutingSyncV2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoutingSyncV2 {
    fn default() -> &'a RoutingSyncV2 {
        <RoutingSyncV2 as ::protobuf::Message>::default_instance()
    }
}

impl RoutingSyncV2 {
    pub fn new() -> RoutingSyncV2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "borsh",
            |m: &RoutingSyncV2| { &m.borsh },
            |m: &mut RoutingSyncV2| { &mut m.borsh },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoutingSyncV2>(
            "RoutingSyncV2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoutingSyncV2 {
    const NAME: &'static str = "RoutingSyncV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.borsh = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.borsh.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.borsh);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.borsh.is_empty() {
            os.write_bytes(1, &self.borsh)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoutingSyncV2 {
        RoutingSyncV2::new()
    }

    fn clear(&mut self) {
        self.borsh.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoutingSyncV2 {
        static instance: RoutingSyncV2 = RoutingSyncV2 {
            borsh: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoutingSyncV2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoutingSyncV2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoutingSyncV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingSyncV2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.TraceContext)
pub struct TraceContext {
    // message fields
    // @@protoc_insertion_point(field:network.TraceContext.trace_id)
    pub trace_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:network.TraceContext.span_id)
    pub span_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:network.TraceContext.sampling_priority)
    pub sampling_priority: ::protobuf::EnumOrUnknown<trace_context::SamplingPriority>,
    // special fields
    // @@protoc_insertion_point(special_field:network.TraceContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TraceContext {
    fn default() -> &'a TraceContext {
        <TraceContext as ::protobuf::Message>::default_instance()
    }
}

impl TraceContext {
    pub fn new() -> TraceContext {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &TraceContext| { &m.trace_id },
            |m: &mut TraceContext| { &mut m.trace_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "span_id",
            |m: &TraceContext| { &m.span_id },
            |m: &mut TraceContext| { &mut m.span_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sampling_priority",
            |m: &TraceContext| { &m.sampling_priority },
            |m: &mut TraceContext| { &mut m.sampling_priority },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TraceContext>(
            "TraceContext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TraceContext {
    const NAME: &'static str = "TraceContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trace_id = is.read_bytes()?;
                },
                18 => {
                    self.span_id = is.read_bytes()?;
                },
                24 => {
                    self.sampling_priority = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.trace_id);
        }
        if !self.span_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.span_id);
        }
        if self.sampling_priority != ::protobuf::EnumOrUnknown::new(trace_context::SamplingPriority::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.sampling_priority.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.trace_id.is_empty() {
            os.write_bytes(1, &self.trace_id)?;
        }
        if !self.span_id.is_empty() {
            os.write_bytes(2, &self.span_id)?;
        }
        if self.sampling_priority != ::protobuf::EnumOrUnknown::new(trace_context::SamplingPriority::UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.sampling_priority))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TraceContext {
        TraceContext::new()
    }

    fn clear(&mut self) {
        self.trace_id.clear();
        self.span_id.clear();
        self.sampling_priority = ::protobuf::EnumOrUnknown::new(trace_context::SamplingPriority::UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TraceContext {
        static instance: TraceContext = TraceContext {
            trace_id: ::std::vec::Vec::new(),
            span_id: ::std::vec::Vec::new(),
            sampling_priority: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TraceContext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TraceContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TraceContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TraceContext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TraceContext`
pub mod trace_context {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:network.TraceContext.SamplingPriority)
    pub enum SamplingPriority {
        // @@protoc_insertion_point(enum_value:network.TraceContext.SamplingPriority.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:network.TraceContext.SamplingPriority.AutoReject)
        AutoReject = 1,
        // @@protoc_insertion_point(enum_value:network.TraceContext.SamplingPriority.UserReject)
        UserReject = 2,
        // @@protoc_insertion_point(enum_value:network.TraceContext.SamplingPriority.AutoKeep)
        AutoKeep = 3,
        // @@protoc_insertion_point(enum_value:network.TraceContext.SamplingPriority.UserKeep)
        UserKeep = 4,
    }

    impl ::protobuf::Enum for SamplingPriority {
        const NAME: &'static str = "SamplingPriority";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SamplingPriority> {
            match value {
                0 => ::std::option::Option::Some(SamplingPriority::UNKNOWN),
                1 => ::std::option::Option::Some(SamplingPriority::AutoReject),
                2 => ::std::option::Option::Some(SamplingPriority::UserReject),
                3 => ::std::option::Option::Some(SamplingPriority::AutoKeep),
                4 => ::std::option::Option::Some(SamplingPriority::UserKeep),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SamplingPriority] = &[
            SamplingPriority::UNKNOWN,
            SamplingPriority::AutoReject,
            SamplingPriority::UserReject,
            SamplingPriority::AutoKeep,
            SamplingPriority::UserKeep,
        ];
    }

    impl ::protobuf::EnumFull for SamplingPriority {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TraceContext.SamplingPriority").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SamplingPriority {
        fn default() -> Self {
            SamplingPriority::UNKNOWN
        }
    }

    impl SamplingPriority {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SamplingPriority>("TraceContext.SamplingPriority")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:network.PeerMessage)
pub struct PeerMessage {
    // message fields
    // @@protoc_insertion_point(field:network.PeerMessage.trace_context)
    pub trace_context: ::protobuf::MessageField<TraceContext>,
    // message oneof groups
    pub message_type: ::std::option::Option<peer_message::Message_type>,
    // special fields
    // @@protoc_insertion_point(special_field:network.PeerMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerMessage {
    fn default() -> &'a PeerMessage {
        <PeerMessage as ::protobuf::Message>::default_instance()
    }
}

impl PeerMessage {
    pub fn new() -> PeerMessage {
        ::std::default::Default::default()
    }

    // .network.Handshake tier1_handshake = 27;

    pub fn tier1_handshake(&self) -> &Handshake {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Tier1Handshake(ref v)) => v,
            _ => <Handshake as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tier1_handshake(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_tier1_handshake(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Tier1Handshake(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tier1_handshake(&mut self, v: Handshake) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::Tier1Handshake(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tier1_handshake(&mut self) -> &mut Handshake {
        if let ::std::option::Option::Some(peer_message::Message_type::Tier1Handshake(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::Tier1Handshake(Handshake::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Tier1Handshake(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tier1_handshake(&mut self) -> Handshake {
        if self.has_tier1_handshake() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::Tier1Handshake(v)) => v,
                _ => panic!(),
            }
        } else {
            Handshake::new()
        }
    }

    // .network.Handshake tier2_handshake = 4;

    pub fn tier2_handshake(&self) -> &Handshake {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Tier2Handshake(ref v)) => v,
            _ => <Handshake as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tier2_handshake(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_tier2_handshake(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Tier2Handshake(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tier2_handshake(&mut self, v: Handshake) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::Tier2Handshake(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tier2_handshake(&mut self) -> &mut Handshake {
        if let ::std::option::Option::Some(peer_message::Message_type::Tier2Handshake(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::Tier2Handshake(Handshake::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Tier2Handshake(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tier2_handshake(&mut self) -> Handshake {
        if self.has_tier2_handshake() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::Tier2Handshake(v)) => v,
                _ => panic!(),
            }
        } else {
            Handshake::new()
        }
    }

    // .network.HandshakeFailure handshake_failure = 5;

    pub fn handshake_failure(&self) -> &HandshakeFailure {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::HandshakeFailure(ref v)) => v,
            _ => <HandshakeFailure as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_handshake_failure(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_handshake_failure(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::HandshakeFailure(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handshake_failure(&mut self, v: HandshakeFailure) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::HandshakeFailure(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handshake_failure(&mut self) -> &mut HandshakeFailure {
        if let ::std::option::Option::Some(peer_message::Message_type::HandshakeFailure(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::HandshakeFailure(HandshakeFailure::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::HandshakeFailure(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handshake_failure(&mut self) -> HandshakeFailure {
        if self.has_handshake_failure() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::HandshakeFailure(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeFailure::new()
        }
    }

    // .network.LastEdge last_edge = 6;

    pub fn last_edge(&self) -> &LastEdge {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::LastEdge(ref v)) => v,
            _ => <LastEdge as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_last_edge(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_last_edge(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::LastEdge(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_last_edge(&mut self, v: LastEdge) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::LastEdge(v))
    }

    // Mutable pointer to the field.
    pub fn mut_last_edge(&mut self) -> &mut LastEdge {
        if let ::std::option::Option::Some(peer_message::Message_type::LastEdge(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::LastEdge(LastEdge::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::LastEdge(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_last_edge(&mut self) -> LastEdge {
        if self.has_last_edge() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::LastEdge(v)) => v,
                _ => panic!(),
            }
        } else {
            LastEdge::new()
        }
    }

    // .network.RoutingTableUpdate sync_routing_table = 7;

    pub fn sync_routing_table(&self) -> &RoutingTableUpdate {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::SyncRoutingTable(ref v)) => v,
            _ => <RoutingTableUpdate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sync_routing_table(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_sync_routing_table(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::SyncRoutingTable(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sync_routing_table(&mut self, v: RoutingTableUpdate) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::SyncRoutingTable(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sync_routing_table(&mut self) -> &mut RoutingTableUpdate {
        if let ::std::option::Option::Some(peer_message::Message_type::SyncRoutingTable(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::SyncRoutingTable(RoutingTableUpdate::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::SyncRoutingTable(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sync_routing_table(&mut self) -> RoutingTableUpdate {
        if self.has_sync_routing_table() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::SyncRoutingTable(v)) => v,
                _ => panic!(),
            }
        } else {
            RoutingTableUpdate::new()
        }
    }

    // .network.UpdateNonceRequest update_nonce_request = 8;

    pub fn update_nonce_request(&self) -> &UpdateNonceRequest {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::UpdateNonceRequest(ref v)) => v,
            _ => <UpdateNonceRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_update_nonce_request(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_update_nonce_request(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::UpdateNonceRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_update_nonce_request(&mut self, v: UpdateNonceRequest) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::UpdateNonceRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_update_nonce_request(&mut self) -> &mut UpdateNonceRequest {
        if let ::std::option::Option::Some(peer_message::Message_type::UpdateNonceRequest(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::UpdateNonceRequest(UpdateNonceRequest::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::UpdateNonceRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_update_nonce_request(&mut self) -> UpdateNonceRequest {
        if self.has_update_nonce_request() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::UpdateNonceRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            UpdateNonceRequest::new()
        }
    }

    // .network.UpdateNonceResponse update_nonce_response = 9;

    pub fn update_nonce_response(&self) -> &UpdateNonceResponse {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::UpdateNonceResponse(ref v)) => v,
            _ => <UpdateNonceResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_update_nonce_response(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_update_nonce_response(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::UpdateNonceResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_update_nonce_response(&mut self, v: UpdateNonceResponse) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::UpdateNonceResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_update_nonce_response(&mut self) -> &mut UpdateNonceResponse {
        if let ::std::option::Option::Some(peer_message::Message_type::UpdateNonceResponse(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::UpdateNonceResponse(UpdateNonceResponse::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::UpdateNonceResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_update_nonce_response(&mut self) -> UpdateNonceResponse {
        if self.has_update_nonce_response() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::UpdateNonceResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            UpdateNonceResponse::new()
        }
    }

    // .network.SyncAccountsData sync_accounts_data = 25;

    pub fn sync_accounts_data(&self) -> &SyncAccountsData {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::SyncAccountsData(ref v)) => v,
            _ => <SyncAccountsData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sync_accounts_data(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_sync_accounts_data(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::SyncAccountsData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sync_accounts_data(&mut self, v: SyncAccountsData) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::SyncAccountsData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sync_accounts_data(&mut self) -> &mut SyncAccountsData {
        if let ::std::option::Option::Some(peer_message::Message_type::SyncAccountsData(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::SyncAccountsData(SyncAccountsData::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::SyncAccountsData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sync_accounts_data(&mut self) -> SyncAccountsData {
        if self.has_sync_accounts_data() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::SyncAccountsData(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncAccountsData::new()
        }
    }

    // .network.PeersRequest peers_request = 10;

    pub fn peers_request(&self) -> &PeersRequest {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::PeersRequest(ref v)) => v,
            _ => <PeersRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_peers_request(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_peers_request(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::PeersRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peers_request(&mut self, v: PeersRequest) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::PeersRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_peers_request(&mut self) -> &mut PeersRequest {
        if let ::std::option::Option::Some(peer_message::Message_type::PeersRequest(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::PeersRequest(PeersRequest::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::PeersRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peers_request(&mut self) -> PeersRequest {
        if self.has_peers_request() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::PeersRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            PeersRequest::new()
        }
    }

    // .network.PeersResponse peers_response = 11;

    pub fn peers_response(&self) -> &PeersResponse {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::PeersResponse(ref v)) => v,
            _ => <PeersResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_peers_response(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_peers_response(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::PeersResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peers_response(&mut self, v: PeersResponse) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::PeersResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_peers_response(&mut self) -> &mut PeersResponse {
        if let ::std::option::Option::Some(peer_message::Message_type::PeersResponse(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::PeersResponse(PeersResponse::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::PeersResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peers_response(&mut self) -> PeersResponse {
        if self.has_peers_response() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::PeersResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            PeersResponse::new()
        }
    }

    // .network.BlockHeadersRequest block_headers_request = 12;

    pub fn block_headers_request(&self) -> &BlockHeadersRequest {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockHeadersRequest(ref v)) => v,
            _ => <BlockHeadersRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_headers_request(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_block_headers_request(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockHeadersRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_headers_request(&mut self, v: BlockHeadersRequest) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockHeadersRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_headers_request(&mut self) -> &mut BlockHeadersRequest {
        if let ::std::option::Option::Some(peer_message::Message_type::BlockHeadersRequest(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockHeadersRequest(BlockHeadersRequest::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockHeadersRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_headers_request(&mut self) -> BlockHeadersRequest {
        if self.has_block_headers_request() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::BlockHeadersRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockHeadersRequest::new()
        }
    }

    // .network.BlockHeadersResponse block_headers_response = 13;

    pub fn block_headers_response(&self) -> &BlockHeadersResponse {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockHeadersResponse(ref v)) => v,
            _ => <BlockHeadersResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_headers_response(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_block_headers_response(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockHeadersResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_headers_response(&mut self, v: BlockHeadersResponse) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockHeadersResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_headers_response(&mut self) -> &mut BlockHeadersResponse {
        if let ::std::option::Option::Some(peer_message::Message_type::BlockHeadersResponse(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockHeadersResponse(BlockHeadersResponse::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockHeadersResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_headers_response(&mut self) -> BlockHeadersResponse {
        if self.has_block_headers_response() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::BlockHeadersResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockHeadersResponse::new()
        }
    }

    // .network.BlockRequest block_request = 14;

    pub fn block_request(&self) -> &BlockRequest {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockRequest(ref v)) => v,
            _ => <BlockRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_request(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_block_request(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_request(&mut self, v: BlockRequest) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_request(&mut self) -> &mut BlockRequest {
        if let ::std::option::Option::Some(peer_message::Message_type::BlockRequest(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockRequest(BlockRequest::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_request(&mut self) -> BlockRequest {
        if self.has_block_request() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::BlockRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockRequest::new()
        }
    }

    // .network.BlockResponse block_response = 15;

    pub fn block_response(&self) -> &BlockResponse {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockResponse(ref v)) => v,
            _ => <BlockResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_response(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_block_response(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_response(&mut self, v: BlockResponse) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_response(&mut self) -> &mut BlockResponse {
        if let ::std::option::Option::Some(peer_message::Message_type::BlockResponse(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockResponse(BlockResponse::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::BlockResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_response(&mut self) -> BlockResponse {
        if self.has_block_response() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::BlockResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockResponse::new()
        }
    }

    // .network.SignedTransaction transaction = 16;

    pub fn transaction(&self) -> &SignedTransaction {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Transaction(ref v)) => v,
            _ => <SignedTransaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_transaction(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_transaction(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Transaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: SignedTransaction) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::Transaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut SignedTransaction {
        if let ::std::option::Option::Some(peer_message::Message_type::Transaction(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::Transaction(SignedTransaction::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Transaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transaction(&mut self) -> SignedTransaction {
        if self.has_transaction() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::Transaction(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedTransaction::new()
        }
    }

    // .network.RoutedMessage routed = 17;

    pub fn routed(&self) -> &RoutedMessage {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Routed(ref v)) => v,
            _ => <RoutedMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_routed(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_routed(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Routed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_routed(&mut self, v: RoutedMessage) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::Routed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_routed(&mut self) -> &mut RoutedMessage {
        if let ::std::option::Option::Some(peer_message::Message_type::Routed(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::Routed(RoutedMessage::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Routed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_routed(&mut self) -> RoutedMessage {
        if self.has_routed() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::Routed(v)) => v,
                _ => panic!(),
            }
        } else {
            RoutedMessage::new()
        }
    }

    // .network.Disconnect disconnect = 18;

    pub fn disconnect(&self) -> &Disconnect {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Disconnect(ref v)) => v,
            _ => <Disconnect as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_disconnect(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_disconnect(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Disconnect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_disconnect(&mut self, v: Disconnect) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::Disconnect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_disconnect(&mut self) -> &mut Disconnect {
        if let ::std::option::Option::Some(peer_message::Message_type::Disconnect(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::Disconnect(Disconnect::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Disconnect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_disconnect(&mut self) -> Disconnect {
        if self.has_disconnect() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::Disconnect(v)) => v,
                _ => panic!(),
            }
        } else {
            Disconnect::new()
        }
    }

    // .network.Challenge challenge = 19;

    pub fn challenge(&self) -> &Challenge {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Challenge(ref v)) => v,
            _ => <Challenge as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_challenge(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Challenge(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: Challenge) {
        self.message_type = ::std::option::Option::Some(peer_message::Message_type::Challenge(v))
    }

    // Mutable pointer to the field.
    pub fn mut_challenge(&mut self) -> &mut Challenge {
        if let ::std::option::Option::Some(peer_message::Message_type::Challenge(_)) = self.message_type {
        } else {
            self.message_type = ::std::option::Option::Some(peer_message::Message_type::Challenge(Challenge::new()));
        }
        match self.message_type {
            ::std::option::Option::Some(peer_message::Message_type::Challenge(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_challenge(&mut self) -> Challenge {
        if self.has_challenge() {
            match self.message_type.take() {
                ::std::option::Option::Some(peer_message::Message_type::Challenge(v)) => v,
                _ => panic!(),
            }
        } else {
            Challenge::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TraceContext>(
            "trace_context",
            |m: &PeerMessage| { &m.trace_context },
            |m: &mut PeerMessage| { &mut m.trace_context },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Handshake>(
            "tier1_handshake",
            PeerMessage::has_tier1_handshake,
            PeerMessage::tier1_handshake,
            PeerMessage::mut_tier1_handshake,
            PeerMessage::set_tier1_handshake,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Handshake>(
            "tier2_handshake",
            PeerMessage::has_tier2_handshake,
            PeerMessage::tier2_handshake,
            PeerMessage::mut_tier2_handshake,
            PeerMessage::set_tier2_handshake,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HandshakeFailure>(
            "handshake_failure",
            PeerMessage::has_handshake_failure,
            PeerMessage::handshake_failure,
            PeerMessage::mut_handshake_failure,
            PeerMessage::set_handshake_failure,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LastEdge>(
            "last_edge",
            PeerMessage::has_last_edge,
            PeerMessage::last_edge,
            PeerMessage::mut_last_edge,
            PeerMessage::set_last_edge,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RoutingTableUpdate>(
            "sync_routing_table",
            PeerMessage::has_sync_routing_table,
            PeerMessage::sync_routing_table,
            PeerMessage::mut_sync_routing_table,
            PeerMessage::set_sync_routing_table,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UpdateNonceRequest>(
            "update_nonce_request",
            PeerMessage::has_update_nonce_request,
            PeerMessage::update_nonce_request,
            PeerMessage::mut_update_nonce_request,
            PeerMessage::set_update_nonce_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UpdateNonceResponse>(
            "update_nonce_response",
            PeerMessage::has_update_nonce_response,
            PeerMessage::update_nonce_response,
            PeerMessage::mut_update_nonce_response,
            PeerMessage::set_update_nonce_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SyncAccountsData>(
            "sync_accounts_data",
            PeerMessage::has_sync_accounts_data,
            PeerMessage::sync_accounts_data,
            PeerMessage::mut_sync_accounts_data,
            PeerMessage::set_sync_accounts_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PeersRequest>(
            "peers_request",
            PeerMessage::has_peers_request,
            PeerMessage::peers_request,
            PeerMessage::mut_peers_request,
            PeerMessage::set_peers_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PeersResponse>(
            "peers_response",
            PeerMessage::has_peers_response,
            PeerMessage::peers_response,
            PeerMessage::mut_peers_response,
            PeerMessage::set_peers_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockHeadersRequest>(
            "block_headers_request",
            PeerMessage::has_block_headers_request,
            PeerMessage::block_headers_request,
            PeerMessage::mut_block_headers_request,
            PeerMessage::set_block_headers_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockHeadersResponse>(
            "block_headers_response",
            PeerMessage::has_block_headers_response,
            PeerMessage::block_headers_response,
            PeerMessage::mut_block_headers_response,
            PeerMessage::set_block_headers_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockRequest>(
            "block_request",
            PeerMessage::has_block_request,
            PeerMessage::block_request,
            PeerMessage::mut_block_request,
            PeerMessage::set_block_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockResponse>(
            "block_response",
            PeerMessage::has_block_response,
            PeerMessage::block_response,
            PeerMessage::mut_block_response,
            PeerMessage::set_block_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SignedTransaction>(
            "transaction",
            PeerMessage::has_transaction,
            PeerMessage::transaction,
            PeerMessage::mut_transaction,
            PeerMessage::set_transaction,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RoutedMessage>(
            "routed",
            PeerMessage::has_routed,
            PeerMessage::routed,
            PeerMessage::mut_routed,
            PeerMessage::set_routed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Disconnect>(
            "disconnect",
            PeerMessage::has_disconnect,
            PeerMessage::disconnect,
            PeerMessage::mut_disconnect,
            PeerMessage::set_disconnect,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Challenge>(
            "challenge",
            PeerMessage::has_challenge,
            PeerMessage::challenge,
            PeerMessage::mut_challenge,
            PeerMessage::set_challenge,
        ));
        oneofs.push(peer_message::Message_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerMessage>(
            "PeerMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerMessage {
    const NAME: &'static str = "PeerMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trace_context)?;
                },
                218 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::Tier1Handshake(is.read_message()?));
                },
                34 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::Tier2Handshake(is.read_message()?));
                },
                42 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::HandshakeFailure(is.read_message()?));
                },
                50 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::LastEdge(is.read_message()?));
                },
                58 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::SyncRoutingTable(is.read_message()?));
                },
                66 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::UpdateNonceRequest(is.read_message()?));
                },
                74 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::UpdateNonceResponse(is.read_message()?));
                },
                202 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::SyncAccountsData(is.read_message()?));
                },
                82 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::PeersRequest(is.read_message()?));
                },
                90 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::PeersResponse(is.read_message()?));
                },
                98 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockHeadersRequest(is.read_message()?));
                },
                106 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockHeadersResponse(is.read_message()?));
                },
                114 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockRequest(is.read_message()?));
                },
                122 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::BlockResponse(is.read_message()?));
                },
                130 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::Transaction(is.read_message()?));
                },
                138 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::Routed(is.read_message()?));
                },
                146 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::Disconnect(is.read_message()?));
                },
                154 => {
                    self.message_type = ::std::option::Option::Some(peer_message::Message_type::Challenge(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trace_context.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.message_type {
            match v {
                &peer_message::Message_type::Tier1Handshake(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::Tier2Handshake(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::HandshakeFailure(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::LastEdge(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::SyncRoutingTable(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::UpdateNonceRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::UpdateNonceResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::SyncAccountsData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::PeersRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::PeersResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::BlockHeadersRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::BlockHeadersResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::BlockRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::BlockResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::Transaction(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::Routed(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::Disconnect(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &peer_message::Message_type::Challenge(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trace_context.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message_type {
            match v {
                &peer_message::Message_type::Tier1Handshake(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
                },
                &peer_message::Message_type::Tier2Handshake(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &peer_message::Message_type::HandshakeFailure(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &peer_message::Message_type::LastEdge(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &peer_message::Message_type::SyncRoutingTable(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &peer_message::Message_type::UpdateNonceRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &peer_message::Message_type::UpdateNonceResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &peer_message::Message_type::SyncAccountsData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
                },
                &peer_message::Message_type::PeersRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &peer_message::Message_type::PeersResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &peer_message::Message_type::BlockHeadersRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &peer_message::Message_type::BlockHeadersResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &peer_message::Message_type::BlockRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &peer_message::Message_type::BlockResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &peer_message::Message_type::Transaction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &peer_message::Message_type::Routed(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &peer_message::Message_type::Disconnect(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &peer_message::Message_type::Challenge(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerMessage {
        PeerMessage::new()
    }

    fn clear(&mut self) {
        self.trace_context.clear();
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerMessage {
        static instance: PeerMessage = PeerMessage {
            trace_context: ::protobuf::MessageField::none(),
            message_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PeerMessage`
pub mod peer_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:network.PeerMessage.message_type)
    pub enum Message_type {
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.tier1_handshake)
        Tier1Handshake(super::Handshake),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.tier2_handshake)
        Tier2Handshake(super::Handshake),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.handshake_failure)
        HandshakeFailure(super::HandshakeFailure),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.last_edge)
        LastEdge(super::LastEdge),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.sync_routing_table)
        SyncRoutingTable(super::RoutingTableUpdate),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.update_nonce_request)
        UpdateNonceRequest(super::UpdateNonceRequest),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.update_nonce_response)
        UpdateNonceResponse(super::UpdateNonceResponse),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.sync_accounts_data)
        SyncAccountsData(super::SyncAccountsData),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.peers_request)
        PeersRequest(super::PeersRequest),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.peers_response)
        PeersResponse(super::PeersResponse),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.block_headers_request)
        BlockHeadersRequest(super::BlockHeadersRequest),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.block_headers_response)
        BlockHeadersResponse(super::BlockHeadersResponse),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.block_request)
        BlockRequest(super::BlockRequest),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.block_response)
        BlockResponse(super::BlockResponse),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.transaction)
        Transaction(super::SignedTransaction),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.routed)
        Routed(super::RoutedMessage),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.disconnect)
        Disconnect(super::Disconnect),
        // @@protoc_insertion_point(oneof_field:network.PeerMessage.challenge)
        Challenge(super::Challenge),
    }

    impl ::protobuf::Oneof for Message_type {
    }

    impl ::protobuf::OneofFull for Message_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PeerMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("message_type").unwrap()).clone()
        }
    }

    impl Message_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Message_type>("message_type")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1enetwork_protocol/network.proto\x12\x07network\x1a\x1fgoogle/protob\
    uf/timestamp.proto\"\xaa\x01\n\x0cOwnedAccount\x123\n\x0baccount_key\x18\
    \x01\x20\x01(\x0b2\x12.network.PublicKeyR\naccountKey\x12+\n\x07peer_id\
    \x18\x02\x20\x01(\x0b2\x12.network.PublicKeyR\x06peerId\x128\n\ttimestam\
    p\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ttimestamp\"\xa2\
    \x01\n\x11AccountKeyPayload\x129\n\x0caccount_data\x18\x02\x20\x01(\x0b2\
    \x14.network.AccountDataH\0R\x0baccountData\x12<\n\rowned_account\x18\
    \x03\x20\x01(\x0b2\x15.network.OwnedAccountH\0R\x0cownedAccountB\x0e\n\
    \x0cpayload_typeJ\x04\x08\x01\x10\x02\"!\n\tSignature\x12\x14\n\x05borsh\
    \x18\x01\x20\x01(\x0cR\x05borsh\"e\n\x17AccountKeySignedPayload\x12\x18\
    \n\x07payload\x18\x01\x20\x01(\x0cR\x07payload\x120\n\tsignature\x18\x02\
    \x20\x01(\x0b2\x12.network.SignatureR\tsignature\"!\n\tPublicKey\x12\x14\
    \n\x05borsh\x18\x01\x20\x01(\x0cR\x05borsh\"\x20\n\x08PeerInfo\x12\x14\n\
    \x05borsh\x18\x01\x20\x01(\x0cR\x05borsh\"\x20\n\nCryptoHash\x12\x12\n\
    \x04hash\x18\x01\x20\x01(\x0cR\x04hash\"\x1c\n\x04Edge\x12\x14\n\x05bors\
    h\x18\x01\x20\x01(\x0cR\x05borsh\"'\n\x0fPartialEdgeInfo\x12\x14\n\x05bo\
    rsh\x18\x01\x20\x01(\x0cR\x05borsh\"'\n\x0fAnnounceAccount\x12\x14\n\x05\
    borsh\x18\x01\x20\x01(\x0cR\x05borsh\"\x1d\n\x05Block\x12\x14\n\x05borsh\
    \x18\x01\x20\x01(\x0cR\x05borsh\"#\n\x0bBlockHeader\x12\x14\n\x05borsh\
    \x18\x01\x20\x01(\x0cR\x05borsh\"O\n\tGenesisId\x12\x19\n\x08chain_id\
    \x18\x01\x20\x01(\tR\x07chainId\x12'\n\x04hash\x18\x02\x20\x01(\x0b2\x13\
    .network.CryptoHashR\x04hash\"\x9d\x01\n\rPeerChainInfo\x121\n\ngenesis_\
    id\x18\x01\x20\x01(\x0b2\x12.network.GenesisIdR\tgenesisId\x12\x16\n\x06\
    height\x18\x02\x20\x01(\x04R\x06height\x12%\n\x0etracked_shards\x18\x03\
    \x20\x03(\x04R\rtrackedShards\x12\x1a\n\x08archival\x18\x04\x20\x01(\x08\
    R\x08archival\"\xe3\x03\n\tHandshake\x12)\n\x10protocol_version\x18\x01\
    \x20\x01(\rR\x0fprotocolVersion\x128\n\x18oldest_supported_version\x18\
    \x02\x20\x01(\rR\x16oldestSupportedVersion\x128\n\x0esender_peer_id\x18\
    \x03\x20\x01(\x0b2\x12.network.PublicKeyR\x0csenderPeerId\x128\n\x0etarg\
    et_peer_id\x18\x04\x20\x01(\x0b2\x12.network.PublicKeyR\x0ctargetPeerId\
    \x12,\n\x12sender_listen_port\x18\x05\x20\x01(\rR\x10senderListenPort\
    \x12B\n\x11sender_chain_info\x18\x06\x20\x01(\x0b2\x16.network.PeerChain\
    InfoR\x0fsenderChainInfo\x12D\n\x11partial_edge_info\x18\x07\x20\x01(\
    \x0b2\x18.network.PartialEdgeInfoR\x0fpartialEdgeInfo\x12E\n\rowned_acco\
    unt\x18\x08\x20\x01(\x0b2\x20.network.AccountKeySignedPayloadR\x0cownedA\
    ccount\"\xdf\x02\n\x10HandshakeFailure\x128\n\x06reason\x18\x01\x20\x01(\
    \x0e2\x20.network.HandshakeFailure.ReasonR\x06reason\x12.\n\tpeer_info\
    \x18\x02\x20\x01(\x0b2\x11.network.PeerInfoR\x08peerInfo\x121\n\ngenesis\
    _id\x18\x03\x20\x01(\x0b2\x12.network.GenesisIdR\tgenesisId\x12\x18\n\
    \x07version\x18\x04\x20\x01(\rR\x07version\x128\n\x18oldest_supported_ve\
    rsion\x18\x05\x20\x01(\rR\x16oldestSupportedVersion\"Z\n\x06Reason\x12\
    \x0b\n\x07UNKNOWN\x10\0\x12\x1b\n\x17ProtocolVersionMismatch\x10\x01\x12\
    \x13\n\x0fGenesisMismatch\x10\x02\x12\x11\n\rInvalidTarget\x10\x03\"-\n\
    \x08LastEdge\x12!\n\x04edge\x18\x01\x20\x01(\x0b2\r.network.EdgeR\x04edg\
    e\"0\n\nSocketAddr\x12\x0e\n\x02ip\x18\x01\x20\x01(\x0cR\x02ip\x12\x12\n\
    \x04port\x18\x02\x20\x01(\rR\x04port\"`\n\x08PeerAddr\x12'\n\x04addr\x18\
    \x01\x20\x01(\x0b2\x13.network.SocketAddrR\x04addr\x12+\n\x07peer_id\x18\
    \x02\x20\x01(\x0b2\x12.network.PublicKeyR\x06peerId\"\xfc\x01\n\x0bAccou\
    ntData\x12+\n\x07peer_id\x18\x05\x20\x01(\x0b2\x12.network.PublicKeyR\
    \x06peerId\x123\n\x0baccount_key\x18\x06\x20\x01(\x0b2\x12.network.Publi\
    cKeyR\naccountKey\x12+\n\x07proxies\x18\x02\x20\x03(\x0b2\x11.network.Pe\
    erAddrR\x07proxies\x12\x18\n\x07version\x18\x07\x20\x01(\x04R\x07version\
    \x128\n\ttimestamp\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \ttimestampJ\x04\x08\x01\x10\x02J\x04\x08\x03\x10\x04\"{\n\x12RoutingTab\
    leUpdate\x12#\n\x05edges\x18\x01\x20\x03(\x0b2\r.network.EdgeR\x05edges\
    \x124\n\x08accounts\x18\x02\x20\x03(\x0b2\x18.network.AnnounceAccountR\
    \x08accountsJ\x04\x08\x03\x10\x04J\x04\x08\x04\x10\x05\"Z\n\x12UpdateNon\
    ceRequest\x12D\n\x11partial_edge_info\x18\x01\x20\x01(\x0b2\x18.network.\
    PartialEdgeInfoR\x0fpartialEdgeInfo\"8\n\x13UpdateNonceResponse\x12!\n\
    \x04edge\x18\x01\x20\x01(\x0b2\r.network.EdgeR\x04edge\"\xad\x01\n\x10Sy\
    ncAccountsData\x12E\n\raccounts_data\x18\x01\x20\x03(\x0b2\x20.network.A\
    ccountKeySignedPayloadR\x0caccountsData\x12\x20\n\x0bincremental\x18\x02\
    \x20\x01(\x08R\x0bincremental\x120\n\x14requesting_full_sync\x18\x03\x20\
    \x01(\x08R\x12requestingFullSync\"\x82\x01\n\x0cPeersRequest\x12\x20\n\t\
    max_peers\x18\x01\x20\x01(\rH\0R\x08maxPeers\x88\x01\x01\x12-\n\x10max_d\
    irect_peers\x18\x02\x20\x01(\rH\x01R\x0emaxDirectPeers\x88\x01\x01B\x0c\
    \n\n_max_peersB\x13\n\x11_max_direct_peers\"n\n\rPeersResponse\x12'\n\
    \x05peers\x18\x01\x20\x03(\x0b2\x11.network.PeerInfoR\x05peers\x124\n\
    \x0cdirect_peers\x18\x02\x20\x03(\x0b2\x11.network.PeerInfoR\x0bdirectPe\
    ers\"M\n\x13BlockHeadersRequest\x126\n\x0cblock_hashes\x18\x01\x20\x03(\
    \x0b2\x13.network.CryptoHashR\x0bblockHashes\"Q\n\x14BlockHeadersRespons\
    e\x129\n\rblock_headers\x18\x01\x20\x03(\x0b2\x14.network.BlockHeaderR\
    \x0cblockHeaders\"B\n\x0cBlockRequest\x122\n\nblock_hash\x18\x01\x20\x01\
    (\x0b2\x13.network.CryptoHashR\tblockHash\"5\n\rBlockResponse\x12$\n\x05\
    block\x18\x01\x20\x01(\x0b2\x0e.network.BlockR\x05block\")\n\x11SignedTr\
    ansaction\x12\x14\n\x05borsh\x18\x01\x20\x01(\x0cR\x05borsh\"\x8d\x01\n\
    \rRoutedMessage\x12\x14\n\x05borsh\x18\x01\x20\x01(\x0cR\x05borsh\x129\n\
    \ncreated_at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreat\
    edAt\x12\x1e\n\x08num_hops\x18\x03\x20\x01(\x05H\0R\x07numHops\x88\x01\
    \x01B\x0b\n\t_num_hops\"M\n\nDisconnect\x12?\n\x1cremove_from_connection\
    _store\x18\x01\x20\x01(\x08R\x19removeFromConnectionStore\"!\n\tChalleng\
    e\x12\x14\n\x05borsh\x18\x01\x20\x01(\x0cR\x05borsh\"%\n\rRoutingSyncV2\
    \x12\x14\n\x05borsh\x18\x01\x20\x01(\x0cR\x05borsh\"\xf4\x01\n\x0cTraceC\
    ontext\x12\x19\n\x08trace_id\x18\x01\x20\x01(\x0cR\x07traceId\x12\x17\n\
    \x07span_id\x18\x02\x20\x01(\x0cR\x06spanId\x12S\n\x11sampling_priority\
    \x18\x03\x20\x01(\x0e2&.network.TraceContext.SamplingPriorityR\x10sampli\
    ngPriority\"[\n\x10SamplingPriority\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0e\n\
    \nAutoReject\x10\x01\x12\x0e\n\nUserReject\x10\x02\x12\x0c\n\x08AutoKeep\
    \x10\x03\x12\x0c\n\x08UserKeep\x10\x04\"\xc6\n\n\x0bPeerMessage\x12:\n\r\
    trace_context\x18\x1a\x20\x01(\x0b2\x15.network.TraceContextR\x0ctraceCo\
    ntext\x12=\n\x0ftier1_handshake\x18\x1b\x20\x01(\x0b2\x12.network.Handsh\
    akeH\0R\x0etier1Handshake\x12=\n\x0ftier2_handshake\x18\x04\x20\x01(\x0b\
    2\x12.network.HandshakeH\0R\x0etier2Handshake\x12H\n\x11handshake_failur\
    e\x18\x05\x20\x01(\x0b2\x19.network.HandshakeFailureH\0R\x10handshakeFai\
    lure\x120\n\tlast_edge\x18\x06\x20\x01(\x0b2\x11.network.LastEdgeH\0R\
    \x08lastEdge\x12K\n\x12sync_routing_table\x18\x07\x20\x01(\x0b2\x1b.netw\
    ork.RoutingTableUpdateH\0R\x10syncRoutingTable\x12O\n\x14update_nonce_re\
    quest\x18\x08\x20\x01(\x0b2\x1b.network.UpdateNonceRequestH\0R\x12update\
    NonceRequest\x12R\n\x15update_nonce_response\x18\t\x20\x01(\x0b2\x1c.net\
    work.UpdateNonceResponseH\0R\x13updateNonceResponse\x12I\n\x12sync_accou\
    nts_data\x18\x19\x20\x01(\x0b2\x19.network.SyncAccountsDataH\0R\x10syncA\
    ccountsData\x12<\n\rpeers_request\x18\n\x20\x01(\x0b2\x15.network.PeersR\
    equestH\0R\x0cpeersRequest\x12?\n\x0epeers_response\x18\x0b\x20\x01(\x0b\
    2\x16.network.PeersResponseH\0R\rpeersResponse\x12R\n\x15block_headers_r\
    equest\x18\x0c\x20\x01(\x0b2\x1c.network.BlockHeadersRequestH\0R\x13bloc\
    kHeadersRequest\x12U\n\x16block_headers_response\x18\r\x20\x01(\x0b2\x1d\
    .network.BlockHeadersResponseH\0R\x14blockHeadersResponse\x12<\n\rblock_\
    request\x18\x0e\x20\x01(\x0b2\x15.network.BlockRequestH\0R\x0cblockReque\
    st\x12?\n\x0eblock_response\x18\x0f\x20\x01(\x0b2\x16.network.BlockRespo\
    nseH\0R\rblockResponse\x12>\n\x0btransaction\x18\x10\x20\x01(\x0b2\x1a.n\
    etwork.SignedTransactionH\0R\x0btransaction\x120\n\x06routed\x18\x11\x20\
    \x01(\x0b2\x16.network.RoutedMessageH\0R\x06routed\x125\n\ndisconnect\
    \x18\x12\x20\x01(\x0b2\x13.network.DisconnectH\0R\ndisconnect\x122\n\tch\
    allenge\x18\x13\x20\x01(\x0b2\x12.network.ChallengeH\0R\tchallengeB\x0e\
    \n\x0cmessage_typeJ\x04\x08\x01\x10\x02J\x04\x08\x02\x10\x03J\x04\x08\
    \x03\x10\x04J\x04\x08\x14\x10\x15J\x04\x08\x15\x10\x16J\x04\x08\x16\x10\
    \x17J\x04\x08\x17\x10\x18J\x04\x08\x18\x10\x19b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(37);
            messages.push(OwnedAccount::generated_message_descriptor_data());
            messages.push(AccountKeyPayload::generated_message_descriptor_data());
            messages.push(Signature::generated_message_descriptor_data());
            messages.push(AccountKeySignedPayload::generated_message_descriptor_data());
            messages.push(PublicKey::generated_message_descriptor_data());
            messages.push(PeerInfo::generated_message_descriptor_data());
            messages.push(CryptoHash::generated_message_descriptor_data());
            messages.push(Edge::generated_message_descriptor_data());
            messages.push(PartialEdgeInfo::generated_message_descriptor_data());
            messages.push(AnnounceAccount::generated_message_descriptor_data());
            messages.push(Block::generated_message_descriptor_data());
            messages.push(BlockHeader::generated_message_descriptor_data());
            messages.push(GenesisId::generated_message_descriptor_data());
            messages.push(PeerChainInfo::generated_message_descriptor_data());
            messages.push(Handshake::generated_message_descriptor_data());
            messages.push(HandshakeFailure::generated_message_descriptor_data());
            messages.push(LastEdge::generated_message_descriptor_data());
            messages.push(SocketAddr::generated_message_descriptor_data());
            messages.push(PeerAddr::generated_message_descriptor_data());
            messages.push(AccountData::generated_message_descriptor_data());
            messages.push(RoutingTableUpdate::generated_message_descriptor_data());
            messages.push(UpdateNonceRequest::generated_message_descriptor_data());
            messages.push(UpdateNonceResponse::generated_message_descriptor_data());
            messages.push(SyncAccountsData::generated_message_descriptor_data());
            messages.push(PeersRequest::generated_message_descriptor_data());
            messages.push(PeersResponse::generated_message_descriptor_data());
            messages.push(BlockHeadersRequest::generated_message_descriptor_data());
            messages.push(BlockHeadersResponse::generated_message_descriptor_data());
            messages.push(BlockRequest::generated_message_descriptor_data());
            messages.push(BlockResponse::generated_message_descriptor_data());
            messages.push(SignedTransaction::generated_message_descriptor_data());
            messages.push(RoutedMessage::generated_message_descriptor_data());
            messages.push(Disconnect::generated_message_descriptor_data());
            messages.push(Challenge::generated_message_descriptor_data());
            messages.push(RoutingSyncV2::generated_message_descriptor_data());
            messages.push(TraceContext::generated_message_descriptor_data());
            messages.push(PeerMessage::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(handshake_failure::Reason::generated_enum_descriptor_data());
            enums.push(trace_context::SamplingPriority::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
