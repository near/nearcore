
#[cfg(feature = "codegen")]
mod template {
    use tinytemplate::TinyTemplate;

    #[derive(Debug, Copy, Clone)]
    #[allow(dead_code, non_camel_case_types)]
    pub enum Template {
        CARGO_MANIFEST,
        CLIENT_MOD,
        CLAP_YAML,
        CLI_MAIN,
        UTIL_MOD,
        CLI_UTIL,
    }
    pub const CARGO_MANIFEST: &str = "[package]\nname = { name | unescaped }\nversion = { version | unescaped }\nauthors = { authors | unescaped }\nedition = \"2018\"\n{{ if is_cli }}\n[[bin]]\nname = { name | unescaped }\npath = \"main.rs\"\n{{ else }}\n[lib]\npath = \"lib.rs\"\n{{ endif }}\n[dependencies]\nasync-trait = \"0.1\"\nbytes = \"0.5\"\nthiserror = \"1.0\"\nfutures = \"0.3\"\nhttp = \"0.2\"\nlazy_static = \"1.4\"\nlog = \"0.4\"\nmime = \\{ git = \"https://github.com/hyperium/mime\" }\nmime_guess = \"2.0\"\nserde = \\{ version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nserde_yaml = \"0.8\"\ntokio-util = \\{ version = \"0.4\", features = [\"codec\"] }\nurl = \"2.1\"\n{{ if is_cli }}\nanyhow = \"1.0\"\nclap = \\{ version = \"2.33\", features = [\"yaml\"] }\nenv_logger = \"0.7\"\nhumantime = \"2.0\"\nopenssl = \\{ version = \"0.10\", features = [\"vendored\"] }\ntokio = \\{ version = \"0.3\", features = [\"fs\", \"io-util\", \"io-std\", \"macros\", \"rt-multi-thread\"] }\nreqwest = \\{ version = \"0.10\", features = [\"stream\", \"json\", \"native-tls\"] }\n{{ else }}\ntokio = \\{ version = \"0.3\", features = [\"fs\", \"io-util\"] }\nreqwest = \\{ version = \"0.10\", features = [\"stream\", \"json\"] }\n{{ endif }}\n{{ if not no_root -}}\n[workspace]\n{{- endif }}\n";

    pub const CLIENT_MOD: &str = "\npub mod client \\{\n    use futures::Stream;\n\n\n    use std::borrow::Cow;\n    use std::fmt::Debug;\n    use std::path::Path;\n\n    /// Common API errors.\n    #[derive(Debug, thiserror::Error)]\n    pub enum ApiError<R: Debug + Send + 'static> \\{\n        #[error(\"API request failed for path: \\{} (code: \\{})\", _0, _1)]\n        Failure(String, http::status::StatusCode, R),\n        #[error(\"Unsupported media type in response: \\{}\", _0)]\n        UnsupportedMediaType(String, R),\n        #[error(\"An error has occurred while performing the API request: \\{}\", _0)]\n        Reqwest(reqwest::Error),\n        #[error(\"I/O error: \\{}\", _0)]\n        Io(std::io::Error),\n        {{- for coder in media_coders }}\n        #[error(\"Error en/decoding \\\"{coder.range | unescaped}\\\" data: \\{}\", _0)]\n        {coder.error_variant | unescaped}({coder.error_ty_path | unescaped}),\n        {{- endfor }}\n    }\n\n    /// Form object for building multipart request body.\n    pub trait Form: Sized \\{\n        /// Creates a new builder.\n        fn new() -> Self;\n\n        /// Adds the given key and value as text.\n        fn text<T, U>(self, key: T, value: U) -> Self\n            where T: Into<Cow<'static, str>>,\n                  U: Into<Cow<'static, str>>;\n\n        /// Adds the file from the given path for streaming.\n        fn file<K>(self, key: K, path: &Path) -> std::io::Result<Self>\n            where K: Into<Cow<'static, str>>;\n    }\n\n    /// HTTP Request.\n    pub trait Request \\{\n        type Form: Form;\n\n        /// Sets the header with the given key and value.\n        fn header(self, name: &'static str, value: &str) -> Self;\n\n        /// Sets body using the given vector of bytes.\n        ///\n        /// **NOTE:** Appropriate `Content-Type` header must be set\n        /// after calling this method.\n        fn body_bytes(self, body: Vec<u8>) -> Self;\n\n        /// Sets JSON body based on the given value.\n        fn json<T: serde::Serialize>(self, value: &T) -> Self;\n\n        /// Sets `multipart/form-data` body using the given form.\n        fn multipart_form_data(self, form: Self::Form) -> Self;\n\n        /// Sets/adds query parameters based on the given value.\n        ///\n        /// **NOTE:** This method must be called only once. It's unspecified\n        /// as to whether this appends/replaces query parameters.\n        fn query<T: serde::Serialize>(self, params: &T) -> Self;\n    }\n\n    impl Form for reqwest::multipart::Form \\{\n        fn new() -> Self \\{\n            reqwest::multipart::Form::new()\n        }\n\n        fn text<T, U>(self, key: T, value: U) -> Self\n            where T: Into<Cow<'static, str>>,\n                  U: Into<Cow<'static, str>>\n        \\{\n            reqwest::multipart::Form::text(self, key, value)\n        }\n\n        fn file<K>(self, key: K, path: &Path) -> std::io::Result<Self>\n            where K: Into<Cow<'static, str>>\n        \\{\n            use reqwest::multipart::\\{Form, Part};\n            use tokio_util::codec::\\{BytesCodec, FramedRead};\n\n            let fd = std::fs::File::open(path)?;\n            let reader = tokio::fs::File::from_std(fd);\n            let bytes_stream = FramedRead::new(reader, BytesCodec::new());\n            let part = Part::stream(reqwest::Body::wrap_stream(bytes_stream));\n            Ok(Form::part(self, key, part))\n        }\n    }\n\n    impl Request for reqwest::RequestBuilder \\{\n        type Form = reqwest::multipart::Form;\n\n        fn header(self, name: &'static str, value: &str) -> Self \\{\n            reqwest::RequestBuilder::header(self, name, value)\n        }\n\n        fn multipart_form_data(self, form: Self::Form) -> Self \\{\n            self.multipart(form)\n        }\n\n        fn body_bytes(self, body: Vec<u8>) -> Self \\{\n            self.body(body)\n        }\n\n        fn json<T: serde::Serialize>(self, value: &T) -> Self \\{\n            <reqwest::RequestBuilder>::json(self, value)\n        }\n\n        fn query<T: serde::Serialize>(self, params: &T) -> Self \\{\n            reqwest::RequestBuilder::query(self, params)\n        }\n    }\n\n    /// HTTP Response.\n    #[async_trait::async_trait]\n    pub trait Response: Debug + Send + Sized \\{\n        type Bytes: AsRef<[u8]>;\n        type Error;\n\n        /// Gets the value for the given header name, if any.\n        fn header(&self, name: &'static str) -> Option<&str>;\n\n        /// Takes all headers from the response.\n        fn take_headers(&mut self) -> http::header::HeaderMap;\n\n        /// Status code for this response.\n        fn status(&self) -> http::status::StatusCode;\n\n        /// Media type for this response body (if any).\n        fn media_type(&self) -> Option<mime::MediaType>;\n\n        /// Response body as a stream.\n        fn stream(self) -> Box<dyn Stream<Item=Result<Self::Bytes, Self::Error>> + Unpin>;\n\n        /// Vector of bytes from the response body.\n        async fn body_bytes(self) -> Result<Self::Bytes, ApiError<Self>>;\n    }\n\n    #[async_trait::async_trait]\n    impl Response for reqwest::Response \\{\n        type Bytes = bytes::Bytes;\n        type Error = reqwest::Error;\n\n        fn header(&self, name: &'static str) -> Option<&str> \\{\n            self.headers().get(name).and_then(|v| v.to_str().ok())\n        }\n\n        fn take_headers(&mut self) -> http::header::HeaderMap \\{\n            std::mem::replace(self.headers_mut(), http::header::HeaderMap::new())\n        }\n\n        fn status(&self) -> http::status::StatusCode \\{\n            reqwest::Response::status(self)\n        }\n\n        fn media_type(&self) -> Option<mime::MediaType> \\{\n            self.header(http::header::CONTENT_TYPE.as_str())\n                .and_then(|v| v.parse().ok())\n        }\n\n        fn stream(self) -> Box<dyn Stream<Item=Result<Self::Bytes, Self::Error>> + Unpin> \\{\n            Box::new(self.bytes_stream()) as Box<_>\n        }\n\n        async fn body_bytes(self) -> Result<Self::Bytes, ApiError<Self>> \\{\n            Ok(self.bytes().await.map_err(ApiError::Reqwest)?)\n        }\n    }\n\n    /// Represents an API client.\n    #[async_trait::async_trait]\n    pub trait ApiClient \\{\n        type Request: Request + Send;\n        type Response: Response;\n\n        /// Consumes a method and a relative path and produces a request builder for a single API call.\n        fn request_builder(&self, method: http::Method, rel_path: &str) -> Self::Request;\n\n        /// Performs the HTTP request using the given `Request` object\n        /// and returns a `Response` future.\n        async fn make_request(&self, req: Self::Request) -> Result<Self::Response, ApiError<Self::Response>>;\n    }\n\n    #[async_trait::async_trait]\n    impl ApiClient for reqwest::Client \\{\n        type Request = reqwest::RequestBuilder;\n        type Response = reqwest::Response;\n\n        fn request_builder(&self, method: http::Method, rel_path: &str) -> Self::Request \\{\n            let mut u = String::from(\"{base_url | unescaped}\");\n            u.push_str(rel_path.trim_start_matches('/'));\n            self.request(method, &u)\n        }\n\n        async fn make_request(&self, req: Self::Request) -> Result<Self::Response, ApiError<Self::Response>> \\{\n            let req = req.build().map_err(ApiError::Reqwest)?;\n            let resp = self.execute(req).await.map_err(ApiError::Reqwest)?;\n            Ok(resp)\n        }\n    }\n\n    /// A trait for indicating that the implementor can send an API call.\n    #[async_trait::async_trait]\n    pub trait Sendable<Client>\n    where\n        Client: ApiClient + Sync + 'static,\n        Self: Sized\n    \\{\n        /// The output object from this API request.\n        type Output: serde::de::DeserializeOwned;\n\n        /// HTTP method used by this call.\n        const METHOD: http::Method;\n\n        /// Relative URL for this API call formatted appropriately with parameter values.\n        ///\n        /// **NOTE:** This URL **must** begin with `/`.\n        fn rel_path(&self) -> std::borrow::Cow<'static, str>;\n\n        /// Modifier for this object. Builders override this method if they\n        /// wish to add query parameters, set body, etc.\n        fn modify(&self, req: Client::Request) -> Result<Client::Request, ApiError<Client::Response>> \\{\n            Ok(req)\n        }\n\n        /// Sends the request and returns a future for the response object.\n        async fn send(&self, client: &Client) -> Result<ResponseWrapper<Self::Output, Self>, ApiError<Client::Response>> \\{\n            let resp = self.send_raw(client).await?;\n            let media = resp.media_type();\n            if let Some(ty) = media \\{\n                if media_types::M_0.matches(&ty) \\{\n                    return ResponseWrapper::wrap(resp, |r| async \\{\n                        let bytes = r.body_bytes().await?;\n                        serde_json::from_reader(bytes.as_ref()).map_err(ApiError::from)\n                    }).await\n                }\n                else if media_types::M_1.matches(&ty) \\{\n                    return ResponseWrapper::wrap(resp, |r| async \\{\n                        let bytes = r.body_bytes().await?;\n                        serde_yaml::from_reader(bytes.as_ref()).map_err(ApiError::from)\n                    }).await\n                }\n            }\n\n            let ty = resp.header(http::header::CONTENT_TYPE.as_str())\n                .map(|v| String::from_utf8_lossy(v.as_bytes()).into_owned())\n                .unwrap_or_default();\n            Err(ApiError::UnsupportedMediaType(ty, resp))\n        }\n\n        /// Convenience method for returning a raw response after sending a request.\n        async fn send_raw(&self, client: &Client) -> Result<Client::Response, ApiError<Client::Response>> \\{\n            let rel_path = self.rel_path();\n            let req = self.modify(client.request_builder(Self::METHOD, &rel_path))?;\n            let resp = client.make_request(req).await?;\n            if resp.status().is_success() \\{\n                Ok(resp)\n            } else \\{\n                Err(ApiError::Failure(rel_path.into_owned(), resp.status(), resp))\n            }\n        }\n    }\n\n    /// Wrapper containing response-related information.\n    pub struct ResponseWrapper<T, B> \\{\n        /// Response object\n        pub object: T,\n        /// Response headers\n        pub headers: http::HeaderMap,\n        /// Response status code\n        pub status: http::status::StatusCode,\n        _builder: core::marker::PhantomData<B>,\n    }\n\n    impl<T, B> ResponseWrapper<T, B> \\{\n        pub(crate) async fn wrap<F, R>(mut resp: R, f: impl FnOnce(R) -> F) -> Result<Self, ApiError<R>>\n            where F: std::future::Future<Output=Result<T, ApiError<R>>>,\n                  R: Response + 'static\n        \\{\n            let status = resp.status();\n            let headers = resp.take_headers();\n            Ok(ResponseWrapper \\{\n                object: f(resp).await?,\n                headers,\n                status,\n                _builder: core::marker::PhantomData,\n            })\n        }\n    }\n\n    impl<'de, T, B> serde::de::Deserialize<'de> for ResponseWrapper<T, B> \\{\n        fn deserialize<D>(_: D) -> Result<Self, D::Error>\n        where\n            D: serde::de::Deserializer<'de>\n        \\{\n            unimplemented!(\"ResponseWrapper is not supposed to be deserialized.\");\n        }\n    }\n\n    impl<T, B> std::ops::Deref for ResponseWrapper<T, B> \\{\n        type Target = T;\n\n        fn deref(&self) -> &Self::Target \\{\n            &self.object\n        }\n    }\n\n    impl<T, B> std::ops::DerefMut for ResponseWrapper<T, B> \\{\n        fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target \\{\n            &mut self.object\n        }\n    }\n\n    pub mod media_types \\{\n        use lazy_static::lazy_static;\n\n        lazy_static! \\{\n            {{- for coder in media_coders }}\n            pub static ref M_{ @index }: mime::MediaRange =\n                mime::MediaRange::parse(\"{coder.range | unescaped}\").expect(\"cannot parse \\\"{coder.range | unescaped}\\\" as media range\");\n            {{- endfor }}\n        }\n    }\n\n    impl<R: Response + 'static> From<std::io::Error> for ApiError<R> \\{\n        fn from(e: std::io::Error) -> Self \\{\n            ApiError::Io(e)\n        }\n    }\n    {{- for coder in media_coders }}\n\n    impl<R: Response + 'static> From<{coder.error_ty_path | unescaped}> for ApiError<R> \\{\n        fn from(e: {coder.error_ty_path | unescaped}) -> Self \\{\n            ApiError::{coder.error_variant | unescaped}(e)\n        }\n    }\n    {{- endfor }}\n}\n";

    pub const CLAP_YAML: &str = "\nname: { name | unescaped }\nversion: { version | unescaped }\n\nsettings:\n- SubcommandRequiredElseHelp\n\nargs:\n    - ca-cert:\n        long: ca-cert\n        help: Path to CA certificate to be added to trust store.\n        takes_value: true\n    - client-cert:\n        long: client-cert\n        help: Path to certificate for TLS client verification.\n        takes_value: true\n        requires:\n            - client-key\n    - client-key:\n        long: client-key\n        help: Path to private key for TLS client verification.\n        takes_value: true\n        requires:\n            - client-cert\n    - url:\n        long: url\n        help: Base URL for your API.\n        takes_value: true\n        required: true\n    - verbose:\n        short: v\n        long: verbose\n        help: Enable verbose mode.\n    - timeout:\n        short: t\n        long: timeout\n        help: Set the request timeout.\n        takes_value: true\n\nsubcommands:\n";

    pub const CLI_MAIN: &str = "\nuse self::client::\\{ApiClient, ApiError, Response};\nuse self::util::ResponseStream;\nuse anyhow::Error;\nuse clap::\\{App, ArgMatches};\nuse openssl::pkcs12::Pkcs12;\nuse openssl::pkey::PKey;\nuse openssl::x509::X509;\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\n#[derive(Debug, thiserror::Error)]\n#[allow(dead_code)]\nenum ClientError \\{\n    #[error(\"Duration parse error: \\{}\", _0)]\n    Duration(humantime::DurationError),\n    #[error(\"I/O error: \\{}\", _0)]\n    Io(std::io::Error),\n    #[error(\"OpenSSL error: \\{}\", _0)]\n    OpenSsl(openssl::error::ErrorStack),\n    #[error(\"Client error: \\{}\", _0)]\n    Reqwest(reqwest::Error),\n    #[error(\"URL error: \\{}\", _0)]\n    Url(url::ParseError),\n    #[error(\"\\{}\", _0)]\n    Api(self::client::ApiError<reqwest::Response>),\n    #[error(\"\")]\n    Empty,\n}\n\nimpl From<ApiError<reqwest::Response>> for ClientError \\{\n    fn from(e: ApiError<reqwest::Response>) -> Self \\{\n        ClientError::Api(e)\n    }\n}\n\nfn read_file<P: AsRef<Path>>(path: P) -> Result<Vec<u8>, Error> \\{\n    let mut data = vec![];\n    let mut fd = File::open(path.as_ref()).map_err(ClientError::Io)?;\n    fd.read_to_end(&mut data).map_err(ClientError::Io)?;\n    Ok(data)\n}\n\n#[derive(Clone)]\nstruct WrappedClient \\{\n    verbose: bool,\n    inner: reqwest::Client,\n    url: reqwest::Url,\n}\n\n#[async_trait::async_trait]\nimpl ApiClient for WrappedClient \\{\n    type Request = reqwest::RequestBuilder;\n    type Response = reqwest::Response;\n\n    async fn make_request(&self, req: Self::Request) -> Result<Self::Response, ApiError<Self::Response>> \\{\n        let req = req.build().map_err(ApiError::Reqwest)?;\n        if self.verbose \\{\n            println!(\"\\{} \\{}\", req.method(), req.url());\n        }\n\n        Ok(self.inner.execute(req).await.map_err(ApiError::Reqwest)?)\n    }\n\n    fn request_builder(&self, method: http::Method, rel_path: &str) -> Self::Request \\{\n        let mut u = self.url.clone();\n        let mut path = u.path().trim_matches('/').to_owned();\n        if !path.is_empty() \\{\n            path = String::from(\"/\") + &path;\n        }\n\n        path.push_str(rel_path);\n        u.set_path(&path);\n        self.inner.request(method, u)\n    }\n}\n\nfn make_client<'a>(matches: &'a ArgMatches<'a>) -> Result<WrappedClient, Error> \\{\n    let mut client = reqwest::Client::builder();\n\n    if let Some(p) = matches.value_of(\"ca-cert\") \\{\n        let ca_cert = X509::from_pem(&read_file(p)?)\n            .map_err(ClientError::OpenSsl)?;\n        let ca_der = ca_cert.to_der().map_err(ClientError::OpenSsl)?;\n        client = client.add_root_certificate(\n            reqwest::Certificate::from_der(&ca_der)\n                .map_err(ClientError::Reqwest)?\n        );\n    }\n\n    // FIXME: Is this the only way?\n    if let (Some(p1), Some(p2)) = (matches.value_of(\"client-key\"), matches.value_of(\"client-cert\")) \\{\n        let cert = X509::from_pem(&read_file(p2)?).map_err(ClientError::OpenSsl)?;\n        let key = PKey::private_key_from_pem(&read_file(p1)?)\n            .map_err(ClientError::OpenSsl)?;\n        let builder = Pkcs12::builder();\n        let pkcs12 = builder.build(\"foobar\", \"my-client\", &key, &cert)\n            .map_err(ClientError::OpenSsl)?;\n        let identity = reqwest::Identity::from_pkcs12_der(\n            &pkcs12.to_der().map_err(ClientError::OpenSsl)?,\n            \"foobar\"\n        ).map_err(ClientError::Reqwest)?;\n        client = client.identity(identity);\n    }\n\n    if let Some(timeout) = matches.value_of(\"timeout\") \\{\n        let d = timeout.parse::<humantime::Duration>()?;\n        client = client.timeout(d.into());\n    }\n\n    let is_verbose = matches.is_present(\"verbose\");\n    let url = matches.value_of(\"url\").expect(\"required arg URL?\");\n    Ok(WrappedClient \\{\n        inner: client.build().map_err(ClientError::Reqwest)?,\n        url: reqwest::Url::parse(url).map_err(ClientError::Url)?,\n        verbose: is_verbose,\n    })\n}\n\nasync fn run_app() -> Result<(), Error> \\{\n    let yml = load_yaml!(\"app.yaml\");\n    let app = App::from_yaml(yml);\n    let matches = app.get_matches();\n    let (sub_cmd, sub_matches) = matches.subcommand();\n\n    let client = make_client(&matches)?;\n    let response = self::cli::fetch_response(&client, &matches, sub_cmd, sub_matches).await?;\n\n    let status = response.status();\n    if client.verbose \\{\n        println!(\"\\{}\", status);\n    }\n\n    let mut stdout = tokio::io::stdout();\n    ResponseStream(response.stream()).to_writer(&mut stdout).await?;\n    if !status.is_success() \\{\n        Err(ClientError::Empty)?\n    }\n\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() \\{\n    env_logger::init();\n    if let Err(e) = run_app().await \\{\n        println!(\"\\{}\", e);\n    }\n}\n";

    pub const UTIL_MOD: &str = "\nuse futures::stream::\\{Stream, StreamExt};\nuse serde::\\{Deserialize, Deserializer};\nuse tokio::io::\\{AsyncWrite, AsyncWriteExt};\n\nuse std::error::Error;\nuse std::fmt::\\{self, Display, Write};\nuse std::io;\nuse std::marker::\\{PhantomData, Unpin};\nuse std::ops::\\{Deref, DerefMut};\nuse std::str::FromStr;\n\n/// HTTP body response stream.\npub struct ResponseStream<T, E>(pub Box<dyn Stream<Item=Result<T, E>> + Unpin>);\n\n/// **NOTE:** This is just a stub. It panics on deserialization.\nimpl<'de, T, E> Deserialize<'de> for ResponseStream<T, E> \\{\n    fn deserialize<D>(_: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>\n    \\{\n        unimplemented!(\"Response stream is not supposed to be deserialized\");\n    }\n}\n\nimpl<T, E> ResponseStream<T, E>\n    where T: AsRef<[u8]>,\n          E: Into<Box<dyn Error + Send + Sync + 'static>>\n\\{\n    /// Copy this stream to anything that implements `AsyncWrite`.\n    pub async fn to_writer<W>(mut self, writer: &mut W) -> io::Result<()>\n        where W: AsyncWrite + Unpin + ?Sized\n    \\{\n        while let Some(r) = self.0.next().await \\{\n            let chunk = r.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n            writer.write_all(chunk.as_ref()).await?;\n        }\n\n        Ok(())\n    }\n}\n\n/// Marker trait for delimiting. We represent each type of delimiting\n/// with an unit struct and implement this\npub trait Delimiting \\{\n    const DELIMITER: char;\n}\n\n/// Marker trait for whether the delimiting unit struct can be used by\n/// iterators. This is not implemented by `multi` - Multiple instances are\n/// allowed only in form data and query, and we need something for parsing\n/// stuff from CLI. At the same time, we also cannot allow serializing this\n/// container in the same way as others.\npub trait Allowed \\{}\n\nmacro_rules! impl_delim \\{\n    ($ty:ident => $delim:expr) => \\{\n        #[derive(Debug, Clone)]\n        pub struct $ty;\n\n        impl Delimiting for $ty \\{\n            const DELIMITER: char = $delim;\n        }\n    };\n}\n\nimpl_delim!(Csv => ',');\nimpl Allowed for Csv \\{}\n\nimpl_delim!(Ssv => ' ');\nimpl Allowed for Ssv \\{}\n\nimpl_delim!(Tsv => '\\t');\nimpl Allowed for Tsv \\{}\n\nimpl_delim!(Pipes => '|');\nimpl Allowed for Pipes \\{}\n\n// NOTE: We use ampersand only for convenience.\nimpl_delim!(Multi => '&');\n\n/// Wrapper over a vector which also holds a marker type for delimiting.\n#[derive(Debug, Clone)]\npub struct Delimited<T, D>(Vec<T>, PhantomData<D>);\n\nimpl<T, D> From<Vec<T>> for Delimited<T, D> \\{\n    fn from(v: Vec<T>) -> Self \\{\n        Delimited(v, PhantomData)\n    }\n}\n\nimpl<T, D> Deref for Delimited<T, D> \\{\n    type Target = Vec<T>;\n\n    fn deref(&self) -> &Self::Target \\{\n        &self.0\n    }\n}\n\nimpl<T, D> DerefMut for Delimited<T, D> \\{\n    fn deref_mut(&mut self) -> &mut <Self as Deref>::Target \\{\n        &mut self.0\n    }\n}\n\nimpl<T: FromStr, D: Delimiting> FromStr for Delimited<T, D> \\{\n    type Err = <T as FromStr>::Err;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> \\{\n        let vec: Result<Vec<_>, _> = s.split(D::DELIMITER).map(|s| s.parse::<T>()).collect();\n        Ok(Delimited(vec?, PhantomData))\n    }\n}\n\nimpl<T: Display, D: Delimiting + Allowed> Display for Delimited<T, D> \\{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result \\{\n        for (i, v) in self.0.iter().enumerate() \\{\n            if i > 0 \\{\n                f.write_char(D::DELIMITER)?;\n            }\n\n            v.fmt(f)?;\n        }\n\n        Ok(())\n    }\n}\n";

    pub const CLI_UTIL: &str = "use clap::ArgMatches;\nuse crate::client::\\{ApiClient, ApiError, Sendable};\nuse serde::\\{Serialize, Deserialize};\n\nuse std::io::Read;\n\npub(crate) fn read_from_input<T>(matches: Option<&ArgMatches<'_>>) -> Result<T, crate::ClientError>\nwhere\n    T: Serialize,\n    for<'de> T: Deserialize<'de>\n\\{\n    let path = matches\n        .expect(\"no args for builder with body?\")\n        .value_of(\"payload\").expect(\"payload?\");\n\n    let mut bytes = vec![];\n    if path == \"-\" \\{\n        std::io::stdin().read_to_end(&mut bytes).map_err(crate::ClientError::Io)?;\n    } else \\{\n        std::fs::File::open(&path)\n            .and_then(|mut fd| fd.read_to_end(&mut bytes))\n            .map_err(crate::ClientError::Io)?;\n    };\n\n    {{- for coder in media_coders }}\n\n    let err = match {coder.decoder | unescaped}(bytes.as_slice()) \\{\n        Ok(t) => return Ok(t),\n        Err(e) => crate::ClientError::Api(ApiError::{coder.error_variant | unescaped}(e)),\n    };\n\n    log::debug!(\"Error decoding payload as {coder.range | unescaped}: \\{:?}\", err);\n    {{- endfor }}\n\n    Err(err)\n}\n\npub(super) async fn fetch_response<'a, C>(client: &'a C,\n                                          _matches: &ArgMatches<'_>,\n                                          sub_cmd: &str,\n                                          sub_matches: Option<&ArgMatches<'_>>)\n                                          -> Result<C::Response, crate::ClientError>\nwhere\n    C: ApiClient + Send + Sync + 'static,\n    crate::ClientError: From<ApiError<C::Response>>\n\\{\n    let resp = match sub_cmd \\{\n{match_arms | unescaped}\n        _ => unimplemented!(),\n    };\n\n    match resp \\{\n        Ok(r) => Ok(r),\n        Err(ApiError::Failure(_, _, r)) => Ok(r.into_inner()),\n        Err(e) => return Err(e.into()),\n    }\n}\n";

    pub fn render<C>(t: Template, context: &C) -> tinytemplate::error::Result<String>
        where C: serde::Serialize
    {
        let mut temp = TinyTemplate::new();
        temp.add_template("file", match t {
            Template::CARGO_MANIFEST => CARGO_MANIFEST,
            Template::CLIENT_MOD => CLIENT_MOD,
            Template::CLAP_YAML => CLAP_YAML,
            Template::CLI_MAIN => CLI_MAIN,
            Template::UTIL_MOD => UTIL_MOD,
            Template::CLI_UTIL => CLI_UTIL,
        })?;

        temp.render("file", context)
    }
}
