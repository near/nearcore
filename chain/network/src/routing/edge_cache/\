use crate::network_protocol::Edge;
use near_async::time;
use near_primitives::network::PeerId;
use std::collections::hash_map::Entry;
use std::collections::HashMap;

type EdgeKey = (PeerId, PeerId);

struct ActiveEdge {
    edge: Edge,
    refcount: u32,
}

/// Cache of all known edges in the network. It serves three purposes.
/// 1) It is used to avoid repeating verification of signatures on edges.
/// 2) It stores the known Edges which are presently used for routing in the network.
/// 3) It maintains a mapping from known PeerIds in the network to u32 ids 0,1,2,...
pub struct EdgeCache {
    /// Mapping from EdgeKey to the most recent verified nonce
    verified_nonces: im::HashMap<EdgeKey, u64>,

    /// Mapping from EdgeKey to Edge object
    active_edges im::HashMap<EdgeKey, ActiveEdge>,

    /// Mapping from PeerId to assigned u32 id
    p2id: HashMap<PeerId, u32>,
    /// Mapping from u32 id to the number of active edges for the node
    degree: Vec<u32>,
    /// List of unused u32 ids
    unused: Vec<u32>,
}

impl EdgeCache {
    pub fn new() -> Self {
        Self { verified_nonces: Default::default(), active_edges: Default::default(), p2id: HashMap::new(), degree: vec![], unused: vec![] }
    }

    /// Returns true iff we already verified a nonce for this key
    /// which is at least as new as the given one
    pub fn has(&self, edge: &Edge) -> bool {
        self.verified_nonces.get(&edge.key()).map_or(false, |cached_nonce| cached_nonce >= edge.nonce())
    }

    /// Returns the u32 id associated with the given PeerId, assigning one if necessary.
    pub fn get_id(&mut self, peer: &PeerId) -> u32 {
        match self.p2id.entry(peer.clone()) {
            Entry::Occupied(occupied) => *occupied.get(),
            Entry::Vacant(vacant) => {
                let val = if let Some(val) = self.unused.pop() {
                    assert!(self.degree[val as usize] == 0);
                    val
                } else {
                    let val = self.degree.len() as u32;
                    self.degree.push(0);
                    val
                };

                vacant.insert(val);
                val
            }
        }
    }

    fn decrement_degree(&mut self, peer_id: &PeerId) {
        let id = self.get_id(peer_id);
        self.degree[id as usize] -= 1;
        if self.degree[id as usize] == 0 {
            self.unused.push(id);
        }
    }

    fn decrement_degrees_for_key(&mut self, key: &EdgeKey) {
        let (peer0, peer1) = key;
        self.decrement_degree(peer0);
        self.decrement_degree(peer1);
    }

    fn increment_degrees_for_key(&mut self, key: &EdgeKey) {
        let (peer0, peer1) = key;
        let id0 = self.get_id(peer0) as usize;
        let id1 = self.get_id(peer1) as usize;
        self.degree[id0] += 1;
        self.degree[id1] += 1;
    }

    pub fn remove_edge(&mut self, key: &EdgeKey) {
        if self.edges.remove(key).is_some() {
            self.decrement_degrees_for_key(key);
        }
    }

    pub fn prune_old_edges(&mut self, prune_edges_older_than: time::Utc) {
        let mut pruned_keys = vec![];
        self.edges.retain(|key, e| {
            if e.is_edge_older_than(prune_edges_older_than) {
                pruned_keys.push(key.clone());
                return false;
            }
            return true;
        });

        for key in pruned_keys {
            self.decrement_degrees_for_key(&key);
        }
    }

    pub fn node_ct(&mut self) -> usize {
        self.degrees.len() - self.unused.len()
    }

    pub fn len(&mut self) -> usize {
        self.edges.len()
    }
}
