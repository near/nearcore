/// This is an autogenerated file. DO NOT EDIT.
/// proto file sha256 = 6cCHV67TDVmFyUkUlLyv4MG2Kxf2wpBbiUrE6DahzWI=
/// this file sha256 = nbysx4WEJ5feDPNLFKfMZcOniKrxVNRa0jQluDzXIxA=
/// Wrapper of borsh-encoded PublicKey.
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/core/crypto/src/signature.rs#L201>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKey {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// Wrapper of borsh-encoded PeerInfo.
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/chain/network-primitives/src/network_protocol/mod.rs#L30>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerInfo {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// sha256 hash of the borsh-encoded NEAR Block.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CryptoHash {
    /// sha256 hash (32 bytes)
    #[prost(bytes="vec", tag="1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
}
/// Wrapper of borsh-encoded Edge.
/// <https://cs.github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/chain/network-primitives/src/network_protocol/edge.rs#L32>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Edge {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// Wrapper of the borsh-encoded PartialEdgeInfo.
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/chain/network-primitives/src/network_protocol/edge.rs#L11>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartialEdgeInfo {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// Wrapper of the borsh-encoded AnnounceAccount.
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/core/primitives/src/network.rs#L86>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnounceAccount {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// Wrapper of the borsh-encoded NEAR chain block.
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/core/primitives/src/block.rs#L77>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// Wrapper of the borsh-encoded BlockHeader.
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/core/primitives/src/block_header.rs#L325>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// Unique identifier of the NEAR chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisId {
    /// Name of the chain (for example "mainnet").
    #[prost(string, tag="1")]
    pub chain_id: ::prost::alloc::string::String,
    /// Hash of the genesis block(?) of the NEAR chain.
    #[prost(message, optional, tag="2")]
    pub hash: ::core::option::Option<CryptoHash>,
}
/// Basic information about the chain view maintained by a peer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerChainInfo {
    #[prost(message, optional, tag="1")]
    pub genesis_id: ::core::option::Option<GenesisId>,
    /// Height of the highest NEAR chain block known to a peer.
    #[prost(uint64, tag="2")]
    pub height: u64,
    /// Shards of the NEAR chain tracked by the peer.
    #[prost(uint64, repeated, tag="3")]
    pub tracked_shards: ::prost::alloc::vec::Vec<u64>,
    /// Whether the peer is an archival node.
    #[prost(bool, tag="4")]
    pub archival: bool,
}
//////////////////////////////////////

/// Handshake is the first message exchanged after establishing a TCP connection.
/// If A opened a connection B, then
/// 1. A sends Handshake to B.
/// 2a. If B accepts the handshake, it sends Handshake to A and connection is established.
/// 2b. If B rejects the handshake, it sends HandshakeFailure to A.
///     A may retry the Handshake with a different payload.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Handshake {
    /// The protocol_version that the sender wants to use for communication.
    /// Currently NEAR protocol and NEAR network protocol are versioned together
    /// (it may change in the future), however peers may communicate with the newer version
    /// of the NEAR network protol, than the NEAR protocol version approved by the quorum of
    /// the validators. If B doesn't support protocol_version, it sends back HandshakeFailure
    /// with reason ProtocolVersionMismatch.
    #[prost(uint32, tag="1")]
    pub protocol_version: u32,
    /// Oldest version of the NEAR network protocol that the peer supports.
    #[prost(uint32, tag="2")]
    pub oldest_supported_version: u32,
    /// PeerId of the sender.
    #[prost(message, optional, tag="3")]
    pub sender_peer_id: ::core::option::Option<PublicKey>,
    /// PeerId of the receiver that the sender expects.
    /// In case of mismatch, receiver sends back HandshakeFailure with
    /// reason InvalidTarget.
    #[prost(message, optional, tag="4")]
    pub target_peer_id: ::core::option::Option<PublicKey>,
    /// TCP port on which sender is listening for inbound connections.
    #[prost(uint32, tag="5")]
    pub sender_listen_port: u32,
    /// Basic info about the NEAR chain that the sender belongs to.
    /// Sender expects receiver to belong to the same chain.
    /// In case of mismatch, receiver sends back HandshakeFailure with 
    /// reason GenesisMismatch.
    #[prost(message, optional, tag="6")]
    pub sender_chain_info: ::core::option::Option<PeerChainInfo>,
    /// Edge (sender,receiver) signed by sender, which once signed by
    /// receiver may be broadcasted to the network to prove that the
    /// connection has been established.
    /// In case receiver accepts the Handshake, it sends back back a Handshake
    /// containing his signature in this field.
    #[prost(message, optional, tag="7")]
    pub partial_edge_info: ::core::option::Option<PartialEdgeInfo>,
}
/// Response to Handshake, in case the Handshake was rejected.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HandshakeFailure {
    /// Reason for rejecting the Handshake.
    #[prost(enumeration="handshake_failure::Reason", tag="1")]
    pub reason: i32,
    /// Data about the peer.
    #[prost(message, optional, tag="2")]
    pub peer_info: ::core::option::Option<PeerInfo>,
    /// GenesisId of the NEAR chain that the peer belongs to.
    #[prost(message, optional, tag="3")]
    pub genesis_id: ::core::option::Option<GenesisId>,
    /// Newest NEAR network version supported by the peer.
    #[prost(uint32, tag="4")]
    pub version: u32,
    /// Oldest NEAR network version supported by the peer.
    #[prost(uint32, tag="5")]
    pub oldest_supported_version: u32,
}
/// Nested message and enum types in `HandshakeFailure`.
pub mod handshake_failure {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Reason {
        Unknown = 0,
        /// Peer doesn't support protocol_version indicated in the handshake.
        ProtocolVersionMismatch = 1,
        /// Peer doesn't belong to the chain indicated in the handshake.
        GenesisMismatch = 2,
        /// target_id doesn't match the id of the peer.
        InvalidTarget = 3,
    }
}
/// TODO: document it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LastEdge {
    #[prost(message, optional, tag="1")]
    pub edge: ::core::option::Option<Edge>,
}
/// Message sent whenever the sender learns about new connections
/// between the peers in the network (I think).
/// It provides a view of the whole NEAR network to each peer.
///
/// Edges constitute a graph between PeerIds, signed by both of
/// the peers. This is one of the first messages sent after Handshake.
/// First RoutingTableUpdate contains the whole graph known to peer.
/// Afterwards only the graph delta (changed edges) are included.
///
/// Accounts provides a mapping AccountId -> PeerId, providing knowledge
/// about which NEAR peer controls which NEAR account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutingTableUpdate {
    #[prost(message, repeated, tag="1")]
    pub edges: ::prost::alloc::vec::Vec<Edge>,
    /// list of known NEAR validator accounts 
    #[prost(message, repeated, tag="2")]
    pub accounts: ::prost::alloc::vec::Vec<AnnounceAccount>,
}
/// TODO: document it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNonceRequest {
    #[prost(message, optional, tag="1")]
    pub partial_edge_info: ::core::option::Option<PartialEdgeInfo>,
}
/// TODO: document it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNonceResponse {
    #[prost(message, optional, tag="1")]
    pub edge: ::core::option::Option<Edge>,
}
/// Request to send a list of known healthy peers
/// (i.e. considered honest and available by the receiver).
/// Currently this list might include both
/// - peers directly connected to the receiver
/// - peers that the receiver transitively learned about from other peers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeersRequest {
}
/// Response to PeersRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeersResponse {
    #[prost(message, repeated, tag="1")]
    pub peers: ::prost::alloc::vec::Vec<PeerInfo>,
}
/// Request to send back headers of the NEAR chain blocks.
/// Receiver finds in block_hashes the first hash of a block it knows about
/// and rends back BlockHeadersResponse with block headers following that block.
/// At most 512 block headers are returned:
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/chain/client/src/sync.rs#L38>
/// It might happen that the receiver doesn't know some of the hashes in the list
/// in the following cases:
/// - sender's view of the chain forked from the receiver's view of the chain
/// - sender's view of the chain is ahead of receiver's view of the chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeadersRequest {
    #[prost(message, repeated, tag="1")]
    pub block_hashes: ::prost::alloc::vec::Vec<CryptoHash>,
}
/// A collection of headers of the NEAR chain blocks.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeadersResponse {
    #[prost(message, repeated, tag="1")]
    pub block_headers: ::prost::alloc::vec::Vec<BlockHeader>,
}
/// Request to send back a NEAR chain block with a given hash.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRequest {
    #[prost(message, optional, tag="1")]
    pub block_hash: ::core::option::Option<CryptoHash>,
}
/// NEAR chain Block.
/// It might be send both as a response to BlockRequest,
/// or unsolicitated in case a new Block is being broadcasted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockResponse {
    #[prost(message, optional, tag="1")]
    pub block: ::core::option::Option<Block>,
}
/// Wrapper of borsh-encoded SignedTransaction
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/core/primitives/src/transaction.rs#L218>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedTransaction {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// Wrapper of borsh-encoded RoutedMessage
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/chain/network-primitives/src/network_protocol/mod.rs#L295>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutedMessage {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// Disconnect is send by a node before closing a TCP connection.
/// There is no guarantee that it will be sent in all circumstances.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Disconnect {
}
/// Wrapper of borsh-encoded Challenge
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/core/primitives/src/challenge.rs#L89>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Challenge {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// TODO: document it
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EpochSyncRequest {
    #[prost(message, optional, tag="1")]
    pub epoch_id: ::core::option::Option<CryptoHash>,
}
/// Wrapper of borsh-encoded EpochSyncResponse
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/core/primitives/src/syncing.rs#L225>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EpochSyncResponse {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// TODO: document it 
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EpochSyncFinalizationRequest {
    #[prost(message, optional, tag="1")]
    pub epoch_id: ::core::option::Option<CryptoHash>,
}
/// Wrapper of borsh-encoded EpochSyncFinalizationResponse
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/core/primitives/src/syncing.rs#L202>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EpochSyncFinalizationResponse {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// Wrapper of borsh-encoded RoutingSyncV2
/// <https://github.com/near/nearcore/blob/1a4edefd0116f7d1e222bc96569367a02fe64199/chain/network/src/network_protocol.rs#L225>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutingSyncV2 {
    #[prost(bytes="vec", tag="1")]
    pub borsh: ::prost::alloc::vec::Vec<u8>,
}
/// PeerMessage is a wrapper of all message types exchanged between NEAR nodes.
/// The wire format of a single message M consists of len(M)+4 bytes:
/// <len(M)> : 4 bytes : little endian uint32
/// <M> : N bytes : binary encoded protobuf PeerMessage M
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerMessage {
    #[prost(oneof="peer_message::MessageType", tags="4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24")]
    pub message_type: ::core::option::Option<peer_message::MessageType>,
}
/// Nested message and enum types in `PeerMessage`.
pub mod peer_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MessageType {
        #[prost(message, tag="4")]
        Handshake(super::Handshake),
        #[prost(message, tag="5")]
        HandshakeFailure(super::HandshakeFailure),
        #[prost(message, tag="6")]
        LastEdge(super::LastEdge),
        #[prost(message, tag="7")]
        SyncRoutingTable(super::RoutingTableUpdate),
        #[prost(message, tag="8")]
        UpdateNonceRequest(super::UpdateNonceRequest),
        #[prost(message, tag="9")]
        UpdateNonceResponse(super::UpdateNonceResponse),
        #[prost(message, tag="10")]
        PeersRequest(super::PeersRequest),
        #[prost(message, tag="11")]
        PeersResponse(super::PeersResponse),
        #[prost(message, tag="12")]
        BlockHeadersRequest(super::BlockHeadersRequest),
        #[prost(message, tag="13")]
        BlockHeadersResponse(super::BlockHeadersResponse),
        #[prost(message, tag="14")]
        BlockRequest(super::BlockRequest),
        #[prost(message, tag="15")]
        BlockResponse(super::BlockResponse),
        #[prost(message, tag="16")]
        Transaction(super::SignedTransaction),
        #[prost(message, tag="17")]
        Routed(super::RoutedMessage),
        #[prost(message, tag="18")]
        Disconnect(super::Disconnect),
        #[prost(message, tag="19")]
        Challenge(super::Challenge),
        #[prost(message, tag="20")]
        EpochSyncRequest(super::EpochSyncRequest),
        #[prost(message, tag="21")]
        EpochSyncResponse(super::EpochSyncResponse),
        #[prost(message, tag="22")]
        EpochSyncFinalizationRequest(super::EpochSyncFinalizationRequest),
        #[prost(message, tag="23")]
        EpochSyncFinalizationResponse(super::EpochSyncFinalizationResponse),
        #[prost(message, tag="24")]
        RoutingTableSyncV2(super::RoutingSyncV2),
    }
}
