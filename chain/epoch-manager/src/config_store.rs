use std::{fs, path::Path};

use near_primitives::{epoch_manager::EpochConfig, errors::EpochError, types::ProtocolVersion};

fn parse_config_file(
    chain_id: &str,
    protocol_version: ProtocolVersion,
) -> Result<EpochConfig, EpochError> {
    let content = fs::read_to_string(
        Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("res/epoch_configs")
            .join(chain_id)
            .join(format!("{}.json", protocol_version)),
    )?;
    serde_json::from_str::<EpochConfig>(&content)
        .map_err(|e| EpochError::LoadConfigurationError(e.to_string()))
}

#[cfg(test)]
mod tests {
    use near_primitives::epoch_manager::{AllEpochConfig, EpochConfig};
    use near_primitives::version::PROTOCOL_VERSION;

    use crate::config_store::parse_config_file;

    /// Checks that stored epoch config for latest protocol version matches the
    /// one generated by overrides from genesis config.
    /// If the test fails, it is either a configuration bug or the stored
    /// epoch config must be updated.
    fn run(chain_id: &str) {
        let initial_epoch_config: EpochConfig = parse_config_file(chain_id, 0).unwrap();
        let all_config =
            AllEpochConfig::new_with_test_overrides(true, initial_epoch_config, chain_id, None);
        let config = all_config.for_protocol_version(PROTOCOL_VERSION);

        let expected_config: EpochConfig = parse_config_file(chain_id, PROTOCOL_VERSION).unwrap();
        assert_eq!(config, expected_config);
    }

    #[test]
    fn mainnet() {
        run("mainnet");
    }

    #[test]
    fn testnet() {
        run("testnet");
    }

    #[test]
    fn mocknet() {
        run("mocknet");
    }
}
