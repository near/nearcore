use std::{collections::BTreeMap, ops::Bound, sync::Arc};

use near_primitives::{epoch_manager::EpochConfig, errors::EpochError, types::ProtocolVersion};

macro_rules! include_config {
    ($chain:expr, $version:expr, $file:expr) => {
        (
            $chain,
            $version,
            include_str!(concat!(
                env!("CARGO_MANIFEST_DIR"),
                "/res/epoch_configs/",
                $chain,
                "/",
                $file
            )),
        )
    };
}

static CONFIGS: &[(&str, ProtocolVersion, &str)] = &[
    // Epoch configs for mainnet.
    include_config!("mainnet", 0, "0.json"),
    include_config!("mainnet", 48, "48.json"),
    include_config!("mainnet", 56, "56.json"),
    include_config!("mainnet", 64, "64.json"),
    include_config!("mainnet", 65, "65.json"),
    include_config!("mainnet", 69, "69.json"),
    include_config!("mainnet", 70, "70.json"),
    // Epoch configs for testnet.
    include_config!("testnet", 0, "0.json"),
    include_config!("testnet", 48, "48.json"),
    include_config!("testnet", 56, "56.json"),
    include_config!("testnet", 64, "64.json"),
    include_config!("testnet", 65, "65.json"),
    include_config!("testnet", 69, "69.json"),
    include_config!("testnet", 70, "70.json"),
    // Epoch configs for mocknet (forknet).
    include_config!("mocknet", 0, "0.json"),
    include_config!("mocknet", 48, "48.json"),
    include_config!("mocknet", 64, "64.json"),
    include_config!("mocknet", 65, "65.json"),
    include_config!("mocknet", 69, "69.json"),
    include_config!("mocknet", 70, "70.json"),
];

pub struct EpochConfigStore {
    store: BTreeMap<ProtocolVersion, Arc<EpochConfig>>,
}

impl EpochConfigStore {
    pub fn for_chain_id(chain_id: &str) -> Result<Self, EpochError> {
        let mut store = BTreeMap::new();
        for (chain, version, content) in CONFIGS.iter() {
            if *chain == chain_id {
                let config: EpochConfig = serde_json::from_str(*content)
                    .map_err(|e| EpochError::LoadConfigurationError(e.to_string()))?;
                store.insert(*version, Arc::new(config));
            }
        }
        Ok(Self { store })
    }

    fn get_config(
        &self,
        protocol_version: ProtocolVersion,
    ) -> Result<&Arc<EpochConfig>, EpochError> {
        Ok(self
            .store
            .range((Bound::Unbounded, Bound::Included(protocol_version)))
            .next_back()
            .ok_or_else(|| {
                EpochError::LoadConfigurationError(format!(
                    "Failed to find EpochConfig for protocol version {}",
                    protocol_version
                ))
            })?
            .1)
    }

    // fn validate_genesis_config(&self) {
    //     let EpochConfig = self.get_config(0);
    // }
}

#[cfg(test)]
mod tests {
    use std::fs;
    use std::path::Path;

    use near_primitives::epoch_manager::{AllEpochConfig, EpochConfig};
    use near_primitives::errors::EpochError;
    use near_primitives::types::ProtocolVersion;
    use near_primitives::version::PROTOCOL_VERSION;

    use super::EpochConfigStore;

    /// Checks that stored epoch config for latest protocol version matches the
    /// one generated by overrides from genesis config.
    /// If the test fails, it is either a configuration bug or the stored
    /// epoch config must be updated.
    fn test_epoch_config_store(chain_id: &str) {
        let genesis_epoch_config = parse_config_file(chain_id, 0).unwrap().unwrap();
        let all_epoch_config = AllEpochConfig::new_with_test_overrides(
            true,
            genesis_epoch_config,
            chain_id,
            None,
        );

        let config_store = EpochConfigStore::for_chain_id(chain_id).unwrap();
        for protocol_version in 0..=PROTOCOL_VERSION {
            let stored_config = config_store.get_config(protocol_version).unwrap();
            let expected_config = all_epoch_config.for_protocol_version(protocol_version);
            assert_eq!(*stored_config.as_ref(), expected_config);
        }
    }

    #[test]
    fn test_epoch_config_store_ainnet() {
        test_epoch_config_store("mainnet");
    }

    #[test]
    fn test_epoch_config_store_testnet() {
        test_epoch_config_store("testnet");
    }

    #[test]
    fn test_epoch_config_store_mocknet() {
        test_epoch_config_store("mocknet");
    }

    #[allow(unused)]
    fn generate_epoch_configs(chain_id: &str) {
        let genesis_epoch_config = parse_config_file(chain_id, 0).unwrap().unwrap();
        let all_epoch_config = AllEpochConfig::new_with_test_overrides(
            true,
            genesis_epoch_config.clone(),
            chain_id,
            None,
        );

        let mut prev_config = genesis_epoch_config;
        for protocol_version in 1..=PROTOCOL_VERSION {
            let next_config = all_epoch_config.for_protocol_version(protocol_version);
            if next_config != prev_config {
                tracing::info!("Writing config for protocol version {}", protocol_version);
                dump_config_file(&next_config, chain_id, protocol_version).unwrap();
            }
            prev_config = next_config;
        }
    }

    #[test]
    #[ignore]
    fn generate_epoch_configs_mainnet() {
        generate_epoch_configs("mainnet");
    }

    #[test]
    #[ignore]
    fn generate_epoch_configs_testnet() {
        generate_epoch_configs("testnet");
    }

    #[test]
    #[ignore]
    fn generate_epoch_configs_mocknet() {
        generate_epoch_configs("mocknet");
    }

    #[allow(unused)]
    fn parse_config_file(
        chain_id: &str,
        protocol_version: ProtocolVersion,
    ) -> Result<Option<EpochConfig>, EpochError> {
        let path = Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("res/epoch_configs")
            .join(chain_id)
            .join(format!("{}.json", protocol_version));
        if path.exists() {
            let content = fs::read_to_string(path)?;
            let config: EpochConfig = serde_json::from_str(&content)
                .map_err(|e| EpochError::LoadConfigurationError(e.to_string()))?;
            Ok(Some(config))
        } else {
            Ok(None)
        }
    }

    #[allow(unused)]
    fn dump_config_file(
        config: &EpochConfig,
        chain_id: &str,
        protocol_version: ProtocolVersion,
    ) -> Result<(), EpochError> {
        let content = serde_json::to_string_pretty(config)
            .map_err(|e| EpochError::LoadConfigurationError(e.to_string()))?;
        fs::write(
            Path::new(env!("CARGO_MANIFEST_DIR"))
                .join("res/epoch_configs")
                .join(chain_id)
                .join(format!("{}.json", protocol_version)),
            content,
        )
        .map_err(|e| EpochError::LoadConfigurationError(e.to_string()))
    }
}
