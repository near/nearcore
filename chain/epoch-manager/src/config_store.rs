use std::{fs, path::Path};

use near_primitives::{epoch_manager::EpochConfig, errors::EpochError, types::ProtocolVersion};

fn parse_config_file(
    chain_id: &str,
    protocol_version: ProtocolVersion,
) -> Result<Option<EpochConfig>, EpochError> {
    let path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("res/epoch_configs")
        .join(chain_id)
        .join(format!("{}.json", protocol_version));
    if path.exists() {
        let content = fs::read_to_string(path)?;
        let config: EpochConfig = serde_json::from_str(&content)
            .map_err(|e| EpochError::LoadConfigurationError(e.to_string()))?;
        Ok(Some(config))
    } else {
        Ok(None)
    }
}

fn dump_config_file(
    config: &EpochConfig,
    chain_id: &str,
    protocol_version: ProtocolVersion,
) -> Result<(), EpochError> {
    let content = serde_json::to_string_pretty(config)
        .map_err(|e| EpochError::LoadConfigurationError(e.to_string()))?;
    fs::write(
        Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("res/epoch_configs")
            .join(chain_id)
            .join(format!("{}.json", protocol_version)),
        content,
    )
    .map_err(|e| EpochError::LoadConfigurationError(e.to_string()))
}

#[cfg(test)]
mod tests {
    use near_primitives::epoch_manager::AllEpochConfig;
    use near_primitives::version::PROTOCOL_VERSION;

    use crate::config_store::{dump_config_file, parse_config_file};

    /// Checks that stored epoch config for latest protocol version matches the
    /// one generated by overrides from genesis config.
    /// If the test fails, it is either a configuration bug or the stored
    /// epoch config must be updated.
    fn check_epoch_configs(chain_id: &str) {
        let genesis_epoch_config = parse_config_file(chain_id, 0).unwrap().unwrap();
        let all_epoch_config = AllEpochConfig::new_with_test_overrides(
            true,
            genesis_epoch_config.clone(),
            chain_id,
            None,
        );

        let mut prev_config = genesis_epoch_config;
        for protocol_version in 1..=PROTOCOL_VERSION {
            let expected_config = all_epoch_config.for_protocol_version(protocol_version);
            if let Some(saved_config) = parse_config_file(chain_id, protocol_version).unwrap() {
                assert_eq!(saved_config, expected_config);
            } else {
                assert_eq!(prev_config, expected_config);
            }
            prev_config = expected_config;
        }
    }

    #[test]
    fn check_epoch_configs_mainnet() {
        check_epoch_configs("mainnet");
    }

    #[test]
    fn check_epoch_configs_testnet() {
        check_epoch_configs("testnet");
    }

    #[test]
    fn check_epoch_configs_mocknet() {
        check_epoch_configs("mocknet");
    }

    fn generate_epoch_configs(chain_id: &str) {
        let genesis_epoch_config = parse_config_file(chain_id, 0).unwrap().unwrap();
        let all_epoch_config = AllEpochConfig::new_with_test_overrides(
            true,
            genesis_epoch_config.clone(),
            chain_id,
            None,
        );

        let mut prev_config = genesis_epoch_config;
        for protocol_version in 1..=PROTOCOL_VERSION {
            let next_config = all_epoch_config.for_protocol_version(protocol_version);
            if next_config != prev_config {
                tracing::info!("Writing config for protocol version {}", protocol_version);
                dump_config_file(&next_config, chain_id, protocol_version).unwrap();
            }
            prev_config = next_config;
        }
    }

    #[test]
    fn generate_epoch_configs_mainnet() {
        generate_epoch_configs("mainnet");
    }

    #[test]
    fn generate_epoch_configs_testnet() {
        generate_epoch_configs("testnet");
    }

    #[test]
    fn generate_epoch_configs_mocknet() {
        generate_epoch_configs("mocknet");
    }
}
