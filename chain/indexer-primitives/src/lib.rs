pub use near_primitives::hash::CryptoHash;
pub use near_primitives::{self, types, views};

/// Resulting struct represents block with chunks
#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct StreamerMessage {
    pub block: views::BlockView,
    pub shards: Vec<IndexerShard>,
}

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct IndexerChunkView {
    pub author: types::AccountId,
    pub header: views::ChunkHeaderView,
    pub transactions: Vec<IndexerTransactionWithOutcome>,
    /// Represents receipts generated by execution of the previous chunk.
    /// Note that those are not the receipts executed by this chunk or even
    /// targeting that shard.
    pub receipts: Vec<views::ReceiptView>,
    /// Receipts generated in this chunk from transactions with `signer_id`
    /// equal to `receiver_id`.
    #[serde(default)]
    pub local_receipts: Vec<views::ReceiptView>,
}

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct IndexerTransactionWithOutcome {
    pub transaction: views::SignedTransactionView,
    pub outcome: IndexerExecutionOutcomeWithOptionalReceipt,
}

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct IndexerExecutionOutcomeWithOptionalReceipt {
    pub execution_outcome: views::ExecutionOutcomeWithIdView,
    pub receipt: Option<views::ReceiptView>,
}

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct IndexerExecutionOutcomeWithReceipt {
    pub execution_outcome: views::ExecutionOutcomeWithIdView,
    pub receipt: views::ReceiptView,
}

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct IndexerShard {
    pub shard_id: types::ShardId,
    pub chunk: Option<IndexerChunkView>,
    pub receipt_execution_outcomes: Vec<IndexerExecutionOutcomeWithReceipt>,
    pub state_changes: views::StateChangesView,
}
