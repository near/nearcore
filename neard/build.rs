use std::io::Write;

use anyhow::{anyhow, Result};

use near_primitives::version::{Version, DB_VERSION, PROTOCOL_VERSION};

/// Returns value of given environment variable or error if missing.
fn env(key: &str) -> Result<std::ffi::OsString> {
    println!("cargo:rerun-if-env-changed={}", key);
    std::env::var_os(key).ok_or_else(|| anyhow!("missing ‘{}’ environment variable", key))
}

/// Calls program with given arguments and returns its standard output.  If
/// calling the program fails or it exits with non-zero exit status returns an
/// error.
fn command(prog: &str, args: &[&str]) -> Result<Vec<u8>> {
    println!("cargo:rerun-if-env-changed=PATH");
    let out = std::process::Command::new(prog)
        .args(args)
        .stderr(std::process::Stdio::inherit())
        .output()?;
    if out.status.success() {
        Ok(out.stdout)
    } else if let Some(code) = out.status.code() {
        Err(anyhow!("{}: terminated with {}", prog, code))
    } else {
        Err(anyhow!("{}: killed by signal", prog))
    }
}

/// Returns version read from git repository or ‘unknown’ if could not be
/// determined.
fn get_git_version() -> Result<String> {
    let git_dir = std::path::Path::new(&env("CARGO_MANIFEST_DIR")?).join("../.git");
    for subpath in ["HEAD", "logs/HEAD", "index"] {
        let path = git_dir.join(subpath).canonicalize()?;
        println!("cargo:rerun-if-changed={}", path.display());
    }
    match command("git", &["describe", "--always", "--dirty=-modified"]) {
        Ok(out) => Ok(std::str::from_utf8(&out)?.trim().into()),
        Err(msg) => {
            println!("cargo:warning=unable to determine git version");
            println!("cargo:warning={}", msg);
            Ok("unknown".into())
        }
    }
}

/// Returns version information for the neard binary.
fn get_version() -> Result<Version> {
    let version = env("CARGO_PKG_VERSION")?;
    let version = version.to_str().unwrap();
    Ok(Version {
        version: match version {
            "0.0.0" => "trunk".to_string(),
            version => version.to_string(),
        },
        build: get_git_version()?,
    })
}

/// Quotes a string in a format which can be included in Rust source code.
fn quote(value: String) -> String {
    // I’m not sure if Rust string literal grammar is a superset of JSON’s
    // grammar.  It’s probably fine though.
    serde_json::Value::String(value).to_string()
}

/// Generates a `version.rs` which defines static variables with neard version
/// information.
fn write_version_info(info: Version) -> Result<()> {
    let version_string = format!(
        "(release {}) (build {}) (protocol {}) (db {})",
        info.version, info.build, PROTOCOL_VERSION, DB_VERSION
    );
    let out_dir = env("OUT_DIR")?;
    let dest = std::path::Path::new(&out_dir).join("version.rs");
    let mut dest = std::fs::File::create(dest)?;
    writeln!(
        dest,
        r#"// Generated by build.rs

static NEARD_VERSION: &'static str = {version};
static NEARD_BUILD: &'static str = {build};
static NEARD_VERSION_STRING: &'static str = {version_string};

fn neard_version() -> near_primitives::version::Version {{
    near_primitives::version::Version {{
        version: NEARD_VERSION.to_string(),
        build: NEARD_BUILD.to_string(),
    }}
}}
"#,
        version = quote(info.version),
        build = quote(info.build),
        version_string = quote(version_string)
    )?;
    Ok(())
}

fn main() {
    if let Err(err) = try_main() {
        eprintln!("{}", err);
        std::process::exit(1);
    }
}

fn try_main() -> Result<()> {
    let version = get_version()?;
    write_version_info(version)
}
