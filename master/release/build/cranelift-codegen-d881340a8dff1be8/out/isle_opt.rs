// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_opt.isle
// - src/opts/algebraic.isle
// - src/opts/cprop.isle
// - /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> Option<u32>;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_as_u32(&mut self, arg0: u8) -> Option<u32>;
    fn u8_as_u64(&mut self, arg0: u8) -> Option<u64>;
    fn u16_as_u64(&mut self, arg0: u16) -> Option<u64>;
    fn u32_as_u64(&mut self, arg0: u32) -> Option<u64>;
    fn i64_as_u64(&mut self, arg0: i64) -> Option<u64>;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_not(&mut self, arg0: u64) -> Option<u64>;
    fn u64_sextend_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u64_uextend_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> Option<bool>;
    fn ty_bits(&mut self, arg0: Type) -> Option<u8>;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Option<Imm64>;
    fn u64_from_ieee32(&mut self, arg0: Ieee32) -> u64;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    fn eclass_type(&mut self, arg0: Id) -> Option<Type>;
    fn enodes_etor(&mut self, arg0: Id) -> Option<Self::enodes_etor_iter>;
    type enodes_etor_iter: ContextIter<Context = Self, Output = (Type, InstructionImms, IdArray)>;
    fn pure_enode_ctor(&mut self, arg0: Type, arg1: &InstructionImms, arg2: IdArray) -> Id;
    fn id_array_0_etor(&mut self, arg0: IdArray) -> Option<()>;
    fn id_array_0_ctor(&mut self) -> IdArray;
    fn id_array_1_etor(&mut self, arg0: IdArray) -> Option<Id>;
    fn id_array_1_ctor(&mut self, arg0: Id) -> IdArray;
    fn id_array_2_etor(&mut self, arg0: IdArray) -> Option<(Id, Id)>;
    fn id_array_2_ctor(&mut self, arg0: Id, arg1: Id) -> IdArray;
    fn id_array_3_etor(&mut self, arg0: IdArray) -> Option<(Id, Id, Id)>;
    fn id_array_3_ctor(&mut self, arg0: Id, arg1: Id, arg2: Id) -> IdArray;
    fn at_loop_level(&mut self, arg0: Id) -> (u8, Id);
    fn remat(&mut self, arg0: Id) -> Id;
    fn subsume(&mut self, arg0: Id) -> Id;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(
    ctx: &mut C,
    arg0: Id,
) -> Option<impl ContextIter<Context = C, Output = Id>> {
    let mut returns = ConstructorVec::new();
    let pattern0_0 = arg0;
    if let Some(mut iter) = C::enodes_etor(ctx, pattern0_0) {
        while let Some((pattern1_0, pattern1_1, pattern1_2)) = iter.next(ctx) {
            if pattern1_0 == I32 {
                if let &InstructionImms::Binary {
                    opcode: ref pattern3_0,
                } = &pattern1_1
                {
                    match pattern3_0 {
                        &Opcode::Band => {
                            if let Some((pattern5_0, pattern5_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                    while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern6_0 == I32 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern8_0,
                                                imm: pattern8_1,
                                            } = &pattern6_1
                                            {
                                                if let &Opcode::Iconst = pattern8_0 {
                                                    let pattern10_0 =
                                                        C::u64_from_imm64(ctx, pattern8_1);
                                                    if pattern10_0 == 4294967295i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 122.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern5_1);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern5_1) {
                                    while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern6_0 == I32 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern8_0,
                                                imm: pattern8_1,
                                            } = &pattern6_1
                                            {
                                                if let &Opcode::Iconst = pattern8_0 {
                                                    let pattern10_0 =
                                                        C::u64_from_imm64(ctx, pattern8_1);
                                                    if pattern10_0 == 4294967295i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 121.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern5_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Bxor => {
                            if let Some((pattern5_0, pattern5_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                    while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern6_0 == I32 {
                                            if let &InstructionImms::Unary {
                                                opcode: ref pattern8_0,
                                            } = &pattern6_1
                                            {
                                                if let &Opcode::Bnot = pattern8_0 {
                                                    if let Some(pattern10_0) =
                                                        C::id_array_1_etor(ctx, pattern6_2)
                                                    {
                                                        if pattern5_1 == pattern10_0 {
                                                            // Rule at src/opts/algebraic.isle line 115.
                                                            let expr0_0: Type = I32;
                                                            let expr1_0: u64 =
                                                                4294967295i128 as u64;
                                                            let expr2_0 = C::imm64(ctx, expr1_0)?;
                                                            let expr3_0 = constructor_iconst(
                                                                ctx, expr0_0, expr2_0,
                                                            )?;
                                                            let expr4_0 = C::subsume(ctx, expr3_0);
                                                            returns.push(expr4_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern5_1) {
                                    while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern6_0 == I32 {
                                            if let &InstructionImms::Unary {
                                                opcode: ref pattern8_0,
                                            } = &pattern6_1
                                            {
                                                if let &Opcode::Bnot = pattern8_0 {
                                                    if let Some(pattern10_0) =
                                                        C::id_array_1_etor(ctx, pattern6_2)
                                                    {
                                                        if pattern10_0 == pattern5_0 {
                                                            // Rule at src/opts/algebraic.isle line 114.
                                                            let expr0_0: Type = I32;
                                                            let expr1_0: u64 =
                                                                4294967295i128 as u64;
                                                            let expr2_0 = C::imm64(ctx, expr1_0)?;
                                                            let expr3_0 = constructor_iconst(
                                                                ctx, expr0_0, expr2_0,
                                                            )?;
                                                            let expr4_0 = C::subsume(ctx, expr3_0);
                                                            returns.push(expr4_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
            if pattern1_0 == I64 {
                match &pattern1_1 {
                    &InstructionImms::Binary {
                        opcode: ref pattern3_0,
                    } => {
                        match pattern3_0 {
                            &Opcode::Band => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == I64 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if pattern10_0
                                                            == 18446744073709551615i128 as u64
                                                        {
                                                            if let Some(()) =
                                                                C::id_array_0_etor(ctx, pattern6_2)
                                                            {
                                                                // Rule at src/opts/algebraic.isle line 124.
                                                                let expr0_0 =
                                                                    C::subsume(ctx, pattern5_1);
                                                                returns.push(expr0_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_1) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == I64 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if pattern10_0
                                                            == 18446744073709551615i128 as u64
                                                        {
                                                            if let Some(()) =
                                                                C::id_array_0_etor(ctx, pattern6_2)
                                                            {
                                                                // Rule at src/opts/algebraic.isle line 123.
                                                                let expr0_0 =
                                                                    C::subsume(ctx, pattern5_0);
                                                                returns.push(expr0_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Bxor => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == I64 {
                                                if let &InstructionImms::Unary {
                                                    opcode: ref pattern8_0,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Bnot = pattern8_0 {
                                                        if let Some(pattern10_0) =
                                                            C::id_array_1_etor(ctx, pattern6_2)
                                                        {
                                                            if pattern5_1 == pattern10_0 {
                                                                // Rule at src/opts/algebraic.isle line 117.
                                                                let expr0_0: Type = I64;
                                                                let expr1_0: u64 =
                                                                    18446744073709551615i128 as u64;
                                                                let expr2_0 =
                                                                    C::imm64(ctx, expr1_0)?;
                                                                let expr3_0 = constructor_iconst(
                                                                    ctx, expr0_0, expr2_0,
                                                                )?;
                                                                let expr4_0 =
                                                                    C::subsume(ctx, expr3_0);
                                                                returns.push(expr4_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_1) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == I64 {
                                                if let &InstructionImms::Unary {
                                                    opcode: ref pattern8_0,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Bnot = pattern8_0 {
                                                        if let Some(pattern10_0) =
                                                            C::id_array_1_etor(ctx, pattern6_2)
                                                        {
                                                            if pattern10_0 == pattern5_0 {
                                                                // Rule at src/opts/algebraic.isle line 116.
                                                                let expr0_0: Type = I64;
                                                                let expr1_0: u64 =
                                                                    18446744073709551615i128 as u64;
                                                                let expr2_0 =
                                                                    C::imm64(ctx, expr1_0)?;
                                                                let expr3_0 = constructor_iconst(
                                                                    ctx, expr0_0, expr2_0,
                                                                )?;
                                                                let expr4_0 =
                                                                    C::subsume(ctx, expr3_0);
                                                                returns.push(expr4_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Ushr => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == I64 {
                                                if let &InstructionImms::Binary {
                                                    opcode: ref pattern8_0,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Ishl = pattern8_0 {
                                                        if let Some((pattern10_0, pattern10_1)) =
                                                            C::id_array_2_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern10_0)
                                                            {
                                                                while let Some((
                                                                    pattern11_0,
                                                                    pattern11_1,
                                                                    pattern11_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern11_0 == I64 {
                                                                        if let &InstructionImms::Unary { opcode: ref pattern13_0 } = &pattern11_1 {
                                                                            if let &Opcode::Uextend  = pattern13_0 {
                                                                                if let Some(pattern15_0) = C::id_array_1_etor(ctx, pattern11_2) {
                                                                                    if let Some(pattern16_0) = C::eclass_type(ctx, pattern15_0) {
                                                                                        if pattern16_0 == I32 {
                                                                                            if let Some(mut iter) = C::enodes_etor(ctx, pattern10_1) {
                                                                                                while let Some((pattern18_0, pattern18_1, pattern18_2)) = iter.next(ctx) {
                                                                                                    if let &InstructionImms::UnaryImm { opcode: ref pattern19_0, imm: pattern19_1 } = &pattern18_1 {
                                                                                                        if let &Opcode::Iconst  = pattern19_0 {
                                                                                                            if let Some(pattern21_0) = C::simm32(ctx, pattern19_1) {
                                                                                                                if pattern21_0 == 32i128 as u32  {
                                                                                                                    if let Some(()) = C::id_array_0_etor(ctx, pattern18_2) {
                                                                                                                        if let Some(mut iter) = C::enodes_etor(ctx, pattern5_1) {
                                                                                                                            while let Some((pattern24_0, pattern24_1, pattern24_2)) = iter.next(ctx) {
                                                                                                                                if let &InstructionImms::UnaryImm { opcode: ref pattern25_0, imm: pattern25_1 } = &pattern24_1 {
                                                                                                                                    if let &Opcode::Iconst  = pattern25_0 {
                                                                                                                                        if let Some(pattern27_0) = C::simm32(ctx, pattern25_1) {
                                                                                                                                            if pattern27_0 == 32i128 as u32  {
                                                                                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern24_2) {
                                                                                                                                                    // Rule at src/opts/algebraic.isle line 148.
                                                                                                                                                    let expr0_0: Type = I64;
                                                                                                                                                    let expr1_0 = constructor_uextend(ctx, expr0_0, pattern15_0)?;
                                                                                                                                                    returns.push(expr1_0);
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                        }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                            }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Sshr => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == I64 {
                                                if let &InstructionImms::Binary {
                                                    opcode: ref pattern8_0,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Ishl = pattern8_0 {
                                                        if let Some((pattern10_0, pattern10_1)) =
                                                            C::id_array_2_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern10_0)
                                                            {
                                                                while let Some((
                                                                    pattern11_0,
                                                                    pattern11_1,
                                                                    pattern11_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern11_0 == I64 {
                                                                        if let &InstructionImms::Unary { opcode: ref pattern13_0 } = &pattern11_1 {
                                                                            if let &Opcode::Uextend  = pattern13_0 {
                                                                                if let Some(pattern15_0) = C::id_array_1_etor(ctx, pattern11_2) {
                                                                                    if let Some(pattern16_0) = C::eclass_type(ctx, pattern15_0) {
                                                                                        if pattern16_0 == I32 {
                                                                                            if let Some(mut iter) = C::enodes_etor(ctx, pattern10_1) {
                                                                                                while let Some((pattern18_0, pattern18_1, pattern18_2)) = iter.next(ctx) {
                                                                                                    if let &InstructionImms::UnaryImm { opcode: ref pattern19_0, imm: pattern19_1 } = &pattern18_1 {
                                                                                                        if let &Opcode::Iconst  = pattern19_0 {
                                                                                                            if let Some(pattern21_0) = C::simm32(ctx, pattern19_1) {
                                                                                                                if pattern21_0 == 32i128 as u32  {
                                                                                                                    if let Some(()) = C::id_array_0_etor(ctx, pattern18_2) {
                                                                                                                        if let Some(mut iter) = C::enodes_etor(ctx, pattern5_1) {
                                                                                                                            while let Some((pattern24_0, pattern24_1, pattern24_2)) = iter.next(ctx) {
                                                                                                                                if let &InstructionImms::UnaryImm { opcode: ref pattern25_0, imm: pattern25_1 } = &pattern24_1 {
                                                                                                                                    if let &Opcode::Iconst  = pattern25_0 {
                                                                                                                                        if let Some(pattern27_0) = C::simm32(ctx, pattern25_1) {
                                                                                                                                            if pattern27_0 == 32i128 as u32  {
                                                                                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern24_2) {
                                                                                                                                                    // Rule at src/opts/algebraic.isle line 151.
                                                                                                                                                    let expr0_0: Type = I64;
                                                                                                                                                    let expr1_0 = constructor_sextend(ctx, expr0_0, pattern15_0)?;
                                                                                                                                                    returns.push(expr1_0);
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                        }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                            }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &InstructionImms::Unary {
                        opcode: ref pattern3_0,
                    } => {
                        match pattern3_0 {
                            &Opcode::Uextend => {
                                if let Some(pattern5_0) = C::id_array_1_etor(ctx, pattern1_2) {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == I32 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 10.
                                                            let expr0_0: Type = I64;
                                                            let expr1_0 = C::u64_uextend_u32(
                                                                ctx,
                                                                pattern10_0,
                                                            )?;
                                                            let expr2_0 = C::imm64(ctx, expr1_0)?;
                                                            let expr3_0 = constructor_iconst(
                                                                ctx, expr0_0, expr2_0,
                                                            )?;
                                                            returns.push(expr3_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Sextend => {
                                if let Some(pattern5_0) = C::id_array_1_etor(ctx, pattern1_2) {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == I32 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 12.
                                                            let expr0_0: Type = I64;
                                                            let expr1_0 = C::u64_sextend_u32(
                                                                ctx,
                                                                pattern10_0,
                                                            )?;
                                                            let expr2_0 = C::imm64(ctx, expr1_0)?;
                                                            let expr3_0 = constructor_iconst(
                                                                ctx, expr0_0, expr2_0,
                                                            )?;
                                                            returns.push(expr3_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    _ => {}
                }
            }
            match &pattern1_1 {
                &InstructionImms::Binary {
                    opcode: ref pattern2_0,
                } => {
                    match pattern2_0 {
                        &Opcode::Iadd => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_0) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            match &pattern5_1 {
                                                &InstructionImms::Binary {
                                                    opcode: ref pattern7_0,
                                                } => {
                                                    match pattern7_0 {
                                                        &Opcode::Iadd => {
                                                            if let Some((pattern9_0, pattern9_1)) =
                                                                C::id_array_2_etor(ctx, pattern5_2)
                                                            {
                                                                let mut closure10 = || {
                                                                    return Some(pattern9_0);
                                                                };
                                                                if let Some(pattern10_0) =
                                                                    closure10()
                                                                {
                                                                    let (pattern11_0, pattern11_1) =
                                                                        C::at_loop_level(
                                                                            ctx,
                                                                            pattern10_0,
                                                                        );
                                                                    let mut closure12 = || {
                                                                        return Some(pattern9_1);
                                                                    };
                                                                    if let Some(pattern12_0) =
                                                                        closure12()
                                                                    {
                                                                        let (
                                                                            pattern13_0,
                                                                            pattern13_1,
                                                                        ) = C::at_loop_level(
                                                                            ctx,
                                                                            pattern12_0,
                                                                        );
                                                                        let mut closure14 = || {
                                                                            return Some(
                                                                                pattern4_1,
                                                                            );
                                                                        };
                                                                        if let Some(pattern14_0) =
                                                                            closure14()
                                                                        {
                                                                            let (
                                                                                pattern15_0,
                                                                                pattern15_1,
                                                                            ) = C::at_loop_level(
                                                                                ctx,
                                                                                pattern14_0,
                                                                            );
                                                                            let mut closure16 =
                                                                                || {
                                                                                    let expr0_0 = C::u8_lt(ctx, pattern11_0, pattern13_0)?;
                                                                                    return Some(
                                                                                        expr0_0,
                                                                                    );
                                                                                };
                                                                            if let Some(
                                                                                pattern16_0,
                                                                            ) = closure16()
                                                                            {
                                                                                let mut closure17 =
                                                                                    || {
                                                                                        let expr0_0 = C::u8_lt(ctx, pattern15_0, pattern13_0)?;
                                                                                        return Some(expr0_0);
                                                                                    };
                                                                                if let Some(
                                                                                    pattern17_0,
                                                                                ) = closure17()
                                                                                {
                                                                                    // Rule at src/opts/algebraic.isle line 158.
                                                                                    let expr0_0 = constructor_iadd(ctx, pattern1_0, pattern9_0, pattern4_1)?;
                                                                                    let expr1_0 = constructor_iadd(ctx, pattern1_0, expr0_0, pattern9_1)?;
                                                                                    returns.push(
                                                                                        expr1_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                            let mut closure16 =
                                                                                || {
                                                                                    let expr0_0 = C::u8_lt(ctx, pattern13_0, pattern11_0)?;
                                                                                    return Some(
                                                                                        expr0_0,
                                                                                    );
                                                                                };
                                                                            if let Some(
                                                                                pattern16_0,
                                                                            ) = closure16()
                                                                            {
                                                                                let mut closure17 =
                                                                                    || {
                                                                                        let expr0_0 = C::u8_lt(ctx, pattern15_0, pattern11_0)?;
                                                                                        return Some(expr0_0);
                                                                                    };
                                                                                if let Some(
                                                                                    pattern17_0,
                                                                                ) = closure17()
                                                                                {
                                                                                    // Rule at src/opts/algebraic.isle line 165.
                                                                                    let expr0_0 = constructor_iadd(ctx, pattern1_0, pattern9_1, pattern4_1)?;
                                                                                    let expr1_0 = constructor_iadd(ctx, pattern1_0, expr0_0, pattern9_0)?;
                                                                                    returns.push(
                                                                                        expr1_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                if let Some(mut iter) =
                                                                    C::enodes_etor(ctx, pattern9_1)
                                                                {
                                                                    while let Some((
                                                                        pattern10_0,
                                                                        pattern10_1,
                                                                        pattern10_2,
                                                                    )) = iter.next(ctx)
                                                                    {
                                                                        if pattern10_0 == pattern1_0
                                                                        {
                                                                            if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                                if let &Opcode::Iconst  = pattern12_0 {
                                                                                    if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                        if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                            while let Some((pattern15_0, pattern15_1, pattern15_2)) = iter.next(ctx) {
                                                                                                if pattern15_0 == pattern1_0 {
                                                                                                    if let &InstructionImms::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                                                        if let &Opcode::Iconst  = pattern17_0 {
                                                                                                            if let Some(()) = C::id_array_0_etor(ctx, pattern15_2) {
                                                                                                                // Rule at src/opts/cprop.isle line 89.
                                                                                                                let expr0_0 = constructor_iadd(ctx, pattern1_0, pattern9_1, pattern4_1)?;
                                                                                                                let expr1_0 = constructor_iadd(ctx, pattern1_0, pattern9_0, expr0_0)?;
                                                                                                                returns.push(expr1_0);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                        }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Isub => {
                                                            if let Some((pattern9_0, pattern9_1)) =
                                                                C::id_array_2_etor(ctx, pattern5_2)
                                                            {
                                                                if let Some(mut iter) =
                                                                    C::enodes_etor(ctx, pattern9_0)
                                                                {
                                                                    while let Some((
                                                                        pattern10_0,
                                                                        pattern10_1,
                                                                        pattern10_2,
                                                                    )) = iter.next(ctx)
                                                                    {
                                                                        if pattern10_0 == pattern1_0
                                                                        {
                                                                            if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                                if let &Opcode::Iconst  = pattern12_0 {
                                                                                    let pattern14_0 = C::u64_from_imm64(ctx, pattern12_1);
                                                                                    if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                        if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                            while let Some((pattern16_0, pattern16_1, pattern16_2)) = iter.next(ctx) {
                                                                                                if pattern16_0 == pattern1_0 {
                                                                                                    if let &InstructionImms::UnaryImm { opcode: ref pattern18_0, imm: pattern18_1 } = &pattern16_1 {
                                                                                                        if let &Opcode::Iconst  = pattern18_0 {
                                                                                                            let pattern20_0 = C::u64_from_imm64(ctx, pattern18_1);
                                                                                                            if let Some(()) = C::id_array_0_etor(ctx, pattern16_2) {
                                                                                                                // Rule at src/opts/cprop.isle line 115.
                                                                                                                let expr0_0 = C::u64_add(ctx, pattern14_0, pattern20_0)?;
                                                                                                                let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0)?;
                                                                                                                let expr3_0 = constructor_isub(ctx, pattern1_0, expr2_0, pattern9_1)?;
                                                                                                                returns.push(expr3_0);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                        }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                if let Some(mut iter) =
                                                                    C::enodes_etor(ctx, pattern9_1)
                                                                {
                                                                    while let Some((
                                                                        pattern10_0,
                                                                        pattern10_1,
                                                                        pattern10_2,
                                                                    )) = iter.next(ctx)
                                                                    {
                                                                        if pattern10_0 == pattern1_0
                                                                        {
                                                                            if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                                if let &Opcode::Iconst  = pattern12_0 {
                                                                                    let pattern14_0 = C::u64_from_imm64(ctx, pattern12_1);
                                                                                    if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                        if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                            while let Some((pattern16_0, pattern16_1, pattern16_2)) = iter.next(ctx) {
                                                                                                if pattern16_0 == pattern1_0 {
                                                                                                    if let &InstructionImms::UnaryImm { opcode: ref pattern18_0, imm: pattern18_1 } = &pattern16_1 {
                                                                                                        if let &Opcode::Iconst  = pattern18_0 {
                                                                                                            let pattern20_0 = C::u64_from_imm64(ctx, pattern18_1);
                                                                                                            if let Some(()) = C::id_array_0_etor(ctx, pattern16_2) {
                                                                                                                // Rule at src/opts/cprop.isle line 111.
                                                                                                                let expr0_0 = C::u64_sub(ctx, pattern20_0, pattern14_0)?;
                                                                                                                let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0)?;
                                                                                                                let expr3_0 = constructor_iadd(ctx, pattern1_0, pattern9_0, expr2_0)?;
                                                                                                                returns.push(expr3_0);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                        }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionImms::UnaryImm {
                                                    opcode: ref pattern7_0,
                                                    imm: pattern7_1,
                                                } => {
                                                    if let &Opcode::Iconst = pattern7_0 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/cprop.isle line 62.
                                                            let expr0_0 = constructor_iadd(
                                                                ctx, pattern1_0, pattern4_1,
                                                                pattern4_0,
                                                            )?;
                                                            returns.push(expr0_0);
                                                        }
                                                        let pattern9_0 =
                                                            C::u64_from_imm64(ctx, pattern7_1);
                                                        if pattern9_0 == 0i128 as u64 {
                                                            if let Some(()) =
                                                                C::id_array_0_etor(ctx, pattern5_2)
                                                            {
                                                                // Rule at src/opts/algebraic.isle line 20.
                                                                let expr0_0 =
                                                                    C::subsume(ctx, pattern4_1);
                                                                returns.push(expr0_0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 176.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 16.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 178.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Isub => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_0) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            match &pattern5_1 {
                                                &InstructionImms::Binary {
                                                    opcode: ref pattern7_0,
                                                } => {
                                                    match pattern7_0 {
                                                        &Opcode::Iadd => {
                                                            if let Some((pattern9_0, pattern9_1)) =
                                                                C::id_array_2_etor(ctx, pattern5_2)
                                                            {
                                                                if let Some(mut iter) =
                                                                    C::enodes_etor(ctx, pattern9_1)
                                                                {
                                                                    while let Some((
                                                                        pattern10_0,
                                                                        pattern10_1,
                                                                        pattern10_2,
                                                                    )) = iter.next(ctx)
                                                                    {
                                                                        if pattern10_0 == pattern1_0
                                                                        {
                                                                            if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                                if let &Opcode::Iconst  = pattern12_0 {
                                                                                    let pattern14_0 = C::u64_from_imm64(ctx, pattern12_1);
                                                                                    if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                        if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                            while let Some((pattern16_0, pattern16_1, pattern16_2)) = iter.next(ctx) {
                                                                                                if pattern16_0 == pattern1_0 {
                                                                                                    if let &InstructionImms::UnaryImm { opcode: ref pattern18_0, imm: pattern18_1 } = &pattern16_1 {
                                                                                                        if let &Opcode::Iconst  = pattern18_0 {
                                                                                                            let pattern20_0 = C::u64_from_imm64(ctx, pattern18_1);
                                                                                                            if let Some(()) = C::id_array_0_etor(ctx, pattern16_2) {
                                                                                                                // Rule at src/opts/cprop.isle line 107.
                                                                                                                let expr0_0 = C::u64_sub(ctx, pattern14_0, pattern20_0)?;
                                                                                                                let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0)?;
                                                                                                                let expr3_0 = constructor_isub(ctx, pattern1_0, pattern9_0, expr2_0)?;
                                                                                                                returns.push(expr3_0);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                        }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Isub => {
                                                            if let Some((pattern9_0, pattern9_1)) =
                                                                C::id_array_2_etor(ctx, pattern5_2)
                                                            {
                                                                if let Some(mut iter) =
                                                                    C::enodes_etor(ctx, pattern9_0)
                                                                {
                                                                    while let Some((
                                                                        pattern10_0,
                                                                        pattern10_1,
                                                                        pattern10_2,
                                                                    )) = iter.next(ctx)
                                                                    {
                                                                        if pattern10_0 == pattern1_0
                                                                        {
                                                                            if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                                if let &Opcode::Iconst  = pattern12_0 {
                                                                                    let pattern14_0 = C::u64_from_imm64(ctx, pattern12_1);
                                                                                    if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                        if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                            while let Some((pattern16_0, pattern16_1, pattern16_2)) = iter.next(ctx) {
                                                                                                if pattern16_0 == pattern1_0 {
                                                                                                    if let &InstructionImms::UnaryImm { opcode: ref pattern18_0, imm: pattern18_1 } = &pattern16_1 {
                                                                                                        if let &Opcode::Iconst  = pattern18_0 {
                                                                                                            let pattern20_0 = C::u64_from_imm64(ctx, pattern18_1);
                                                                                                            if let Some(()) = C::id_array_0_etor(ctx, pattern16_2) {
                                                                                                                // Rule at src/opts/cprop.isle line 103.
                                                                                                                let expr0_0 = C::u64_sub(ctx, pattern14_0, pattern20_0)?;
                                                                                                                let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0)?;
                                                                                                                let expr3_0 = constructor_isub(ctx, pattern1_0, expr2_0, pattern9_1)?;
                                                                                                                returns.push(expr3_0);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                        }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                if let Some(mut iter) =
                                                                    C::enodes_etor(ctx, pattern9_1)
                                                                {
                                                                    while let Some((
                                                                        pattern10_0,
                                                                        pattern10_1,
                                                                        pattern10_2,
                                                                    )) = iter.next(ctx)
                                                                    {
                                                                        if pattern10_0 == pattern1_0
                                                                        {
                                                                            if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                                if let &Opcode::Iconst  = pattern12_0 {
                                                                                    let pattern14_0 = C::u64_from_imm64(ctx, pattern12_1);
                                                                                    if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                        if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                            while let Some((pattern16_0, pattern16_1, pattern16_2)) = iter.next(ctx) {
                                                                                                if pattern16_0 == pattern1_0 {
                                                                                                    if let &InstructionImms::UnaryImm { opcode: ref pattern18_0, imm: pattern18_1 } = &pattern16_1 {
                                                                                                        if let &Opcode::Iconst  = pattern18_0 {
                                                                                                            let pattern20_0 = C::u64_from_imm64(ctx, pattern18_1);
                                                                                                            if let Some(()) = C::id_array_0_etor(ctx, pattern16_2) {
                                                                                                                // Rule at src/opts/cprop.isle line 99.
                                                                                                                let expr0_0 = C::u64_add(ctx, pattern14_0, pattern20_0)?;
                                                                                                                let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0)?;
                                                                                                                let expr3_0 = constructor_isub(ctx, pattern1_0, pattern9_0, expr2_0)?;
                                                                                                                returns.push(expr3_0);
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                        }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionImms::UnaryImm {
                                                    opcode: ref pattern7_0,
                                                    imm: pattern7_1,
                                                } => {
                                                    if let &Opcode::Iconst = pattern7_0 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/cprop.isle line 67.
                                                            let expr0_0 = constructor_isub(
                                                                ctx, pattern1_0, pattern4_1,
                                                                pattern4_0,
                                                            )?;
                                                            let expr1_0 = constructor_ineg(
                                                                ctx, pattern1_0, expr0_0,
                                                            )?;
                                                            returns.push(expr1_0);
                                                        }
                                                        let pattern9_0 =
                                                            C::u64_from_imm64(ctx, pattern7_1);
                                                        if pattern9_0 == 0i128 as u64 {
                                                            if let Some(()) =
                                                                C::id_array_0_etor(ctx, pattern5_2)
                                                            {
                                                                // Rule at src/opts/algebraic.isle line 30.
                                                                let expr0_0 = constructor_ineg(
                                                                    ctx, pattern1_0, pattern4_1,
                                                                )?;
                                                                returns.push(expr0_0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 180.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 25.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 182.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Imul => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_0) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            match &pattern5_1 {
                                                &InstructionImms::Binary {
                                                    opcode: ref pattern7_0,
                                                } => {
                                                    if let &Opcode::Imul = pattern7_0 {
                                                        if let Some((pattern9_0, pattern9_1)) =
                                                            C::id_array_2_etor(ctx, pattern5_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern9_1)
                                                            {
                                                                while let Some((
                                                                    pattern10_0,
                                                                    pattern10_1,
                                                                    pattern10_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern10_0 == pattern1_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                            if let &Opcode::Iconst  = pattern12_0 {
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                        while let Some((pattern15_0, pattern15_1, pattern15_2)) = iter.next(ctx) {
                                                                                            if pattern15_0 == pattern1_0 {
                                                                                                if let &InstructionImms::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                                                    if let &Opcode::Iconst  = pattern17_0 {
                                                                                                        if let Some(()) = C::id_array_0_etor(ctx, pattern15_2) {
                                                                                                            // Rule at src/opts/cprop.isle line 120.
                                                                                                            let expr0_0 = constructor_imul(ctx, pattern1_0, pattern9_1, pattern4_1)?;
                                                                                                            let expr1_0 = constructor_imul(ctx, pattern1_0, pattern9_0, expr0_0)?;
                                                                                                            returns.push(expr1_0);
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                    }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionImms::UnaryImm {
                                                    opcode: ref pattern7_0,
                                                    imm: pattern7_1,
                                                } => {
                                                    if let &Opcode::Iconst = pattern7_0 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/cprop.isle line 70.
                                                            let expr0_0 = constructor_imul(
                                                                ctx, pattern1_0, pattern4_1,
                                                                pattern4_0,
                                                            )?;
                                                            returns.push(expr0_0);
                                                        }
                                                        let pattern9_0 =
                                                            C::u64_from_imm64(ctx, pattern7_1);
                                                        if pattern9_0 == 0i128 as u64 {
                                                            if let Some(()) =
                                                                C::id_array_0_etor(ctx, pattern5_2)
                                                            {
                                                                // Rule at src/opts/algebraic.isle line 50.
                                                                let expr0_0: u64 = 0i128 as u64;
                                                                let expr1_0 =
                                                                    C::imm64(ctx, expr0_0)?;
                                                                let expr2_0 = constructor_iconst(
                                                                    ctx, pattern1_0, expr1_0,
                                                                )?;
                                                                returns.push(expr2_0);
                                                            }
                                                        }
                                                        if pattern9_0 == 1i128 as u64 {
                                                            if let Some(()) =
                                                                C::id_array_0_etor(ctx, pattern5_2)
                                                            {
                                                                // Rule at src/opts/algebraic.isle line 40.
                                                                let expr0_0 =
                                                                    C::subsume(ctx, pattern4_1);
                                                                returns.push(expr0_0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(pattern8_0) = C::simm32(ctx, pattern6_1)
                                                {
                                                    if pattern8_0 == 2i128 as u32 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 144.
                                                            let expr0_0 = constructor_iadd(
                                                                ctx, pattern1_0, pattern4_1,
                                                                pattern4_1,
                                                            )?;
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 46.
                                                            let expr0_0: u64 = 0i128 as u64;
                                                            let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                            let expr2_0 = constructor_iconst(
                                                                ctx, pattern1_0, expr1_0,
                                                            )?;
                                                            returns.push(expr2_0);
                                                        }
                                                    }
                                                    if pattern9_0 == 1i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 36.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(pattern8_0) = C::simm32(ctx, pattern6_1)
                                                {
                                                    if pattern8_0 == 2i128 as u32 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 142.
                                                            let expr0_0 = constructor_iadd(
                                                                ctx, pattern1_0, pattern4_0,
                                                                pattern4_0,
                                                            )?;
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Udiv => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 1i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 60.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Sdiv => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 1i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 56.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Band => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if pattern4_1 == pattern4_0 {
                                    // Rule at src/opts/algebraic.isle line 120.
                                    returns.push(pattern4_0);
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_0) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            match &pattern5_1 {
                                                &InstructionImms::Binary {
                                                    opcode: ref pattern7_0,
                                                } => {
                                                    if let &Opcode::Band = pattern7_0 {
                                                        if let Some((pattern9_0, pattern9_1)) =
                                                            C::id_array_2_etor(ctx, pattern5_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern9_1)
                                                            {
                                                                while let Some((
                                                                    pattern10_0,
                                                                    pattern10_1,
                                                                    pattern10_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern10_0 == pattern1_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                            if let &Opcode::Iconst  = pattern12_0 {
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                        while let Some((pattern15_0, pattern15_1, pattern15_2)) = iter.next(ctx) {
                                                                                            if pattern15_0 == pattern1_0 {
                                                                                                if let &InstructionImms::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                                                    if let &Opcode::Iconst  = pattern17_0 {
                                                                                                        if let Some(()) = C::id_array_0_etor(ctx, pattern15_2) {
                                                                                                            // Rule at src/opts/cprop.isle line 126.
                                                                                                            let expr0_0 = constructor_band(ctx, pattern1_0, pattern9_1, pattern4_1)?;
                                                                                                            let expr1_0 = constructor_band(ctx, pattern1_0, pattern9_0, expr0_0)?;
                                                                                                            returns.push(expr1_0);
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                    }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionImms::UnaryImm {
                                                    opcode: ref pattern7_0,
                                                    imm: pattern7_1,
                                                } => {
                                                    if let &Opcode::Iconst = pattern7_0 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/cprop.isle line 77.
                                                            let expr0_0 = constructor_band(
                                                                ctx, pattern1_0, pattern4_1,
                                                                pattern4_0,
                                                            )?;
                                                            returns.push(expr0_0);
                                                        }
                                                        let pattern9_0 =
                                                            C::u64_from_imm64(ctx, pattern7_1);
                                                        if pattern9_0 == 0i128 as u64 {
                                                            if let Some(()) =
                                                                C::id_array_0_etor(ctx, pattern5_2)
                                                            {
                                                                // Rule at src/opts/algebraic.isle line 128.
                                                                let expr0_0: u64 = 0i128 as u64;
                                                                let expr1_0 =
                                                                    C::imm64(ctx, expr0_0)?;
                                                                let expr2_0 = constructor_iconst(
                                                                    ctx, pattern1_0, expr1_0,
                                                                )?;
                                                                returns.push(expr2_0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 184.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 127.
                                                            let expr0_0: u64 = 0i128 as u64;
                                                            let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                            let expr2_0 = constructor_iconst(
                                                                ctx, pattern1_0, expr1_0,
                                                            )?;
                                                            returns.push(expr2_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 186.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Bor => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if pattern4_1 == pattern4_0 {
                                    // Rule at src/opts/algebraic.isle line 96.
                                    let expr0_0 = C::subsume(ctx, pattern4_0);
                                    returns.push(expr0_0);
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_0) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            match &pattern5_1 {
                                                &InstructionImms::Binary {
                                                    opcode: ref pattern7_0,
                                                } => {
                                                    if let &Opcode::Bor = pattern7_0 {
                                                        if let Some((pattern9_0, pattern9_1)) =
                                                            C::id_array_2_etor(ctx, pattern5_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern9_1)
                                                            {
                                                                while let Some((
                                                                    pattern10_0,
                                                                    pattern10_1,
                                                                    pattern10_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern10_0 == pattern1_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                            if let &Opcode::Iconst  = pattern12_0 {
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                        while let Some((pattern15_0, pattern15_1, pattern15_2)) = iter.next(ctx) {
                                                                                            if pattern15_0 == pattern1_0 {
                                                                                                if let &InstructionImms::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                                                    if let &Opcode::Iconst  = pattern17_0 {
                                                                                                        if let Some(()) = C::id_array_0_etor(ctx, pattern15_2) {
                                                                                                            // Rule at src/opts/cprop.isle line 123.
                                                                                                            let expr0_0 = constructor_bor(ctx, pattern1_0, pattern9_1, pattern4_1)?;
                                                                                                            let expr1_0 = constructor_bor(ctx, pattern1_0, pattern9_0, expr0_0)?;
                                                                                                            returns.push(expr1_0);
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                    }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionImms::UnaryImm {
                                                    opcode: ref pattern7_0,
                                                    imm: pattern7_1,
                                                } => {
                                                    if let &Opcode::Iconst = pattern7_0 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/cprop.isle line 74.
                                                            let expr0_0 = constructor_bor(
                                                                ctx, pattern1_0, pattern4_1,
                                                                pattern4_0,
                                                            )?;
                                                            returns.push(expr0_0);
                                                        }
                                                        let pattern9_0 =
                                                            C::u64_from_imm64(ctx, pattern7_1);
                                                        if pattern9_0 == 0i128 as u64 {
                                                            if let Some(()) =
                                                                C::id_array_0_etor(ctx, pattern5_2)
                                                            {
                                                                // Rule at src/opts/algebraic.isle line 92.
                                                                let expr0_0 =
                                                                    C::subsume(ctx, pattern4_1);
                                                                returns.push(expr0_0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 188.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 88.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 190.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Bxor => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_0) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            match &pattern5_1 {
                                                &InstructionImms::Binary {
                                                    opcode: ref pattern7_0,
                                                } => {
                                                    if let &Opcode::Bxor = pattern7_0 {
                                                        if let Some((pattern9_0, pattern9_1)) =
                                                            C::id_array_2_etor(ctx, pattern5_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern9_1)
                                                            {
                                                                while let Some((
                                                                    pattern10_0,
                                                                    pattern10_1,
                                                                    pattern10_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern10_0 == pattern1_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern12_0, imm: pattern12_1 } = &pattern10_1 {
                                                                            if let &Opcode::Iconst  = pattern12_0 {
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern10_2) {
                                                                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                                                                        while let Some((pattern15_0, pattern15_1, pattern15_2)) = iter.next(ctx) {
                                                                                            if pattern15_0 == pattern1_0 {
                                                                                                if let &InstructionImms::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                                                    if let &Opcode::Iconst  = pattern17_0 {
                                                                                                        if let Some(()) = C::id_array_0_etor(ctx, pattern15_2) {
                                                                                                            // Rule at src/opts/cprop.isle line 129.
                                                                                                            let expr0_0 = constructor_bxor(ctx, pattern1_0, pattern9_1, pattern4_1)?;
                                                                                                            let expr1_0 = constructor_bxor(ctx, pattern1_0, pattern9_0, expr0_0)?;
                                                                                                            returns.push(expr1_0);
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                    }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionImms::UnaryImm {
                                                    opcode: ref pattern7_0,
                                                    imm: pattern7_1,
                                                } => {
                                                    if let &Opcode::Iconst = pattern7_0 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/cprop.isle line 80.
                                                            let expr0_0 = constructor_bxor(
                                                                ctx, pattern1_0, pattern4_1,
                                                                pattern4_0,
                                                            )?;
                                                            returns.push(expr0_0);
                                                        }
                                                        let pattern9_0 =
                                                            C::u64_from_imm64(ctx, pattern7_1);
                                                        if pattern9_0 == 0i128 as u64 {
                                                            if let Some(()) =
                                                                C::id_array_0_etor(ctx, pattern5_2)
                                                            {
                                                                // Rule at src/opts/algebraic.isle line 104.
                                                                let expr0_0 =
                                                                    C::subsume(ctx, pattern4_1);
                                                                returns.push(expr0_0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 192.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 100.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if let &InstructionImms::UnaryImm {
                                            opcode: ref pattern6_0,
                                            imm: pattern6_1,
                                        } = &pattern5_1
                                        {
                                            if let &Opcode::Iconst = pattern6_0 {
                                                if let Some(()) =
                                                    C::id_array_0_etor(ctx, pattern5_2)
                                                {
                                                    // Rule at src/opts/algebraic.isle line 194.
                                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                                    returns.push(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Rotl => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 82.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Rotr => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 78.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Ishl => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 66.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Ushr => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 70.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Sshr => {
                            if let Some((pattern4_0, pattern4_1)) =
                                C::id_array_2_etor(ctx, pattern1_2)
                            {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern4_1) {
                                    while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern5_0 == pattern1_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern7_0,
                                                imm: pattern7_1,
                                            } = &pattern5_1
                                            {
                                                if let &Opcode::Iconst = pattern7_0 {
                                                    let pattern9_0 =
                                                        C::u64_from_imm64(ctx, pattern7_1);
                                                    if pattern9_0 == 0i128 as u64 {
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern5_2)
                                                        {
                                                            // Rule at src/opts/algebraic.isle line 74.
                                                            let expr0_0 =
                                                                C::subsume(ctx, pattern4_0);
                                                            returns.push(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
                &InstructionImms::Unary {
                    opcode: ref pattern2_0,
                } => {
                    if let &Opcode::Bnot = pattern2_0 {
                        if let Some(pattern4_0) = C::id_array_1_etor(ctx, pattern1_2) {
                            if let Some(mut iter) = C::enodes_etor(ctx, pattern4_0) {
                                while let Some((pattern5_0, pattern5_1, pattern5_2)) =
                                    iter.next(ctx)
                                {
                                    if pattern5_0 == pattern1_0 {
                                        match &pattern5_1 {
                                            &InstructionImms::Binary {
                                                opcode: ref pattern7_0,
                                            } => {
                                                if let &Opcode::Bor = pattern7_0 {
                                                    if let Some((pattern9_0, pattern9_1)) =
                                                        C::id_array_2_etor(ctx, pattern5_2)
                                                    {
                                                        // Rule at src/opts/algebraic.isle line 135.
                                                        let expr0_0 = constructor_bnot(
                                                            ctx, pattern1_0, pattern9_0,
                                                        )?;
                                                        let expr1_0 = constructor_bnot(
                                                            ctx, pattern1_0, pattern9_1,
                                                        )?;
                                                        let expr2_0 = constructor_band(
                                                            ctx, pattern1_0, expr0_0, expr1_0,
                                                        )?;
                                                        returns.push(expr2_0);
                                                    }
                                                }
                                            }
                                            &InstructionImms::Unary {
                                                opcode: ref pattern7_0,
                                            } => {
                                                if let &Opcode::Bnot = pattern7_0 {
                                                    if let Some(pattern9_0) =
                                                        C::id_array_1_etor(ctx, pattern5_2)
                                                    {
                                                        // Rule at src/opts/algebraic.isle line 131.
                                                        let expr0_0 = C::subsume(ctx, pattern9_0);
                                                        returns.push(expr0_0);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    if let &InstructionImms::Binary {
                                        opcode: ref pattern6_0,
                                    } = &pattern5_1
                                    {
                                        if let &Opcode::Band = pattern6_0 {
                                            if let Some((pattern8_0, pattern8_1)) =
                                                C::id_array_2_etor(ctx, pattern5_2)
                                            {
                                                // Rule at src/opts/algebraic.isle line 138.
                                                let expr0_0 =
                                                    constructor_bnot(ctx, pattern1_0, pattern8_0)?;
                                                let expr1_0 =
                                                    constructor_bnot(ctx, pattern1_0, pattern8_1)?;
                                                let expr2_0 = constructor_bor(
                                                    ctx, pattern1_0, expr0_0, expr1_0,
                                                )?;
                                                returns.push(expr2_0);
                                            }
                                        }
                                    }
                                }
                            }
                            // Rule at src/opts/algebraic.isle line 196.
                            let expr0_0 = C::remat(ctx, pattern0_0);
                            returns.push(expr0_0);
                        }
                    }
                }
                &InstructionImms::UnaryIeee32 {
                    opcode: ref pattern2_0,
                    imm: pattern2_1,
                } => {
                    if let &Opcode::F32const = pattern2_0 {
                        if let Some(()) = C::id_array_0_etor(ctx, pattern1_2) {
                            // Rule at src/opts/algebraic.isle line 200.
                            let expr0_0 = C::remat(ctx, pattern0_0);
                            returns.push(expr0_0);
                        }
                    }
                }
                &InstructionImms::UnaryIeee64 {
                    opcode: ref pattern2_0,
                    imm: pattern2_1,
                } => {
                    if let &Opcode::F64const = pattern2_0 {
                        if let Some(()) = C::id_array_0_etor(ctx, pattern1_2) {
                            // Rule at src/opts/algebraic.isle line 202.
                            let expr0_0 = C::remat(ctx, pattern0_0);
                            returns.push(expr0_0);
                        }
                    }
                }
                &InstructionImms::UnaryImm {
                    opcode: ref pattern2_0,
                    imm: pattern2_1,
                } => {
                    if let &Opcode::Iconst = pattern2_0 {
                        if let Some(()) = C::id_array_0_etor(ctx, pattern1_2) {
                            // Rule at src/opts/algebraic.isle line 198.
                            let expr0_0 = C::remat(ctx, pattern0_0);
                            returns.push(expr0_0);
                        }
                    }
                }
                _ => {}
            }
            if let Some(pattern2_0) = C::fits_in_64(ctx, pattern1_0) {
                match &pattern1_1 {
                    &InstructionImms::Binary {
                        opcode: ref pattern3_0,
                    } => {
                        match pattern3_0 {
                            &Opcode::Iadd => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == pattern2_0 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern5_1)
                                                            {
                                                                while let Some((
                                                                    pattern12_0,
                                                                    pattern12_1,
                                                                    pattern12_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern12_0 == pattern2_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern14_0, imm: pattern14_1 } = &pattern12_1 {
                                                                            if let &Opcode::Iconst  = pattern14_0 {
                                                                                let pattern16_0 = C::u64_from_imm64(ctx, pattern14_1);
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern12_2) {
                                                                                    // Rule at src/opts/cprop.isle line 3.
                                                                                    let expr0_0 = C::u64_add(ctx, pattern10_0, pattern16_0)?;
                                                                                    let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                    let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0)?;
                                                                                    let expr3_0 = C::subsume(ctx, expr2_0);
                                                                                    returns.push(expr3_0);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Isub => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == pattern2_0 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern5_1)
                                                            {
                                                                while let Some((
                                                                    pattern12_0,
                                                                    pattern12_1,
                                                                    pattern12_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern12_0 == pattern2_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern14_0, imm: pattern14_1 } = &pattern12_1 {
                                                                            if let &Opcode::Iconst  = pattern14_0 {
                                                                                let pattern16_0 = C::u64_from_imm64(ctx, pattern14_1);
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern12_2) {
                                                                                    // Rule at src/opts/cprop.isle line 9.
                                                                                    let expr0_0 = C::u64_sub(ctx, pattern10_0, pattern16_0)?;
                                                                                    let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                    let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0)?;
                                                                                    let expr3_0 = C::subsume(ctx, expr2_0);
                                                                                    returns.push(expr3_0);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Imul => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == pattern2_0 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern5_1)
                                                            {
                                                                while let Some((
                                                                    pattern12_0,
                                                                    pattern12_1,
                                                                    pattern12_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern12_0 == pattern2_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern14_0, imm: pattern14_1 } = &pattern12_1 {
                                                                            if let &Opcode::Iconst  = pattern14_0 {
                                                                                let pattern16_0 = C::u64_from_imm64(ctx, pattern14_1);
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern12_2) {
                                                                                    // Rule at src/opts/cprop.isle line 15.
                                                                                    let expr0_0 = C::u64_mul(ctx, pattern10_0, pattern16_0)?;
                                                                                    let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                    let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0)?;
                                                                                    let expr3_0 = C::subsume(ctx, expr2_0);
                                                                                    returns.push(expr3_0);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Udiv => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == pattern2_0 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern5_1)
                                                            {
                                                                while let Some((
                                                                    pattern12_0,
                                                                    pattern12_1,
                                                                    pattern12_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern12_0 == pattern2_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern14_0, imm: pattern14_1 } = &pattern12_1 {
                                                                            if let &Opcode::Iconst  = pattern14_0 {
                                                                                let pattern16_0 = C::u64_from_imm64(ctx, pattern14_1);
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern12_2) {
                                                                                    let mut closure18 = || {
                                                                                        let expr0_0 = C::u64_udiv(ctx, pattern10_0, pattern16_0)?;
                                                                                        return Some(expr0_0);
                                                                                    };
                                                                                    if let Some(pattern18_0) = closure18() {
                                                                                        // Rule at src/opts/cprop.isle line 28.
                                                                                        let expr0_0 = C::imm64(ctx, pattern18_0)?;
                                                                                        let expr1_0 = constructor_iconst(ctx, pattern2_0, expr0_0)?;
                                                                                        let expr2_0 = C::subsume(ctx, expr1_0);
                                                                                        returns.push(expr2_0);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Sdiv => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == pattern2_0 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern5_1)
                                                            {
                                                                while let Some((
                                                                    pattern12_0,
                                                                    pattern12_1,
                                                                    pattern12_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern12_0 == pattern2_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern14_0, imm: pattern14_1 } = &pattern12_1 {
                                                                            if let &Opcode::Iconst  = pattern14_0 {
                                                                                let pattern16_0 = C::u64_from_imm64(ctx, pattern14_1);
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern12_2) {
                                                                                    let mut closure18 = || {
                                                                                        let expr0_0 = C::u64_sdiv(ctx, pattern10_0, pattern16_0)?;
                                                                                        return Some(expr0_0);
                                                                                    };
                                                                                    if let Some(pattern18_0) = closure18() {
                                                                                        // Rule at src/opts/cprop.isle line 21.
                                                                                        let expr0_0 = C::imm64(ctx, pattern18_0)?;
                                                                                        let expr1_0 = constructor_iconst(ctx, pattern2_0, expr0_0)?;
                                                                                        let expr2_0 = C::subsume(ctx, expr1_0);
                                                                                        returns.push(expr2_0);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Band => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == pattern2_0 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern5_1)
                                                            {
                                                                while let Some((
                                                                    pattern12_0,
                                                                    pattern12_1,
                                                                    pattern12_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern12_0 == pattern2_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern14_0, imm: pattern14_1 } = &pattern12_1 {
                                                                            if let &Opcode::Iconst  = pattern14_0 {
                                                                                let pattern16_0 = C::u64_from_imm64(ctx, pattern14_1);
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern12_2) {
                                                                                    // Rule at src/opts/cprop.isle line 41.
                                                                                    let expr0_0 = C::u64_and(ctx, pattern10_0, pattern16_0)?;
                                                                                    let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                    let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0)?;
                                                                                    let expr3_0 = C::subsume(ctx, expr2_0);
                                                                                    returns.push(expr3_0);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Bor => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == pattern2_0 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern5_1)
                                                            {
                                                                while let Some((
                                                                    pattern12_0,
                                                                    pattern12_1,
                                                                    pattern12_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern12_0 == pattern2_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern14_0, imm: pattern14_1 } = &pattern12_1 {
                                                                            if let &Opcode::Iconst  = pattern14_0 {
                                                                                let pattern16_0 = C::u64_from_imm64(ctx, pattern14_1);
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern12_2) {
                                                                                    // Rule at src/opts/cprop.isle line 35.
                                                                                    let expr0_0 = C::u64_or(ctx, pattern10_0, pattern16_0)?;
                                                                                    let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                    let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0)?;
                                                                                    let expr3_0 = C::subsume(ctx, expr2_0);
                                                                                    returns.push(expr3_0);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Bxor => {
                                if let Some((pattern5_0, pattern5_1)) =
                                    C::id_array_2_etor(ctx, pattern1_2)
                                {
                                    if pattern5_1 == pattern5_0 {
                                        // Rule at src/opts/algebraic.isle line 110.
                                        let expr0_0: u64 = 0i128 as u64;
                                        let expr1_0 = C::imm64(ctx, expr0_0)?;
                                        let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0)?;
                                        let expr3_0 = C::subsume(ctx, expr2_0);
                                        returns.push(expr3_0);
                                    }
                                    if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                        while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                            iter.next(ctx)
                                        {
                                            if pattern6_0 == pattern2_0 {
                                                if let &InstructionImms::UnaryImm {
                                                    opcode: ref pattern8_0,
                                                    imm: pattern8_1,
                                                } = &pattern6_1
                                                {
                                                    if let &Opcode::Iconst = pattern8_0 {
                                                        let pattern10_0 =
                                                            C::u64_from_imm64(ctx, pattern8_1);
                                                        if let Some(()) =
                                                            C::id_array_0_etor(ctx, pattern6_2)
                                                        {
                                                            if let Some(mut iter) =
                                                                C::enodes_etor(ctx, pattern5_1)
                                                            {
                                                                while let Some((
                                                                    pattern12_0,
                                                                    pattern12_1,
                                                                    pattern12_2,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern12_0 == pattern2_0 {
                                                                        if let &InstructionImms::UnaryImm { opcode: ref pattern14_0, imm: pattern14_1 } = &pattern12_1 {
                                                                            if let &Opcode::Iconst  = pattern14_0 {
                                                                                let pattern16_0 = C::u64_from_imm64(ctx, pattern14_1);
                                                                                if let Some(()) = C::id_array_0_etor(ctx, pattern12_2) {
                                                                                    // Rule at src/opts/cprop.isle line 47.
                                                                                    let expr0_0 = C::u64_xor(ctx, pattern10_0, pattern16_0)?;
                                                                                    let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                                                    let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0)?;
                                                                                    let expr3_0 = C::subsume(ctx, expr2_0);
                                                                                    returns.push(expr3_0);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &InstructionImms::Unary {
                        opcode: ref pattern3_0,
                    } => {
                        if let &Opcode::Bnot = pattern3_0 {
                            if let Some(pattern5_0) = C::id_array_1_etor(ctx, pattern1_2) {
                                if let Some(mut iter) = C::enodes_etor(ctx, pattern5_0) {
                                    while let Some((pattern6_0, pattern6_1, pattern6_2)) =
                                        iter.next(ctx)
                                    {
                                        if pattern6_0 == pattern2_0 {
                                            if let &InstructionImms::UnaryImm {
                                                opcode: ref pattern8_0,
                                                imm: pattern8_1,
                                            } = &pattern6_1
                                            {
                                                if let &Opcode::Iconst = pattern8_0 {
                                                    let pattern10_0 =
                                                        C::u64_from_imm64(ctx, pattern8_1);
                                                    if let Some(()) =
                                                        C::id_array_0_etor(ctx, pattern6_2)
                                                    {
                                                        // Rule at src/opts/cprop.isle line 53.
                                                        let expr0_0 = C::u64_not(ctx, pattern10_0)?;
                                                        let expr1_0 = C::imm64(ctx, expr0_0)?;
                                                        let expr2_0 = constructor_iconst(
                                                            ctx, pattern2_0, expr1_0,
                                                        )?;
                                                        let expr3_0 = C::subsume(ctx, expr2_0);
                                                        returns.push(expr3_0);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    return Some(ContextIterWrapper::from(returns.into_iter()));
}

// Generated as internal constructor for term br_table.
pub fn constructor_br_table<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Block,
    arg3: JumpTable,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 352.
    let expr0_0 = Opcode::BrTable;
    let expr1_0 = InstructionImms::BranchTable {
        opcode: expr0_0,
        destination: pattern2_0,
        table: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term debugtrap.
pub fn constructor_debugtrap<C: Context>(ctx: &mut C, arg0: Type) -> Option<Id> {
    let pattern0_0 = arg0;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 361.
    let expr0_0 = Opcode::Debugtrap;
    let expr1_0 = InstructionImms::NullAry { opcode: expr0_0 };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term trap.
pub fn constructor_trap<C: Context>(ctx: &mut C, arg0: Type, arg1: &TrapCode) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 370.
    let expr0_0 = Opcode::Trap;
    let expr1_0 = InstructionImms::Trap {
        opcode: expr0_0,
        code: pattern1_0.clone(),
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term trapz.
pub fn constructor_trapz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: &TrapCode,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 379.
    let expr0_0 = Opcode::Trapz;
    let expr1_0 = InstructionImms::CondTrap {
        opcode: expr0_0,
        code: pattern2_0.clone(),
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term resumable_trap.
pub fn constructor_resumable_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &TrapCode,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 388.
    let expr0_0 = Opcode::ResumableTrap;
    let expr1_0 = InstructionImms::Trap {
        opcode: expr0_0,
        code: pattern1_0.clone(),
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term trapnz.
pub fn constructor_trapnz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: &TrapCode,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 397.
    let expr0_0 = Opcode::Trapnz;
    let expr1_0 = InstructionImms::CondTrap {
        opcode: expr0_0,
        code: pattern2_0.clone(),
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term resumable_trapnz.
pub fn constructor_resumable_trapnz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: &TrapCode,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 406.
    let expr0_0 = Opcode::ResumableTrapnz;
    let expr1_0 = InstructionImms::CondTrap {
        opcode: expr0_0,
        code: pattern2_0.clone(),
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term func_addr.
pub fn constructor_func_addr<C: Context>(ctx: &mut C, arg0: Type, arg1: FuncRef) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 415.
    let expr0_0 = Opcode::FuncAddr;
    let expr1_0 = InstructionImms::FuncAddr {
        opcode: expr0_0,
        func_ref: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term splat.
pub fn constructor_splat<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 424.
    let expr0_0 = Opcode::Splat;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term swizzle.
pub fn constructor_swizzle<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 433.
    let expr0_0 = Opcode::Swizzle;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term insertlane.
pub fn constructor_insertlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Uimm8,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 442.
    let expr0_0 = Opcode::Insertlane;
    let expr1_0 = InstructionImms::TernaryImm8 {
        opcode: expr0_0,
        imm: pattern3_0,
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term extractlane.
pub fn constructor_extractlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Uimm8,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 451.
    let expr0_0 = Opcode::Extractlane;
    let expr1_0 = InstructionImms::BinaryImm8 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term smin.
pub fn constructor_smin<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 460.
    let expr0_0 = Opcode::Smin;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term umin.
pub fn constructor_umin<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 469.
    let expr0_0 = Opcode::Umin;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term smax.
pub fn constructor_smax<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 478.
    let expr0_0 = Opcode::Smax;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term umax.
pub fn constructor_umax<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 487.
    let expr0_0 = Opcode::Umax;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term avg_round.
pub fn constructor_avg_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 496.
    let expr0_0 = Opcode::AvgRound;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uadd_sat.
pub fn constructor_uadd_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 505.
    let expr0_0 = Opcode::UaddSat;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sadd_sat.
pub fn constructor_sadd_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 514.
    let expr0_0 = Opcode::SaddSat;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term usub_sat.
pub fn constructor_usub_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 523.
    let expr0_0 = Opcode::UsubSat;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ssub_sat.
pub fn constructor_ssub_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 532.
    let expr0_0 = Opcode::SsubSat;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term load.
pub fn constructor_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 541.
    let expr0_0 = Opcode::Load;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term store.
pub fn constructor_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Id,
    arg4: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 550.
    let expr0_0 = Opcode::Store;
    let expr1_0 = InstructionImms::Store {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern4_0,
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uload8.
pub fn constructor_uload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 559.
    let expr0_0 = Opcode::Uload8;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sload8.
pub fn constructor_sload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 568.
    let expr0_0 = Opcode::Sload8;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term istore8.
pub fn constructor_istore8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Id,
    arg4: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 577.
    let expr0_0 = Opcode::Istore8;
    let expr1_0 = InstructionImms::Store {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern4_0,
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uload16.
pub fn constructor_uload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 586.
    let expr0_0 = Opcode::Uload16;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sload16.
pub fn constructor_sload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 595.
    let expr0_0 = Opcode::Sload16;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term istore16.
pub fn constructor_istore16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Id,
    arg4: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 604.
    let expr0_0 = Opcode::Istore16;
    let expr1_0 = InstructionImms::Store {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern4_0,
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uload32.
pub fn constructor_uload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 613.
    let expr0_0 = Opcode::Uload32;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sload32.
pub fn constructor_sload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 622.
    let expr0_0 = Opcode::Sload32;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term istore32.
pub fn constructor_istore32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Id,
    arg4: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 631.
    let expr0_0 = Opcode::Istore32;
    let expr1_0 = InstructionImms::Store {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern4_0,
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uload8x8.
pub fn constructor_uload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 640.
    let expr0_0 = Opcode::Uload8x8;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sload8x8.
pub fn constructor_sload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 649.
    let expr0_0 = Opcode::Sload8x8;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uload16x4.
pub fn constructor_uload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 658.
    let expr0_0 = Opcode::Uload16x4;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sload16x4.
pub fn constructor_sload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 667.
    let expr0_0 = Opcode::Sload16x4;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uload32x2.
pub fn constructor_uload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 676.
    let expr0_0 = Opcode::Uload32x2;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sload32x2.
pub fn constructor_sload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 685.
    let expr0_0 = Opcode::Sload32x2;
    let expr1_0 = InstructionImms::Load {
        opcode: expr0_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term stack_load.
pub fn constructor_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 694.
    let expr0_0 = Opcode::StackLoad;
    let expr1_0 = InstructionImms::StackLoad {
        opcode: expr0_0,
        stack_slot: pattern1_0,
        offset: pattern2_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term stack_store.
pub fn constructor_stack_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: StackSlot,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 703.
    let expr0_0 = Opcode::StackStore;
    let expr1_0 = InstructionImms::StackStore {
        opcode: expr0_0,
        stack_slot: pattern2_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term stack_addr.
pub fn constructor_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 712.
    let expr0_0 = Opcode::StackAddr;
    let expr1_0 = InstructionImms::StackLoad {
        opcode: expr0_0,
        stack_slot: pattern1_0,
        offset: pattern2_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term dynamic_stack_load.
pub fn constructor_dynamic_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 721.
    let expr0_0 = Opcode::DynamicStackLoad;
    let expr1_0 = InstructionImms::DynamicStackLoad {
        opcode: expr0_0,
        dynamic_stack_slot: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term dynamic_stack_store.
pub fn constructor_dynamic_stack_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: DynamicStackSlot,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 730.
    let expr0_0 = Opcode::DynamicStackStore;
    let expr1_0 = InstructionImms::DynamicStackStore {
        opcode: expr0_0,
        dynamic_stack_slot: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term dynamic_stack_addr.
pub fn constructor_dynamic_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 739.
    let expr0_0 = Opcode::DynamicStackAddr;
    let expr1_0 = InstructionImms::DynamicStackLoad {
        opcode: expr0_0,
        dynamic_stack_slot: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term global_value.
pub fn constructor_global_value<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: GlobalValue,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 748.
    let expr0_0 = Opcode::GlobalValue;
    let expr1_0 = InstructionImms::UnaryGlobalValue {
        opcode: expr0_0,
        global_value: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term symbol_value.
pub fn constructor_symbol_value<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: GlobalValue,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 757.
    let expr0_0 = Opcode::SymbolValue;
    let expr1_0 = InstructionImms::UnaryGlobalValue {
        opcode: expr0_0,
        global_value: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term tls_value.
pub fn constructor_tls_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 766.
    let expr0_0 = Opcode::TlsValue;
    let expr1_0 = InstructionImms::UnaryGlobalValue {
        opcode: expr0_0,
        global_value: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term heap_addr.
pub fn constructor_heap_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Heap,
    arg2: Id,
    arg3: Uimm32,
    arg4: Uimm8,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 775.
    let expr0_0 = Opcode::HeapAddr;
    let expr1_0 = InstructionImms::HeapAddr {
        opcode: expr0_0,
        heap: pattern1_0,
        offset: pattern3_0,
        size: pattern4_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term heap_load.
pub fn constructor_heap_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: HeapImm,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 784.
    let expr0_0 = Opcode::HeapLoad;
    let expr1_0 = InstructionImms::HeapLoad {
        opcode: expr0_0,
        heap_imm: pattern1_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term heap_store.
pub fn constructor_heap_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: HeapImm,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 793.
    let expr0_0 = Opcode::HeapStore;
    let expr1_0 = InstructionImms::HeapStore {
        opcode: expr0_0,
        heap_imm: pattern1_0,
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term get_pinned_reg.
pub fn constructor_get_pinned_reg<C: Context>(ctx: &mut C, arg0: Type) -> Option<Id> {
    let pattern0_0 = arg0;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 802.
    let expr0_0 = Opcode::GetPinnedReg;
    let expr1_0 = InstructionImms::NullAry { opcode: expr0_0 };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term set_pinned_reg.
pub fn constructor_set_pinned_reg<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 811.
    let expr0_0 = Opcode::SetPinnedReg;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term get_frame_pointer.
pub fn constructor_get_frame_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Option<Id> {
    let pattern0_0 = arg0;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 820.
    let expr0_0 = Opcode::GetFramePointer;
    let expr1_0 = InstructionImms::NullAry { opcode: expr0_0 };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term get_stack_pointer.
pub fn constructor_get_stack_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Option<Id> {
    let pattern0_0 = arg0;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 829.
    let expr0_0 = Opcode::GetStackPointer;
    let expr1_0 = InstructionImms::NullAry { opcode: expr0_0 };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term get_return_address.
pub fn constructor_get_return_address<C: Context>(ctx: &mut C, arg0: Type) -> Option<Id> {
    let pattern0_0 = arg0;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 838.
    let expr0_0 = Opcode::GetReturnAddress;
    let expr1_0 = InstructionImms::NullAry { opcode: expr0_0 };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term table_addr.
pub fn constructor_table_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Table,
    arg2: Id,
    arg3: Offset32,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 847.
    let expr0_0 = Opcode::TableAddr;
    let expr1_0 = InstructionImms::TableAddr {
        opcode: expr0_0,
        table: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iconst.
pub fn constructor_iconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Imm64) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 856.
    let expr0_0 = Opcode::Iconst;
    let expr1_0 = InstructionImms::UnaryImm {
        opcode: expr0_0,
        imm: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term f32const.
pub fn constructor_f32const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee32) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 865.
    let expr0_0 = Opcode::F32const;
    let expr1_0 = InstructionImms::UnaryIeee32 {
        opcode: expr0_0,
        imm: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term f64const.
pub fn constructor_f64const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee64) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 874.
    let expr0_0 = Opcode::F64const;
    let expr1_0 = InstructionImms::UnaryIeee64 {
        opcode: expr0_0,
        imm: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term vconst.
pub fn constructor_vconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Constant) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 883.
    let expr0_0 = Opcode::Vconst;
    let expr1_0 = InstructionImms::UnaryConst {
        opcode: expr0_0,
        constant_handle: pattern1_0,
    };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term shuffle.
pub fn constructor_shuffle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Immediate,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 892.
    let expr0_0 = Opcode::Shuffle;
    let expr1_0 = InstructionImms::Shuffle {
        opcode: expr0_0,
        imm: pattern3_0,
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term null.
pub fn constructor_null<C: Context>(ctx: &mut C, arg0: Type) -> Option<Id> {
    let pattern0_0 = arg0;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 901.
    let expr0_0 = Opcode::Null;
    let expr1_0 = InstructionImms::NullAry { opcode: expr0_0 };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term nop.
pub fn constructor_nop<C: Context>(ctx: &mut C, arg0: Type) -> Option<Id> {
    let pattern0_0 = arg0;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 910.
    let expr0_0 = Opcode::Nop;
    let expr1_0 = InstructionImms::NullAry { opcode: expr0_0 };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term select.
pub fn constructor_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 919.
    let expr0_0 = Opcode::Select;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term select_spectre_guard.
pub fn constructor_select_spectre_guard<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 928.
    let expr0_0 = Opcode::SelectSpectreGuard;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bitselect.
pub fn constructor_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 937.
    let expr0_0 = Opcode::Bitselect;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term vsplit.
pub fn constructor_vsplit<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 946.
    let expr0_0 = Opcode::Vsplit;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term vconcat.
pub fn constructor_vconcat<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 955.
    let expr0_0 = Opcode::Vconcat;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term vselect.
pub fn constructor_vselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 964.
    let expr0_0 = Opcode::Vselect;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term vany_true.
pub fn constructor_vany_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 973.
    let expr0_0 = Opcode::VanyTrue;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term vall_true.
pub fn constructor_vall_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 982.
    let expr0_0 = Opcode::VallTrue;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term vhigh_bits.
pub fn constructor_vhigh_bits<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 991.
    let expr0_0 = Opcode::VhighBits;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term icmp.
pub fn constructor_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1000.
    let expr0_0 = Opcode::Icmp;
    let expr1_0 = InstructionImms::IntCompare {
        opcode: expr0_0,
        cond: pattern1_0.clone(),
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term icmp_imm.
pub fn constructor_icmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Id,
    arg3: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1009.
    let expr0_0 = Opcode::IcmpImm;
    let expr1_0 = InstructionImms::IntCompareImm {
        opcode: expr0_0,
        cond: pattern1_0.clone(),
        imm: pattern3_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ifcmp.
pub fn constructor_ifcmp<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1018.
    let expr0_0 = Opcode::Ifcmp;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ifcmp_imm.
pub fn constructor_ifcmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1027.
    let expr0_0 = Opcode::IfcmpImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iadd.
pub fn constructor_iadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1036.
    let expr0_0 = Opcode::Iadd;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term isub.
pub fn constructor_isub<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1045.
    let expr0_0 = Opcode::Isub;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ineg.
pub fn constructor_ineg<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1054.
    let expr0_0 = Opcode::Ineg;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iabs.
pub fn constructor_iabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1063.
    let expr0_0 = Opcode::Iabs;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term imul.
pub fn constructor_imul<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1072.
    let expr0_0 = Opcode::Imul;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term umulhi.
pub fn constructor_umulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1081.
    let expr0_0 = Opcode::Umulhi;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term smulhi.
pub fn constructor_smulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1090.
    let expr0_0 = Opcode::Smulhi;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sqmul_round_sat.
pub fn constructor_sqmul_round_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1099.
    let expr0_0 = Opcode::SqmulRoundSat;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term udiv.
pub fn constructor_udiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1108.
    let expr0_0 = Opcode::Udiv;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sdiv.
pub fn constructor_sdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1117.
    let expr0_0 = Opcode::Sdiv;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term urem.
pub fn constructor_urem<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1126.
    let expr0_0 = Opcode::Urem;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term srem.
pub fn constructor_srem<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1135.
    let expr0_0 = Opcode::Srem;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iadd_imm.
pub fn constructor_iadd_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1144.
    let expr0_0 = Opcode::IaddImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term imul_imm.
pub fn constructor_imul_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1153.
    let expr0_0 = Opcode::ImulImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term udiv_imm.
pub fn constructor_udiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1162.
    let expr0_0 = Opcode::UdivImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sdiv_imm.
pub fn constructor_sdiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1171.
    let expr0_0 = Opcode::SdivImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term urem_imm.
pub fn constructor_urem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1180.
    let expr0_0 = Opcode::UremImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term srem_imm.
pub fn constructor_srem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1189.
    let expr0_0 = Opcode::SremImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term irsub_imm.
pub fn constructor_irsub_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1198.
    let expr0_0 = Opcode::IrsubImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iadd_cin.
pub fn constructor_iadd_cin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1207.
    let expr0_0 = Opcode::IaddCin;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iadd_ifcin.
pub fn constructor_iadd_ifcin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1216.
    let expr0_0 = Opcode::IaddIfcin;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iadd_cout.
pub fn constructor_iadd_cout<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1225.
    let expr0_0 = Opcode::IaddCout;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iadd_ifcout.
pub fn constructor_iadd_ifcout<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1234.
    let expr0_0 = Opcode::IaddIfcout;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iadd_carry.
pub fn constructor_iadd_carry<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1243.
    let expr0_0 = Opcode::IaddCarry;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iadd_ifcarry.
pub fn constructor_iadd_ifcarry<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1252.
    let expr0_0 = Opcode::IaddIfcarry;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uadd_overflow_trap.
pub fn constructor_uadd_overflow_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: &TrapCode,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1261.
    let expr0_0 = Opcode::UaddOverflowTrap;
    let expr1_0 = InstructionImms::IntAddTrap {
        opcode: expr0_0,
        code: pattern3_0.clone(),
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term isub_bin.
pub fn constructor_isub_bin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1270.
    let expr0_0 = Opcode::IsubBin;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term isub_ifbin.
pub fn constructor_isub_ifbin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1279.
    let expr0_0 = Opcode::IsubIfbin;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term isub_bout.
pub fn constructor_isub_bout<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1288.
    let expr0_0 = Opcode::IsubBout;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term isub_ifbout.
pub fn constructor_isub_ifbout<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1297.
    let expr0_0 = Opcode::IsubIfbout;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term isub_borrow.
pub fn constructor_isub_borrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1306.
    let expr0_0 = Opcode::IsubBorrow;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term isub_ifborrow.
pub fn constructor_isub_ifborrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1315.
    let expr0_0 = Opcode::IsubIfborrow;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term band.
pub fn constructor_band<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1324.
    let expr0_0 = Opcode::Band;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bor.
pub fn constructor_bor<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1333.
    let expr0_0 = Opcode::Bor;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bxor.
pub fn constructor_bxor<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1342.
    let expr0_0 = Opcode::Bxor;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bnot.
pub fn constructor_bnot<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1351.
    let expr0_0 = Opcode::Bnot;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term band_not.
pub fn constructor_band_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1360.
    let expr0_0 = Opcode::BandNot;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bor_not.
pub fn constructor_bor_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1369.
    let expr0_0 = Opcode::BorNot;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bxor_not.
pub fn constructor_bxor_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1378.
    let expr0_0 = Opcode::BxorNot;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term band_imm.
pub fn constructor_band_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1387.
    let expr0_0 = Opcode::BandImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bor_imm.
pub fn constructor_bor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1396.
    let expr0_0 = Opcode::BorImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bxor_imm.
pub fn constructor_bxor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1405.
    let expr0_0 = Opcode::BxorImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term rotl.
pub fn constructor_rotl<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1414.
    let expr0_0 = Opcode::Rotl;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term rotr.
pub fn constructor_rotr<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1423.
    let expr0_0 = Opcode::Rotr;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term rotl_imm.
pub fn constructor_rotl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1432.
    let expr0_0 = Opcode::RotlImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term rotr_imm.
pub fn constructor_rotr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1441.
    let expr0_0 = Opcode::RotrImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ishl.
pub fn constructor_ishl<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1450.
    let expr0_0 = Opcode::Ishl;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ushr.
pub fn constructor_ushr<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1459.
    let expr0_0 = Opcode::Ushr;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sshr.
pub fn constructor_sshr<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1468.
    let expr0_0 = Opcode::Sshr;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ishl_imm.
pub fn constructor_ishl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1477.
    let expr0_0 = Opcode::IshlImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ushr_imm.
pub fn constructor_ushr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1486.
    let expr0_0 = Opcode::UshrImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sshr_imm.
pub fn constructor_sshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Imm64,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1495.
    let expr0_0 = Opcode::SshrImm;
    let expr1_0 = InstructionImms::BinaryImm64 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bitrev.
pub fn constructor_bitrev<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1504.
    let expr0_0 = Opcode::Bitrev;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term clz.
pub fn constructor_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1513.
    let expr0_0 = Opcode::Clz;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term cls.
pub fn constructor_cls<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1522.
    let expr0_0 = Opcode::Cls;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ctz.
pub fn constructor_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1531.
    let expr0_0 = Opcode::Ctz;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bswap.
pub fn constructor_bswap<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1540.
    let expr0_0 = Opcode::Bswap;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term popcnt.
pub fn constructor_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1549.
    let expr0_0 = Opcode::Popcnt;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fcmp.
pub fn constructor_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1558.
    let expr0_0 = Opcode::Fcmp;
    let expr1_0 = InstructionImms::FloatCompare {
        opcode: expr0_0,
        cond: pattern1_0.clone(),
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ffcmp.
pub fn constructor_ffcmp<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1567.
    let expr0_0 = Opcode::Ffcmp;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fadd.
pub fn constructor_fadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1576.
    let expr0_0 = Opcode::Fadd;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fsub.
pub fn constructor_fsub<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1585.
    let expr0_0 = Opcode::Fsub;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fmul.
pub fn constructor_fmul<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1594.
    let expr0_0 = Opcode::Fmul;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fdiv.
pub fn constructor_fdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1603.
    let expr0_0 = Opcode::Fdiv;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sqrt.
pub fn constructor_sqrt<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1612.
    let expr0_0 = Opcode::Sqrt;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fma.
pub fn constructor_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1621.
    let expr0_0 = Opcode::Fma;
    let expr1_0 = InstructionImms::Ternary { opcode: expr0_0 };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fneg.
pub fn constructor_fneg<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1630.
    let expr0_0 = Opcode::Fneg;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fabs.
pub fn constructor_fabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1639.
    let expr0_0 = Opcode::Fabs;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fcopysign.
pub fn constructor_fcopysign<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1648.
    let expr0_0 = Opcode::Fcopysign;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fmin.
pub fn constructor_fmin<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1657.
    let expr0_0 = Opcode::Fmin;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fmin_pseudo.
pub fn constructor_fmin_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1666.
    let expr0_0 = Opcode::FminPseudo;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fmax.
pub fn constructor_fmax<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1675.
    let expr0_0 = Opcode::Fmax;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fmax_pseudo.
pub fn constructor_fmax_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1684.
    let expr0_0 = Opcode::FmaxPseudo;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ceil.
pub fn constructor_ceil<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1693.
    let expr0_0 = Opcode::Ceil;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term floor.
pub fn constructor_floor<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1702.
    let expr0_0 = Opcode::Floor;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term trunc.
pub fn constructor_trunc<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1711.
    let expr0_0 = Opcode::Trunc;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term nearest.
pub fn constructor_nearest<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1720.
    let expr0_0 = Opcode::Nearest;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term is_null.
pub fn constructor_is_null<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1729.
    let expr0_0 = Opcode::IsNull;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term is_invalid.
pub fn constructor_is_invalid<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1738.
    let expr0_0 = Opcode::IsInvalid;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bitcast.
pub fn constructor_bitcast<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1747.
    let expr0_0 = Opcode::Bitcast;
    let expr1_0 = InstructionImms::LoadNoOffset {
        opcode: expr0_0,
        flags: pattern1_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term scalar_to_vector.
pub fn constructor_scalar_to_vector<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1756.
    let expr0_0 = Opcode::ScalarToVector;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term bmask.
pub fn constructor_bmask<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1765.
    let expr0_0 = Opcode::Bmask;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term ireduce.
pub fn constructor_ireduce<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1774.
    let expr0_0 = Opcode::Ireduce;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term snarrow.
pub fn constructor_snarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1783.
    let expr0_0 = Opcode::Snarrow;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term unarrow.
pub fn constructor_unarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1792.
    let expr0_0 = Opcode::Unarrow;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uunarrow.
pub fn constructor_uunarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1801.
    let expr0_0 = Opcode::Uunarrow;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term swiden_low.
pub fn constructor_swiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1810.
    let expr0_0 = Opcode::SwidenLow;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term swiden_high.
pub fn constructor_swiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1819.
    let expr0_0 = Opcode::SwidenHigh;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uwiden_low.
pub fn constructor_uwiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1828.
    let expr0_0 = Opcode::UwidenLow;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uwiden_high.
pub fn constructor_uwiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1837.
    let expr0_0 = Opcode::UwidenHigh;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iadd_pairwise.
pub fn constructor_iadd_pairwise<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1846.
    let expr0_0 = Opcode::IaddPairwise;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term widening_pairwise_dot_product_s.
pub fn constructor_widening_pairwise_dot_product_s<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1855.
    let expr0_0 = Opcode::WideningPairwiseDotProductS;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term uextend.
pub fn constructor_uextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1864.
    let expr0_0 = Opcode::Uextend;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term sextend.
pub fn constructor_sextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1873.
    let expr0_0 = Opcode::Sextend;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fpromote.
pub fn constructor_fpromote<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1882.
    let expr0_0 = Opcode::Fpromote;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fdemote.
pub fn constructor_fdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1891.
    let expr0_0 = Opcode::Fdemote;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fvdemote.
pub fn constructor_fvdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1900.
    let expr0_0 = Opcode::Fvdemote;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fvpromote_low.
pub fn constructor_fvpromote_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1909.
    let expr0_0 = Opcode::FvpromoteLow;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fcvt_to_uint.
pub fn constructor_fcvt_to_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1918.
    let expr0_0 = Opcode::FcvtToUint;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fcvt_to_sint.
pub fn constructor_fcvt_to_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1927.
    let expr0_0 = Opcode::FcvtToSint;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fcvt_to_uint_sat.
pub fn constructor_fcvt_to_uint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1936.
    let expr0_0 = Opcode::FcvtToUintSat;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fcvt_to_sint_sat.
pub fn constructor_fcvt_to_sint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1945.
    let expr0_0 = Opcode::FcvtToSintSat;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fcvt_from_uint.
pub fn constructor_fcvt_from_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1954.
    let expr0_0 = Opcode::FcvtFromUint;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fcvt_from_sint.
pub fn constructor_fcvt_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1963.
    let expr0_0 = Opcode::FcvtFromSint;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fcvt_low_from_sint.
pub fn constructor_fcvt_low_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1972.
    let expr0_0 = Opcode::FcvtLowFromSint;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term isplit.
pub fn constructor_isplit<C: Context>(ctx: &mut C, arg0: Type, arg1: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1981.
    let expr0_0 = Opcode::Isplit;
    let expr1_0 = InstructionImms::Unary { opcode: expr0_0 };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term iconcat.
pub fn constructor_iconcat<C: Context>(ctx: &mut C, arg0: Type, arg1: Id, arg2: Id) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1990.
    let expr0_0 = Opcode::Iconcat;
    let expr1_0 = InstructionImms::Binary { opcode: expr0_0 };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term atomic_rmw.
pub fn constructor_atomic_rmw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: &AtomicRmwOp,
    arg3: Id,
    arg4: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 1999.
    let expr0_0 = Opcode::AtomicRmw;
    let expr1_0 = InstructionImms::AtomicRmw {
        opcode: expr0_0,
        flags: pattern1_0,
        op: pattern2_0.clone(),
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern3_0, pattern4_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term atomic_cas.
pub fn constructor_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Id,
    arg4: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 2008.
    let expr0_0 = Opcode::AtomicCas;
    let expr1_0 = InstructionImms::AtomicCas {
        opcode: expr0_0,
        flags: pattern1_0,
    };
    let expr2_0 = C::id_array_3_ctor(ctx, pattern2_0, pattern3_0, pattern4_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term atomic_load.
pub fn constructor_atomic_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 2017.
    let expr0_0 = Opcode::AtomicLoad;
    let expr1_0 = InstructionImms::LoadNoOffset {
        opcode: expr0_0,
        flags: pattern1_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern2_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term atomic_store.
pub fn constructor_atomic_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Id,
    arg3: Id,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 2026.
    let expr0_0 = Opcode::AtomicStore;
    let expr1_0 = InstructionImms::StoreNoOffset {
        opcode: expr0_0,
        flags: pattern1_0,
    };
    let expr2_0 = C::id_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term fence.
pub fn constructor_fence<C: Context>(ctx: &mut C, arg0: Type) -> Option<Id> {
    let pattern0_0 = arg0;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 2035.
    let expr0_0 = Opcode::Fence;
    let expr1_0 = InstructionImms::NullAry { opcode: expr0_0 };
    let expr2_0 = C::id_array_0_ctor(ctx);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term extract_vector.
pub fn constructor_extract_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Id,
    arg2: Uimm8,
) -> Option<Id> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/xiangyiz/workspace/near/nearcore_fork/master/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_opt.isle line 2044.
    let expr0_0 = Opcode::ExtractVector;
    let expr1_0 = InstructionImms::BinaryImm8 {
        opcode: expr0_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::id_array_1_ctor(ctx, pattern1_0);
    let expr3_0 = C::pure_enode_ctor(ctx, pattern0_0, &expr1_0, expr2_0);
    return Some(expr3_0);
}
