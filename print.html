<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Guide to Nearcore Development</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Architecture</li><li class="chapter-item expanded "><a href="architecture/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="architecture/how/index.html"><strong aria-hidden="true">2.</strong> How neard works</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/how/sync.html"><strong aria-hidden="true">2.1.</strong> How Sync Works</a></li><li class="chapter-item expanded "><a href="architecture/how/gc.html"><strong aria-hidden="true">2.2.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="architecture/how/epoch.html"><strong aria-hidden="true">2.3.</strong> How Epoch Works</a></li><li class="chapter-item expanded "><a href="architecture/how/tx_routing.html"><strong aria-hidden="true">2.4.</strong> Transaction Routing</a></li><li class="chapter-item expanded "><a href="architecture/how/tx_receipts.html"><strong aria-hidden="true">2.5.</strong> Transactions And Receipts</a></li><li class="chapter-item expanded "><a href="architecture/how/cross-shard.html"><strong aria-hidden="true">2.6.</strong> Cross shard transactions - deep dive</a></li><li class="chapter-item expanded "><a href="architecture/how/gas.html"><strong aria-hidden="true">2.7.</strong> Gas</a></li><li class="chapter-item expanded "><a href="architecture/how/receipt-congestion.html"><strong aria-hidden="true">2.8.</strong> Receipt Congestion</a></li><li class="chapter-item expanded "><a href="architecture/how/meta-tx.html"><strong aria-hidden="true">2.9.</strong> Meta transactions</a></li><li class="chapter-item expanded "><a href="architecture/how/serialization.html"><strong aria-hidden="true">2.10.</strong> Serialization: Borsh, Json, ProtoBuf</a></li><li class="chapter-item expanded "><a href="architecture/how/proofs.html"><strong aria-hidden="true">2.11.</strong> Proofs</a></li><li class="chapter-item expanded "><a href="architecture/how/resharding_v2.html"><strong aria-hidden="true">2.12.</strong> Resharding V2</a></li></ol></li><li class="chapter-item expanded "><a href="architecture/next/index.html"><strong aria-hidden="true">3.</strong> How neard will work</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/next/catchup_and_state_sync.html"><strong aria-hidden="true">3.1.</strong> Catchup and state sync improvements</a></li><li class="chapter-item expanded "><a href="architecture/next/malicious_chunk_producer_and_phase2.html"><strong aria-hidden="true">3.2.</strong> Malicious producers and phase 2</a></li></ol></li><li class="chapter-item expanded "><a href="architecture/storage.html"><strong aria-hidden="true">4.</strong> Storage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/storage/flow.html"><strong aria-hidden="true">4.1.</strong> Storage Request Flow</a></li><li class="chapter-item expanded "><a href="architecture/storage/trie_storage.html"><strong aria-hidden="true">4.2.</strong> Trie Storage</a></li><li class="chapter-item expanded "><a href="architecture/storage/database.html"><strong aria-hidden="true">4.3.</strong> Database Format</a></li><li class="chapter-item expanded "><a href="architecture/storage/flat_storage.html"><strong aria-hidden="true">4.4.</strong> Flat Storage</a></li></ol></li><li class="chapter-item expanded "><a href="architecture/network.html"><strong aria-hidden="true">5.</strong> Network</a></li><li class="chapter-item expanded "><a href="architecture/gas/index.html"><strong aria-hidden="true">6.</strong> Gas Cost Parameters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/gas/parameter_definition.html"><strong aria-hidden="true">6.1.</strong> Parameter Definitions</a></li><li class="chapter-item expanded "><a href="architecture/gas/gas_profile.html"><strong aria-hidden="true">6.2.</strong> Gas Profile</a></li><li class="chapter-item expanded "><a href="architecture/gas/estimator.html"><strong aria-hidden="true">6.3.</strong> Runtime Parameter Estimator</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Practices</li><li class="chapter-item expanded "><a href="practices/index.html"><strong aria-hidden="true">7.</strong> Overview</a></li><li class="chapter-item expanded "><a href="practices/rust.html"><strong aria-hidden="true">8.</strong> Rust 🦀</a></li><li class="chapter-item expanded "><a href="practices/workflows/index.html"><strong aria-hidden="true">9.</strong> Workflows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practices/workflows/run_a_node.html"><strong aria-hidden="true">9.1.</strong> Run a Node</a></li><li class="chapter-item expanded "><a href="practices/workflows/deploy_a_contract.html"><strong aria-hidden="true">9.2.</strong> Deploy a Contract</a></li><li class="chapter-item expanded "><a href="practices/workflows/gas_estimations.html"><strong aria-hidden="true">9.3.</strong> Run Gas Estimations</a></li><li class="chapter-item expanded "><a href="practices/workflows/localnet_on_many_machines.html"><strong aria-hidden="true">9.4.</strong> Localnet on many machines</a></li><li class="chapter-item expanded "><a href="practices/workflows/io_trace.html"><strong aria-hidden="true">9.5.</strong> IO tracing</a></li><li class="chapter-item expanded "><a href="practices/workflows/profiling.html"><strong aria-hidden="true">9.6.</strong> Profiling</a></li><li class="chapter-item expanded "><a href="practices/workflows/otel_traces.html"><strong aria-hidden="true">9.7.</strong> Working with OpenTelemetry Traces</a></li></ol></li><li class="chapter-item expanded "><a href="practices/style.html"><strong aria-hidden="true">10.</strong> Code Style</a></li><li class="chapter-item expanded "><a href="practices/docs.html"><strong aria-hidden="true">11.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="practices/tracking_issues.html"><strong aria-hidden="true">12.</strong> Tracking Issues</a></li><li class="chapter-item expanded "><a href="practices/security_vulnerabilities.html"><strong aria-hidden="true">13.</strong> Security Vulnerabilities</a></li><li class="chapter-item expanded "><a href="practices/fast_builds.html"><strong aria-hidden="true">14.</strong> Fast Builds</a></li><li class="chapter-item expanded "><a href="practices/testing/index.html"><strong aria-hidden="true">15.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practices/testing/python_tests.html"><strong aria-hidden="true">15.1.</strong> Python Tests</a></li><li class="chapter-item expanded "><a href="practices/testing/test_utils.html"><strong aria-hidden="true">15.2.</strong> Testing Utils</a></li><li class="chapter-item expanded "><a href="practices/testing/coverage.html"><strong aria-hidden="true">15.3.</strong> Test Coverage</a></li></ol></li><li class="chapter-item expanded "><a href="practices/protocol_upgrade.html"><strong aria-hidden="true">16.</strong> Protocol Upgrade</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced configuration</li><li class="chapter-item expanded "><a href="advanced_configuration/networking.html"><strong aria-hidden="true">17.</strong> Networking</a></li><li class="chapter-item expanded affix "><li class="part-title">Custom test networks</li><li class="chapter-item expanded "><a href="test_networks/mainnet_spoon.html"><strong aria-hidden="true">18.</strong> Starting a network from mainnet state</a></li><li class="chapter-item expanded affix "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="misc/index.html"><strong aria-hidden="true">19.</strong> Overview</a></li><li class="chapter-item expanded "><a href="misc/state_sync_dump.html"><strong aria-hidden="true">20.</strong> State Sync Dump</a></li><li class="chapter-item expanded "><a href="misc/archival_data_recovery.html"><strong aria-hidden="true">21.</strong> Archival node - recovery of missing data</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Guide to Nearcore Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/near/nearcore/tree/master/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the nearcore development guide!</p>
<p>The target audience of this guide is developers of nearcore itself. If you are
a user of NEAR (either a contract developer, or validator running a node),
please refer to the user docs at <a href="https://docs.near.org">https://docs.near.org</a>.</p>
<p>This guide is built with <a href="https://rust-lang.github.io/mdBook/">mdBook</a>
from sources in the <a href="https://github.com/near/nearcore/">nearcore repository</a>.
You can edit it by pressing the &quot;edit&quot; icon in the top right corner, we welcome
all contributions. The guide is hosted at <a href="https://near.github.io/nearcore/">https://near.github.io/nearcore/</a>.</p>
<p>The guide is organized as a collection of loosely coupled chapters -- you don't
need to read them in order, feel free to peruse the TOC, and focus on
the interesting bits. The chapters are classified into three parts:</p>
<ul>
<li><a href="./architecture/"><strong>Architecture</strong></a> talks about how the code works.
So, for example, if you are interested in how a transaction flows through the
system, look there!</li>
<li><a href="./practices/"><strong>Practices</strong></a> describe, broadly, how we write code.
For example, if you want to learn about code style, issue tracking, or
debugging performance problems, this is the chapter for you.</li>
<li>Finally, the <a href="./misc/"><strong>Misc</strong></a> part holds various assorted bits
and pieces. We are trying to bias ourselves towards writing more docs, so, if
you want to document something and it doesn't cleanly map to a category above,
just put it in misc!</li>
</ul>
<p>If you are unsure, start with <a href="./architecture/">Architecture Overview</a> and then
read <a href="./practices/workflows/run_a_node.html">Run a Node</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This document describes the high-level architecture of nearcore. The focus here
is on the implementation of the blockchain protocol, not the protocol itself.
For reference documentation of the protocol, please refer to
<a href="https://nomicon.io/">nomicon</a></p>
<p>Some parts of our architecture are also covered in this <a href="https://www.youtube.com/playlist?list=PL9tzQn_TEuFV4qlts0tVgndnytFs4QSYo">video series on YouTube</a>.</p>
<h2 id="birds-eye-view"><a class="header" href="#birds-eye-view">Bird's Eye View</a></h2>
<p>If we put the entirety of nearcore onto one picture, we get something like this:</p>
<p><img src="architecture/../images/architecture.svg" alt="" /></p>
<p>Don't worry if this doesn't yet make a lot of sense: hopefully, by the end of
this document the above picture would become much clearer!</p>
<h2 id="overall-operation"><a class="header" href="#overall-operation">Overall Operation</a></h2>
<p><code>nearcore</code> is a blockchain node -- it's a single binary (<code>neard</code>) which runs on
some machine and talks to other similar binaries running elsewhere. Together,
the nodes agree (using a distributed consensus algorithm) on a particular
sequence of transactions. Once transaction sequence is established, each node
applies transactions to the current state. Because transactions are fully
deterministic, each node in the network ends up with identical state. To allow
greater scalability, NEAR protocol uses sharding, which allows a node to hold
only a small subset (shard) of the whole state.</p>
<p><code>neard</code> is a stateful, restartable process. When <code>neard</code> starts, the node
connects to the network and starts processing blocks (block is a batch of
transactions, processed together; transactions are batched into blocks for
greater efficiency). The results of processing are persisted in the database.
RocksDB is used for storage. Usually, the node's data is found in the <code>~/.near</code>
directory. The node can be stopped at any moment and be restarted later. While
the node is offline it misses the block, so, after a restart, the sync process
kicks in which brings the node up-to-speed with the network by downloading the
missing bits of history from more up-to-date peer nodes.</p>
<p>Major components of nearcore:</p>
<ul>
<li>
<p><strong>JSON RPC</strong>. This HTTP RPC interface is how <code>neard</code> communicates with
non-blockchain outside world. For example, to submit a transaction, some
client sends an RPC request with it to some node in the network. From that
node, the transaction propagates through the network, until it is included in
some block. Similarly, a client can send an HTTP request to a node to learn
about current state of the blockchain. The <strong>JSON RPC</strong> interface is documented
<a href="https://docs.near.org/api/rpc/introduction">here</a>.</p>
</li>
<li>
<p><strong>Network</strong>. If RPC is aimed &quot;outside&quot; the blockchain, &quot;network&quot; is how peer
<code>neard</code> nodes communicate with each other within the blockchain. RPC carries
requests from users of the blockchain, while network carries various messages
needed to implement consensus. Two directly connected nodes communicate by
sending protobuf-encoded messages over TCP. A node also includes logic to
route messages for indirect peers through intermediaries. Oversimplifying a
lot, it's enough for a new node to know an IP address of just one other
network participant. From this bootstrap connection, the node learns how to
communicate with any other node in the network.</p>
</li>
<li>
<p><strong>Client</strong>. Somewhat confusingly named, <strong>client</strong> is the logical state of the
blockchain. After receiving and decoding a request, both <strong>RPC</strong> and <strong>network</strong>
usually forward it in the parsed form to the <strong>client</strong>. Internally, <strong>client</strong> is
split in two somewhat independent components: <strong>chain</strong> and <strong>runtime</strong>.</p>
</li>
<li>
<p><strong>Chain</strong>. The job of <strong>chain</strong>, in a nutshell, is to determine a global order of
transactions. <strong>Chain</strong> builds and maintains the blockchain data structure. This
includes block and chunk production and processing, consensus, and validator
selection. However, <strong>chain</strong> is not responsible for actually applying
transactions and receipts.</p>
</li>
<li>
<p><strong>Runtime</strong>. If <strong>chain</strong> selects the <em>order</em> of transactions, <strong>Runtime</strong> applies
transaction to the state. <strong>Chain</strong> guarantees that everyone agrees on the order
and content of transactions, and <strong>Runtime</strong> guarantees that each transaction is
fully deterministic. It follows that everyone agrees on the &quot;current state&quot; of
the blockchain. Some transactions are as simple as &quot;transfer X tokens from
Alice to Bob&quot;. But a much more powerful class of transactions is supported:
&quot;run this arbitrary WebAssembly code in the context of the current state of
the chain&quot;. Running such &quot;smart contract&quot; transactions securely and
efficiently is a major part of what <strong>Runtime</strong> does. Today, <strong>Runtime</strong> uses a JIT
compiler to do that.</p>
</li>
<li>
<p><strong>Storage</strong>. <strong>Storage</strong> is more of a cross-cutting concern, than an isolated
component. Many parts of a node want to durably persist various bits of state
to disk. One notable case is the logical state of the blockchain, and, in
particular, data associated with each account. Logically, the state of an account
on a chain is a key-value map: <code>HashMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;</code>. But there is a
twist: it should be possible to provide a succinct proof that a particular key
indeed holds a particular value. To allow that internally the state is
implemented as a persistent (in both senses, &quot;functional&quot; and &quot;on disk&quot;)
merkle-patricia trie.</p>
</li>
<li>
<p><strong>Parameter Estimator</strong>. One kind of transaction we support is &quot;run this
arbitrary, Turing-complete computation&quot;. To protect from a <code>loop {}</code>
transaction halting the whole network, <strong>Runtime</strong> implements resource limiting:
each transaction runs with a certain finite amount of &quot;gas&quot;, and each
operation costs a certain amount of gas to perform. <strong>Parameter estimator</strong> is
essentially a set of benchmarks used to estimate relative gas costs of
various operations.</p>
</li>
</ul>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry Points</a></h2>
<p><code>neard/src/main.rs</code> contains the main function that starts a blockchain node.
However, this file mostly only contains the logic to parse arguments and
dispatch different commands. <code>start_with_config</code> in <code>nearcore/src/lib.rs</code> is the
actual entry point and it starts all the actors.</p>
<p><code>JsonRpcHandler::process</code> in the <code>jsonrpc</code> crate is the RPC entry point. It
implements the public API of a node, which is documented
<a href="https://docs.near.org/api/rpc/introduction">here</a>.</p>
<p><code>PeerManagerActor::spawn</code> in the <code>network</code> is an entry for the other point of
contract with the outside world -- the peer-to-peer network.</p>
<p><code>Runtime::apply</code> in the <code>runtime</code> crate is the entry point for transaction
processing logic. This is where state transitions actually happen, after chain
decided, according to distributed consensus, which transitions need  to
happen.</p>
<h2 id="code-map"><a class="header" href="#code-map">Code Map</a></h2>
<p>This section contains some high-level overview of important crates and data
structures.</p>
<h3 id="coreprimitives"><a class="header" href="#coreprimitives"><code>core/primitives</code></a></h3>
<p>This crate contains most of the types that are shared across different crates.</p>
<h3 id="coreprimitives-core"><a class="header" href="#coreprimitives-core"><code>core/primitives-core</code></a></h3>
<p>This crate contains types needed for runtime.</p>
<h3 id="corestoretrie"><a class="header" href="#corestoretrie"><code>core/store/trie</code></a></h3>
<p>This directory contains the MPT state implementation. Note that we usually use
<code>TrieUpdate</code> to interact with the state.</p>
<h3 id="chainchain"><a class="header" href="#chainchain"><code>chain/chain</code></a></h3>
<p>This crate contains most of the chain logic (consensus, block processing, etc).
<code>ChainUpdate::process_block</code> is where most of the block processing logic
happens.</p>
<p><strong>State update</strong></p>
<p>The blockchain state of a node can be changed in the following two ways:</p>
<ul>
<li>Applying a chunk. This is how the state is normally updated: through
<code>Runtime::apply</code>.</li>
<li>State sync. State sync can happen in two cases:
<ul>
<li>A node is far enough behind the most recent block and triggers state sync to
fast forward to the state of a very recent block without having to apply
blocks in the middle.</li>
<li>A node is about to become validator for some shard in the next epoch, but it
does not yet have the state for that shard. In this case, it would run state
sync through the <code>catchup</code> routine.</li>
</ul>
</li>
</ul>
<h3 id="chainchunks"><a class="header" href="#chainchunks"><code>chain/chunks</code></a></h3>
<p>This crate contains most of the sharding logic which includes chunk creation,
distribution, and processing. <code>ShardsManager</code> is the main struct that
orchestrates everything here.</p>
<h3 id="chainclient"><a class="header" href="#chainclient"><code>chain/client</code></a></h3>
<p>This crate defines two important structs, <code>Client</code> and <code>ViewClient</code>. <code>Client</code>
includes everything necessary for the chain (without network and runtime) to
function and runs in a single thread. <code>ViewClient</code> is a &quot;read-only&quot; client that
answers queries without interfering with the operations of <code>Client</code>.
<code>ViewClient</code> runs in multiple threads.</p>
<h3 id="chainnetwork"><a class="header" href="#chainnetwork"><code>chain/network</code></a></h3>
<p>This crate contains the entire implementation of the p2p network used by NEAR
blockchain nodes.</p>
<p>Two important structs here: <code>PeerManagerActor</code> and <code>Peer</code>. Peer manager
orchestrates all the communications from network to other components and from
other components to network. <code>Peer</code> is responsible for low-level network
communications from and to a given peer (more details in
<a href="architecture/./network.html#23-peeractor">this article</a>). Peer manager runs in one thread while each
<code>Peer</code> runs in its own thread.</p>
<p><strong>Architecture Invariant:</strong> Network communicates to <code>Client</code> through
<code>NetworkClientMessages</code> and to <code>ViewClient</code> through <code>NetworkViewClientMessages</code>.
Conversely, <code>Client</code> and <code>ViewClient</code> communicates to network through
<code>NetworkRequests</code>.</p>
<h3 id="chainepoch_manager"><a class="header" href="#chainepoch_manager"><code>chain/epoch_manager</code></a></h3>
<p>This crate is responsible for determining validators and other epoch related
information such as epoch id for each epoch.</p>
<p><strong>Note:</strong> <code>EpochManager</code> is constructed in <code>NightshadeRuntime</code> rather than in
<code>Chain</code>, partially because we had this idea of making epoch manager a smart
contract.</p>
<h3 id="chainjsonrpc"><a class="header" href="#chainjsonrpc"><code>chain/jsonrpc</code></a></h3>
<p>This crate implements <a href="https://www.jsonrpc.org/">JSON-RPC</a> API server to enable
submission of new transactions and inspection of the blockchain data, the
network state, and the node status. When a request is processed, it generates a
message to either <code>ClientActor</code> or <code>ViewClientActor</code> to interact with the
blockchain. For queries of blockchain data, such as block, chunk, account, etc,
the request usually generates a message to <code>ViewClientActor</code>. Transactions, on
the other hand, are sent to <code>ClientActor</code> for further processing.</p>
<h3 id="runtimeruntime"><a class="header" href="#runtimeruntime"><code>runtime/runtime</code></a></h3>
<p>This crate contains the main entry point to runtime -- <code>Runtime::apply</code>. This
function takes <code>ApplyState</code>, which contains necessary information passed from
chain to runtime, a list of <code>SignedTransaction</code> and a list of <code>Receipt</code>, and
returns an <code>ApplyResult</code>, which includes state changes, execution outcomes, etc.</p>
<p><strong>Architecture Invariant:</strong> The state update is only finalized at the end of
<code>apply</code>. During all intermediate steps state changes can be reverted.</p>
<h3 id="runtimenear-vm-logic"><a class="header" href="#runtimenear-vm-logic"><code>runtime/near-vm-logic</code></a></h3>
<p><code>VMLogic</code> contains all the implementations of host functions and is the
interface between runtime and wasm. <code>VMLogic</code> is constructed when runtime
applies function call actions. In <code>VMLogic</code>, interaction with NEAR blockchain
happens in the following two ways:</p>
<ul>
<li><code>VMContext</code>, which contains lightweight information such as current block
hash, current block height, epoch id, etc.</li>
<li><code>External</code>, which is a trait that contains functions to interact with
blockchain by either reading some nontrivial data, or writing to the
blockchain.</li>
</ul>
<h3 id="runtimenear-vm-runner"><a class="header" href="#runtimenear-vm-runner"><code>runtime/near-vm-runner</code></a></h3>
<p><code>run</code> function in <code>runner.rs</code> is the entry point to the vm runner. This function
essentially spins up the vm and executes some function in a contract. It
supports different wasm compilers including wasmer0, wasmer2, and wasmtime
through compile-time feature flags. Currently we use wasmer0 and wasmer2 in
production. The <code>imports</code> module exposes host functions defined in
<code>near-vm-logic</code> to WASM code. In other words, it defines the ABI of the
contracts on NEAR.</p>
<h3 id="neard"><a class="header" href="#neard"><code>neard</code></a></h3>
<p>As mentioned before, <code>neard</code> is the crate that contains that main entry points.
All the actors are spawned in <code>start_with_config</code>. It is also worth noting that
<code>NightshadeRuntime</code> is the struct that implements <code>RuntimeAdapter</code>.</p>
<!-- TODO: Maybe add RuntimeAdapter mention or explanation in runtime/runtime chapter? -->
<h3 id="corestoresrcdbrs"><a class="header" href="#corestoresrcdbrs"><code>core/store/src/db.rs</code></a></h3>
<p>This file contains the schema (DBCol) of our internal RocksDB storage - a good
starting point when reading the code base.</p>
<h2 id="cross-cutting-concerns"><a class="header" href="#cross-cutting-concerns">Cross Cutting Concerns</a></h2>
<h3 id="observability"><a class="header" href="#observability">Observability</a></h3>
<p>The <a href="https://tracing.rs">tracing</a> crate is used for structured, hierarchical
event output and logging. We also integrate <a href="https://prometheus.io">Prometheus</a>
for light-weight metric output. See the <a href="architecture/../practices/style.html">style</a> documentation for
more information on the usage.</p>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<p>Rust has built-in support for writing unit tests by marking functions
with the <code>#[test]</code> directive.  Take full advantage of that!  Testing not
only confirms that what was written works the way it was intended to but
also helps during refactoring since it catches unintended behaviour
changes.</p>
<p>Not all tests are created equal though and while some may only need
milliseconds to run, others may run for several seconds or even
minutes.  Tests that take a long time should be marked as such by
prefixing their name with <code>slow_test_</code> or <code>ultra_slow_test_</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn ultra_slow_test_catchup_random_single_part_sync() {
    test_catchup_random_single_part_sync_common(false, false, 13)
}
<span class="boring">}
</span></code></pre></pre>
<p>During local development both slow and ultra-slow tests will not run
with a typical <code>just nextest</code> invocation. You can run them with <code>just nextest-slow</code> or <code>just nextest-all</code> locally. CI will run the slow
tests and the <code>ultra_slow</code> ones are left to run on Nayduck.</p>
<p>Because <code>ultra_slow</code> tests are run on nayduck, they need to be explicitly
included in <code>nightly/expensive.txt</code> file; for example:</p>
<pre><code class="language-text">expensive --timeout=1800 near-client near_client tests::catching_up::ultra_slow_test_catchup_random_single_part_sync
expensive --timeout=1800 near-client near_client tests::catching_up::ultra_slow_test_catchup_random_single_part_sync --features nightly
</code></pre>
<p>For more details regarding nightly tests see <code>nightly/README.md</code>.</p>
<p>Note that what counts as a slow test is defined in
<code>.config/nextest.toml</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-neard-works"><a class="header" href="#how-neard-works">How neard works</a></h1>
<p>This chapter describes how neard works with a focus on implementation details
and practical scenarios. To get a better understanding of how the protocol
works, please refer to <a href="https://nomicon.io">nomicon</a>. For a high-level code map
of nearcore, please refer to this <a href="architecture/how/../">document</a>.</p>
<h2 id="high-level-overview"><a class="header" href="#high-level-overview">High level overview</a></h2>
<p>On the high level, neard is a daemon that periodically receives messages from
the network and sends messages to peers based on different triggers. Neard is
implemented using an <a href="https://en.wikipedia.org/wiki/Actor_model">actor
framework</a> called
<a href="https://docs.rs/actix">actix</a>.</p>
<p><strong>Note:</strong> Using actix was decided in the early days of the implementation of
nearcore and by no means represents our confidence in actix. On the contrary, we
have noticed a number of issues with actix and are considering implementing an
actor framework in house.</p>
<p>There are several important actors in neard:</p>
<ul>
<li>
<p><code>PeerActor</code> - Each peer is represented by one peer actor and runs in a separate
thread. It is responsible for sending messages to and receiving messages from
a given peer. After <code>PeerActor</code> receives a message, it will route it to
<code>ClientActor</code>, <code>ViewClientActor</code>, or <code>PeerManagerActor</code> depending on the type
of the message.</p>
</li>
<li>
<p><code>PeerManagerActor</code> - Peer Manager is responsible for receiving messages to send
to the network from either <code>ClientActor</code> or <code>ViewClientActor</code> and routing them to
the right <code>PeerActor</code> to send the bytes over the wire. It is also responsible for
handling some types of network messages received and routed through <code>PeerActor</code>.
For the purpose of this document, we only need to know that <code>PeerManagerActor</code>
handles <code>RoutedMessage</code>s. Peer manager would decide whether the <code>RoutedMessage</code>s
should be routed to <code>ClientActor</code> or <code>ViewClientActor</code>.</p>
</li>
<li>
<p><code>ClientActor</code> - Client actor is the “core” of neard. It contains all the main
logic including consensus, block and chunk processing, state transition, garbage
collection, etc. Client actor is single-threaded.</p>
</li>
<li>
<p><code>ViewClientActor</code> - View client actor can be thought of as a read-only interface
to <strong>client</strong>. It only accesses data stored in a node’s storage and does not mutate
any state. It is used for two purposes:</p>
<ul>
<li>Answering RPC requests by fetching the relevant piece of data from storage.</li>
<li>Handling some network requests that do not require any changes to the
storage, such as header sync, state sync, and block sync requests.</li>
</ul>
<p><code>ViewClientActor</code> runs in four threads by default but this number is configurable.</p>
</li>
</ul>
<h2 id="data-flow-within-neard"><a class="header" href="#data-flow-within-neard">Data flow within <code>neard</code></a></h2>
<p>Flow for incoming messages:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195619986-25798cde-8a91-4721-86bd-93fa924b483a.png" alt="" /></p>
<p>Flow for outgoing messages:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195626792-7697129b-7f9c-4953-b939-0b9bcacaf72c.png" alt="" /></p>
<h2 id="how-neard-operates-when-it-is-fully-synced"><a class="header" href="#how-neard-operates-when-it-is-fully-synced">How neard operates when it is fully synced</a></h2>
<p>When a node is fully synced, the main logic of the node operates in the
following way (the node is assumed to track all shards, as most nodes on mainnet
do today):</p>
<ol>
<li>A block is produced by some block producer and sent to the node through
broadcasting.</li>
<li>The node receives a block and tries to process it. If the node is synced it
presumably has the previous block and the state before the current block to
apply. It then checks whether it has all the chunks available. If the node is
not a validator node, it won’t have any chunk parts and therefore won’t have
the chunks available. If the node is a validator node, it may already have
chunk parts through chunk parts forwarding from other nodes and therefore may
have already reconstructed some chunks. Regardless, if the node doesn’t have all
chunks for all shards, it will request them from peers by parts.</li>
<li>The chunk requests are sent and the node waits for enough chunk parts to be
received to reconstruct the chunks. For each chunk, 1/3 of all the parts<!-- TODO: Is 100 the number of all the parts or one third of all the parts? -->
(100) is sufficient to reconstruct a chunk. If new blocks arrive while waiting
for chunk parts, they will be put into an <code>OrphanPool</code>, waiting to be processed.
If a chunk part request is not responded to within <code>chunk_request_retry_period</code>,
which is set to 400ms by default, then a request for the same chunk part
would be sent again.</li>
<li>After all chunks are reconstructed, the node processes the current block by
applying transactions and receipts from the chunks. Afterwards, it will
update the head according to the fork choice rule, which only looks at block
height. In other words, if the newly processed block is of higher height than
the current head of the node, the head is updated.</li>
<li>The node checks whether any blocks in the <code>OrphanPool</code> are ready to be
processed in a BFS order and processes all of them until none can be
processed anymore. Note that a block is put into the <code>OrphanPool</code> if and
only if its previous block is not accepted.</li>
<li>Upon acceptance of a block, the node would check whether it needs to run
garbage collection. If it needs to, it would garbage collect two blocks worth
of data at a time. The logic of garbage collection is complicated and could
be found <a href="architecture/how/./gc.html">here</a>.</li>
<li>If the node is a validator node, it would start a timer after the current
block is accepted. After <code>min_block_production_delay</code> which is currently
configured to be 1.3s on mainnet, it would send an approval to the block
producer of the next block (current block height + 1).</li>
</ol>
<p>The main logic is illustrated below:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195635652-f0c7ebae-a2e5-423f-8e62-b853b815fcec.png" alt="" /></p>
<h2 id="how-neard-works-when-it-is-synchronizing"><a class="header" href="#how-neard-works-when-it-is-synchronizing">How neard works when it is synchronizing</a></h2>
<p><code>PeerManagerActor</code> periodically sends a <code>NetworkInfo</code> message to <code>ClientActor</code>
to update it on the latest peer information, which includes the height of each
peer. Once <code>ClientActor</code> realizes that it is more than <code>sync_height_threshold</code>
(which by default is set to 1) behind the highest height among peers, it starts
to sync. The synchronization process is done in three steps:</p>
<ol>
<li>
<p>Header sync. The node first identifies the headers it needs to sync through a
<a href="https://github.com/near/nearcore/blob/279044f09a7e6e5e3f26db4898af3655dae6eda6/chain/client/src/sync.rs#L332"><code>get_locator</code></a>
calculation. This is essentially an exponential backoff computation that
tries to identify commonly known headers between the node and its peers. Then
it would request headers from different peers, at most
<code>MAX_BLOCK_HEADER_HASHES</code> (which is 512) headers at a time.</p>
</li>
<li>
<p>After the headers are synced, the node would determine whether it needs to
run state sync. The exact condition can be found
<a href="https://github.com/near/nearcore/blob/279044f09a7e6e5e3f26db4898af3655dae6eda6/chain/client/src/sync.rs#L458">here</a>
but basically a node would do state sync if it is more than 2 epochs behind
the head of the network. State sync is a very complex process and warrants
its own section. We will give a high level overview here.</p>
<ol>
<li>First, the node computes <code>sync_hash</code> which is the hash of the block that
identifies the state that the node wants to sync. This is guaranteed to be
the first block of the most recent epoch. In fact, there is a
<a href="https://github.com/near/nearcore/blob/279044f09a7e6e5e3f26db4898af3655dae6eda6/chain/chain/src/chain.rs#L4292">check</a>
on the receiver side that this is indeed the case. The node would also
request the block whose hash is <code>sync_hash</code></li>
<li>The node <a href="https://github.com/near/nearcore/blob/279044f09a7e6e5e3f26db4898af3655dae6eda6/chain/chain/src/chain.rs#L1809">deletes basically all data (blocks, chunks, state) from its
storage</a>.
This is not an optimal solution, but it makes the implementation for
combining state easier when there is no stale data in storage.</li>
<li>For the state of each shard that the node needs to download, it first
requests a
<a href="https://github.com/near/nearcore/blob/279044f09a7e6e5e3f26db4898af3655dae6eda6/core/primitives/src/syncing.rs#L40">header</a>
that contains some metadata the node needs to know about. Then the node
computes the number of state parts it needs to download and requests those
parts from different peers who track the shard.</li>
<li>After all parts are downloaded, the node <a href="https://github.com/near/nearcore/blob/279044f09a7e6e5e3f26db4898af3655dae6eda6/chain/client/src/client_actor.rs#L1877">combines those state
parts</a>
and then
<a href="https://github.com/near/nearcore/blob/279044f09a7e6e5e3f26db4898af3655dae6eda6/chain/chain/src/chain.rs#L3065">finalizes</a>
the state sync by applying the last chunk included in or before the sync
block so that the node has the state after applying sync block to be able
to apply the next block.</li>
<li>The node <a href="https://github.com/near/nearcore/blob/279044f09a7e6e5e3f26db4898af3655dae6eda6/chain/chain/src/chain.rs#L1874">resets
heads</a>
properly after state sync.</li>
</ol>
</li>
<li>
<p>Block Sync. The node first gets the block with highest height that is on the
canonical chain and request from there <code>MAX_BLOCK_REQUESTS</code> (which is set to 5)
blocks from different peers in a round robin order. The block sync routine
runs again if head has changed (progress is made) or if a timeout (which is
set to 2s) has happened.</p>
</li>
</ol>
<p><strong>Note:</strong> when a block is received and its height is no more than 500 + the
node’s current head height, then the node would request its previous block
automatically. This is called orphan sync and helps to speed up the syncing
process. If, on the other hand, the height is more than 500 + the node’s current
head height, the block is simply dropped.</p>
<!-- TODO: Either this note is incorrect or the block processing diagram is. -->
<h2 id="how-clientactor-works"><a class="header" href="#how-clientactor-works">How <code>ClientActor</code> works</a></h2>
<p>ClientActor has some periodically running routines that are worth noting:</p>
<ul>
<li><a href="https://github.com/near/nearcore/blob/fa78002a1b4119e5efe277c3073b3f333f451ffc/chain/client/src/client_actor.rs#L1198">Doomslug
timer</a> - 
This routine runs every <code>doosmslug_step_period</code> (set to 100ms by default) and
updates consensus information. If the node is a validator node, it also sends
approvals when necessary.</li>
<li><a href="https://github.com/near/nearcore/blob/fa78002a1b4119e5efe277c3073b3f333f451ffc/chain/client/src/client_actor.rs#L991">Block
production</a> - 
This routine runs every <code>block_production_tracking_delay</code> (which is set to
100ms by default) and checks if the node should produce a block.</li>
<li><a href="https://github.com/near/nearcore/blob/fa78002a1b4119e5efe277c3073b3f333f451ffc/chain/client/src/client_actor.rs#L1790">Log
summary</a> - 
Prints a log line that summarizes block rate, average gas used, the height of
the node, etc. every 10 seconds.</li>
<li><a href="https://github.com/near/nearcore/blob/fa78002a1b4119e5efe277c3073b3f333f451ffc/chain/chunks/src/lib.rs#L910">Resend chunk
requests</a> - 
This routine runs every <code>chunk_request_retry_period</code> (which is set to 400ms).
It resends the chunk part requests for those that are not yet responded to.</li>
<li><a href="https://github.com/near/nearcore/blob/fa78002a1b4119e5efe277c3073b3f333f451ffc/chain/client/src/client_actor.rs#L1629">Sync</a> - 
This routine runs every <code>sync_step_period</code> (which is set to 10ms by default)
and checks whether the node needs to sync from its peers and, if needed, also
starts the syncing process.</li>
<li><a href="https://github.com/near/nearcore/blob/fa78002a1b4119e5efe277c3073b3f333f451ffc/chain/client/src/client_actor.rs#L1581">Catch
up</a> - 
This routine runs every <code>catchup_step_period</code> (which is set to 100ms by
default) and runs the catch up process. This only applies if a node validates
shard A in epoch X and is going to validate a different shard B in epoch X+1.
In this case, the node would start downloading the state for shard B at the
beginning of epoch X. After the state downloading is complete, it would apply
all blocks in the current epoch (epoch X) for shard B to ensure that the node
has the state needed to validate shard B when epoch X+1 starts.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-sync-works"><a class="header" href="#how-sync-works">How Sync Works</a></h1>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>While Sync and Catchup sounds similar - they are actually describing two
completely different things.</p>
<p><strong>Sync</strong> - is used when your node falls ‘behind’ other nodes in the network (for
example because it was down for some time or it took longer to process some
blocks etc).</p>
<p><strong>Catchup</strong> - is used when you want (or have to) start caring about (a.k.a.
tracking) additional shards in the future epochs. Currently it should be a no-op
for 99% of nodes (see below).</p>
<p><strong>Tracking shards:</strong> as you know our system has multiple shards (currently 4).
Currently 99% of nodes are tracking all the shards: validators have to - as they
have to validate the chunks from all the shards, and normal nodes mostly also
track all the shards as this is default.</p>
<p>But in the future - we will have more and more people tracking only a subset of
the shards, so the catchup will be increasingly important.</p>
<h2 id="sync"><a class="header" href="#sync">Sync</a></h2>
<p>If your node is behind the head - it will start the sync process (this code is
running periodically in the client_actor and if you’re behind for more than
<code>sync_height_threshold</code> (currently 50) blocks - it will enable the sync.</p>
<p>The Sync behavior differs depending on whether you’re an archival node (which
means you care about the state of each block) or ‘normal’ node - where you care
mostly about the Tip of the network.</p>
<h3 id="step-1-header-sync-archival-node--normal-node-downloading-headers"><a class="header" href="#step-1-header-sync-archival-node--normal-node-downloading-headers">Step 1: Header Sync [archival node &amp; normal node*] (“downloading headers”)</a></h3>
<p>The goal of the header sync is to get all the block headers from your current
HEAD all the way to the top of the chain.</p>
<p>As headers are quite small, we try to request multiple of them in a single call
(currently we ask for 512 headers at once).</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195892312-2fbd8241-87ce-4241-a44d-ff3056b12bab.png" alt="image" /></p>
<h3 id="step-1a-epoch-sync-normal-node--not-implemented-yet"><a class="header" href="#step-1a-epoch-sync-normal-node--not-implemented-yet">Step 1a: Epoch Sync [normal node*] // not implemented yet</a></h3>
<p>While currently normal nodes are using Header sync, we could actually allow them
to do something faster - “light client sync” a.k.a “epoch sync”.</p>
<p>The idea of the epoch sync, is to read “just” a single block header from each
epoch - that has to contain additional information about validators.</p>
<p>This way it would drastically reduce both the time needed for the sync and the
db resources.</p>
<p>Implementation target date is TBD.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195892336-cc117c08-d3ad-43f7-9304-3233b25e8bb1.png" alt="image" /></p>
<p>Notice that in the image above - it is enough to only get the ‘last’ header from
each epoch. For the ‘current’ epoch, we still need to get all the headers.</p>
<h3 id="step-2-state-sync-normal-node"><a class="header" href="#step-2-state-sync-normal-node">Step 2: State sync [normal node]</a></h3>
<p>After header sync - if you notice that you’re too far behind, i.e. the chain
head is at least two epochs ahead of your local head - the node will try to do
the ‘state sync’.</p>
<p>The idea of the state sync is - rather than trying to process all the blocks -
try to ‘jump’ ahead by downloading the freshest state instead - and continue
processing blocks from that place in the chain. As a side effect, it is going to
create a ‘gap’ in the chunks/state on this node (which is fine - as the data
will be garbage collected after 5 epochs anyway). State sync will ONLY sync to
the beginning of the epoch - it cannot sync to any random block.</p>
<p>This step is never run on the archival nodes - as these nodes want to have whole
history and cannot have any gaps.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195892354-cf2befed-98e9-40a2-9b81-b5cf738406e0.png" alt="image" /></p>
<p>In this case, we can skip processing transactions that are in the blocks 124 - 128, and start from 129 (after sync state finishes)</p>
<p>See <a href="architecture/how/../../misc/state_sync_from_external_storage.html">how-to</a> to learn how to configure your node to state sync.</p>
<h3 id="step-3-block-sync-archival-node-normal-node-downloading-blocks"><a class="header" href="#step-3-block-sync-archival-node-normal-node-downloading-blocks">Step 3: Block sync [archival node, normal node] (“downloading blocks”)</a></h3>
<p>The final step is to start requesting and processing blocks as soon as possible,
hoping to catch up with the chain.</p>
<p>Block sync will request up to 5  (<code>MAX_BLOCK_REQUESTS</code>) blocks at a time - sending
explicit Network BlockRequests for each one.</p>
<p>After the response (Block) is received - the code will execute the ‘standard’ path
that tries to add this block to the chain (see section below).</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195892370-b177228b-2520-486a-94fc-67a91978cb58.png" alt="image" /></p>
<p>In this case, we are processing each transaction for each block - until we catch
up with the chain.</p>
<h2 id="side-topic-how-blocks-are-added-to-the-chain"><a class="header" href="#side-topic-how-blocks-are-added-to-the-chain">Side topic: how blocks are added to the chain?</a></h2>
<p>A node can receive a Block in two ways:</p>
<ul>
<li>Either by broadcasting - when a new block is produced, its contents are
broadcasted within the network by the nodes</li>
<li>Or by explicitly sending a BlockRequest to another peer - and getting a Block
in return.</li>
</ul>
<p>(in case of broadcasting, the node will automatically reject any Blocks that are
more than 500 (<code>BLOCK_HORIZON</code>) blocks away from the current HEAD).</p>
<p>When a given block is received, the node checks if it can be added to the
current chain.</p>
<p>If block’s “parent” (<code>prev_block</code>) is not in the chain yet - the block gets added
to the orphan list.</p>
<p>If the parent is already in the chain - we can try to add the block as the head
of the chain.</p>
<p>Before adding the block, we want to download the chunks for the shards that we
are tracking - so in many cases, we’ll call <code>missing_chunks</code> functions that will
try to go ahead and request those chunks.</p>
<p><strong>Note:</strong> as an optimization, we’re also sometimes trying to fetch chunks for
the blocks that are in the orphan pool – but only if they are not more than 3
(<code>NUM_ORPHAN_ANCESTORS_CHECK</code>) blocks away from our head.</p>
<p>We also keep a separate job in client_actor that keeps retrying chunk fetching
from other nodes if the original request fails.</p>
<p>After all the chunks for a given block are received (we have a separate HashMap
that checks how many chunks are missing for each block) - we’re ready to
process the block and attach it to the chain.</p>
<p>Afterwards, we look at other entries in the orphan pool to see if any of them
are a direct descendant of the block that we just added - and if yes, we repeat
the process.</p>
<h2 id="catchup"><a class="header" href="#catchup">Catchup</a></h2>
<h3 id="the-goal-of-catchup"><a class="header" href="#the-goal-of-catchup">The goal of catchup</a></h3>
<p>Catchup is needed when not all nodes in the network track all shards and nodes
can change the shard they are tracking during different epochs.</p>
<p>For example, if a node tracks shard 0 at epoch T and tracks shard 1 at epoch T+1,
it actually needs to have the state of shard 1 ready before the beginning of
epoch T+1. We make sure this happens by making the node start downloading
the state for shard 1 at the beginning of epoch T and applying blocks during
epoch T to shard 1’s state. Because downloading state can take time, the
node may have already processed some blocks (for shard 0 at this epoch), so when
the state finishes downloading, the node needs to “catch up” processing these
blocks for shard 1.</p>
<p>Right now, all nodes do track all shards, so technically we shouldn’t need the
catchup process, but it is still implemented for the future.</p>
<p>Image below: Example of the node, that tracked only shard 0 in epoch T-1, and
will start tracking shard 0 &amp; 1 in epoch T+1.</p>
<p>At the beginning of the epoch T, it will initiate the state download (green) and
afterwards will try to ‘catchup’ the blocks (orange). After blocks are caught
up, it will continue processing as normal.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195892395-2e12808e-002b-4c04-9505-611288386dc8.png" alt="image" /></p>
<h3 id="how-catchup-interact-with-normal-block-processing"><a class="header" href="#how-catchup-interact-with-normal-block-processing">How catchup interact with normal block processing</a></h3>
<p>The catchup process has two phases: downloading states for shards that we are
going to care about in epoch T+1 and catching up blocks that have already been
applied.</p>
<p>When epoch T starts, the node will start downloading states of shards that it
will track for epoch T+1, which it doesn't track already. Downloading happens in
a different thread so <code>ClientActor</code> can still process new blocks. Before the
shard states for epoch T+1 are ready, processing new blocks only applies chunks
for the shards that the node is tracking in epoch T. When the shard states for
epoch T+1 finish downloading, the catchup process needs to reprocess the
blocks that have already been processed in epoch T to apply the chunks for the
shards in epoch T+1. We assume that it will be faster than regular block
processing, because blocks are not full and block production has its own delays,
so catchup can finish within an epoch.</p>
<p>In other words, there are three modes for applying chunks and two code paths,
either through the normal <code>process_block</code> (blue) or through <code>catchup_blocks</code>
(orange). When <code>process_block</code>, either that the shard states for the next epoch
are ready, corresponding to <code>IsCaughtUp</code> and all shards the node is tracking in
this, or will be tracking in the next, epoch will be applied, or when the
states are not ready, corresponding to <code>NotCaughtUp</code>, then only the shards for
this epoch will be applied. When <code>catchup_blocks</code>, shards for the next epoch
will be applied.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ApplyChunksMode {
    IsCaughtUp,
    CatchingUp,
    NotCaughtUp,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="how-catchup-works"><a class="header" href="#how-catchup-works">How catchup works</a></h3>
<p>The catchup process is initiated by <code>process_block</code>, where we check if the block
is caught up and if we need to download states. The logic works as follows:</p>
<ul>
<li>For the first block in an epoch T, we check if the previous block is caught
up, which signifies if the state of the new epoch is ready. If the previous
block is not caught up, the block will be orphaned and not processed for now
because it is not ready to be processed yet. Ideally, this case should never
happen, because the node will appear stalled until the blocks in the previous
epoch are catching up.</li>
<li>Otherwise, we start processing blocks for the new epoch T. For the first
block, we always mark it as not caught up and will initiate the process
for downloading states for shards that we are going to care about in epoch
T+1. Info about downloading states is persisted in <code>DBCol::StateDlInfos</code>.</li>
<li>For other blocks, we mark them as not caught up if the previous block is not
caught up. This info is persisted in <code>DBCol::BlocksToCatchup</code> which stores
mapping from previous block to vector of all child blocks to catch up.</li>
<li>Chunks for already tracked shards will be applied during <code>process_block</code>, as 
we said before mentioning <code>ApplyChunksMode</code>.</li>
<li>Once we downloaded state, we start catchup. It will take blocks from 
<code>DBCol::BlocksToCatchup</code> in breadth-first search order and apply chunks for 
shards which have to be tracked in the next epoch.</li>
<li>When catchup doesn't see any more blocks to process, <code>DBCol::BlocksToCatchup</code>
is cleared, which means that catchup process is finished.</li>
</ul>
<p>The catchup process is implemented through the function <code>Client::run_catchup</code>.
<code>ClientActor</code> schedules a call to <code>run_catchup</code> every 100ms. However, the call
can be delayed if ClientActor has a lot of messages in its actix queue.</p>
<p>Every time <code>run_catchup</code> is called, it checks <code>DBCol::StateDlInfos</code> to see 
if there are any shard states that should be downloaded. If so, it
initiates the syncing process for these shards. After the state is downloaded,
<code>run_catchup</code> will start to apply blocks that need to be caught up.</p>
<p>One thing to note is that <code>run_catchup</code> is located at <code>ClientActor</code>, but
intensive work such as applying state parts and applying blocks is actually
offloaded to <code>SyncJobsActor</code> in another thread, because we don’t want
<code>ClientActor</code> to be blocked by this. <code>run_catchup</code> is simply responsible for
scheduling <code>SyncJobsActor</code> to do the intensive job. Note that <code>SyncJobsActor</code> is
state-less, it doesn’t have write access to the chain. It will return the changes
that need to be made as part of the response to <code>ClientActor</code>, and <code>ClientActor</code>
is responsible for applying these changes. This is to ensure only one thread
(<code>ClientActor</code>) has write access to the chain state. However, this also adds a
lot of limits, for example, <code>SyncJobsActor</code> can only be scheduled to apply one
block at a time. Because <code>run_catchup</code> is only scheduled to run every 100ms, the
speed of catching up blocks is limited to 100ms per block, even when blocks
applying can be faster. Similar constraints happen to apply state parts.</p>
<h3 id="improvements"><a class="header" href="#improvements">Improvements</a></h3>
<p>There are three improvements we can make to the current code.</p>
<p>First, currently we always initiate the state downloading process at the first
block of an epoch, even when there are no new states to be downloaded for the
new epoch. This is unnecessary.</p>
<p>Second, even though <code>run_catchup</code> is scheduled to run every 100ms, the call can
be delayed if ClientActor has messages in its actix queue. A better way to do
this is to move the scheduling of <code>run_catchup</code> to <code>check_triggers</code>.</p>
<p>Third, because of how <code>run_catchup</code> interacts with <code>SyncJobsActor</code>, <code>run_catchup</code>
can catch up at most one block every 100 ms. This is because we don’t want to
write to <code>ChainStore</code> in multiple threads. However, the changes that catching up
blocks make do not interfere with regular block processing and they can be
processed at the same time. However, to restructure this, we will need to
re-implement <code>ChainStore</code> to separate the parts that can be shared among threads
and the part that can’t.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h1>
<p>This document covers the basics of Chain garbage collection.</p>
<p>Currently we run garbage collection only in non-archival nodes,  to keep the
size of the storage under control. Therefore, we remove blocks, chunks and state
that is ‘old’ enough  - which in current configuration means 5 epochs ago.</p>
<p>We run a single ‘round’ of GC after a new block is accepted to the chain - and
in order not to delay the chain too much, we make sure that each round removes
at most 2 blocks from the chain.</p>
<p>For more details look at function <code>clear_data()</code> in file <code>chain/chain/src/chain.rs</code></p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works:</a></h2>
<p>Imagine the following chain (with 2 forks)</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195649805-e7997192-be3a-4bf0-992d-d35b2ad80847.png" alt="" /></p>
<p>In the pictures below, let’s assume that epoch length is 5 and we keep only 3
epochs (rather than 5 that is currently set in production) - otherwise the image
becomes too large 😉.</p>
<p>If head is in the middle of the epoch, the <code>gc_stop</code> will be set to the first
block of epoch T-2, and <code>tail</code> &amp; <code>fork_tail</code> will be sitting at the last block of
epoch T-3.</p>
<p>(and no GC is happening in this round - as tail is next to <code>gc_stop</code>).</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195649850-95dee667-b88b-4ef6-b08c-77a17b8d4ae2.png" alt="" /></p>
<p>Next block was accepted on the chain (head jumped ahead), but still no GC
happening in this round:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195649879-e29cc826-dfd8-4cbc-a66d-72e42202d26a.png" alt="" /></p>
<p>Now interesting things will start happening once head ‘crosses’ over to the
next epoch.</p>
<p>First, the <code>gc_stop</code> will jump to the beginning of the next epoch.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195649928-0401b221-b6b3-4986-8931-54fbdd1adda0.png" alt="" /></p>
<p>Then we’ll start the GC of the forks: by first moving the <code>fork_tail</code> to match
the <code>gc_stop</code> and going backwards from there.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195649966-dac6a4dd-f04b-4131-887a-58efe89d456a.png" alt="" /></p>
<p>It will start removing all the blocks that don’t have a successor (a.k.a the tip
of the fork). And then it will proceed to lower height.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195650003-90e1fde7-18a6-4343-b0dd-9a10a596f136.png" alt="" /></p>
<p>Will keep going until it ‘hits’ the tail.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195650059-dd6b3d30-7dd5-4324-8e65-80f955960c47.png" alt="" /></p>
<p>In order not to do too much in one go, we’d only remove up to 2 block in each
run  (that happens after each head update).</p>
<p>Now, the forks are gone, so we can proceed with GCing of the blocks from
the canonical chain:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195650101-dc6953a7-0d55-4db8-a78b-6a52310410b2.png" alt="" /></p>
<p>Same as before, we’d remove up to 2 blocks in each run:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195650127-b30865e1-d9c1-4950-8607-67d82a185b76.png" alt="" /></p>
<p>Until we catch up to the <code>gc_stop</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-epoch-works"><a class="header" href="#how-epoch-works">How Epoch Works</a></h1>
<p>This short document will tell you all you need to know about Epochs in NEAR
protocol.</p>
<p>You can also find additional information about epochs in
<a href="https://nomicon.io/BlockchainLayer/EpochManager/">nomicon</a>.</p>
<h2 id="what-is-an-epoch"><a class="header" href="#what-is-an-epoch">What is an Epoch?</a></h2>
<p>Epoch is a sequence of consecutive blocks.
Within one epoch, the set of validators is fixed, and validator rotation
happens at epoch boundaries.</p>
<p>Basically almost all the changes that we do are happening at epoch boundaries:</p>
<ul>
<li>sharding changes</li>
<li>protocol version changes</li>
<li>validator changes</li>
<li>changing tracking shards</li>
<li>state sync</li>
</ul>
<h2 id="where-does-the-epoch-id-come-from"><a class="header" href="#where-does-the-epoch-id-come-from">Where does the Epoch Id come from?</a></h2>
<p><code>EpochId</code> for epoch T+2 is the last hash of the block of epoch T.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/195907256-c4b1d956-632c-4c11-aa38-17603b1fcc40.png" alt="image" /></p>
<p>Situation at genesis is interesting. We have three blocks:</p>
<p>dummy ← genesis ← first-block</p>
<h2 id="where-do-we-set-the-epoch-length"><a class="header" href="#where-do-we-set-the-epoch-length">Where do we set the epoch length?</a></h2>
<p>Epoch length is set in the genesis config. Currently in mainnet it is set to 43200 blocks:</p>
<pre><code class="language-json">  &quot;epoch_length&quot;: 43200
</code></pre>
<p>See <a href="https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/mainnet/genesis.json">the mainnet genesis</a> for more details.</p>
<p>This means that each epoch lasts around 15 hours.</p>
<p><strong>Important:</strong> sometimes there might be ‘troubles’ on the network, that might result
in epoch lasting a little bit longer (if we cannot get enough signatures on the
last blocks of the previous epoch).</p>
<p>You can read specific details on our
<a href="https://nomicon.io/BlockchainLayer/EpochManager/Epoch">nomicon page</a>.</p>
<h2 id="how-do-we-pick-the-next-validators"><a class="header" href="#how-do-we-pick-the-next-validators">How do we pick the next validators?</a></h2>
<p><strong>TL;DR:</strong> in the last block of the epoch T, we look at the accounts that have
highest stake and we pick them to become validators in <strong>T+2</strong>.</p>
<p>We are deciding on validators for T+2 (and not T+1) as we want to make sure that
validators have enough time to prepare for block production and validation (they
have to download the state of shards etc).</p>
<p>For more info on how we pick validators please look at
<a href="https://nomicon.io/Economics/Economic#validator-selection">nomicon</a>.</p>
<h2 id="epoch-and-sharding"><a class="header" href="#epoch-and-sharding">Epoch and Sharding</a></h2>
<p>Sharding changes happen only on epoch boundary - that’s why many of the requests
(like which shard does my account belong to), require also an <code>epoch_id</code> as a
parameter.</p>
<p>As of April 2022 we don’t have dynamic sharding yet, so the whole chain is
simply using 4 shards.</p>
<h3 id="how-can-i-get-more-information-about-currentprevious-epochs"><a class="header" href="#how-can-i-get-more-information-about-currentprevious-epochs">How can I get more information about current/previous epochs?</a></h3>
<p>We don’t show much information about Epochs in Explorer. Today, you can use
<code>state_viewer</code> (if you have access to the network database).</p>
<p>At the same time, we’re working on a small debug dashboard, to show you the
basic information about past epochs - stay tuned.</p>
<h2 id="technical-details"><a class="header" href="#technical-details">Technical details</a></h2>
<h3 id="where-do-we-store-epoch-info"><a class="header" href="#where-do-we-store-epoch-info">Where do we store epoch info?</a></h3>
<p>We use a couple of columns in the database to store epoch information:</p>
<ul>
<li><strong>ColEpochInfo = 11</strong> - is storing the mapping from EpochId to EpochInfo
structure that contains all the details.</li>
<li><strong>ColEpochStart = 23</strong> - has a mapping from EpochId to the first block height
of that epoch.</li>
<li><strong>ColEpochValidatorInfo = 47</strong> - contains validator statistics (blocks
produced etc.) for each epoch.</li>
</ul>
<h3 id="how-does-epoch-info-look-like"><a class="header" href="#how-does-epoch-info-look-like">How does epoch info look like?</a></h3>
<p>Here’s the example epoch info from a localnet node. As you can see below,
EpochInfo mostly contains information about who is the validator and in which
order should they produce the blocks.</p>
<pre><code>EpochInfo.V3(
  epoch_height=7,
  validators=ListContainer([
    validator_stake.V1(account_id='node0', public_key=public_key.ED25519(tuple_data=ListContainer([b'7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX'])), stake=51084320187874404740382878961615),
    validator_stake.V1(account_id='node2', public_key=public_key.ED25519(tuple_data=ListContainer([b'GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5'])), stake=51084320187874404740382878961615),
    validator_stake.V1(account_id='node1', public_key=public_key.ED25519(tuple_data=ListContainer([b'6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e'])), stake=50569171534262067815663761517574)]),

  validator_to_index={'node0': 0, 'node1': 2, 'node2': 1},

  block_producers_settlement=ListContainer([0, 1, 2]),
  chunk_producers_settlement=ListContainer([ListContainer([0, 1, 2]), ListContainer([0, 1, 2]), ListContainer([0, 1, 2]), ListContainer([0, 1, 2]), ListContainer([0, 1, 2])]),

  hidden_validators_settlement=ListContainer([]),
  fishermen=ListContainer([]),
  fishermen_to_index={},
  stake_change={'node0': 51084320187874404740382878961615, 'node1': 50569171534262067815663761517574, 'node2': 51084320187874404740382878961615},
  validator_reward={'near': 37059603312899067633082436, 'node0': 111553789870214657675206177, 'node1': 110428850075662293347329569, 'node2': 111553789870214657675206177},
  validator_kickout={},
  minted_amount=370596033128990676330824359,
  seat_price=24438049905601740367428723111,
  protocol_version=52
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-routing"><a class="header" href="#transaction-routing">Transaction Routing</a></h1>
<p>We all know that transactions are ‘added’ to the chain - but how do they get
there?</p>
<p>Hopefully by the end of this article, the image below should make total sense.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/196204937-d6828382-16df-42bd-b59b-50eb2e6f07af.png" alt="image" /></p>
<h2 id="step-1-transaction-creatorauthor"><a class="header" href="#step-1-transaction-creatorauthor">Step 1: Transaction creator/author</a></h2>
<p>The journey starts with the author of the transaction - who creates the
transaction object (basically list of commands) - and signs them with their
private key.</p>
<p>Basically, they prepare the payload that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SignedTransaction {
    pub transaction: Transaction,
    pub signature: Signature,
}
<span class="boring">}
</span></code></pre></pre>
<p>With such a payload, they can go ahead and send it as a JSON-RPC request to ANY
node in the system (they can choose between using ‘sync’ or ‘async’ options).</p>
<p>From now on, they’ll also be able to query the status of the transaction - by
using the hash of this object.</p>
<p><strong>Fun fact:</strong> the <code>Transaction</code> object also contains some fields to prevent
attacks: like <code>nonce</code> to prevent replay attack, and <code>block_hash</code> to limit the
validity of the transaction (it must be added within
<code>transaction_validity_period</code> (defined in genesis) blocks of <code>block_hash</code>).</p>
<h2 id="step-2-inside-the-node"><a class="header" href="#step-2-inside-the-node">Step 2: Inside the node</a></h2>
<p>Our transaction has made it to a node in the system - but most of the nodes
are not validators - which means that they cannot mutate the chain.</p>
<p>That’s why the node has to forward it to someone who can - the upcoming
validator.</p>
<p>The node, roughly, does the following steps:</p>
<ul>
<li>verify transaction’s metadata - check signatures etc. (we want to make sure
that we don’t forward bogus data)</li>
<li>forward it to the ‘upcoming’ validator - currently we pick the validators that
would be a chunk creator in +2, +3, +4 and +8 blocks (this is controlled by
<code>TX_ROUTING_HEIGHT_HORIZON</code>) - and send the transaction to all of them.</li>
</ul>
<h2 id="step-3-en-route-to-validatorproducer"><a class="header" href="#step-3-en-route-to-validatorproducer">Step 3: En-route to validator/producer</a></h2>
<p>Great, the node knows to send (forward) the transaction to the validator, but
how does the routing work? How do we know which peer is hosting a validator?</p>
<p>Each validator is regularly (every <code>config.ttl_account_id_router</code>/2 seconds == 30
minutes in production) broadcasting so called <code>AnnounceAccount</code>, which is
basically a pair of <code>(account_id, peer_id)</code>, to the whole network. This way each
node knows which <code>peer_id</code> to send the message to.</p>
<p>Then it asks the routing table about the shortest path to the peer, and sends
the <code>ForwardTx</code> message to the peer.</p>
<h2 id="step-4-chunk-producer"><a class="header" href="#step-4-chunk-producer">Step 4: Chunk producer</a></h2>
<p>When a validator receives such a forwarded transaction, it double-checks that it is
about to produce the block, and if so, it adds the transaction to the mempool
(<code>TransactionPool</code>) for this shard, where it waits to be picked up when the chunk
is produced.</p>
<p>What happens afterwards will be covered in future episodes/articles.</p>
<h2 id="additional-notes"><a class="header" href="#additional-notes">Additional notes:</a></h2>
<h3 id="transaction-being-added-multiple-times"><a class="header" href="#transaction-being-added-multiple-times">Transaction being added multiple times</a></h3>
<p>But such an approach means, that we’re forwarding the same transaction to multiple
validators (currently 4) - so can it be added multiple times?</p>
<p>No. Remember that a transaction has a concrete hash which is used as a global
identifier. If the validator sees that the transaction is present in the chain,
it removes it from its local mempool.</p>
<h3 id="can-transaction-get-lost"><a class="header" href="#can-transaction-get-lost">Can transaction get lost?</a></h3>
<p>Yes - they can and they do. Sometimes a node doesn’t have a path to a given
validator or it didn’t receive an <code>AnnounceAccount</code> for it, so it doesn’t know
where to forward the message. And if this happens to all 4 validators that we
try to send to, then the message can be silently dropped.</p>
<p>We’re working on adding some monitoring to see how often this happens.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions-receipts-and-chunk-surprises"><a class="header" href="#transactions-receipts-and-chunk-surprises">Transactions, Receipts and Chunk Surprises</a></h1>
<p>We finished the previous article (<a href="architecture/how/./tx_routing.html">Transaction routing</a>)
where a transaction was successfully added to the soon-to-be block
producer’s mempool.</p>
<p>In this article, we’ll cover what happens next:
How it is changed into a receipt and executed, potentially creating even
more receipts in the process.</p>
<p>First, let’s look at the ‘high-level view’:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/198282472-3883dcc1-77ca-452c-b21e-0a7af1435ede.png" alt="image" /></p>
<h2 id="transaction-vs-receipt"><a class="header" href="#transaction-vs-receipt">Transaction vs Receipt</a></h2>
<p>As you can see from the image above:</p>
<p><strong>Transactions</strong> are ‘external’ communication - they are coming from the
outside.</p>
<p><strong>Receipts</strong> are used for ‘internal’ communication (cross shard, cross
contract) - they are created by the block/chunk producers.</p>
<h2 id="life-of-a-transaction"><a class="header" href="#life-of-a-transaction">Life of a Transaction</a></h2>
<p>If we ‘zoom-in‘, the chunk producer's work looks like this:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/198282518-cdeb375e-8f1c-4634-842c-6490020ad9c0.png" alt="image" /></p>
<h3 id="step-1-process-transaction-into-receipt"><a class="header" href="#step-1-process-transaction-into-receipt">Step 1: Process Transaction into receipt</a></h3>
<p>Once a chunk producer is ready to produce a chunk, it will fetch the
transactions from its mempool, check that they are valid, and if so, prepare to
process them into receipts.</p>
<p><strong>Note:</strong> There are additional restrictions (e.g. making sure that we take them in
the right order, that we don’t take too many, etc.) - that you can see in
nomicon’s <a href="https://nomicon.io/ChainSpec/Transactions">transaction page</a>.</p>
<p>You can see this part in explorer:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/198282561-c97235a1-93a1-4dc8-b6bc-ee9983376b2c.png" alt="image" /></p>
<h3 id="step-2-sending-receipt-to-the-proper-destination"><a class="header" href="#step-2-sending-receipt-to-the-proper-destination">Step 2: Sending receipt to the proper destination</a></h3>
<p>Once we have a receipt, we have to send it to the proper destination - by adding
it to the <code>outgoing_receipt</code> list, which will be forwarded to the chunk
producers from the next block.</p>
<p><strong>Note:</strong> There is a special case here - if the sender of the receipt is the
same as the receiver, then the receipt will be added to the <code>local_receipts</code>
queue and executed in the same block.</p>
<h3 id="step-3-when-an-incoming-receipt-arrives"><a class="header" href="#step-3-when-an-incoming-receipt-arrives">Step 3: When an incoming receipt arrives</a></h3>
<p>(<strong>Note:</strong> this happens in the ‘next’ block)</p>
<p>When a chunk producer receives an incoming receipt, it will try to execute its
actions (creating accounts, executing function calls etc).</p>
<p>Such actions might generate additional receipts (for example a contract might
want to call other contracts). All these outputs are added to the outgoing
receipt queue to be executed in the next block.</p>
<p>If the incoming receipt queue is too large to execute in the current chunk,
the producer will put the remaining receipts onto the ‘delayed’ queue.</p>
<h3 id="step-4-profit"><a class="header" href="#step-4-profit">Step 4: Profit</a></h3>
<p>When all the ‘dependant’ receipts are executed for a given transaction, we can
consider the transaction to be successful.</p>
<h3 id="advanced-but-reality-is-more-complex"><a class="header" href="#advanced-but-reality-is-more-complex">[Advanced] But reality is more complex</a></h3>
<p><strong>Caution:</strong> In the section below, some things are simplified and do not match exactly 
how the current code works.</p>
<p>Let’s quickly also check what’s inside a Chunk:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ShardChunkV2 {
    pub chunk_hash: ChunkHash,
    pub header: ShardChunkHeader,
    pub transactions: Vec&lt;SignedTransaction&gt;,
    pub receipts: Vec&lt;Receipt&gt;, // outgoing receipts from 'previous' block
}
<span class="boring">}
</span></code></pre></pre>
<p>Yes, it is a little bit confusing, that receipts here are NOT the ‘incoming’
ones for this chunk, but instead the ‘outgoing’ ones from the previous block, i.e. all receipts from shard 0, block B are actually found in shard 0, block B+1.  Why?!?!</p>
<p>This has to do with performance.</p>
<p>The steps usually followed for producing a block are as follows</p>
<ol>
<li>Chunk producer executes the receipts and creates a chunk. It sends the chunk to other validators. Note that it's the execution/processing of the receipts that usually takes the most time.</li>
<li>Validators receive the chunk and validate it before signing the chunk. Validation involves executing/processing of the receipts in the chunk.</li>
<li>Once the next block chunk producer receives the validation (signature), only then can it start producing the next chunk.</li>
</ol>
<h4 id="simple-approach"><a class="header" href="#simple-approach">Simple approach</a></h4>
<p>First, let’s imagine how the system would look like, if chunks contained things
that we’d expect:</p>
<ul>
<li>list of transactions</li>
<li>list of incoming receipts</li>
<li>list of outgoing receipts</li>
<li>hash of the final state</li>
</ul>
<p>This means, that the chunk producer has to compute all this information first,
before sending the chunk to other validators.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/198282601-383977f1-08dd-45fe-aa19-70556d585034.png" alt="image" /></p>
<p>Once the other validators receive the chunk, they can start their own processing to
verify those outgoing receipts/final state - and then do the signing. Only then,
can the next chunk producer start creating the next chunk.</p>
<p>While this approach does work, we can do it faster.</p>
<h4 id="faster-approach"><a class="header" href="#faster-approach">Faster approach</a></h4>
<p>What if the chunk didn’t contain the ‘output’ state? This changes our ‘mental’ model
a little bit, as now when we’re singing the chunk, we’d actually be
verifying the previous chunk - but that’s the topic for the next article (to be added).</p>
<!-- TODO: add future link to article about signatures and verification -->
<p>For now, imagine if the chunk only had:</p>
<ul>
<li>a list of transactions</li>
<li>a list of incoming receipts</li>
</ul>
<p>In this case, the chunk producer could send the chunk a lot earlier, and
validators (and chunk producer) could do their processing at the same time:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/198282641-1e728088-6f2b-4cb9-90c9-5eb09304e72a.png" alt="image" /></p>
<p>Now the last mystery:
Why do we have ‘outgoing’ receipts from previous chunks rather than incoming
to the current one?</p>
<p>This is yet another optimization. This way the chunk producer can send out the
chunk a little bit earlier - without having to wait for all the other shards.</p>
<p>But that’s a topic for another article (to be added).</p>
<!-- TODO: add future link to article about chunk fragments etc. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-shard-transactions---deep-dive"><a class="header" href="#cross-shard-transactions---deep-dive">Cross shard transactions - deep dive</a></h1>
<p>In this article, we'll look deeper into how cross-shard transactions are working
on the simple example of user <code>shard0</code> transferring money to user <code>shard1</code>.</p>
<p>These users are on separate shards (<code>shard0</code> is on shard 0 and <code>shard1</code> is on
shard 1).</p>
<p>Imagine, we run the following command in the command line:</p>
<pre><code class="language-console">$ NEAR_ENV=local near send shard0 shard1 500
</code></pre>
<p>What happens under the hood? How is this transaction changed into receipts and
processed by near?</p>
<h2 id="from-explorer-perspective"><a class="header" href="#from-explorer-perspective">From Explorer perspective</a></h2>
<p>If you look at a simple token transfer in explorer
(<a href="https://explorer.near.org/transactions/79gPsyYRG2xghr6oNLpMbdjP2jpafjVT35no9atS6zUf">example</a>),
you can see that it is broken into three separate sections:</p>
<ul>
<li>convert transaction into receipt ( executed in block B )</li>
<li>receipt that transfers tokens ( executed in block B+1 )</li>
<li>receipt that refunds gas ( executed in block B+2 )</li>
</ul>
<p>But under the hood, the situation is a little bit more complex, as there is
actually one more receipt (that is created after converting the transaction).
Let's take a deeper look.</p>
<h2 id="internal-perspective-transactions--receipts"><a class="header" href="#internal-perspective-transactions--receipts">Internal perspective (Transactions &amp; Receipts)</a></h2>
<p>One important thing to remember is that NEAR is sharded - so in all our
designs, we have to assume that each account is on a separate shard. So that the
fact that some of them are colocated doesn't give any advantage.</p>
<h3 id="step-1---transaction"><a class="header" href="#step-1---transaction">Step 1 - Transaction</a></h3>
<p>This is the part which we receive from the user (<code>SignedTransaction</code>) - it has 3
parts:</p>
<ul>
<li>signer (account + key) who signed the transaction</li>
<li>receiver (in which account context should we execute this)</li>
<li>payload - a.k.a Actions to execute.</li>
</ul>
<p>As the first step, we want to change this transaction into a Receipt (a.k.a
'internal' message) - but before doing that, we must verify that:</p>
<ul>
<li>the message signature matches (that is - that this message was actually signed
by this key)</li>
<li>that this key is authorized to act on behalf of that account (so it is a full
access key to this account - or a valid function key).</li>
</ul>
<p>The last point above means, that we MUST execute this (Transaction to Receipt)
transition within the shard that the <code>signer</code> belongs to (as other shards don't
know the state that belongs to signer - so they don't know which keys it has).</p>
<p>So actually if we look inside the chunk 0 (where <code>shard0</code> belongs) at block
B, we'll see the transaction:</p>
<pre><code>Chunk: Ok(
    V2(
        ShardChunkV2 {
            chunk_hash: ChunkHash(
                8mgtzxNxPeEKfvDcNdFisVq8TdeqpCcwfPMVk219zRfV,
            ),
            header: V3(
                ShardChunkHeaderV3 {
                    inner: V2(
                        ShardChunkHeaderInnerV2 {
                            prev_block_hash: CgTJ7FFwmawjffrMNsJ5XhvoxRtQPXdrtAjrQjG91gkQ,
                            prev_state_root: 99pXnYjQbKE7bEf277urcxzG3TaN79t2NgFJXU5NQVHv,
                            outcome_root: 11111111111111111111111111111111,
                            encoded_merkle_root: 67zdyWTvN7kB61EgTqecaNgU5MzJaCiRnstynerRbmct,
                            encoded_length: 187,
                            height_created: 1676,
                            shard_id: 0,
                            gas_used: 0,
                            gas_limit: 1000000000000000,
                            balance_burnt: 0,
                            outgoing_receipts_root: 8s41rye686T2ronWmFE38ji19vgeb6uPxjYMPt8y8pSV,
                            tx_root: HyS6YfQbfBRniVSbWRnxsxEZi9FtLqHwyzNivrF6aNAM,
                            validator_proposals: [],
                        },
                    ),
                    height_included: 0,
                    signature: ed25519:uUvmvDV2cRVf1XW93wxDU8zkYqeKRmjpat4UUrHesJ81mmr27X43gFvFuoiJHWXz47czgX68eyBN38ejwL1qQTD,
                    hash: ChunkHash(
                        8mgtzxNxPeEKfvDcNdFisVq8TdeqpCcwfPMVk219zRfV,
                    ),
                },
            ),
            transactions: [
                SignedTransaction {
                    transaction: Transaction {
                        signer_id: AccountId(
                            &quot;shard0&quot;,
                        ),
                        public_key: ed25519:Ht8EqXGUnY8B8x7YvARE1LRMEpragRinqA6wy5xSyfj5,
                        nonce: 11,
                        receiver_id: AccountId(
                            &quot;shard1&quot;,
                        ),
                        block_hash: 6d5L1Vru2c4Cwzmbskm23WoUP4PKFxBHSP9AKNHbfwps,
                        actions: [
                            Transfer(
                                TransferAction {
                                    deposit: 500000000000000000000000000,
                                },
                            ),
                        ],
                    },
                    signature: ed25519:63ssFeMyS2N1khzNFyDqiwSELFaUqMFtAkRwwwUgrPbd1DU5tYKxz9YL2sg1NiSjaA71aG8xSB7aLy5VdwgpvfjR,
                    hash: 6NSJFsTTEQB4EKNKoCmvB1nLuQy4wgSKD51rfXhmgjLm,
                    size: 114,
                },
            ],
            receipts: [],
        },
    ),
)
</code></pre>
<p><strong>Side note:</strong> When we're converting the transaction into a receipt, we also use
this moment to deduct prepaid gas fees and transferred tokens from the 'signer'
account. The details on how much gas is charged can be found at https://nomicon.io/RuntimeSpec/Fees/.</p>
<h2 id="step-2---cross-shard-receipt"><a class="header" href="#step-2---cross-shard-receipt">Step 2 - cross shard receipt</a></h2>
<p>After transaction was changed into a receipt, this receipt must now be sent to
the shard where the <code>receiver</code> is (in our example <code>shard1</code> is on shard 1).</p>
<p>We can actually see this in the chunk of the next block:</p>
<pre><code>Chunk: Ok(
    V2(
        ShardChunkV2 {
            chunk_hash: ChunkHash(
                DoF7yoCzyBSNzB8R7anWwx6vrimYqz9ZbEmok4eqHZ3m,
            ),
            header: V3(
                ShardChunkHeaderV3 {
                    inner: V2(
                        ShardChunkHeaderInnerV2 {
                            prev_block_hash: 82dKeRnE262qeVf31DXaxHvbYEugPUDvjGGiPkjm9Rbp,
                            prev_state_root: DpsigPFeVJDenQWVueGKyTLVYkQuQjeQ6e7bzNSC7JVN,
                            outcome_root: H34BZknAfWrPCcppcHSqbXwFvAiD9gknG8Vnrzhcc4w,
                            encoded_merkle_root: 3NDvQBrcRSAsWVPWkUTTrBomwdwEpHhJ9ofEGGaWsBv9,
                            encoded_length: 149,
                            height_created: 1677,
                            shard_id: 0,
                            gas_used: 223182562500,
                            gas_limit: 1000000000000000,
                            balance_burnt: 22318256250000000000,
                            outgoing_receipts_root: Co1UNMcKnuhXaHZz8ozMnSfgBKPqyTKLoC2oBtoSeKAy,
                            tx_root: 11111111111111111111111111111111,
                            validator_proposals: [],
                        },
                    ),
                    height_included: 0,
                    signature: ed25519:32hozA7GMqNqJzscEWzYBXsTrJ9RDhW5Ly4sp7FXP1bmxoCsma8Usxry3cjvSuywzMYSD8HvGntVtJh34G2dKJpE,
                    hash: ChunkHash(
                        DoF7yoCzyBSNzB8R7anWwx6vrimYqz9ZbEmok4eqHZ3m,
                    ),
                },
            ),
            transactions: [],
            receipts: [
                Receipt {
                    predecessor_id: AccountId(
                        &quot;shard0&quot;,
                    ),
                    receiver_id: AccountId(
                        &quot;shard1&quot;,
                    ),
                    receipt_id: 3EtEcg7QSc2CYzuv67i9xyZTyxBD3Dvx6X5yf2QgH83g,
                    receipt: Action(
                        ActionReceipt {
                            signer_id: AccountId(
                                &quot;shard0&quot;,
                            ),
                            signer_public_key: ed25519:Ht8EqXGUnY8B8x7YvARE1LRMEpragRinqA6wy5xSyfj5,
                            gas_price: 103000000,
                            output_data_receivers: [],
                            input_data_ids: [],
                            actions: [
                                Transfer(
                                    TransferAction {
                                        deposit: 500000000000000000000000000,
                                    },
                                ),
                            ],
                        },
                    ),
                },
            ],
        },
    ),
)
</code></pre>
<p><strong>Side comment:</strong> notice that the receipt itself no longer has a <code>signer</code> field, but
a <code>predecessor_id</code> one.</p>
<p>Such a receipt is sent to the destination shard (we'll explain this process in a
separate article) where it can be executed.</p>
<!-- TODO: maybe add the link to that article here? -->
<h2 id="3-gas-refund"><a class="header" href="#3-gas-refund">3. Gas refund.</a></h2>
<p>When shard 1 processes the receipt above, it is then ready to refund the unused
gas to the original account (<code>shard0</code>). So it also creates the receipt, and puts
it inside the chunk. This time it is in shard 1 (as that's where it was
executed).</p>
<pre><code>Chunk: Ok(
    V2(
        ShardChunkV2 {
            chunk_hash: ChunkHash(
                8sPHYmBFp7cfnXDAKdcATFYfh9UqjpAyqJSBKAngQQxL,
            ),
            header: V3(
                ShardChunkHeaderV3 {
                    inner: V2(
                        ShardChunkHeaderInnerV2 {
                            prev_block_hash: Fj7iu26Yy9t5e9k9n1fSSjh6ZoTafWyxcL2TgHHHskjd,
                            prev_state_root: 4y6VL9BoMJg92Z9a83iqKSfVUDGyaMaVU1RNvcBmvs8V,
                            outcome_root: 7V3xRUeWgQa7D9c8s5jTq4dwdRcyTuY4BENRmbWaHiS5,
                            encoded_merkle_root: BnCE9LZgnFEjhQv1fSYpxPNw56vpcLQW8zxNmoMS8H4u,
                            encoded_length: 149,
                            height_created: 1678,
                            shard_id: 1,
                            gas_used: 223182562500,
                            gas_limit: 1000000000000000,
                            balance_burnt: 22318256250000000000,
                            outgoing_receipts_root: HYjZzyTL5JBfe1Ar4C4qPKc5E6Vbo9xnLHBKLVAqsqG2,
                            tx_root: 11111111111111111111111111111111,
                            validator_proposals: [],
                        },
                    ),
                    height_included: 0,
                    signature: ed25519:4FzcDw2ay2gAGosNpFdTyEwABJhhCwsi9g47uffi77N21EqEaamCg9p2tALbDt5fNeCXXoKxjWbHsZ1YezT2cL94,
                    hash: ChunkHash(
                        8sPHYmBFp7cfnXDAKdcATFYfh9UqjpAyqJSBKAngQQxL,
                    ),
                },
            ),
            transactions: [],
            receipts: [
                Receipt {
                    predecessor_id: AccountId(
                        &quot;system&quot;,
                    ),
                    receiver_id: AccountId(
                        &quot;shard0&quot;,
                    ),
                    receipt_id: 6eei79WLYHGfv5RTaee4kCmzFx79fKsX71vzeMjCe6rL,
                    receipt: Action(
                        ActionReceipt {
                            signer_id: AccountId(
                                &quot;shard0&quot;,
                            ),
                            signer_public_key: ed25519:Ht8EqXGUnY8B8x7YvARE1LRMEpragRinqA6wy5xSyfj5,
                            gas_price: 0,
                            output_data_receivers: [],
                            input_data_ids: [],
                            actions: [
                                Transfer(
                                    TransferAction {
                                        deposit: 669547687500000000,
                                    },
                                ),
                            ],
                        },
                    ),
                },
            ],
        },
    ),
)
</code></pre>
<p>Such gas refund receipts are a little bit special - as we'll set the
<code>predecessor_id</code> to be <code>system</code> - but the receiver is what we expect (<code>shard0</code>
account).</p>
<p><strong>Note:</strong> <code>system</code> is a special account that doesn't really belong to any shard.
As you can see in this example, the receipt was created within shard 1.</p>
<p>So putting it all together would look like this:</p>
<p><img src="https://user-images.githubusercontent.com/91919554/200617392-00b9fa0c-2f15-40ad-9802-137ca9a5a15d.png" alt="image" /></p>
<p>But wait - NEAR was saying that transfers are happening with 2 blocks - but here
I see that it took 3 blocks. What's wrong?</p>
<p>The image above is a simplification, and reality is a little bit trickier -
especially as receipts in a given chunks are actually receipts received as a
result from running a PREVIOUS chunk from this shard.</p>
<p>We'll explain it more in the next section.</p>
<h1 id="advanced-whats-actually-going-on"><a class="header" href="#advanced-whats-actually-going-on">Advanced: What's actually going on?</a></h1>
<p>As you could have read in <a href="architecture/how/./tx_receipts.html">Transactions And Receipts</a> - the
'receipts' field in the chunk is actually representing 'outgoing' receipts
from the previous block.</p>
<p>So our image should look more like this:</p>
<p><img src="https://user-images.githubusercontent.com/91919554/200621066-a5d06f2d-ff43-44ce-a52b-47dc44d6f8ab.png" alt="image" /></p>
<p>In this example, the black boxes are representing the 'processing' of the chunk,
and red arrows are cross-shard communication.</p>
<p>So when we process Shard 0 from block 1676, we read the transaction, and output
the receipt - which later becomes the input for shard 1 in block 1677.</p>
<p>But you might still be wondering - so why didn't we add the Receipt (transfer)
to the list of receipts of shard0 1676?</p>
<p>That's because the shards &amp; blocks are set BEFORE we do any computation. So the
more correct image would look like this:</p>
<p><img src="https://user-images.githubusercontent.com/91919554/200621808-1ce78047-6968-4af5-9c2a-805a0f1643fc.png" alt="image" /></p>
<p>Here you can clearly see that chunk processing (black box), is happening AFTER
the chunk is set.</p>
<p>In this example, the blue arrows are showing the part where we persist the
result (receipt) into next block's chunk.</p>
<!-- TODO: maybe add the link to that article here? -->
<p>In a future article, we'll discuss how the actual cross-shard communication
works (red arrows) in the picture, and how we could guarantee that a given shard
really gets all the red arrows, before it starts processing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas"><a class="header" href="#gas">Gas</a></h1>
<p>This page describes the technical details around gas during the lifecycle of a
<em>transaction</em>(*) while giving an intuition for why things are the way they are
from a technical perspective. For a more practical, user-oriented angle, please
refer to the <a href="https://docs.near.org/concepts/basics/transactions/gas">gas section in the official protocol
documentation</a>.</p>
<p>(*) <em>For this page, a transaction shall refer to the set of all recursively
generated receipts by a <code>SignedTransaction</code>. When referring to only the original
transaction object, we write <code>SignedTransaction</code>.</em></p>
<p>The topic is split into several sections.</p>
<ol>
<li><a href="architecture/how/gas.html#gas-flow">Gas Flow</a>
<ul>
<li><a href="architecture/how/gas.html#buying-gas-for-a-transaction">Buying Gas</a>: How are NEAR tokens converted to gas?</li>
<li><a href="architecture/how/gas.html#burning-gas">Burning Gas</a>: Who receives burnt tokens?</li>
<li><a href="architecture/how/gas.html#gas-in-contract-calls">Gas in Contract Calls</a>: How is gas attached to calls?</li>
<li><a href="architecture/how/gas.html#contract-reward">Contract Reward</a>: How smart contract earn a reward.</li>
</ul>
</li>
<li><a href="architecture/how/gas.html#gas-price">Gas Price</a>: 
<ul>
<li><a href="architecture/how/gas.html#block-level-gas-price">Block-Level Gas Price</a>: How the block-level gas price is determined.</li>
<li><a href="architecture/how/gas.html#pessimistic-gas-price">Pessimistic Gas Price</a>: How worst-case gas pricing is estimated.</li>
<li><a href="architecture/how/gas.html#effective-gas-purchase-cost">Effective Gas Purchase Cost</a>: The cost paid for a receipt.</li>
</ul>
</li>
<li><a href="architecture/how/gas.html#tracking-gas-in-receipts">Tracking Gas</a>: How the system keeps track of purchased gas during the transaction execution.</li>
</ol>
<h2 id="gas-flow"><a class="header" href="#gas-flow">Gas Flow</a></h2>
<p>On the highest level, gas is bought by the signer, burnt during execution, and
contracts receive a part of the burnt gas as a reward. We will discuss each step
in more details.</p>
<h3 id="buying-gas-for-a-transaction"><a class="header" href="#buying-gas-for-a-transaction">Buying Gas for a Transaction</a></h3>
<p>A signer pays all the gas required for a transaction upfront. However, there is
no explicit act of buying gas. Instead, the fee is subtracted directly in NEAR
tokens from the balance of the signer's account. If we ignore all the details
explained further down, the fee is calculated as <code>gas amount</code> * <code>gas price</code>.</p>
<p>The <code>gas amount</code> is not a field of <code>SignedTransaction</code>, nor is it something the
signer can choose. It is only a virtual field that is computed on-chain following
the protocol's rules.</p>
<p>The <code>gas price</code> is a variable that may change during the execution of the
transaction. The way it is implemented today, a single transaction can be
charged a different gas price for different receipts.</p>
<p>Already we can see a fundamental problem: Gas is bought once at the beginning
but the gas price may change during execution. To solve this incompatibility,
the protocol calculates a pessimistic gas price for the initial purchase. Later
on, the delta between real and pessimistic gas prices is refunded at the end of
every receipt execution.</p>
<p>An alternative implementation would instead charge the gas at every receipt,
instead of once at the start. However, remember that the execution may happen on
a different shard than the signer account. Therefore we cannot access the
signer's balance while executing.</p>
<h3 id="burning-gas"><a class="header" href="#burning-gas">Burning Gas</a></h3>
<p>Buying gas immediately removes a part of the signer's tokens from the total
supply. However, the equivalent value in gas still exists in the form of the
receipt and the unused gas will be converted back to tokens as a refund.</p>
<p>The gas spent on execution on the other hand is burnt and removed from total
supply forever. Unlike gas in other chains, none of it goes to validators. This
is roughly equivalent to the base fee burning mechanism which Ethereum added in
<a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>. But in Near Protocol, the
entire fee is burnt because there is no <a href="https://ethereum.org/en/developers/docs/gas/#priority-fee">priority
fee</a> that Ethereum
pays out to validators.</p>
<p>The following diagram shows how gas flows through the execution of a
transaction. The transaction consists of a function call performing a cross
contract call, hence two function calls in sequence. (Note: This diagram is
heavily simplified, more accurate diagrams are further down.)</p>
<p><img src="https://github.com/near/nearcore/assets/6342444/f52c6e4b-6fca-4f61-8e6e-ac786076aa65" alt="Very Simplified Gas Flow Diagram" /></p>
<!-- Editable source: https://github.com/near/nearcore/issues/7821#issuecomment-1705672850 -->
<h3 id="gas-in-contract-calls"><a class="header" href="#gas-in-contract-calls">Gas in Contract Calls</a></h3>
<p>A function call has a fixed gas cost to be initiated. Then the execution itself
draws gas from the <code>attached_gas</code>, sometimes also called <code>prepaid_gas</code>, until it
reaches zero, at which point the function call aborts with a <code>GasExceeded</code>
error. No changes are persisted on chain.</p>
<p>(<em>Note on naming: If you see <code>prepaid_fee: Balance</code> in the nearcore code base,
this is NOT only the fee for <code>prepaid_gas</code>. It also includes prepaid fees for
other gas costs. However, <code>prepaid_gas: Gas</code> is used the same in the code base
as described in this document.</em>)</p>
<p>Attaching gas to function calls is the primary way for end-users and contract
developers to interact with gas. All other gas fees are implicitly computed and
are hidden from the users except for the fact that the equivalent in tokens is
removed from their account balance.</p>
<p>To attach gas, the signer sets the gas field of the function call action.
Wallets and CLI tools expose this to the users in different ways. Usually just
as a <code>gas</code> field, which makes users believe this is the maximum gas the
transaction will consume. Which is not true, the maximum is the specified number
plus the fixed base cost.</p>
<p>Contract developers also have to pick the attached gas values when their
contract calls another contract. They cannot buy additional gas, they have to
work with the unspent gas attached to the current call. They can check how much
gas is left by subtracting the <code>used_gas()</code> from the <code>prepaid_gas()</code> host
function results. But they cannot use all the available gas, since that would
prevent the current function call from executing to the end.</p>
<p>The gas attached to a function can be at most <code>max_total_prepaid_gas</code>, which is
300 Tgas since the mainnet launch. Note that this limit is per
<code>SignedTransaction</code>, not per function call. In other words, batched function
calls share this limit.</p>
<p>There is also a limit to how much single call can burn, <code>max_gas_burnt</code>, which
used to be 200 Tgas but has been increased to 300 Tgas in protocol version 52.
(Note: When attaching gas to an outgoing function call, this is not counted as
gas burnt.) However, given a call can never burn more than was attached anyway,
this second limit is obsolete with the current configuration where the two limits
are equal.</p>
<p>Since protocol version 53, with the stabilization of
<a href="https://github.com/near/NEPs/blob/master/neps/nep-0264.md">NEP-264</a>, contract
developers do not have to specify the absolute amount of gas to attach to calls.
<code>promise_batch_action_function_call_weight</code> allows to specify a ratio of unspent
gas that is computed after the current call has finished. This allows attaching
100% of unspent gas to a call. If there are multiple calls, this allows
attaching an equal fraction to each, or any other split as defined by the weight
per call.</p>
<h3 id="contract-reward"><a class="header" href="#contract-reward">Contract Reward</a></h3>
<p>A rather unique property of Near Protocol is that a part of the gas fee goes to
the contract owner. This &quot;smart contract gets paid&quot; model is pretty much the
opposite design choice from the &quot;smart contract pays&quot; model that for example
<a href="https://internetcomputer.org/docs/current/developer-docs/gas-cost#details-cost-of-compute-and-storage-transactions-on-the-internet-computer">Cycles in the Internet
Computer</a>
implement.</p>
<p>The idea is that it gives contract developers a source of income and hence an
incentive to create useful contracts that are commonly used. But there are also
downsides, such as when implementing a free meta-transaction relayer one has to
be careful not to be susceptible to faucet-draining attacks where an attacker
extracts funds from the relayer by making calls to a contract they own.</p>
<p>How much contracts receive from execution depends on two things. </p>
<ol>
<li>How much gas is burnt on the function call execution itself. That is, only
the gas taken from the <code>attached_gas</code> of a function call is considered for
contract rewards. The base fees paid for creating the receipt, including the
<code>action_function_call</code> fee, are burnt 100%.</li>
<li>The remainder of the burnt gas is multiplied by the runtime configuration
parameter
<a href="architecture/how/../../../core/parameters/res/runtime_configs/parameters.snap#L5C5-L5C5"><code>burnt_gas_reward</code></a>
which currently is at 30%.</li>
</ol>
<p>During receipt execution, nearcore code tracks the <code>gas_burnt_for_function_call</code>
separately from other gas burning to enable this contract reward calculations.</p>
<p>In the (still simplified) flow diagram, the contract reward looks like this.
For brevity, <code>gas_burnt_for_function_call</code> in the diagram is denoted as <code>wasm fee</code>.</p>
<p><img src="https://github.com/near/nearcore/assets/6342444/32600ef0-1475-43af-b196-576317787578" alt="Slightly Simplified Gas Flow Diagram" /></p>
<!-- Editable source: https://github.com/near/nearcore/issues/7821#issuecomment-1705673349 -->
<h2 id="gas-price"><a class="header" href="#gas-price">Gas Price</a></h2>
<p>Gas pricing is a surprisingly deep and complicated topic. Usually, we only think
about the value of the <code>gas_price</code> field in the block header. However, to
understand the internals, this is not enough.</p>
<h3 id="block-level-gas-price"><a class="header" href="#block-level-gas-price">Block-Level Gas Price</a></h3>
<p><code>gas_price</code> is a field in the block header. It determines how much it costs to
burn gas at the given block height. Confusingly, this is not the same price at
which gas is purchased.
(See <a href="architecture/how/gas.html#effective-gas-price">Effective Gas Purchase Price</a>.)</p>
<p>The price is measured in NEAR tokens per unit of gas. It dynamically changes in
the range between 0.1 NEAR per Pgas and 2 NEAR per Pgas, based on demand. (1
Pgas = 1000 Tgas corresponds to a full chunk.)</p>
<p>The block producer has to set this field following the exact formula as defined
by the protocol. Otherwise, the produced block is invalid.</p>
<p>Intuitively, the formula checks how much gas was used compared to the total
capacity. If it exceeds 50%, the gas price increases exponentially within the
limits. When the demand is below 50%, it decreases exponentially. In practice,
it stays at the bottom most of the time.</p>
<p>Note that all shards share the same gas price. Hence, if one out of four shards
is at 100% capacity, this will not cause the price to increase. The 50% capacity
is calculated as an average across all shards.</p>
<p>Going slightly off-topic, it should also be mentioned that chunk capacity is not
constant. Chunk producers can change it by 0.1% per chunk. The nearcore client
does not currently make use of this option, so it really is a nitpick only
relevant in theory. However, any client implementation such as nearcore must
compute the total capacity as the sum of gas limits stored in the chunk headers
to be compliant. Using a hard-coded <code>1000 Tgas * num_shards</code> would lead to
incorrect block header validation.</p>
<h3 id="pessimistic-gas-price"><a class="header" href="#pessimistic-gas-price">Pessimistic Gas Price</a></h3>
<p>The pessimistic gas price calculation uses the fact that any transaction can
only have a limited depth in the generated receipt DAG. For most actions, the
depth is a constant 1 or 2. For function call actions, it is limited to a
hand-wavy <code>attached_gas</code> / <code>min gas per function call</code>. (Note: <code>attached_gas</code> is
a property of a single action and is only a part of the total gas costs of a
receipt.)</p>
<p>Once the maximum depth is known, the protocol assumes that the gas price will
not change more than 3% per receipt. This is not a guarantee since receipts can
be delayed for virtually unlimited blocks.</p>
<p>The final formula for the pessimistic gas price is the following.</p>
<pre><code class="language-txt">pessimistic(current_gas_price, max_depth) = current_gas_price × 1.03^max_depth
</code></pre>
<p>This still is not the price at which gas is purchased. But we are very close.</p>
<h3 id="effective-gas-purchase-cost"><a class="header" href="#effective-gas-purchase-cost">Effective Gas Purchase Cost</a></h3>
<p>When a transaction is converted to its root action receipt, the gas costs are
calculated in two parts.</p>
<p>Part one contains all the gas which is burnt immediately. Namely, the <code>send</code>
costs for a receipt and all the actions it includes. This is charged at the
current block-level gas price.</p>
<p>Part two is everything else, from execution costs of actions that are statically
known such as <code>CreateAccount</code> all the way to <code>attached_gas</code> for function calls.
All of this is purchased at the same pessimistic gas price, even if some actions
inside might have a lower maximum call depth than others.</p>
<p>The deducted tokens are the sum of these two parts. If the account has
insufficient balance to pay for this pessimistic pricing, it will fail with a
<code>NotEnoughBalance</code> error, with the required balance included in the error
message.</p>
<p>Inserting the pessimistic gas pricing into the flow diagram, we finally have a
complete picture. Note how an additional refund receipt is required. Also, check
out the updated formula for the effective purchase price at the top left and the
resulting higher number.</p>
<p><img src="https://github.com/near/nearcore/assets/6342444/8341fb45-9beb-4808-8a89-8144fa075930" alt="Complete Gas Flow Diagram" /></p>
<!-- Editable source: https://github.com/near/nearcore/issues/7821#issuecomment-1705673807 -->
<h2 id="tracking-gas-in-receipts"><a class="header" href="#tracking-gas-in-receipts">Tracking Gas in Receipts</a></h2>
<p>The previous section explained how gas is bought and what determines its price.
This section details the tracking that enables correct refunds.</p>
<p>First, when a <code>SignedTransaction</code> is converted to a receipt, the pessimistic gas
price is written to the receipt's <code>gas_price</code> field.</p>
<p>Later on, when the receipt has been executed, a gas refund is created at the
value of <code>receipt.gas_burnt</code> * (<code>block_header.gas_price</code> - <code>receipt.gas_price</code>).</p>
<p>Some gas goes attaches to outgoing receipts. We commonly refer to this as used
gas that was not burnt, yet. The refund excludes this gas. But it includes the
receipt send cost.</p>
<p>Finally, unspent gas is refunded at the full <code>receipt.gas_price</code>. This refund is
merged with the refund for burnt gas of the same receipt outcome to reduce the
number of spawned system receipts. But it makes it a bit harder to interpret
refunds when backtracking for how much gas a specific refund receipt covers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="receipt-congestion"><a class="header" href="#receipt-congestion">Receipt Congestion</a></h1>
<p>Near Protocol executes transactions in multiple steps, or receipts. Once a
transaction is accepted, the system has committed to finish all those receipts
even if it does not know ahead of time how many receipts there will be or on
which shards they will execute.</p>
<p>This naturally leads to the problem that if shards just keep accepting more
transactions, we might accept workload at a higher rate than we can execute.</p>
<h2 id="cross-shard-congestion-as-flow-problem"><a class="header" href="#cross-shard-congestion-as-flow-problem">Cross-shard congestion as flow problem</a></h2>
<p>For a quick formalized discussion on congestion, let us model the Near Protocol
transaction execution as a <a href="https://en.wikipedia.org/wiki/Flow_network">flow
network</a>.</p>
<p>Each shard has a source that accepts new transactions and a sink for burning
receipts. The flow is measured in gas. Edges to sinks have a capacity of 1000
Tgas. (Technically, it should be 1300 but let's keep it simple for this
discussion.)</p>
<p><img src="architecture/how/../../images/congestion/base_flow_network.svg" alt="graph" /></p>
<p>The edges between shards are not limited in this model. In reality, we are
eventually limited by the receipt sizes and what we can send within a block time
through the network links. But if we only look at that limit, we can send very
many receipts with a lot of gas attached to them. Thus, the model considers it
unlimited.</p>
<p>Okay, we have the capacities of the network modeled. Now let's look at how a
receipt execution maps onto it.</p>
<p>Let's say a receipt starts at shard 1 with 300 Tgas. While executing, it burns 100 Tgas and
creates an outgoing receipts with 200 Tgas to another shard. We can represent this in the flow network with 
100 Tgas to the sink of shard 1 and 200 Tgas to shard 2. </p>
<p><img src="architecture/how/../../images/congestion/receipt_flow_example_0.svg" alt="graph" /></p>
<p>Note: The graph includes the execution of the next block with the 200 Tgas to the
sink of shard 2. This should be interpreted as if we continue sending the exact
same workload on all shards every block. Then we reach this steady state where
we continue to have these gas assignments per edge.</p>
<p>Now we can do some flow analysis. It is immediately obvious that the total
outflow per is limited to N * 1000 Tgas but the incoming flow is unlimited.</p>
<p>For a finite amount of time, we can accept more inflow than outflow, we just have to add buffers to store what we cannot execute, yet. But to stay within finite memory requirements, we need to fall back to a flow diagram where outflows are greater or equal to inflows within a finite time frame.</p>
<p>Next, we look at ideas one at a time before combining some of them into the
cross-shard congestion design proposed in
<a href="https://github.com/near/NEPs/blob/master/neps/nep-0539.md">NEP-539</a>.</p>
<h2 id="idea-1-compute-the-minimum-max-flow-and-stay-below-that-limit"><a class="header" href="#idea-1-compute-the-minimum-max-flow-and-stay-below-that-limit">Idea 1: Compute the minimum max-flow and stay below that limit</a></h2>
<p>One approach to solve congestion would be to never allow more work into the
system than we can execute.</p>
<p>But this is not ideal. Just consider this example where everybody tries to access
a contract on the same shard.</p>
<p><img src="architecture/how/../../images/congestion/receipt_flow_example_1.svg" alt="graph" /></p>
<p>In this workload where everyone want to use the capacity of the same shard, the
max-flow of the system is essentially the 1000 Tgas that shard 3 can execute. No
matter how many additional shards we add, this 1000 Tgas does not increase.</p>
<p>Consequently, if we want to limit inflow to be the same or lower than the
outflow, we cannot accept more than <code>1000 Tgas / NUM_SHARDS</code> of new transactions
per chunk.</p>
<p><img src="architecture/how/../../images/congestion/receipt_flow_example_1_1.svg" alt="graph" /></p>
<p>So, can we just put a constant limit on sources that's <code>1000 Tgas / NUM_SHARDS</code>? Not
really, as this limit is hardly practical. It means we limit global throughput
to that of a single shard. Then why would we do sharding in the first place?</p>
<p>The sad thing is, there is no way around it in the most general case. A
congestion control strategy that does not apply this limit to this workload will
always have infinitely sized queues.</p>
<p>Of course, we won't give up. We are not limited to a constant capacity limit, we
can instead adjust it dynamically. We simply have to find a strategy that
detects such workload and eventually applies the required limit.</p>
<p>Most of these strategies can be gamed by malicious actors and probably that
means we eventually fall back to the minimum of <code>1000 Tgas / NUM_SHARDS</code>. But at
this stage our ambition isn't to have 100% utilization under all malicious
cases. We are instead trying to find a solution that can give 100% utilization
for normal operation and then falls back to <code>1000 Tgas / NUM_SHARDS</code> when it has
to, in order to prevent out-of-memory crashes.</p>
<h2 id="idea-2-limit-transactions-when-we-use-too-much-memory"><a class="header" href="#idea-2-limit-transactions-when-we-use-too-much-memory">Idea 2: Limit transactions when we use too much memory</a></h2>
<p>What if we have no limit at the source until we notice we are above the memory
threshold we are comfortable with? Then we can reduce the source capacity in
steps, potentially down to 0, until buffers are getting emptier and we use less
memory again.</p>
<p>If we do that, we can decide between either applying a global limit on all
sources (allow only <code>1000 Tgas / NUM_SHARDS</code> new transactions on all shards like
in idea 1) or applying the limit only to transactions that go to the shard with
the congestion problem.</p>
<p>The first choice is certainly safe. But it means that a single congested shard
leads to all shards slowing down, even if they could keep working faster without
ever sending receipts to the congested shard. This is a hit to utilization we
want to avoid. So let's try the second way.</p>
<p>In that case we filter transactions by receiver and keep accepting transactions
that go to non-congested shards. This would work fine, if all transactions would
only have depth 1.</p>
<p>But receipts produced by an accepted transaction can produce more receipts to
any other shard. Therefore, we might end up accepting more inflow that
indirectly requires bandwidth on the congested shard.</p>
<p><img src="architecture/how/../../images/congestion/receipt_flow_example_2.svg" alt="graph" /></p>
<p>Crucially, when accepting a transaction, we don't know ahead of time which
shards will be affected by the full directed graph of receipts in a transaction.
We only know the first step. For multi-hop transactions, there is no easy way out.</p>
<p>But it is worth mentioning, that in practice the single-hop function call is the
most common case. And this case can be handled nicely by rejecting incoming
transactions to congested shards.</p>
<h2 id="idea-3-apply-backpressure-to-stop-all-flows-to-a-congested-shard"><a class="header" href="#idea-3-apply-backpressure-to-stop-all-flows-to-a-congested-shard">Idea 3: Apply backpressure to stop all flows to a congested shard</a></h2>
<p>On top of stopping transactions to congested shards, we can also stop receipts if they have a congested shard as the receiver.
We simply put them in a buffer of the sending shard and keep them there until
the congested shard has space again for the receipts.</p>
<p><img src="architecture/how/../../images/congestion/receipt_flow_example_3.svg" alt="graph" /></p>
<p>The problem with this idea is that it leads to deadlocks where all receipts in
the system are waiting in outgoing buffers but cannot make progress because the
receiving shard already has too high memory usage.</p>
<p><img src="architecture/how/../../images/congestion/receipt_flow_example_3_1.svg" alt="graph" /></p>
<h2 id="idea-4-keep-minimum-incoming-queue-length-to-avoid-deadlocks"><a class="header" href="#idea-4-keep-minimum-incoming-queue-length-to-avoid-deadlocks">Idea 4: Keep minimum incoming queue length to avoid deadlocks</a></h2>
<p>This is the final idea we need. To avoid deadlocks, we ensure that we can always
send receipts to a shard that does not have enough work in the delayed receipts queue
already.</p>
<p>Basically, the backpressure limits from idea 3 are only applied to incoming
receipts but not for the total size. This guarantees that in the congested
scenario that previously caused a deadlock, we always have something in the
incoming queue to work on, otherwise there wouldn't be backpressure at all.</p>
<p><img src="architecture/how/../../images/congestion/receipt_flow_example_4.svg" alt="graph" /></p>
<p>We decided to measure the incoming congestion level using gas rather than
bytes, because it is here to maximize utilization, not to minimize memory
consumption. And utilization is best measured in gas. If we have a queue of
10_000 Tgas waiting, even if only 10% of that is burnt in this step of the
transaction, we still have 1000 Tgas of useful work we can contribute to the
total flow. Thus under the assumption that at least 10% of gas is being burnt, 
we have 100% utilization.</p>
<p>A limit in bytes would be better to argue how much memory we need exactly. But
in some sense, the two are equivalent, as producing large receipts should cost a
linear amount of gas. What exactly the conversion rate is, is rather complicated
and warrants its own investigation with potential protocol changes to lower the
ratio in the most extreme cases. And this is important regardless of how
congestion is handled, given that network bandwidth is becoming more and more
important as we add more shards. Issue
<a href="https://github.com/near/nearcore/issues/8214">#8214</a> tracks our effort on
estimating what that cost should be and
<a href="https://github.com/near/nearcore/issues/9378">#9378</a> tracks our best progress
on calculating what it is today.</p>
<p>Of course, we can increase the queue to have even better utility guarantees. But
it comes at the cost of longer delays for every transaction or receipt that goes
through a congested shard.</p>
<p>This strategy also preserves the backpressure property in the sense that all
shards on a path from sources to sinks that contribute to congestion will
eventually end up with full buffers. Combined with idea 2, eventually all
transactions to those shards are rejected. All of this without affecting shards
that are not on the critical path.</p>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it all together</a></h2>
<p>The proposal in <a href="https://github.com/near/NEPs/blob/master/neps/nep-0539.md">NEP-539</a> combines all
ideas 2, 3, and 4.</p>
<p>We have a limit of how much memory we consider to be normal operations (for
example 500 MB). Then we stop new transaction coming in to that shard but still
allow more incoming transactions to other shards if those are not congested.
That alone already solves all problems with single-hop transactions.</p>
<p>In the congested shard itself, we also keep accepting transactions to other
shards. But we heavily reduce the gas allocated for new transactions, in order
to have more capacity to work on finishing the waiting receipts. This is
technically not necessary for any specific property, but it should make sense
intuitively that this helps to reduce congestion quicker and therefore lead to a
better user experience. This is why we added this feature. And our simulations
also support this intuition.</p>
<p>Then we apply backpressure for multi-hop receipts and avoid deadlocks by only
applying the backpressure when we still have enough work queued up that holding
it back cannot lead to a slowed down global throughput.</p>
<p>Another design decision was to linearly interpolate the limits, as opposed to
binary on and off states. This way, we don't have to be too precise in finding
the right parameters, as the system should balance itself around a specific
limit that works for each workload.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meta-transactions"><a class="header" href="#meta-transactions">Meta Transactions</a></h1>
<p><a href="https://github.com/near/NEPs/blob/master/neps/nep-0366.md">NEP-366</a> introduced the concept of meta
transactions to Near Protocol. This feature allows users to execute transactions
on NEAR without owning any gas or tokens. In order to enable this, users
construct and sign transactions off-chain. A third party (the relayer) is used
to cover the fees of submitting and executing the transaction.</p>
<p>The MVP for meta transactions is currently in the stabilization process.
Naturally, the MVP has some limitations, which are discussed in separate
sections below. Future iterations have the potential to make meta transactions
more flexible.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p><img src="https://raw.githubusercontent.com/near/NEPs/003e589e6aba24fc70dd91c9cf7ef0007ca50735/neps/assets/nep-0366/NEP-DelegateAction.png" alt="Flow chart of meta transactions" />
<em>Credits for the diagram go to the NEP authors Alexander Fadeev and Egor
Uleyskiy.</em></p>
<p>The graphic shows an example use case for meta transactions. Alice owns an
amount of the fungible token $FT. She wants to transfer some to John. To do
that, she needs to call <code>ft_transfer(&quot;john&quot;, 10)</code> on an account named <code>FT</code>.</p>
<p>In technical terms, ownership of $FT is an entry in the <code>FT</code> contract's storage
that tracks the balance for her account. Note that this is on the application
layer and thus not a part of Near Protocol itself. But <code>FT</code> relies on the
protocol to verify that the <code>ft_transfer</code> call actually comes from Alice. The
contract code checks that <code>predecessor_id</code> is <code>&quot;Alice&quot;</code> and if that is the case
then the call is legitimately from Alice, as only she could create such a
receipt according to the Near Protocol specification.</p>
<p>The problem is, Alice has no NEAR tokens. She only has a NEAR account that
someone else funded for her and she owns the private keys. She could create a
signed transaction that would make the <code>ft_transfer(&quot;john&quot;, 10)</code> call. But
validator nodes will not accept it, because she does not have the necessary Near
token balance to purchase the gas.</p>
<p>With meta transactions, Alice can create a <code>DelegateAction</code>, which is very
similar to a transaction. It also contains a list of actions to execute and a
single receiver for those actions. She signs the <code>DelegateAction</code> and forwards
it (off-chain) to a relayer. The relayer wraps it in a transaction, of which the
relayer is the signer and therefore pays the gas costs. If the inner actions
have an attached token balance, this is also paid for by the relayer.</p>
<p>On chain, the <code>SignedDelegateAction</code> inside the transaction is converted to an
action receipt with the same <code>SignedDelegateAction</code> on the relayer's shard. The
receipt is forwarded to the account from <code>Alice</code>, which will unpacked the
<code>SignedDelegateAction</code> and verify that it is signed by Alice with a valid Nonce
etc. If all checks are successful, a new action receipt with the inner actions
as body is sent to <code>FT</code>. There, the <code>ft_transfer</code> call finally executes.</p>
<h2 id="relayer"><a class="header" href="#relayer">Relayer</a></h2>
<p>Meta transactions only work with a relayer. This is an application layer
concept, implemented off-chain. Think of it as a server that accepts a
<code>SignedDelegateAction</code>, does some checks on them and eventually forwards it
inside a transaction to the blockchain network.</p>
<p>A relayer may choose to offer their service for free but that's not going to be
financially viable long-term. But they could easily have the user pay using
other means, outside of Near blockchain. And with some tricks, it can even be
paid using fungible tokens on Near.</p>
<p>In the example visualized above, the payment is done using $FT. Together with
the transfer to John, Alice also adds an action to pay 0.1 $FT to the relayer.
The relayer checks the content of the <code>SignedDelegateAction</code> and only processes
it if this payment is included as the first action. In this way, the relayer
will be paid in the same transaction as John. </p>
<p>Note that the payment to the relayer is still not guaranteed. It could be that
Alice does not have sufficient $FT and the transfer fails. To mitigate, the
relayer should check the $FT balance of Alice first.</p>
<p>Unfortunately, this still does not guarantee that the balance will be high
enough once the meta transaction executes. The relayer could waste NEAR gas
without compensation if Alice somehow reduces her $FT balance in just the right
moment. Some level of trust between the relayer and its user is therefore
required.</p>
<p>The vision here is that there will be mostly application-specific relayers. A
general-purpose relayer is difficult to implement with just the MVP. See
limitations below.</p>
<h2 id="limitation-single-receiver"><a class="header" href="#limitation-single-receiver">Limitation: Single receiver</a></h2>
<p>A meta transaction, like a normal transaction, can only have one receiver. It's
possible to chain additional receipts afterwards. But crucially, there is no
atomicity guarantee and no roll-back mechanism.</p>
<p>For normal transactions, this has been widely accepted as a fact for how Near
Protocol works. For meta transactions, there was a discussion around allowing
multiple receivers with separate lists of actions per receiver. While this could
be implemented, it would only create a false sense of atomicity. Since each
receiver would require a separate action receipt, there is no atomicity, the
same as with chains of receipts.</p>
<p>Unfortunately, this means the trick to compensate the relayer in the same meta
transaction as the serviced actions only works if both happen on the same
receiver. In the example, both happen on <code>FT</code> and this case works well. But it
would not be possible to send $FT1 and pay the relayer in $FT2. Nor could one
deploy a contract code on <code>Alice</code> and pay in $FT in one meta transaction. It
would require two separate meta transactions to do that. Due to timing problems,
this again requires some level of trust between the relayer and Alice.</p>
<p>A potential solution could involve linear dependencies between the action
receipts spawned from a single meta transaction. Only if the first succeeds,
will the second start executing, and so on. But this quickly gets too complicated
for the MVP and is therefore left open for future improvements.</p>
<h2 id="constraints-on-the-actions-inside-a-meta-transaction"><a class="header" href="#constraints-on-the-actions-inside-a-meta-transaction">Constraints on the actions inside a meta transaction</a></h2>
<p>A transaction is only allowed to contain one single delegate action. Nested
delegate actions are disallowed and so are delegate actions next to each other
in the same receipt.</p>
<p>Nested delegate actions have no known use case and it would be complicated to
implement. Consequently, it was omitted.</p>
<p>For delegate actions beside each other, there was a bit of back and forth during
the NEP-366 design phase. The potential use case here is essentially the same as
having multiple receivers in a delegate action. Naturally, it runs into all the
same complications (false sense of atomicity) and ends with the same conclusion:
Omitted from the MVP and left open for future improvement.</p>
<h2 id="limitation-accounts-must-be-initialized"><a class="header" href="#limitation-accounts-must-be-initialized">Limitation: Accounts must be initialized</a></h2>
<p>Any transaction, including meta transactions, must use NONCEs to avoid replay
attacks. The NONCE must be chosen by Alice and compared to a NONCE stored on
chain. This NONCE is stored on the access key information that gets initialized
when creating an account. </p>
<p>Implicit accounts don't need to be initialized in order to receive NEAR tokens,
or even $FT. This means users could own $FT but no NONCE is stored on chain for
them. This is problematic because we want to enable this exact use case with
meta transactions, but we have no NONCE to create a meta transaction.</p>
<p>For the MVP, the proposed solution, or work-around, is that the relayer will
have to initialize the account of Alice once if it does not exist. Note that
this cannot be done as part of the meta transaction. Instead, it will be a
separate transaction that executes first. Only then can Alice even create a
<code>SignedDelegateAction</code> with a valid NONCE.</p>
<p>Once again, some trust is required. If Alice wanted to abuse the relayer's
helpful service, she could ask the relayer to initialize her account.
Afterwards, she does not sign a meta transaction, instead she deletes her
account and cashes in the small token balance reserved for storage. If this
attack is repeated, a significant amount of tokens could be stolen from the
relayer.</p>
<p>One partial solution suggested here was to remove the storage staking cost from
accounts. This means there is no financial incentive for Alice to delete her
account. But it does not solve the problem that the relayer has to pay for the
account creation and Alice can simply refuse to send a meta transaction
afterwards. In particular, anyone creating an account would have financial
incentive to let a relayer create it for them instead of paying out of their own
pockets. This would still be better than Alice stealing tokens but
fundamentally, there still needs to be some trust.</p>
<p>An alternative solution discussed is to do NONCE checks on the relayer's access
key. This prevents replay attacks and allows implicit accounts to be used in
meta transactions without even initializing them. The downside is that meta
transactions share the same NONCE counter(s). That means, a meta transaction
sent by Bob may invalidate a meta transaction signed by Alice that was created
and sent to the relayer at the same time. Multiple access keys by the relayer
and coordination between relayer and user could potentially alleviate this
problem. But for the MVP, nothing along those lines has been approved.</p>
<h2 id="gas-costs-for-meta-transactions"><a class="header" href="#gas-costs-for-meta-transactions">Gas costs for meta transactions</a></h2>
<p>Meta transactions challenge the traditional ways of charging gas for actions. To
see why, let's first list the normal flow of gas, outside of meta transactions.</p>
<ol>
<li>Gas is purchased (by deducting NEAR from the transaction signer account),
when the transaction is converted into a receipt. The amount of gas is
implicitly defined by the content of the receipt. For function calls, the
caller decides explicitly how much gas is attached on top of the minimum
required amount. The NEAR token price per gas unit is dynamically adjusted on
the blockchain. In today's nearcore code base, this happens as part of
<a href="https://github.com/near/nearcore/blob/4510472d69c059644bb2d2579837c6bd6d94f190/runtime/runtime/src/verifier.rs#L69"><code>verify_and_charge_transaction</code></a>
which gets called in
<a href="https://github.com/near/nearcore/blob/4510472d69c059644bb2d2579837c6bd6d94f190/runtime/runtime/src/lib.rs#L218"><code>process_transaction</code></a>.</li>
<li>For all actions listed inside the transaction, the <code>SEND</code> cost is burned
immediately. Depending on the condition <code>sender == receiver</code>, one of two
possible <code>SEND</code> costs is chosen. The <code>EXEC</code> cost is not burned, yet. But it
is implicitly part of the transaction cost. The third and last part of the
transaction cost is the gas attached to function calls. The attached gas is
also called prepaid gas. (Not to be confused with <code>total_prepaid_exec_fees</code>
which is the implicitly prepaid gas for <code>EXEC</code> action costs.)</li>
<li>On the receiver shard, <code>EXEC</code> costs are burned before the execution of an
action starts. Should the execution fail and abort the transaction, the
remaining gas will be refunded to the signer of the transaction.</li>
</ol>
<p>Ok, now adapt for meta transactions. Let's assume Alice uses a relayer to
execute actions with Bob as the receiver.</p>
<ol>
<li>The relayer purchases the gas for all inner actions, plus the gas for the
delegate action wrapping them.</li>
<li>The cost of sending the inner actions and the delegate action from the
relayer to Alice's shard will be burned immediately. The condition <code>relayer == Alice</code> determines which action <code>SEND</code> cost is taken (<code>sir</code> or <code>not_sir</code>).
Let's call this <code>SEND(1)</code>.</li>
<li>On Alice's shard, the delegate action is executed, thus the <code>EXEC</code> gas cost
for it is burned. Alice sends the inner actions to Bob's shard. Therefore, we
burn the <code>SEND</code> fee again. This time based on <code>Alice == Bob</code> to figure out
<code>sir</code> or <code>not_sir</code>. Let's call this <code>SEND(2)</code>.</li>
<li>On Bob's shard, we execute all inner actions and burn their <code>EXEC</code> cost.</li>
</ol>
<p>Each of these steps should make sense and not be too surprising. But the
consequence is that the implicit costs paid at the relayer's shard are
<code>SEND(1)</code> + <code>SEND(2)</code> + <code>EXEC</code> for all inner actions plus <code>SEND(1)</code> + <code>EXEC</code> for
the delegate action. This might be surprising but hopefully with this
explanation it makes sense now!</p>
<h2 id="gas-refunds-in-meta-transactions"><a class="header" href="#gas-refunds-in-meta-transactions">Gas refunds in meta transactions</a></h2>
<p>Gas refund receipts work exactly like for normal transaction. At every step, the
difference between the pessimistic gas price and the actual gas price at that
height is computed and refunded. At the end of the last step, additionally all
remaining gas is also refunded at the original purchasing price. The gas refunds
go to the signer of the original transaction, in this case the relayer. This is
only fair, since the relayer also paid for it.</p>
<h2 id="balance-refunds-in-meta-transactions"><a class="header" href="#balance-refunds-in-meta-transactions">Balance refunds in meta transactions</a></h2>
<p>Unlike gas refunds, the protocol sends balance refunds to the predecessor
(a.k.a. sender) of the receipt. This makes sense, as we deposit the attached
balance to the receiver, who has to explicitly reattach a new balance to new
receipts they might spawn.</p>
<p>In the world of meta transactions, this assumption is also challenged. If an
inner action requires an attached balance (for example a transfer action) then
this balance is taken from the relayer.</p>
<p>The relayer can see what the cost will be before submitting the meta transaction
and agrees to pay for it, so nothing wrong so far. But what if the transaction
fails execution on Bob's shard? At this point, the predecessor is <code>Alice</code> and
therefore she receives the token balance refunded, not the relayer. This is
something relayer implementations must be aware of since there is a financial
incentive for Alice to submit meta transactions that have high balances attached
but will fail on Bob's shard.</p>
<h2 id="function-access-keys-in-meta-transactions"><a class="header" href="#function-access-keys-in-meta-transactions">Function access keys in meta transactions</a></h2>
<p>Assume alice sends a meta transaction and signs with a function access key.
How exactly are permissions applied in this case?</p>
<p>Function access keys can limit the allowance, the receiving contract, and the
contract methods. The allowance limitation acts slightly strange with meta
transactions.</p>
<p>But first, both the methods and the receiver will be checked as expected. That
is, when the delegate action is unwrapped on Alice's shard, the access key is
loaded from the DB and compared to the function call. If the receiver or method
is not allowed, the function call action fails.</p>
<p>For allowance, however, there is no check. All costs have been covered by the
relayer. Hence, even if the allowance of the key is insufficient to make the call
directly, indirectly through meta transaction it will still work.</p>
<p>This behavior is in the spirit of allowance limiting how much financial
resources the user can use from a given account. But if someone were to limit a
function access key to one trivial action by setting a very small allowance,
that is circumventable by going through a relayer. An interesting twist that
comes with the addition of meta transactions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-borsh-json-protobuf"><a class="header" href="#serialization-borsh-json-protobuf">Serialization: Borsh, Json, ProtoBuf</a></h1>
<p>If you spent some time looking at NEAR code, you’ll notice that we have
different methods of serializing structures into strings. So in this article,
we’ll compare these different approaches, and explain how and where we’re using
them.</p>
<h2 id="protocolschema"><a class="header" href="#protocolschema">ProtocolSchema</a></h2>
<p>All structs which need to be persisted or sent over the network must derive the
ProtocolSchema trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// First, the schema checksums (hashes) are calculated at compile time and
// require `TypeId` for cross-navigation. However, it is a nightly feature,
// so we enable it manually by putting this in lib.rs:

#![cfg_attr(enable_const_type_id, feature(const_type_id))]

// Then, import schema calculation functionality by putting in Cargo.toml:
// near-schema-checker-lib.workspace = true

[features]
protocol_schema = [
  &quot;near-schema-checker-lib/protocol_schema&quot;,
  ...the same feature in all dependent crates...
]
 
// Then, mark your struct with `#[derive(ProtocolSchema)]`:

use near_schema_checker_lib::ProtocolSchema;

#[derive(ProtocolSchema)]
pub struct BlockHeader {
  pub hash: CryptoHash,
  pub height: BlockHeight,
}

// Lastly, mark your crate in `tools/protocol-schema-check/Cargo.toml`
// as dependency with `protocol_schema` feature enabled.

<span class="boring">}
</span></code></pre></pre>
<p>This is done to protect structures from accidental changes that could corrupt the 
database or disrupt the protocol. Dedicated CI check is responsible to check the 
consistency of the schema. See <a href="architecture/how/../../../tools/protocol-schema-check/README.html">README</a> for more details.</p>
<p>All these structures are likely to implement BorshSerialize and BorshDeserialize (see below).</p>
<h2 id="borsh"><a class="header" href="#borsh">Borsh</a></h2>
<p>Borsh is our custom serializer (<a href="https://github.com/near/borsh">link</a>), that we use
mostly for things that have to be hashed.</p>
<p>The main feature of Borsh is that, there are no two binary representations that
deserialize into the same object.</p>
<p>You can read more on how Borsh serializes the data, by looking at the Specification
tab on <a href="https://borsh.io">borsh.io</a>.</p>
<p>The biggest pitfall/risk of Borsh, is that any change to the structure, might
cause previous data to no longer be parseable.</p>
<p>For example, inserting a new enum ‘in the middle’:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MyCar {
  Bmw,
  Ford,
}

If we change our enum to this:

pub enum MyCar {
  Bmw,
  Citroen,
  Ford, // !! WRONG - Ford objects cannot be deserialized anymore
}
<span class="boring">}
</span></code></pre></pre>
<p>This is especially tricky if we have conditional compilation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MyCar {
  Bmw,
  #[cfg(feature = &quot;french_cars&quot;)]
  Citroen,
  Ford,
}
<span class="boring">}
</span></code></pre></pre>
<p>Is such a scenario - some of the objects created by binaries with this feature
enabled, will not be parseable by binaries without this feature.</p>
<p>Removing and adding fields to structures is also dangerous.</p>
<p>Basically - the only ‘safe’ thing that you can do with Borsh - is add a new Enum
value at the end.</p>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>JSON doesn’t need much introduction. We’re using it for external APIs (jsonrpc)
and configuration. It is a very popular, flexible and human-readable format.</p>
<h2 id="proto-protocol-buffers"><a class="header" href="#proto-protocol-buffers">Proto (Protocol Buffers)</a></h2>
<p>We started using proto recently - and we plan to use it mostly for our network
communication. Protocol buffers are strongly typed - they require you to create
a .proto file, where you describe the contents of your message.</p>
<p>For example:</p>
<pre><code class="language-proto">message HandshakeFailure {
  // Reason for rejecting the Handshake.
  Reason reason = 1;

  // Data about the peer.
  PeerInfo peer_info = 2;
  // GenesisId of the NEAR chain that the peer belongs to.
  GenesisId genesis_id = 3;
}
</code></pre>
<p>Afterwards, such a proto file is fed to protoc ‘compiler’ that returns
auto-generated code (in our case Rust code) - that can be directly imported into
your library.</p>
<p>The main benefit of protocol buffers is their backwards compatibility (as long
as you adhere to the rules and don’t reuse the same field ids).</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>So to recap what we’ve learned:</p>
<p>JSON - mostly used for external APIs - look for serde::Serialize/Deserialize</p>
<p>Proto - currently being developed to be used for network connections - objects
have to be specified in proto file.</p>
<p>Borsh - for things that we hash (and currently also for all the things that we
store on disk - but we might move to proto with this in the future). Look for
BorshSerialize/BorshDeserialize</p>
<h2 id="questions"><a class="header" href="#questions">Questions</a></h2>
<h3 id="why-dont-you-use-json-for-everything"><a class="header" href="#why-dont-you-use-json-for-everything">Why don’t you use JSON for everything?</a></h3>
<p>While this is a tempting option, JSON has a few drawbacks:</p>
<ul>
<li>size (json is self-describing, so all the field names etc are included every time)</li>
<li>non-canonical: JSON doesn’t specify strict ordering of the fields, so we’d
have to do additional restrictions/rules on that - otherwise the same
‘conceptual’ message would end up with different hashes.</li>
</ul>
<h3 id="ok---so-how-about-proto-for-everything"><a class="header" href="#ok---so-how-about-proto-for-everything">Ok - so how about proto for everything?</a></h3>
<p>There are couple risks related with using proto for things that have to be
hashed. A Serialized protocol buffer can contain additional data (for example
fields with tag ids that you’re not using) and still successfully parse (that’s
how it achieves backward compatibility).</p>
<p>For example, in this proto:</p>
<pre><code class="language-proto">message First {
  string foo = 1;
  string bar = 2;
}
message Second {
  string foo = 1;
}
</code></pre>
<p>Every ‘First’ message will be successfully parsed as ‘Second’ message - which
could lead to some programmatic bugs.</p>
<h2 id="advanced-section---rawtrienode"><a class="header" href="#advanced-section---rawtrienode">Advanced section - RawTrieNode</a></h2>
<p>There is one more place in the code where we use a ‘custom’ encoding:
RawTrieNodeWithSize defined in store/src/trie/raw_node.rs.  While the format
uses Borsh derives and API, there is a difference in how branch children
(<code>[Option&lt;CryptoHash&gt;; 16]</code>) are encoded.  Standard Borsh encoding would
encode <code>Option&lt;CryptoHash&gt;</code> sixteen times.  Instead, RawTrieNodeWithSize uses
a bitmap to indicate which elements are set resulting in a different layout.</p>
<p>Imagine a children vector like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[Some(0x11), None, Some(0x12), None, None, …]
<span class="boring">}
</span></code></pre></pre>
<p>Here, we have children at index 0 and 2 which has a bitmap of <code>101</code></p>
<p>Custom encoder:</p>
<pre><code>// Number of children determined by the bitmask
[16 bits bitmask][32 bytes child][32 bytes child]
[5][0x11][0x12]
// Total size: 2 + 32 + 32 = 68 bytes
</code></pre>
<p>Borsh:</p>
<pre><code>[8 bits - 0 or 1][32 bytes child][8 bits 0 or 1][8 bits ]
[1][0x11][0][1][0x11][0][0]...
// Total size: 16 + 32 + 32 = 80 bytes
</code></pre>
<p>Code for encoding children is given in BorshSerialize implementation for
ChildrenRef type and code for decoding in BorshDeserialize implementation for
Children.  All of that is in aforementioned store/src/trie/raw_node.rs file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proofs"><a class="header" href="#proofs">Proofs</a></h1>
<p>“Don’t trust, but verify” - let’s talk about proofs</p>
<h2 id="was-your-transaction-included"><a class="header" href="#was-your-transaction-included">Was your transaction included?</a></h2>
<p>How do you know that your transaction was actually included in the blockchain?
Sure, you can “simply” ask the RPC node, and it might say “yes”, but is it
enough?</p>
<p>The other option would be to ask many nodes - hoping that at least one of them
would be telling the truth. But what if that is not enough?</p>
<p>The final solution would be to run your own node - this way you’d check all the
transactions yourself, and then you could be sure - but this can become a quite
expensive endeavor - especially when many shards are involved.</p>
<p>But there is actually a better solution - that doesn’t require you to trust the
single (or many) RPC nodes, and to verify, by yourself, that your transaction was
actually executed.</p>
<h2 id="lets-talk-about-proofs-merkelization"><a class="header" href="#lets-talk-about-proofs-merkelization">Let’s talk about proofs (merkelization):</a></h2>
<p>Imagine you have 4 values that you’d like to store, in such a way, that you can
easily prove that a given value is present.</p>
<p><img src="https://user-images.githubusercontent.com/1711539/198579560-923f1f97-a8df-486d-b68e-8796c6aaa300.png" alt="image" /></p>
<p>One way to do it, would be to create a binary tree, where each node would hold a
hash:</p>
<ul>
<li>leaves would hold the hashes that represent the hash of the respective value.</li>
<li>internal nodes would hold the hash of “concatenation of hashes of their children”</li>
<li>the top node would be called a root node (in this image it is the node n7)</li>
</ul>
<p>With such a setup, you can prove that a given value exists in this tree, by
providing a “path” from the corresponding leaf to the root, and including all
the siblings.</p>
<p>For example to prove that value v[1] exists, we have to provide all the nodes
marked as green, with the information about which sibling (left or right) they
are:</p>
<p><img src="https://user-images.githubusercontent.com/1711539/198579596-488c540b-cd24-4d38-bc07-4dc3378c53d0.png" alt="image" /></p>
<pre><code># information needed to verify that node v[1] is present in a tree
# with a given root (n7)
[(Left, n0), (Right, n6)]

# Verification
assert_eq!(root, hash(hash(n0, hash(v[1])), n6))
</code></pre>
<p>We use the technique above (called merkelization) in a couple of places in our
protocol, but for today’s article, I’d like to focus on receipts &amp; outcome
roots.</p>
<h2 id="merkelization-receipts-and-outcomes"><a class="header" href="#merkelization-receipts-and-outcomes">Merkelization, receipts and outcomes</a></h2>
<p>In order to prove that a given receipt belongs to a given block, we will need to
fetch some additional information.</p>
<p>As NEAR is sharded, the receipts actually belong to “Chunks” not Blocks
themselves, so the first step is to find the correct chunk and fetch its
<code>ChunkHeader</code>.</p>
<pre><code>ShardChunkHeaderV3 {
    inner: V2(
        ShardChunkHeaderInnerV2 {
            prev_block_hash: `C9WnNCbNvkQvnS7jdpaSGrqGvgM7Wwk5nQvkNC9aZFBH`,
            prev_state_root: `5uExpfRqAoZv2dpkdTxp1ZMcids1cVDCEYAQwAD58Yev`,
            outcome_root: `DBM4ZsoDE4rH5N1AvCWRXFE9WW7kDKmvcpUjmUppZVdS`,
            encoded_merkle_root: `2WavX3DLzMCnUaqfKPE17S1YhwMUntYhAUHLksevGGfM`,
            encoded_length: 425,
            height_created: 417,
            shard_id: 0,
            gas_used: 118427363779280,
            gas_limit: 1000000000000000,
            balance_burnt: 85084341232595000000000,
            outgoing_receipts_root: `4VczEwV9rryiVSmFhxALw5nCe9gSohtRpxP2rskP3m1s`,
            tx_root: `11111111111111111111111111111111`,
            validator_proposals: [],
        },
    ),
}
</code></pre>
<p>The field that we care about is called <code>outcome_root</code>. This value represents the
root of the binary merkle tree, that is created based on all the receipts that
were processed in this chunk.</p>
<p><strong>Note:</strong> You can notice that we also have a field here called
<code>encoded_merkle_root</code> - this is another case where we use merkelization in our
chain - this field is a root of a tree that holds hashes of all the &quot;partial
chunks&quot; into which we split the chunk to be distributed over the network.</p>
<p>So, in order to verify that a given receipt/transaction was really included, we
have to compute its hash (see details below), get the path to the root, and
voila, we can confirm that it was really included.</p>
<p>But how do we get the siblings on the path to the root? This is actually
something that RPC nodes do return in their responses.</p>
<p>If you ever looked closely at NEAR’s tx-status response, you can notice a
&quot;proof&quot; section there. For every receipt, you'd see something like this:</p>
<pre><code>proof: [
    {
        direction: 'Right',
        hash: '2wTFCh2phFfANicngrhMV7Po7nV7pr6gfjDfPJ2QVwCN'
    },
    {
        direction: 'Right',
        hash: '43ei4uFk8Big6Ce6LTQ8rotsMzh9tXZrjsrGTd6aa5o6'
    },
    {
        direction: 'Left',
        hash: '3fhptxeChNrxWWCg8woTWuzdS277u8cWC9TnVgFviu3n'
    },
    {
        direction: 'Left',
        hash: '7NTMqx5ydMkdYDFyNH9fxPNEkpgskgoW56Y8qLoVYZf7'
    }
]
</code></pre>
<p>And the values in there are exactly the siblings (plus info on which side of the
tree the sibling is), on the path to the root.</p>
<p><strong>Note:</strong> proof section doesn’t contain the root itself and also doesn’t include
the hash of the receipt.</p>
<h2 id="advanced-section-lets-look-at-a-concrete-example"><a class="header" href="#advanced-section-lets-look-at-a-concrete-example">[Advanced section]: Let’s look at a concrete example</a></h2>
<p>Imagine that we have the following receipt:</p>
<pre><code>{
  block_hash: '7FtuLHR3VSNhVTDJ8HmrzTffFWoWPAxBusipYa2UfrND',
  id: '6bdKUtGbybhYEQ2hb2BFCTDMrtPBw8YDnFpANZHGt5im',
  outcome: {
    executor_id: 'node0',
    gas_burnt: 223182562500,
    logs: [],
    metadata: { gas_profile: [], version: 1 },
    receipt_ids: [],
    status: { SuccessValue: '' },
    tokens_burnt: '0'
  },
  proof: [
    {
      direction: 'Right',
      hash: 'BWwZ4wHuzaUxdDSrhAEPjFQtDgwzb8K4zoNzfX9A3SkK'
    },
    {
      direction: 'Left',
      hash: 'Dpg4nQQwbkBZMmdNYcZiDPiihZPpsyviSTdDZgBRAn2z'
    },
    {
      direction: 'Right',
      hash: 'BruTLiGx8f71ufoMKzD4H4MbAvWGd3FLL5JoJS3XJS3c'
    }
  ]
}
</code></pre>
<p>Remember that the outcomes of the execution will be added to the NEXT block, so
let’s find the next block hash, and the proper chunk.</p>
<p>(in this example, I’ve used the <code>view-state chain</code> from neard)</p>
<pre><code>417 7FtuLHR3VSNhVTDJ8HmrzTffFWoWPAxBusipYa2UfrND |      node0 | parent: 416 C9WnNCbNvkQvnS7jdpaSGrqGvgM7Wwk5nQvkNC9aZFBH | .... 0: E6pfD84bvHmEWgEAaA8USCn2X3XUJAbFfKLmYez8TgZ8 107 Tgas |1: Ch1zr9TECSjDVaCjupNogLcNfnt6fidtevvKGCx8c9aC 104 Tgas |2: 87CmpU6y7soLJGTVHNo4XDHyUdy5aj9Qqy4V7muF5LyF   0 Tgas |3: CtaPWEvtbV4pWem9Kr7Ex3gFMtPcKL4sxDdXD4Pc7wah   0 Tgas
418 J9WQV9iRJHG1shNwGaZYLEGwCEdTtCEEDUTHjboTLLmf |      node0 | parent: 417 7FtuLHR3VSNhVTDJ8HmrzTffFWoWPAxBusipYa2UfrND | .... 0: 7APjALaoxc8ymqwHiozB5BS6mb3LjTgv4ofRkKx2hMZZ   0 Tgas |1: BoVf3mzDLLSvfvsZ2apPSAKjmqNEHz4MtPkmz9ajSUT6   0 Tgas |2: Auz4FzUCVgnM7RsQ2noXsHW8wuPPrFxZToyLaYq6froT   0 Tgas |3: 5ub8CZMQmzmZYQcJU76hDC3BsajJfryjyShxGF9rzpck   1 Tgas
</code></pre>
<p>I know that the receipt should belong to Shard 3 <!-- TODO: how? :) --> so let’s fetch
the chunk header:</p>
<pre><code class="language-console">$ neard view-state chunks --chunk-hash 5ub8CZMQmzmZYQcJU76hDC3BsajJfryjyShxGF9rzpck
</code></pre>
<pre><code>ShardChunkHeaderV3 {
  inner: V2(
      ShardChunkHeaderInnerV2 {
          prev_block_hash: `7FtuLHR3VSNhVTDJ8HmrzTffFWoWPAxBusipYa2UfrND`,
          prev_state_root: `6rtfqVEXx5STLv5v4zwLVqAfq1aRAvLGXJzZPK84CPpa`,
          outcome_root: `2sZ81kLj2cw5UHTjdTeMxmaWn2zFeyr5pFunxn6aGTNB`,
          encoded_merkle_root: `6xxoqYzsgrudgaVRsTV29KvdTstNYVUxis55KNLg6XtX`,
          encoded_length: 8,
          height_created: 418,
          shard_id: 3,
          gas_used: 1115912812500,
          gas_limit: 1000000000000000,
          balance_burnt: 0,
          outgoing_receipts_root: `8s41rye686T2ronWmFE38ji19vgeb6uPxjYMPt8y8pSV`,
          tx_root: `11111111111111111111111111111111`,
          validator_proposals: [],
      },
  ),
  height_included: 0,
  signature: ed25519:492i57ZAPggqWEjuGcHQFZTh9tAKuQadMXLW7h5CoYBdMRnfY4g7A749YNXPfm6yXnJ3UaG1ahzcSePBGm74Uvz3,
  hash: ChunkHash(
      `5ub8CZMQmzmZYQcJU76hDC3BsajJfryjyShxGF9rzpck`,
  ),
}
</code></pre>
<p>So the <code>outcome_root</code> is <code>2sZ81kLj2cw5UHTjdTeMxmaWn2zFeyr5pFunxn6aGTNB</code> - let’s
verify it then.</p>
<p>Our first step is to compute the hash of the receipt, which is equal to
<code>hash([receipt_id, hash(borsh(receipt_payload)])</code></p>
<pre><code class="language-python"># this is a borsh serialized ExecutionOutcome struct.
# computing this, we leave as an exercise for the reader :-)
receipt_payload_hash = &quot;7PeGiDjssz65GMCS2tYPHUm6jYDeBCzpuPRZPmLNKSy7&quot;

receipt_hash = base58.b58encode(hashlib.sha256(struct.pack(&quot;&lt;I&quot;, 2) + base58.b58decode(&quot;6bdKUtGbybhYEQ2hb2BFCTDMrtPBw8YDnFpANZHGt5im&quot;) + base58.b58decode(receipt_payload_hash)).digest())
</code></pre>
<p>And then we can start reconstructing the tree:</p>
<pre><code class="language-python">def combine(a, b):
   return hashlib.sha256(a + b).digest()

# one node example
# combine(receipt_hash, &quot;BWwZ4wHuzaUxdDSrhAEPjFQtDgwzb8K4zoNzfX9A3SkK&quot;)
# whole tree
combine(combine(&quot;Dpg4nQQwbkBZMmdNYcZiDPiihZPpsyviSTdDZgBRAn2z&quot;, combine(receipt_hash, &quot;BWwZ4wHuzaUxdDSrhAEPjFQtDgwzb8K4zoNzfX9A3SkK&quot;)), &quot;BruTLiGx8f71ufoMKzD4H4MbAvWGd3FLL5JoJS3XJS3c&quot;)
# result == 2sZ81kLj2cw5UHTjdTeMxmaWn2zFeyr5pFunxn6aGTNB
</code></pre>
<p>And success - our result is matching the outcome root, so it means that our
receipt was indeed processed by the blockchain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resharding-v2"><a class="header" href="#resharding-v2">Resharding V2</a></h1>
<p><strong>DISCLAIMER</strong>: This document describes Resharding V2 and it may not be up to date with recent changes to <code>nearcore</code>.</p>
<h2 id="resharding"><a class="header" href="#resharding">Resharding</a></h2>
<p>Resharding is the process in which the shard layout changes. The primary purpose
of resharding is to keep the shards small so that a node meeting minimum hardware
requirements can safely keep up with the network while tracking some set minimum 
number of shards. </p>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<p>The resharding is described in more detail in the following NEPs:</p>
<ul>
<li><a href="https://github.com/near/NEPs/blob/master/specs/Proposals/0040-split-states.md">NEP-0040</a></li>
<li><a href="https://github.com/near/NEPs/blob/master/neps/nep-0508.md">NEP-0508</a></li>
</ul>
<h2 id="shard-layout"><a class="header" href="#shard-layout">Shard layout</a></h2>
<p>The shard layout determines the number of shards and the assignment of accounts
to shards (as single account cannot be split between shards). </p>
<p>There are two versions of the ShardLayout enum. </p>
<ul>
<li>v0 - maps the account to a shard taking hash of the account id modulo number of shards</li>
<li>v1 - maps the account to a shard by looking at a set of predefined boundary accounts
and selecting the shard where the accounts fits by using alphabetical order</li>
</ul>
<p>At the time of writing there are three pre-defined shard layouts but more can
be added in the future. </p>
<ul>
<li>v0 - The first shard layout that contains only a single shard encompassing all the accounts. </li>
<li>simple nightshade - Splits the accounts into 4 shards. </li>
<li>simple nightshade v2 - Splits the accounts into 5 shards. </li>
</ul>
<p><strong>IMPORTANT</strong>: Using alphabetical order applies to the full account name, so <code>a.near</code> could belong to
shard 0, while <code>z.a.near</code> to shard 3.</p>
<p>Currently in mainnet &amp; testnet, we use the fixed shard split (which is defined in <code>get_simple_nightshade_layout</code>):</p>
<p><code>vec![&quot;aurora&quot;, &quot;aurora-0&quot;, &quot;kkuuue2akv_1630967379.near&quot;]</code></p>
<p>In the near future we are planning on switching to simple nightshade v2 (which is defined in <code>get_simple_nightshade_layout_v2</code>)</p>
<p><code>vec![&quot;aurora&quot;, &quot;aurora-0&quot;, &quot;kkuuue2akv_1630967379.near&quot;, &quot;tge-lockup.sweat&quot;]</code></p>
<h2 id="shard-layout-changes"><a class="header" href="#shard-layout-changes">Shard layout changes</a></h2>
<p>Shard Layout is determined at epoch level in the AllEpochConfig based on the protocol version of the epoch. </p>
<p>The shard layout can change at the epoch boundary. Currently in order to change the 
shard layout it is necessary to manually determine the new shard layout and setting it
for the desired protocol version in the <code>AllEpochConfig</code>.</p>
<h3 id="deeper-technical-details"><a class="header" href="#deeper-technical-details">Deeper technical details</a></h3>
<p>It all starts in <code>preprocess_block</code> - if the node sees, that the block it is
about to preprocess is the first block of the epoch (X+1)  - it calls
<code>get_state_sync_info</code>, which is responsible for figuring out which shards will 
be needed in next epoch (X+2).</p>
<p>This is the moment, when node can request new shards that it didn't track before (using StateSync) - and if it detects that the shard layout would change in the next epoch, it also involves the StateSync - but skips the download part (as it already has the data) - and starts from resharding.</p>
<p>StateSync in this phase would send the <code>ReshardingRequest</code> to the <code>SyncJobsActor</code> (you can think about the <code>SyncJobsActor</code> as a background thread).</p>
<p>We'd use the background thread to perform resharding: the goal is to change the one trie (that represents the state of the current shard) - to multiple tries (one for each of the new shards).</p>
<p>In order to split a trie into children tries we use a snapshot of the flat storage. We iterate over all of the entries in the flat storage and we build the children tries by inserting the parent entry into either of the children tries. </p>
<p>Extracting of the account from the key happens in <code>parse_account_id_from_raw_key</code> - and we do it for all types of data that we store in the trie (contract code, keys, account info etc) EXCEPT for Delayed receipts. Then, we figure out the shard that this account is going to belong to, and we add this key/value to that new trie.</p>
<p>This way, after going over all the key/values from the original trie, we end up with X new tries (one for each new shard).</p>
<p>IMPORTANT: in the current code, we only support such 'splitting' (so a new shard can have just one parent).</p>
<h3 id="why-delayed-receipts-are-special"><a class="header" href="#why-delayed-receipts-are-special">Why delayed receipts are special?</a></h3>
<p>For all the other columns, there is no dependency between entries, but in case of delayed receipts - we are forming a 'queue'. We store the information about the first index and the last index (in DelayedReceiptIndices struct).</p>
<p>Then, when receipt arrives, we add it as the 'DELAYED_RECEIPT + last_index' key (and increment last_index by 1).</p>
<p>That is why we cannot move this trie entry type in the same way as others where account id is part of the key. Instead we do it by iterating over this queue and inserting entries to the queue of the relevant child shard. </p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>The state sync of the parent shard, the resharing and the catchup of the children shards must all complete within a single epoch. </p>
<h2 id="rollout"><a class="header" href="#rollout">Rollout</a></h2>
<h3 id="flow"><a class="header" href="#flow">Flow</a></h3>
<p>The resharding will be initiated by having it included in a dedicated protocol version together with neard. Here is the expected flow of events:</p>
<ul>
<li>A new neard release is published and protocol version upgrade date is set to D, roughly a week from the release. </li>
<li>All node operators upgrade their binaries to the newly released version within the given timeframe, ideally as soon as possible but no later than D. </li>
<li>The protocol version upgrade voting takes place at D in an epoch E and nodes vote in favour of switching to the new protocol version in epoch E+2. </li>
<li>The resharding begins at the beginning of epoch E+1. </li>
<li>The network switches to the new shard layout in the first block of epoch E+2. </li>
</ul>
<h3 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h3>
<p>Resharding exposes a number of metrics and logs that allow for monitoring the resharding process as it is happening. Resharding requires manual recovery in case anything goes wrong and should be monitored in order to ensure smooth node operation. </p>
<ul>
<li>near_resharding_status is the primary metric that should be used for tracking the progress of resharding. It's tagged with a shard_uid label of the parent shard. It's set to corresponding ReshardingStatus enum and can take one of the following values
<ul>
<li>0 - Scheduled - resharding is scheduled and waiting to be executed. </li>
<li>1 - Building - resharding is running. Only one shard at a time can be in that state while the rest will be either finished or waiting in the Scheduled state. </li>
<li>2 - Finished - resharding is finished. </li>
<li>-1 - Failed - resharding failed and manual recovery action is required. The node will operate as usual until the end of the epoch but will then stop being able to process blocks. </li>
</ul>
</li>
<li>near_resharding_batch_size and near_resharding_batch_count - those two metrics show how much data has been resharded. Both metrics should progress with the near_resharding_status as follows. 
<ul>
<li>While in the Scheduled state both metrics should remain 0. </li>
<li>While in the Building state both metrics should be gradually increasing. </li>
<li>While in the Finished state both metrics should remain at the same value. </li>
</ul>
</li>
<li>near_resharding_batch_prepare_time_bucket, near_resharding_batch_apply_time_bucket and near_resharding_batch_commit_time_bucket - those three metrics can be used to track the performance of resharding and fine tune throttling if needed. As a rule of thumb the combined time of prepare, apply and commit for a batch should remain at the 100ms-200ms level on average. Higher batch processing time may lead to disruptions in block processing, missing chunks and blocks. </li>
</ul>
<p>Here are some example metric values when finished for different shards and networks. The duration column reflects the duration of the building phase. Those were captured in production like environment in November 2023 and actual times at the time of resharding in production may be slightly higher. </p>
<div class="table-wrapper"><table><thead><tr><th>mainnet</th><th>duration</th><th>batch count</th><th>batch size</th></tr></thead><tbody>
<tr><td>total</td><td>2h23min</td><td></td><td></td></tr>
<tr><td>shard 0</td><td>32min</td><td>12,510</td><td>6.6GB</td></tr>
<tr><td>shard 1</td><td>30min</td><td>12,203</td><td>6.1GB</td></tr>
<tr><td>shard 2</td><td>26min</td><td>10,619</td><td>6.0GB</td></tr>
<tr><td>shard 3</td><td>55min</td><td>21,070</td><td>11.5GB</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>testnet</th><th>duration</th><th>batch count</th><th>batch size</th></tr></thead><tbody>
<tr><td>total</td><td>5h32min</td><td></td><td></td></tr>
<tr><td>shard 0</td><td>21min</td><td>10,259</td><td>10.9GB</td></tr>
<tr><td>shard 1</td><td>18min</td><td>7,034</td><td>3.5GB</td></tr>
<tr><td>shard 2</td><td>2h31min</td><td>75,529</td><td>75.6GB</td></tr>
<tr><td>shard 3</td><td>2h22min</td><td>63,621</td><td>49.2GB</td></tr>
</tbody></table>
</div>
<p>Here is an example of what that may look like in a grafana dashboard. Please keep in mind that the values and duration is not representative as the sample data below is captured in a testing environment with different configuration.</p>
<img width="941" alt="Screenshot 2023-12-01 at 10 10 20" src="https://github.com/near/nearcore/assets/1555986/42824d5a-af16-4a06-9727-a04b1b9d7c03">
<img width="941" alt="Screenshot 2023-12-01 at 10 10 50" src="https://github.com/near/nearcore/assets/1555986/06a2c6f1-1daf-4220-b3fe-e21992e2d62c">
<img width="941" alt="Screenshot 2023-12-01 at 10 10 42" src="https://github.com/near/nearcore/assets/1555986/fea2ad6b-2fa4-4862-875e-a3ca5d61d849">
<h3 id="throttling"><a class="header" href="#throttling">Throttling</a></h3>
<p>The resharding process can be quite resource intensive and affect the regular operation of a node. In order to mitigate that as well as limit any need for increasing hardware specifications of the nodes throttling was added. Throttling slows down resharding to not have it impact other node operations. Throttling can be configured by adjusting the resharding_config in the node config file. </p>
<ul>
<li>batch_size - controls the size of batches in which resharding moves data around. Setting a smaller batch size will slow down the resharding process and make it less resource-consuming.</li>
<li>batch_delay - controls the delay between processing of batches. Setting a smaller batch delay will speed up the resharding process and make it more resource-consuming. </li>
</ul>
<p>The remaining fields in the ReshardingConfig are only intended for testing purposes and should remain set to their default values. </p>
<p>The default configuration for ReshardingConfig should provide a good and safe setting for resharding in the production networks. There is no need for node operators to make any changes to it unless they observe issues. </p>
<p>The resharding config can be adjusted at runtime, without restarting the node. The config needs to be updated first and then a SIGHUP signal should be sent to the neard process. When received the signal neard will update the config and print a log message showing what fields were changed. It's recommended to check the log to make sure the relevant config change was correctly picked up. </p>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<h3 id="localize-resharding-to-a-single-shard"><a class="header" href="#localize-resharding-to-a-single-shard">Localize resharding to a single shard</a></h3>
<p>Currently when resharding we need to move the data for all shards even if only a single shard is being split. That is due to having the version field in the storage key that needs to be updated when changing shard layout version. </p>
<p>This can be improved by changing how ShardUId works e.g. removing the version and instead using globally unique shard ids. </p>
<h3 id="dynamic-resharding"><a class="header" href="#dynamic-resharding">Dynamic resharding</a></h3>
<p>The current implementation relies on having the shard layout determined offline and manually added to the node implementation. </p>
<p>The dynamic resharding would mean that the network itself can automatically determine that resharding is needed, what should be the new shard layout and schedule the resharding.</p>
<h3 id="support-different-changes-to-shard-layout"><a class="header" href="#support-different-changes-to-shard-layout">Support different changes to shard layout</a></h3>
<p>The current implementation only supports splitting a shard. In the future we can consider adding support for other operations such as merging two shards or moving an existing boundary account. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-neard-will-work"><a class="header" href="#how-neard-will-work">How neard will work</a></h1>
<p>The documents under this chapter are talking about the future of NEAR - what we're planning on improving and how.</p>
<p>(This also means that they can get out of date quickly :-).</p>
<p>If you have comments, suggestions or want to help us designing and implementing some of these things here - please reach out on Zulip or github.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This document is still a DRAFT.</p>
<p>This document covers our improvement plans for state sync and catchup.
<strong>Before reading this doc, you should take a look at <a href="architecture/next/../how/sync.html">How sync works</a></strong></p>
<p>State sync is used in two situations:</p>
<ul>
<li>when your node is behind for more than 2 epochs (and it is not an archival node) - then rather than trying to apply block by block (that can take hours) - you 'give up' and download the fresh state (a.k.a state sync) and apply blocks from there.</li>
<li>when you're a block (or chunk) producer - and in the upcoming epoch, you'll have to track a shard that you are not currently tracking.</li>
</ul>
<p>In the past (and currently) - the state sync was mostly used in the first scenario (as all block &amp; chunk producers had to track all the shards for security reasons - so they didn't actually have to do catchup at all).</p>
<p>As we progress towards phase 2 and keep increasing number of shards - the catchup part starts being a lot more critical. When we're running a network with a 100 shards, the single machine is simply not capable of tracking (a.k.a applying all transactions) of all shards - so it will have to track just a subset. And it will have to change this subset almost every epoch (as protocol rebalances the shard-to-producer assignment based on the stakes).</p>
<p>This means that we have to do some larger changes to the state sync design, as requirements start to differ a lot:</p>
<ul>
<li>catchups are high priority (the validator MUST catchup within 1 epoch - otherwise it will not be able to produce blocks for the new shards in the next epoch - and therefore it will not earn rewards).</li>
<li>a lot more catchups in progress (with lots of shards basically every validator would have to catchup at least one shard at each epoch boundary) - this leads to a lot more potential traffic on the network</li>
<li>malicious attacks &amp; incentives - the state data can be large and can cause a lot of network traffic. At the same time it is quite critical (see point above), so we'll have to make sure that the nodes are incentivised to provide the state parts upon request.</li>
<li>only a subset of peers will be available to request the state sync from (as not everyone from our peers will be tracking the shard that we're interested in).</li>
</ul>
<h2 id="things-that-were-actively-analysing"><a class="header" href="#things-that-were-actively-analysing">Things that we're actively analysing</a></h2>
<h3 id="performance-of-state-sync-on-the-receiver-side"><a class="header" href="#performance-of-state-sync-on-the-receiver-side">Performance of state sync on the receiver side</a></h3>
<p>We're looking at the performance of state sync:</p>
<ul>
<li>how long does it take to create the parts,</li>
<li>pro-actively creating the parts as soon as epoch starts</li>
<li>creating them in parallel</li>
<li>allowing user to ask for many at once</li>
<li>allowing user to provide a bitmask of parts that are required (therefore allowing the server to return only the ones that it already cached).</li>
</ul>
<h3 id="better-performance-on-the-requestor-side"><a class="header" href="#better-performance-on-the-requestor-side">Better performance on the requestor side</a></h3>
<p>Currently the parts are applied only once all of them are downloaded - instead we should try to apply them in parallel - after each part is received.</p>
<p>When we receive a part, we should announce this information to our peers - so that they know that they can request it from us if they need it.</p>
<h2 id="ideas---not-actively-working-on-them-yet"><a class="header" href="#ideas---not-actively-working-on-them-yet">Ideas - not actively working on them yet</a></h2>
<h3 id="better-networking-aka-tier-3"><a class="header" href="#better-networking-aka-tier-3">Better networking (a.k.a Tier 3)</a></h3>
<p>Currently our networking code is picking the peers to connect at random (as most of them are tracking all the shards). With phase2 it will no longer be the case, so we should work on improvements of our peer-selection mechanism.</p>
<p>In general - we should make sure that we have direct connection to at least a few nodes that are tracking the same shards that we're tracking right now (or that we'll want to track in the near future).</p>
<h3 id="dedicated-nodes-optimized-towards-state-sync-responses"><a class="header" href="#dedicated-nodes-optimized-towards-state-sync-responses">Dedicated nodes optimized towards state sync responses</a></h3>
<p>The idea is to create a set of nodes that would specialize in state sync responses (similar to how we have archival nodes today).</p>
<p>The sub-idea of this, is to store such data on one of the cloud providers (AWS, GCP).</p>
<h3 id="sending-deltas-instead-of-full-state-syncs"><a class="header" href="#sending-deltas-instead-of-full-state-syncs">Sending deltas instead of full state syncs</a></h3>
<p>In case of catchup, the requesting node might have tracked that shard in the past. So we could consider just sending a delta of the state rather than the whole state.</p>
<p>While this helps with the amount of data being sent - it might require the receiver to do a lot more work (as the data that it is about to send cannot be easily cached).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="malicious-producers-in-phase-2-of-sharding"><a class="header" href="#malicious-producers-in-phase-2-of-sharding">Malicious producers in phase 2 of sharding.</a></h1>
<p>In this document, we'll compare the impact of the hypothetical malicious producer on the NEAR system (both in the current setup and how it will work when phase2 is implemented).</p>
<h2 id="current-state-phase-1"><a class="header" href="#current-state-phase-1">Current state (Phase 1)</a></h2>
<p>Let's assume that a malicious chunk producer <code>C1</code> has produced a bad chunk 
and sent it to the block producer at this height <code>B1</code>. </p>
<p>The block producer IS going to add the chunk to the block (as we don't validate 
the chunks before adding to blocks - but only when signing the block - see 
<a href="architecture/next/./../how/tx_receipts.html">Transactions and receipts - last section</a>).</p>
<p>After this block is produced, it is sent to all the validators to get the 
signatures.</p>
<p>As currently all the validators are tracking all the shards - they will quickly 
notice that the chunk is invalid, so they will not sign the block.</p>
<p>Therefore the next block producer <code>B2</code> is going to ignore <code>B1</code>'s block, and 
select block from <code>B0</code> as a parent instead.</p>
<p>So TL;DR - <strong>a bad chunk would not be added to the chain.</strong></p>
<h2 id="phase-2-and-sharding"><a class="header" href="#phase-2-and-sharding">Phase 2 and sharding</a></h2>
<p>Unfortunately things get a lot more complicated, once we scale.</p>
<p>Let's assume the same setup as above (a single chunk producer <code>C1</code> being 
malicious). But this time, we have 100 shards - each validator is tracking just 
a few (they cannot track all - as today - as they would have to run super 
powerful machines with &gt; 100 cores).</p>
<p>So in the similar scenario as above - <code>C1</code> creates a malicious chunks, and 
sends it to <code>B1</code>, which includes it in the block.</p>
<p>And here's where the complexity starts - as most of the validators will NOT 
track the shard which <code>C1</code> was producing - so they will still sign the block.</p>
<p>The validators that do track that shard will of course (assuming that they are non-malicious) refuse the sign. But overall, they will be a small majority - so the block is going to get enough signatures and be added to the chain.</p>
<h3 id="challenges-slashing-and-rollbacks"><a class="header" href="#challenges-slashing-and-rollbacks">Challenges, Slashing and Rollbacks</a></h3>
<p>So we're in a pickle - as a malicious chunk was just added to the chain. And
that's why need to have mechanisms to automatically recover from such situations:
Challenges, Slashing and Rollbacks.</p>
<h4 id="challenge"><a class="header" href="#challenge">Challenge</a></h4>
<p>Challenge is a self-contained proof, that something went wrong in the chunk 
processing. It must contain all the inputs (with their merkle proof), the code
that was executed, and the outputs (also with merkle proofs).</p>
<p>Such a challenge allows anyone (even nodes that don't track that shard or have 
any state) to verify the validity of the challenge.</p>
<p>When anyone notices that a current chain contains a wrong transition - they 
submit such challenge to the next block producer, which can easily verify it 
and it to the next block.</p>
<p>Then the validators do the verification themselves, and if successful, they 
sign the block.</p>
<p>When such block is successfully signed, the protocol automatically slashes 
malicious nodes (more details below) and initiates the rollback to bring the 
state back to the state before the bad chunk (so in our case, back to the block 
produced by <code>B0</code>).</p>
<h4 id="slashing"><a class="header" href="#slashing">Slashing</a></h4>
<p>Slashing is the process of taking away the part of the stake from validators
that are considered malicious.</p>
<p>In the example above, we'll definitely need to slash the <code>C1</code> - and potentially also any validators that were tracking that shard and did sign the bad block.</p>
<p>Things that we'll have to figure out in the future:</p>
<ul>
<li>how much do we slash? all of the stake? some part?</li>
<li>what happens to the slashed stake? is it burned? does it go to some pool?</li>
</ul>
<h4 id="state-rollbacks"><a class="header" href="#state-rollbacks">State rollbacks</a></h4>
<p>// TODO: add</p>
<h2 id="problems-with-the-current-phase-2-design"><a class="header" href="#problems-with-the-current-phase-2-design">Problems with the current Phase 2 design</a></h2>
<h3 id="is-slashing-painful-enough"><a class="header" href="#is-slashing-painful-enough">Is slashing painful enough?</a></h3>
<p>In the example above, we'd successfully slash the <code>C1</code> producer - but was it<br />
enough?</p>
<p>Currently (with 4 shards) you need around 20k NEAR to become a chunk producer. 
If we increase the number of shards to 100, it would drop the minimum stake to 
around 1k NEAR.</p>
<p>In such scenario, by sacrificing 1k NEAR, the malicious node can cause the 
system to rollback a couple blocks (potentially having bad impact on the bridge 
contracts etc).</p>
<p>On the other side, you could be a non-malicious chunk producer with a corrupted 
database (or a nasty bug in the code) - and the effect would be the same - the 
chunk that you produced would be marked as malicious, and you'd lose your stake 
(which will be a super-scary even for any legitimate validator).</p>
<p>So the open question is - can we do something 'smarter' in the protocol to
detect the case, where there is 'just a single' malicious (or buggy) chunk 
producer and avoid the expensive rollback?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>This is our work-in-progress storage documentation. Things are raw and
incomplete. You are encouraged to help improve it, in any capacity you can!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-1"><a class="header" href="#flow-1">Flow</a></h1>
<p>Here we present the flow of a single read or write request from the transaction runtime
all the way to the OS. As you can see, there are many layers of read-caching and
write-buffering involved.</p>
<p>Blue arrow means a call triggered by read.</p>
<p>Red arrow means a call triggered by write.</p>
<p>Black arrow means a non-trivial data dependency. For example:</p>
<ul>
<li>Nodes which are read on TrieStorage go to TrieRecorder to generate proof, so they
are connected with black arrow.</li>
<li>Memtrie lookup needs current state of accounting cache to compute costs. When
query completes, accounting cache is updated with memtrie nodes. So they are connected
with bidirectional black arrow.</li>
</ul>
<!-- Editable source: https://docs.google.com/presentation/d/1_iU5GfznFDUMUNi_7szBRd5hDrjqBxr8ap7eTCK-lZA/edit#slide=id.p  -->
<p><img src="https://github.com/user-attachments/assets/232ae746-3f86-4a15-8a3a-08a544a88834" alt="Diagram with read and write request flow" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trie"><a class="header" href="#trie">Trie</a></h1>
<p>We use Merkle-Patricia Trie to store blockchain state. Trie is persistent, which
means that insertion of new node actually leads to creation of a new path to this
node, and thus root of Trie after insertion will also be represented by a new
object.</p>
<p>Here we describe its implementation details which are closely related to
Runtime.</p>
<h2 id="main-structures"><a class="header" href="#main-structures">Main structures</a></h2>
<h3 id="trie-1"><a class="header" href="#trie-1">Trie</a></h3>
<p>Trie stores the state - accounts, contract codes, access keys, etc. Each state
item corresponds to the unique trie key. You can read more about this structure on
<a href="https://en.wikipedia.org/wiki/Trie">Wikipedia</a>.</p>
<p>There are two ways to access trie - from memory and from disk. The first one is 
currently the main one, where only the loading stage requires disk, and the
operations are fully done in memory. The latter one relies only on disk with
several layers of caching. Here we describe the disk trie.</p>
<p>Disk trie is stored in the RocksDB, which is persistent across node restarts. Trie
communicates with database using <code>TrieStorage</code>. On the database level, data is
stored in key-value format in <code>DBCol::State</code> column. There are two kinds of
records:</p>
<ul>
<li>trie nodes, for the which key is constructed from shard id and
<code>RawTrieNodeWithSize</code> hash, and value is a <code>RawTrieNodeWithSize</code> serialized by
a custom algorithm;</li>
<li>values (encoded contract codes, postponed receipts, etc.), for which the key is
constructed from shard id and the hash of value, which maps to the encoded value.</li>
</ul>
<p>So, value can be obtained from <code>TrieKey</code> as follows:</p>
<ul>
<li>start from the hash of <code>RawTrieNodeWithSize</code> corresponding to the root;</li>
<li>descend to the needed node using nibbles from <code>TrieKey</code>;</li>
<li>extract underlying <code>RawTrieNode</code>;</li>
<li>if it is a <code>Leaf</code> or <code>Branch</code>, it should contain the hash of the value;</li>
<li>get value from storage by its hash and shard id.</li>
</ul>
<p>Note that <code>Trie</code> is almost never called directly from <code>Runtime</code>, modifications
are made using <code>TrieUpdate</code>.</p>
<h3 id="trieupdate"><a class="header" href="#trieupdate">TrieUpdate</a></h3>
<p>Provides a way to access storage and record changes to commit in the future.
Update is prepared as follows:</p>
<ul>
<li>changes are made using <code>set</code> and <code>remove</code> methods, which are added to
<code>prospective</code> field,</li>
<li>call <code>commit</code> method which moves <code>prospective</code> changes to <code>committed</code>,</li>
<li>call <code>finalize</code> method which prepares <code>TrieChanges</code> and state changes based on
<code>committed</code> field.</li>
</ul>
<p>Prospective changes correspond to intermediate state updates, which can be
discarded if the transaction is considered invalid (because of insufficient
balance, invalidity, etc.). While they can't be applied yet, they must be cached
this way if the updated keys are accessed again in the same transaction.</p>
<p>Committed changes are stored in memory across transactions and receipts.
Similarly, they must be cached if the updated keys are accessed across
transactions. They can be discarded only if the chunk is discarded.</p>
<p>Note that <code>finalize</code>, <code>Trie::insert</code> and <code>Trie::update</code> do not update the
database storage. These functions only modify trie nodes in memory. Instead,
these functions prepare the <code>TrieChanges</code> object, and <code>Trie</code> is actually updated
when <code>ShardTries::apply_insertions</code> is called, which puts new values to
<code>DBCol::State</code> part of the key-value database.</p>
<h3 id="triestorage"><a class="header" href="#triestorage">TrieStorage</a></h3>
<p>Stores all <code>Trie</code> nodes and allows to get serialized nodes by <code>TrieKey</code> hash
using the <code>retrieve_raw_bytes</code> method.</p>
<p>There are two major implementations of <code>TrieStorage</code>:</p>
<ul>
<li><code>TrieCachingStorage</code> - caches all big values ever read by <code>retrieve_raw_bytes</code>.</li>
<li><code>TrieMemoryPartialStorage</code> - used for validating recorded partial storage.</li>
</ul>
<p>Note that these storages use database keys, which are retrieved using hashes of
trie nodes using the <code>get_key_from_shard_id_and_hash</code> method.</p>
<h3 id="shardtries"><a class="header" href="#shardtries">ShardTries</a></h3>
<p>This is the main struct that is used to access all Tries. There's usually only a single instance of this and it contains stores and caches. We use this to gain access to the <code>Trie</code> for a single shard by calling the <code>get_trie_for_shard</code> or equivalent methods.</p>
<p>Each shard within <code>ShardTries</code> has their own <code>cache</code> and <code>view_cache</code>. The <code>cache</code> stores the most frequently accessed nodes and is usually used during block production. The <code>view_cache</code> is used to serve user request to get data, which usually come in via network. It is a good idea to have an independent cache for this as we can have patterns in accessing user data independent of block production.</p>
<h2 id="primitives"><a class="header" href="#primitives">Primitives</a></h2>
<h3 id="triechanges"><a class="header" href="#triechanges">TrieChanges</a></h3>
<p>Stores result of updating <code>Trie</code>.</p>
<ul>
<li><code>old_root</code>: root before updating <code>Trie</code>, i.e. inserting new nodes and deleting
old ones,</li>
<li><code>new_root</code>: root after updating <code>Trie</code>,</li>
<li><code>insertions</code>, <code>deletions</code>: vectors of <code>TrieRefcountChange</code>, describing all
inserted and deleted nodes.</li>
</ul>
<p>This way to update trie allows to add new nodes to storage and remove old ones
separately. The former corresponds to saving new block, the latter - to garbage
collection of old block data which is no longer needed.</p>
<h3 id="trierefcountchange"><a class="header" href="#trierefcountchange">TrieRefcountChange</a></h3>
<p>Because we remove unused nodes during garbage collection, we need to track
the reference count (<code>rc</code>) for each node. Another reason is that we can dedup
values. If the same contract is deployed 1000 times, we only store one contract
binary in storage and track its count.</p>
<p>This structure is used to update <code>rc</code> in the database:</p>
<ul>
<li><code>trie_node_or_value_hash</code> - hash of the trie node or value, used for uniting
with shard id to get DB key,</li>
<li><code>trie_node_or_value</code> - serialized trie node or value,</li>
<li><code>rc</code> - change of reference count.</li>
</ul>
<p>Note that for all reference-counted records, the actual value stored in DB is
the concatenation of <code>trie_node_or_value</code> and <code>rc</code>. The reference count is
updated using a custom merge operation <code>refcount_merge</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="on-disk-database-format"><a class="header" href="#on-disk-database-format">On-Disk Database Format</a></h1>
<p>We store the database in RocksDB. This document is an attempt to give hints about how to navigate it.</p>
<h2 id="rocksdb"><a class="header" href="#rocksdb">RocksDB</a></h2>
<ul>
<li>The column families are defined in <code>DBCol</code>, defined in <code>core/store/src/columns.rs</code></li>
<li>The column families are seen on the rocksdb side as per the <code>col_name</code> function defined in <code>core/store/src/db/rocksdb.rs</code></li>
</ul>
<h2 id="the-trie-col5"><a class="header" href="#the-trie-col5">The Trie (col5)</a></h2>
<ul>
<li>The trie is stored in column family <code>State</code>, number 5</li>
<li>In this family, each key is of the form <code>ShardUId | CryptoHash</code> where <code>ShardUId: u64</code> and <code>CryptoHash: [u8; 32]</code></li>
</ul>
<h2 id="all-historical-state-changes-col35"><a class="header" href="#all-historical-state-changes-col35">All Historical State Changes (col35)</a></h2>
<ul>
<li>The state changes are stored in column family <code>StateChanges</code>, number 35</li>
<li>In this family, each key is of the form <code>BlockHash | Column | AdditionalInfo</code> where:
<ul>
<li><code>BlockHash: [u8; 32]</code> is the block hash for this change</li>
<li><code>Column: u8</code> is defined near the top of <code>core/primitives/src/trie_key.rs</code></li>
<li><code>AdditionalInfo</code> depends on <code>Column</code> and it can be found in the code for the <code>TrieKey</code> struct, same file as <code>Column</code></li>
</ul>
</li>
</ul>
<h3 id="contract-deployments"><a class="header" href="#contract-deployments">Contract Deployments</a></h3>
<ul>
<li>Contract deployments happen with <code>Column = 0x01</code></li>
<li><code>AdditionalInfo</code> is the account id for which the contract is being deployed</li>
<li>The key value contains the contract code alongside other pieces of data. It is possible to extract the contract code by removing everything until the wasm magic number, 0061736D01000000</li>
<li>As such, it is possible to dump all the contracts that were ever deployed on-chain using this command on an archival node:
<pre><code>ldb --db=~/.near/data scan --column_family=col35 --hex | \
    grep -E '^0x.{64}01' | \
    sed 's/0061736D01000000/x/' | \
    sed 's/^.*x/0061736D01000000/' | \
    grep -v ' : '
</code></pre>
(Note that the last grep is required because not every such value appears to contain contract code)
We should implement a feature to state-viewer that’d allow better visualization of this data, but in the meantime this seems to work.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-level-overview-1"><a class="header" href="#high-level-overview-1">High level overview</a></h1>
<p>When mainnet launched, the neard client stored all the chain's state in a single
RocksDB column <code>DBCol::State</code>. This column embeds the entire <a href="architecture/storage/./trie_storage.html">NEAR state
trie</a> directly in the key-value database, using roughly
<code>hash(borsh_encode(trie_node))</code> as the key to store a <code>trie_node</code>. This gives a
content-addressed storage system that can easily self-verify.</p>
<p>Flat storage is a bit like a database index for the values stored in the trie.
It stores a copy of the data in a more accessible way to speed up the lookup
time. </p>
<p>Drastically oversimplified, flat storage uses a hashmap instead of a trie. This
reduces the lookup time from <code>O(d)</code> to <code>O(1)</code> where <code>d</code> is the tree depth of the
value.</p>
<p>But the devil is in the detail. Below is a high-level summary of implementation
challenges, which are the reasons why the above description is an
oversimplification.</p>
<h2 id="time-dimension-of-the-state"><a class="header" href="#time-dimension-of-the-state">Time dimension of the state</a></h2>
<p>The blockchain state is modified with every chunk. Neard must be able to travel
back in time and resolve key lookups for older versions, as well as travel to
alternative universes to resolve requests for chunks that belong to a different
fork.</p>
<p>Using the full trie embedding in RocksDB, this is almost trivial. We only need
to know the state root for a chunk and we can start traversing from the root to
any key. As long as we do not delete (garbage collect) unused trie nodes, the
data remains available. The overhead is minimal, too, since all the trie nodes
that have not been changed are shared between tries.</p>
<p>Enter flat storage territory: A simple hashmap only stores a snapshot. When we
write a new value to the same key, the old value is overwritten and no longer
accessible. A solution to access different versions on each shard is required.</p>
<p>The minimal solution only tracks the final head and all forks building on top. A
full implementation would also allow replaying older chunks and doing view
calls. But even this minimal solution pulls in all complicated details regarding
consensus and multiplies them with all the problems listed below.</p>
<h2 id="fear-of-data-corruption"><a class="header" href="#fear-of-data-corruption">Fear of data corruption</a></h2>
<p>State and FlatState keep a copy of the same data and need to be in sync at all
times. This is a source for errors which any implementation needs to test
properly. Ideally, there are also tools to quickly compare the two and verify
which is correct.</p>
<p>Note: The trie storage is verifiable by construction of the hashes. The flat
state is not directly verifiable. But it is possible to reconstruct the full
trie just from the leaf values and use that for verification.</p>
<h2 id="gas-accounting-requires-a-protocol-change"><a class="header" href="#gas-accounting-requires-a-protocol-change">Gas accounting requires a protocol change</a></h2>
<p>The trie path we take in a trie lookup affects the gas costs, and hence the
balance subtracted from the user. In other words, the lookup algorithm leaks
into the protocol. Hence, we cannot switch between different ways of looking up
state without a protocol change.</p>
<p>This makes things a whole lot more complicated. We have to do the data migration
and prepare flat storage, while still using trie storage. Keeping flat storage
up to date at this point is pure overhead. And then, at the epoch switch where
the new protocol version begins, we have to start using the new storage in all
clients simultaneously. Anyone that has not finished migration, yet, will fail
to produce a chunk due to invalid gas results.</p>
<p>In an ideal future, we want to make gas costs independent of the position in the
trie and then this would no longer be a problem.</p>
<h2 id="performance-reality-check"><a class="header" href="#performance-reality-check">Performance reality check</a></h2>
<p>Going from <code>O(d)</code> to <code>O(1)</code> sounds great. But let's look at actual numbers.</p>
<p>A flat state lookup requires exactly 2 database requests. One for finding the
<code>ValueRef</code> and one for dereferencing the value. (Dereferencing only happens if
the value is present and if enough gas was paid to cover reading the potentially
large value, otherwise we short-circuit.)</p>
<p>A trie lookup requires exactly <code>d</code> trie node lookups where <code>d</code> is the depth in
the trie, plus one more for dereferencing the final value.</p>
<p>Clearly, <code>d + 1</code> is worse than <code>1 + 1</code>, right? Well, as it turns out, we can
cache the trie nodes with surprisingly high effectiveness. In mainnet
workloads (which were often optimized to work well with the trie shape) we
observe a 99% cache hit rate in many cases. </p>
<p>Combine that with the fact that a typical value for <code>d</code> is somewhere between 10
and 20. Then we may conclude that, in expectation, a trie lookup (<code>d * 0.01 + 1</code>
requests) requires less DB requests than a flat state lookup (<code>1 + 1</code> requests). </p>
<p>In practice, however, flat state still has an edge over accessing trie storage
directly. And that is due to two reasons.</p>
<ol>
<li>DB keys are in better order, leading to more cache hits in RocksDB's block cache.</li>
<li>The flat state column is much smaller than the state column.</li>
</ol>
<p>We observed a speedup of 100x and beyond for reading a single value from
<code>DBCol::FlatState</code> compared to reading it from <code>DBCol::State</code>. So that is
clearly a win. But one that is due to the data layout inside RocksDB, not due to
algorithmic improvements.</p>
<h2 id="updating-the-merkle-tree"><a class="header" href="#updating-the-merkle-tree">Updating the Merkle tree</a></h2>
<p>When we update a value in the blockchain state, all ancestor nodes change their
value due to the recursive nature of Merkle trees.</p>
<p>Updating flat state is easy enough but then we would not know the new state
root. Annoyingly, it is rather important to have the state root in due time, as
it is included in the chunk header.</p>
<p>To update the state root, we need to read all nodes between the root and all
changed values. At which point, we are doing all the same reads we were trying
to avoid in the first place.</p>
<p>This makes flat state for writes algorithmically useless, as we still have to do
<code>O(d)</code> requests, no matter what. But there are potential benefits from data
locality, as flat state stores values sorted by a trie key instead of a
perfectly random hash.</p>
<p>For that, we would need a fast index not only for the state value but also for
all intermediate trie nodes. At this point, we would be back to a full embedding
of the trie in a key-value store / hashmap. Just changing the keys we use for
the database.</p>
<p>Note that we can enjoy the benefits of read-only flat storage to improve read
heavy contracts. But a read-modify-write pattern using this hybrid solution is
strictly worse than the original implementation without flat storage.</p>
<h1 id="implementation-status-and-future-ideas"><a class="header" href="#implementation-status-and-future-ideas">Implementation status and future ideas</a></h1>
<p>As of March 2023, we have implemented a read-only flat storage that only works
for the frontier of non-final blocks and the final block itself. Archival calls
and view calls still use the trie directly.</p>
<h2 id="things-we-have-solved"><a class="header" href="#things-we-have-solved">Things we have solved</a></h2>
<p>We are fairly confident we have solved the time-travel issues, the data
migration / protocol upgrade problems, and got a decent handle on avoiding
accidental data corruption.</p>
<p>This improves the worst case (no cache hits) for reads dramatically. And it
paves the way for further improvements, as we have now a good understanding of
all these seemingly-simple but actually-really-hard problems.</p>
<h2 id="flat-state-for-writes"><a class="header" href="#flat-state-for-writes">Flat state for writes</a></h2>
<p>How to use flat storage for writes is not fully designed, yet, but we have some
rough ideas on how to do it. But we don't know the performance we should expect.
Algorithmically, it can only get worse but the speedup on RocksDB we found with
the read-only flat storage is promising. But one has to wonder if there are not
also simpler ways to achieve better data locality in RocksDB.</p>
<h2 id="inlining-values"><a class="header" href="#inlining-values">Inlining values</a></h2>
<p>We hope to get a jump in performance by avoiding dereferencing <code>ValueRef</code> after
the flat state lookup. At least for small values  we could store the value
itself also in flat state. (to be defined what small means)</p>
<p>This seems very promising because the value dereferencing still happens in the
much slower <code>DBCol::State</code>. If we assume small values are the common case, we
would thus expect huge performance improvements for the average case.</p>
<p>It is not clear yet, if we can also optimize large lookups somehow. If not, we
could at least charge them at a higher rate than we do today, to reflect the
real DB cost better.</p>
<h1 id="code-guide"><a class="header" href="#code-guide">Code guide</a></h1>
<p>Here we describe structures used for flat storage implementation.</p>
<h2 id="flatstorage"><a class="header" href="#flatstorage">FlatStorage</a></h2>
<p>This is the main structure which owns information about ValueRefs for all keys from some fixed 
shard for some set of blocks. It is shared by multiple threads, so it is guarded by RwLock:</p>
<ul>
<li>Chain thread, because it sends queries like:
<ul>
<li>&quot;new block B was processed by chain&quot; - supported by add_block</li>
<li>&quot;flat storage head can be moved forward to block B&quot; - supported by update_flat_head</li>
</ul>
</li>
<li>Thread that applies a chunk, because it sends read queries &quot;what is the ValueRef for key for block B&quot;</li>
<li>View client (not fully decided)</li>
</ul>
<p>Requires ChainAccessForFlatStorage on creation because it needs to know the tree of blocks after
the flat storage head, to support getting queries correctly.</p>
<h2 id="flatstoragemanager"><a class="header" href="#flatstoragemanager">FlatStorageManager</a></h2>
<p>It holds all FlatStorages which NightshadeRuntime knows about and:</p>
<ul>
<li>provides views for flat storage for some fixed block - supported by new_flat_state_for_shard</li>
<li>sets initial flat storage state for genesis block - set_flat_storage_for_genesis</li>
<li>adds/removes/gets flat storage if we started/stopped tracking a shard or need to create a view - create_flat_storage_for_shard, etc.</li>
</ul>
<h2 id="flatstoragechunkview"><a class="header" href="#flatstoragechunkview">FlatStorageChunkView</a></h2>
<p>Interface for getting ValueRefs from flat storage for some shard for some fixed block, supported
by get_ref method.</p>
<h2 id="other-notes"><a class="header" href="#other-notes">Other notes</a></h2>
<h3 id="chain-dependency"><a class="header" href="#chain-dependency">Chain dependency</a></h3>
<p>If storage is fully empty, then we need to create flat storage from scratch. FlatStorage is stored
inside NightshadeRuntime, and it itself is stored inside Chain, so we need to create them in the same order
and dependency hierarchy should be the same. But at the same time, we parse genesis file only during Chain
creation. That’s why FlatStorageManager has set_flat_storage_for_genesis method which is called 
during Chain creation.</p>
<h3 id="regular-block-processing-vs-catchups"><a class="header" href="#regular-block-processing-vs-catchups">Regular block processing vs. catchups</a></h3>
<p>For these two usecases we have two different flows: first one is handled in Chain.postprocess_block,
the second one in Chain.block_catch_up_postprocess. Both, when results of applying chunk are ready,
should call Chain.process_apply_chunk_result → RuntimeAdapter.get_flat_storage_for_shard → 
FlatStorage.add_block, and when results of applying ALL processed/postprocessed chunks are ready,
should call RuntimeAdapter.get_flat_storage_for_shard → FlatStorage.update_flat_head.</p>
<p>(because applying some chunk may result in error and we may need to exit there without updating flat head - ?)</p>
<div style="break-before: page; page-break-before: always;"></div><p>This document describes how our network works. At this moment, it is known to be
somewhat outdated, as we are in the process of refactoring the network protocol
somewhat significantly.</p>
<h1 id="1-overview"><a class="header" href="#1-overview">1. Overview</a></h1>
<p>Near Protocol uses its own implementation of a custom peer-to-peer network. Peers
who join the network are represented by nodes and connections between them by edges.</p>
<p>The purpose of this document is to describe the inner workings of the <code>near-network</code>
package; and to be used as reference by future engineers to understand the network
code without any prior knowledge.</p>
<h1 id="2-code-structure"><a class="header" href="#2-code-structure">2. Code structure</a></h1>
<p><code>near-network</code> runs on top of the <code>actor</code> framework called 
<a href="https://actix.rs/docs/"><code>Actix</code></a>. Code structure is split between 4 actors
<code>PeerManagerActor</code>, <code>PeerActor</code>, <code>RoutingTableActor</code>, <code>EdgeValidatorActor</code></p>
<h3 id="21-edgevalidatoractor-currently-called-edgeverifieractor-in-the-code"><a class="header" href="#21-edgevalidatoractor-currently-called-edgeverifieractor-in-the-code">2.1 <code>EdgeValidatorActor</code> (currently called <code>EdgeVerifierActor</code> in the code<!-- TODO: rename -->)</a></h3>
<p><code>EdgeValidatorActor</code> runs on separate thread. The purpose of this <code>actor</code> is to
validate <code>edges</code>, where each <code>edge</code> represents a connection between two peers,
and it's signed with a cryptographic signature of both parties. The process of
edge validation involves verifying cryptographic signatures, which can be quite
expensive, and therefore was moved to another thread.</p>
<p>Responsibilities:</p>
<ul>
<li>Validating edges by checking whenever cryptographic signatures match.</li>
</ul>
<h3 id="22-routingtableactor"><a class="header" href="#22-routingtableactor">2.2 <code>RoutingTableActor</code></a></h3>
<p><code>RoutingTableActor</code> maintains a view of the <code>P2P network</code> represented by a set of
nodes and edges.</p>
<p>In case a message needs to be sent between two nodes, that can be done directly
through a <code>TCP connection</code>. Otherwise, <code>RoutingTableActor</code> is responsible for pinging
the best path between them.</p>
<p>Responsibilities:</p>
<ul>
<li>Keep set of all edges of <code>P2P network</code> called routing table.</li>
<li>Connects to <code>EdgeValidatorActor</code>, and asks for edges to be validated, when
needed.</li>
<li>Has logic related to exchanging edges between peers.</li>
</ul>
<h3 id="23-peeractor"><a class="header" href="#23-peeractor">2.3 <code>PeerActor</code></a></h3>
<p>Whenever a new connection gets accepted, an instance of <code>PeerActor</code> gets
created. Each <code>PeerActor</code> keeps a physical <code>TCP connection</code> to exactly one
peer.</p>
<p>Responsibilities:</p>
<ul>
<li>Maintaining physical connection.</li>
<li>Reading messages from peers, decoding them, and then forwarding them to the
right place.</li>
<li>Encoding messages, sending them to peers on physical layer.</li>
<li>Routing messages between <code>PeerManagerActor</code> and other peers.</li>
</ul>
<h3 id="24-peermanageractor"><a class="header" href="#24-peermanageractor">2.4 <code>PeerManagerActor</code></a></h3>
<p><code>PeerManagerActor</code> is the main actor of <code>near-network</code> crate. It acts as a
bridge connecting to the world outside, the other peers, and <code>ClientActor</code> and
<code>ClientViewActor</code>, which handle processing any operations on the chain.
<code>PeerManagerActor</code> maintains information about p2p network via <code>RoutingTableActor</code>,
and indirectly, through <code>PeerActor</code>, connections to all nodes on the network.
All messages going to other nodes, or coming from other nodes will be routed
through this <code>Actor</code>. <code>PeerManagerActor</code> is responsible for accepting incoming
connections from the outside world and creating <code>PeerActors</code> to manage them.</p>
<p>Responsibilities:</p>
<ul>
<li>Accepting new connections.</li>
<li>Maintaining the list of <code>PeerActors</code>, creating, deleting them.</li>
<li>Routing information about new edges between <code>PeerActors</code> and
<code>RoutingTableManager</code>.</li>
<li>Routing messages between <code>ViewClient</code>, <code>ViewClientActor</code> and <code>PeerActors</code>, and
consequently other peers.</li>
<li>Maintains <code>RouteBack</code> structure, which has information on how to send replies to messages.</li>
</ul>
<h1 id="3-code-flow---initialization"><a class="header" href="#3-code-flow---initialization">3. Code flow - initialization</a></h1>
<p>First, the <code>PeerManagerActor</code> actor gets started. <code>PeerManagerActor</code> opens the
TCP server, which listens to incoming connections. It starts the
<code>RoutingTableActor</code>, which then starts the <code>EdgeValidatorActor</code>. When
an incoming connection gets accepted, it starts a new <code>PeerActor</code>
on its own thread.</p>
<h1 id="4-networkconfig"><a class="header" href="#4-networkconfig">4. NetworkConfig</a></h1>
<p><code>near-network</code> reads configuration from <code>NetworkConfig</code>, which is a part of <code>client config</code>.</p>
<p>Here is a list of features read from config:</p>
<ul>
<li><code>boot_nodes</code> - list of nodes to connect to on start.</li>
<li><code>addr</code> - listening address.</li>
<li><code>max_num_peers</code> - by default we connect up to 40 peers, current implementation
supports up to 128.</li>
</ul>
<h1 id="5-connecting-to-other-peers"><a class="header" href="#5-connecting-to-other-peers">5. Connecting to other peers.</a></h1>
<p>Each peer maintains a list of known peers. They are stored in the database. If
the database is empty, the list of peers, called boot nodes, will be read from
the <code>boot_nodes</code> option in the config. The peer to connect to is chosen at
random from a list of known nodes by the <code>PeerManagerActor::sample_random_peer</code>
method.</p>
<h1 id="6-edges--network---in-code-representation"><a class="header" href="#6-edges--network---in-code-representation">6. Edges &amp; network - in code representation</a></h1>
<p><code>P2P network</code> is represented by a list of <code>peers</code>, where each <code>peer</code> is
represented by a structure <code>PeerId</code>, which is defined by the <code>peer</code>'s public key
<code>PublicKey</code>, and a list of edges, where each edge is represented by the
structure <code>Edge</code>.</p>
<p>Both are defined below.</p>
<h1 id="61-publickey"><a class="header" href="#61-publickey">6.1 PublicKey</a></h1>
<p>We use two types of public keys:</p>
<ul>
<li>a 256 bit <code>ED25519</code> public key.</li>
<li>a 512 bit <code>Secp256K1</code> public key.</li>
</ul>
<p>Public keys are defined in the <code>PublicKey</code> enum, which consists of those two
variants.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ED25519PublicKey(pub [u8; 32]);
pub struct Secp256K1PublicKey([u8; 64]);
pub enum PublicKey {
    ED25519(ED25519PublicKey),
    SECP256K1(Secp256K1PublicKey),
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="62-peerid"><a class="header" href="#62-peerid">6.2 PeerId</a></h1>
<p>Each <code>peer</code> is uniquely defined by its <code>PublicKey</code>, and represented by <code>PeerId</code>
struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PeerId(PublicKey);
<span class="boring">}
</span></code></pre></pre>
<h1 id="63-edge"><a class="header" href="#63-edge">6.3 Edge</a></h1>
<p>Each <code>edge</code> is represented by the <code>Edge</code> structure. It contains the following:</p>
<ul>
<li>pair of nodes represented by their public keys.</li>
<li><code>nonce</code> - a unique number representing the state of an edge. Starting with <code>1</code>.
Odd numbers represent an active edge. Even numbers represent an edge in which
one of the nodes, confirmed that the edge is removed.</li>
<li>Signatures from both peers for active edges.</li>
<li>Signature from one peer in case an edge got removed.</li>
</ul>
<h1 id="64-graph-representation"><a class="header" href="#64-graph-representation">6.4 Graph representation</a></h1>
<p><code>RoutingTableActor</code> is responsible for storing and maintaining the set of all edges.
They are kept in the <code>edge_info</code> data structure of the type <code>HashSet&lt;Edge&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RoutingTableActor {
    /// Collection of edges representing P2P network.
    /// It's indexed by `Edge::key()` key and can be search through by calling `get()` function
    /// with `(PeerId, PeerId)` as argument.
    pub edges_info: HashSet&lt;Edge&gt;,
    /// ...
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="7-code-flow---connecting-to-a-peer---handshake"><a class="header" href="#7-code-flow---connecting-to-a-peer---handshake">7. Code flow - connecting to a peer - handshake</a></h1>
<p>When <code>PeerManagerActor</code> starts, it starts to listen to a specific port.</p>
<h2 id="71---step-1---monitor_peers_trigger-runs"><a class="header" href="#71---step-1---monitor_peers_trigger-runs">7.1 - Step 1 - <code>monitor_peers_trigger</code> runs</a></h2>
<p><code>PeerManager</code> checks if we need to connect to another peer by running the
<code>PeerManager::is_outbound_bootstrap_needed</code> method. If <code>true</code> we will try to
connect to a new node. Let's call the current node, node <code>A</code>.</p>
<h2 id="72---step-2---choosing-the-node-to-connect-to"><a class="header" href="#72---step-2---choosing-the-node-to-connect-to">7.2 - Step 2 - choosing the node to connect to</a></h2>
<p>Method <code>PeerManager::sample_random_peer</code> will be called, and it returns node <code>B</code>
that we will try to connect to.</p>
<h2 id="73---step-3---outboundtcpconnect-message"><a class="header" href="#73---step-3---outboundtcpconnect-message">7.3 - Step 3 - <code>OutboundTcpConnect</code> message</a></h2>
<p><code>PeerManagerActor</code> will send itself a message <code>OutboundTcpConnect</code> in order
to connect to node <code>B</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OutboundTcpConnect {
    /// Peer information of the outbound connection
    pub target_peer_info: PeerInfo,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="74---step-4---outboundtcpconnect-message"><a class="header" href="#74---step-4---outboundtcpconnect-message">7.4 - Step 4 - <code>OutboundTcpConnect</code> message</a></h2>
<p>On receiving the message the <code>handle_msg_outbound_tcp_connect</code> method will be
called, which calls <code>TcpStream::connect</code> to create a new connection.</p>
<h2 id="75---step-5---connection-gets-established"><a class="header" href="#75---step-5---connection-gets-established">7.5 - Step 5 - Connection gets established</a></h2>
<p>Once connection with the outgoing peer gets established. The <code>try_connect_peer</code>
method will be called. And then a new <code>PeerActor</code> will be created and started. Once
the <code>PeerActor</code> starts it will send a <code>Handshake</code> message to the outgoing node <code>B</code>
over a tcp connection.</p>
<p>This message contains <code>protocol_version</code>, node <code>A</code>'s metadata, as well as all
information necessary to create an <code>Edge</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Handshake {
    /// Current protocol version.
    pub(crate) protocol_version: u32,
    /// Oldest supported protocol version.
    pub(crate) oldest_supported_version: u32,
    /// Sender's peer id.
    pub(crate) sender_peer_id: PeerId,
    /// Receiver's peer id.
    pub(crate) target_peer_id: PeerId,
    /// Sender's listening addr.
    pub(crate) sender_listen_port: Option&lt;u16&gt;,
    /// Peer's chain information.
    pub(crate) sender_chain_info: PeerChainInfoV2,
    /// Represents new `edge`. Contains only `none` and `Signature` from the sender.
    pub(crate) partial_edge_info: PartialEdgeInfo,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="76---step-6---handshake-arrives-at-node-b"><a class="header" href="#76---step-6---handshake-arrives-at-node-b">7.6 - Step 6 - <code>Handshake</code> arrives at node <code>B</code></a></h2>
<p>Node <code>B</code> receives a <code>Handshake</code> message. Then it performs various validation
checks. That includes:</p>
<ul>
<li>Check signature of edge from the other peer.</li>
<li>Whenever <code>nonce</code> is the edge, send matches.</li>
<li>Check whether the protocol is above the minimum
<code>OLDEST_BACKWARD_COMPATIBLE_PROTOCOL_VERSION</code>.</li>
<li>Other node <code>view of chain</code> state.</li>
</ul>
<p>If everything is successful, <code>PeerActor</code> will send a <code>RegisterPeer</code> message to
<code>PeerManagerActor</code>. This message contains everything needed to add <code>PeerActor</code>
to the list of active connections in <code>PeerManagerActor</code>.</p>
<p>Otherwise, <code>PeerActor</code> will be stopped immediately or after some timeout.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RegisterPeer {
    pub(crate) actor: Addr&lt;PeerActor&gt;,
    pub(crate) peer_info: PeerInfo,
    pub(crate) peer_type: PeerType,
    pub(crate) chain_info: PeerChainInfoV2,
    // Edge information from this node.
    // If this is None it implies we are outbound connection, so we need to create our
    // EdgeInfo part and send it to the other peer.
    pub(crate) this_edge_info: Option&lt;EdgeInfo&gt;,
    // Edge information from other node.
    pub(crate) other_edge_info: EdgeInfo,
    // Protocol version of new peer. May be higher than ours.
    pub(crate) peer_protocol_version: ProtocolVersion,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="77---step-7---peermanageractor-receives-registerpeer-message---node-b"><a class="header" href="#77---step-7---peermanageractor-receives-registerpeer-message---node-b">7.7 - Step 7 - <code>PeerManagerActor</code> receives <code>RegisterPeer</code> message - node <code>B</code></a></h2>
<p>In the <code>handle_msg_consolidate</code> method, the <code>RegisterPeer</code> message will be validated.
If successful, the <code>register_peer</code> method will be called, which adds the <code>PeerActor</code>
to the list of connected peers.</p>
<p>Each connected peer is represented in <code>PeerActorManager</code> in <code>ActivePeer</code> the data
structure.</p>
<!-- TODO: Rename `ActivePeer` to `RegisterPeer` -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Contains information relevant to an active peer.
struct ActivePeer { // will be renamed to `ConnectedPeer` see #5428
    addr: Addr&lt;PeerActor&gt;,
    full_peer_info: FullPeerInfo,
    /// Number of bytes we've received from the peer.
    received_bytes_per_sec: u64,
    /// Number of bytes we've sent to the peer.
    sent_bytes_per_sec: u64,
    /// Last time requested peers.
    last_time_peer_requested: Instant,
    /// Last time we received a message from this peer.
    last_time_received_message: Instant,
    /// Time where the connection was established.
    connection_established_time: Instant,
    /// Who started connection. Inbound (other) or Outbound (us).
    peer_type: PeerType,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="78---step-8---exchange-routing-table-part-1---node-b"><a class="header" href="#78---step-8---exchange-routing-table-part-1---node-b">7.8 - Step 8 - Exchange routing table part 1 - node <code>B</code></a></h2>
<p>At the end of the <code>register_peer</code> method node <code>B</code> will perform a
<code>RoutingTableSync</code> sync. Sending the list of known <code>edges</code> representing a
full graph, and a list of known <code>AnnounceAccount</code>. Those will be
covered later, in their dedicated sections see sections (to be added). <!-- TODO: TODO1, TODO2 --></p>
<pre><code class="language-rust  ignore">message: PeerMessage::RoutingTableSync(SyncData::edge(new_edge)),
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Contains metadata used for routing messages to particular `PeerId` or `AccountId`.
pub struct RoutingTableSync { // also known as `SyncData` (#5489)
    /// List of known edges from `RoutingTableActor::edges_info`.
    pub(crate) edges: Vec&lt;Edge&gt;,
    /// List of known `account_id` to `PeerId` mappings.
    /// Useful for `send_message_to_account` method, to route message to particular account.
    pub(crate) accounts: Vec&lt;AnnounceAccount&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="79---step-9----exchange-routing-table-part-2---node-a"><a class="header" href="#79---step-9----exchange-routing-table-part-2---node-a">7.9 - Step 9 -  Exchange routing table part 2 - node <code>A</code></a></h2>
<p>Upon receiving a <code>RoutingTableSync</code> message. Node <code>A</code> will reply with its own
<code>RoutingTableSync</code> message.</p>
<h2 id="710---step-10----exchange-routing-table-part-2---node-b"><a class="header" href="#710---step-10----exchange-routing-table-part-2---node-b">7.10 - Step 10 -  Exchange routing table part 2 - node <code>B</code></a></h2>
<p>Node <code>B</code> will get the message from <code>A</code> and update its routing table.</p>
<h1 id="8-adding-new-edges-to-routing-tables"><a class="header" href="#8-adding-new-edges-to-routing-tables">8. Adding new edges to routing tables</a></h1>
<p>This section covers the process of adding new edges, received from another
node, to the routing table. It consists of several steps covered below.</p>
<h2 id="81-step-1"><a class="header" href="#81-step-1">8.1 Step 1</a></h2>
<p><code>PeerManagerActor</code> receives <code>RoutingTableSync</code> message containing list of new
<code>edges</code> to add. <code>RoutingTableSync</code> contains list of edges of the P2P network.
This message is then forwarded to <code>RoutingTableActor</code>.</p>
<h2 id="82-step-2"><a class="header" href="#82-step-2">8.2 Step 2</a></h2>
<p><code>PeerManagerActor</code> forwards those edges to <code>RoutingTableActor</code> inside of
the <code>ValidateEdgeList</code> struct.</p>
<p><code>ValidateEdgeList</code> contains:</p>
<ul>
<li>list of edges to verify.</li>
<li>peer who sent us the edges.</li>
</ul>
<h2 id="83-step-3"><a class="header" href="#83-step-3">8.3 Step 3</a></h2>
<p><code>RoutingTableActor</code> gets the <code>ValidateEdgeList</code> message. Filters out <code>edges</code>
that have already been verified, those that are already in
<code>RoutingTableActor::edges_info</code>.</p>
<p>Then, it updates <code>edge_verifier_requests_in_progress</code> to mark that edge
verifications are in progress, and edges shouldn't be pruned from Routing Table
(see section (to be added)<!-- TODO: add section link -->).</p>
<p>Then, after removing already validated edges, the modified message is forwarded
to <code>EdgeValidatorActor</code>.</p>
<h2 id="84-step-4"><a class="header" href="#84-step-4">8.4 Step 4</a></h2>
<p><code>EdgeValidatorActor</code> goes through the list of all edges. It checks whether all edges
are valid (their cryptographic signatures match, etc.).</p>
<p>If any edge is not valid, the peer will be banned.</p>
<p>Edges that are validated are written to a concurrent queue
<code>ValidateEdgeList::sender</code>. This queue is used to transfer edges from
<code>EdgeValidatorActor</code> back to <code>PeerManagerActor</code>.</p>
<h2 id="85-step-5"><a class="header" href="#85-step-5">8.5 Step 5</a></h2>
<p><code>broadcast_validated_edges_trigger</code> runs, and gets validated edges from
<code>EdgeVerifierActor</code>.</p>
<p>Every new edge will be broadcast to all connected peers.</p>
<p>And then, all validated edges received from <code>EdgeVerifierActor</code> will be sent
again to <code>RoutingTableActor</code> inside <code>AddVerifiedEdges</code>.</p>
<h2 id="85-step-6"><a class="header" href="#85-step-6">8.5 Step 6</a></h2>
<p>When <code>RoutingTableActor</code> receives <code>RoutingTableMessages::AddVerifiedEdges</code>, the
method <code>add_verified_edges_to_routing_table</code> will be called. It will add edges to
<code>RoutingTableActor::edges_info</code> struct, and mark routing table, that it needs
a recalculation (see <code>RoutingTableActor::needs_routing_table_recalculation</code>).</p>
<h1 id="9-routing-table-computation"><a class="header" href="#9-routing-table-computation">9 Routing table computation</a></h1>
<p>Routing table computation does a few things:</p>
<ul>
<li>For each peer <code>B</code>, calculates set of peers <code>|C_b|</code>, such that each peer is on
the shortest path to <code>B</code>.</li>
<li>Removes unreachable edges from memory and stores them to disk.</li>
<li>The distance is calculated as the minimum number of nodes on the path from
given node <code>A</code>, to each other node on the network. That is, <code>A</code> has a distance
of <code>0</code> to itself. Its neighbors will have a distance of <code>1</code>. The neighbors of
their neighbors will have a distance of <code>2</code>, etc.</li>
</ul>
<h2 id="91-step-1"><a class="header" href="#91-step-1">9.1 Step 1</a></h2>
<p><code>PeerManagerActor</code> runs a <code>update_routing_table_trigger</code> every
<code>UPDATE_ROUTING_TABLE_INTERVAL</code> seconds.</p>
<p><code>RoutingTableMessages::RoutingTableUpdate</code> message is sent to
<code>RoutingTableActor</code> to request routing table re-computation.</p>
<h2 id="92-step-2"><a class="header" href="#92-step-2">9.2 Step 2</a></h2>
<p><code>RoutingTableActor</code> receives the message, and then:</p>
<ul>
<li>calls <code>recalculate_routing_table</code> method, which computes
<code>RoutingTableActor::peer_forwarding: HashMap&lt;PeerId, Vec&lt;PeerId&gt;&gt;</code>. For each
<code>PeerId</code> on the network, gives a list of connected peers, which are on the
shortest path to the destination. It marks reachable peers in the
<code>peer_last_time_reachable</code> struct.</li>
<li>calls <code>prune_edges</code> which removes from memory all the edges that were not
reachable for at least 1 hour, based on the <code>peer_last_time_reachable</code> data
structure. Those edges are then stored to disk.</li>
</ul>
<h2 id="93-step-3"><a class="header" href="#93-step-3">9.3 Step 3</a></h2>
<p><code>RoutingTableActor</code> sends a <code>RoutingTableUpdateResponse</code> message back to
<code>PeerManagerActor</code>.</p>
<p><code>PeerManagerActor</code> keeps a local copy of <code>edges_info</code>, called <code>local_edges_info</code>
containing only edges adjacent to current node.</p>
<ul>
<li><code>RoutingTableUpdateResponse</code> contains a list of local edges, which
<code>PeerManagerActor</code> should remove.</li>
<li><code>peer_forwarding</code> which represents how to route messages in the P2P network</li>
<li><code>peers_to_ban</code> represents a list of peers to ban for sending us edges, which failed
validation in <code>EdgeVerifierActor</code>.</li>
</ul>
<h2 id="94-step-4"><a class="header" href="#94-step-4">9.4 Step 4</a></h2>
<p><code>PeerManagerActor</code> receives <code>RoutingTableUpdateResponse</code> and then:</p>
<ul>
<li>updates local copy of <code>peer_forwarding</code>, used for routing messages.</li>
<li>removes <code>local_edges_to_remove</code> from <code>local_edges_info</code>.</li>
<li>bans peers, who sent us invalid edges.</li>
</ul>
<h1 id="10-message-transportation-layers"><a class="header" href="#10-message-transportation-layers">10. Message transportation layers.</a></h1>
<p>This section describes different protocols of sending messages currently used in
<code>Near</code>.</p>
<h2 id="101-messages-between-actors"><a class="header" href="#101-messages-between-actors">10.1 Messages between Actors.</a></h2>
<p><code>Near</code> is built on <code>Actix</code>'s <code>actor</code>
<a href="https://actix.rs/docs/actix/actor">framework</a>. Usually each actor
runs on its own dedicated thread. Some, like <code>PeerActor</code> have one thread per
each instance. Only messages implementing <code>actix::Message</code>, can be sent
using between threads. Each actor has its own queue; Processing of messages
happens asynchronously.</p>
<p>We should not leak implementation details into the spec.</p>
<p>Actix messages can be found by looking for <code>impl actix::Message</code>.</p>
<h2 id="102-messages-sent-through-tcp"><a class="header" href="#102-messages-sent-through-tcp">10.2 Messages sent through TCP</a></h2>
<p>Near is using <code>borsh</code> serialization to exchange messages between nodes (See
<a href="https://borsh.io/">borsh.io</a>). We should be careful when making changes to
them. We have to maintain backward compatibility. Only messages implementing
<code>BorshSerialize</code>, <code>BorshDeserialize</code> can be sent. We also use <code>borsh</code> for
database storage.</p>
<h2 id="103-messages-sentreceived-through-chainjsonrpc"><a class="header" href="#103-messages-sentreceived-through-chainjsonrpc">10.3 Messages sent/received through <code>chain/jsonrpc</code></a></h2>
<p>Near runs a <code>json REST server</code>. (See <code>actix_web::HttpServer</code>). All messages sent
and received must implement <code>serde::Serialize</code> and <code>serde::Deserialize</code>.</p>
<h1 id="11-code-flow---routing-a-message"><a class="header" href="#11-code-flow---routing-a-message">11. Code flow - routing a message</a></h1>
<p>This is the example of the message that is being sent between nodes
<a href="https://github.com/near/nearcore/blob/fa8749dc60fe0de8e94c3046571731c622326e9f/chain/network-primitives/src/types.rs#L362"><code>RawRoutedMessage</code></a>.</p>
<p>Each of these methods have a <code>target</code> - that is either the <code>account_id</code> or <code>peer_id</code>
or hash (which seems to be used only for route back...). If target is the
account - it will be converted using <code>routing_table.account_owner</code> to the peer.</p>
<p>Upon receiving the message, the <code>PeerManagerActor</code>
<a href="https://github.com/near/nearcore/blob/cadf11d5851be7611011b4e89542e11f41f3d827/chain/network/src/peer_manager/peer_manager_actor.rs">will sign it</a>
and convert into RoutedMessage (which also have things like TTL etc.).</p>
<p>Then it will use the <code>routing_table</code>, to find the route to the target peer (add
<code>route_back</code> if needed) and then send the message over the network as
<code>PeerMessage::Routed</code>. Details about routing table computations are covered in
<a href="architecture/network.html#8-adding-new-edges-to-routing-tables">section 8</a>. </p>
<p>When Peer receives this message (as <code>PeerMessage::Routed</code>), it will pass it to
PeerManager (as <code>RoutedMessageFrom</code>), which would then check if the message is
for the current <code>PeerActor</code>. (if yes, it would pass it to the client) and if
not - it would pass it along the network.</p>
<p>All these messages are handled by <code>receive_client_message</code> in Peer.
(<code>NetworkClientMessages</code>) - and transferred to <code>ClientActor</code> in
(<code>chain/client/src/client_actor.rs</code>)</p>
<p><code>NetworkRequests</code> to <code>PeerManager</code> actor trigger the <code>RawRoutedMessage</code> for
messages that are meant to be sent to another <code>peer</code>.</p>
<p><code>lib.rs</code> (<code>ShardsManager</code>) has a <code>network_adapter</code> - coming from the client’s
<code>network_adapter</code> that comes from <code>ClientActor</code> that comes from the <code>start_client</code> call
that comes from <code>start_with_config</code> (that creates <code>PeerManagerActor</code> - that is
passed as target to <code>network_recipent</code>).</p>
<h1 id="12-database"><a class="header" href="#12-database">12. Database</a></h1>
<h3 id="121-storage-of-deleted-edges"><a class="header" href="#121-storage-of-deleted-edges">12.1 Storage of deleted edges</a></h3>
<p>Every time a group of peers becomes unreachable at the same time; We store edges
belonging to them in components. We remove all of those edges from memory, and
save them to the database. If any of them were to be reachable again, we would
re-add them. This is useful in case there is a network split, to recover edges
if needed.</p>
<p>Each component is assigned a unique <code>nonce</code>, where first one is assigned nonce
0. Each new component gets assigned a consecutive integer.</p>
<p>To store components, we have the following columns in the DB.</p>
<ul>
<li><code>DBCol::LastComponentNonce</code> Stores <code>component_nonce: u64</code>, which is the last
used nonce.</li>
<li><code>DBCol::ComponentEdges</code> Mapping from <code>component_nonce</code> to a list of edges.</li>
<li><code>DBCol::PeerComponent</code> Mapping from <code>peer_id</code> to the last component <code>nonce</code> it belongs to.</li>
</ul>
<h3 id="122-storage-of-account_id-to-peer_id-mapping"><a class="header" href="#122-storage-of-account_id-to-peer_id-mapping">12.2 Storage of <code>account_id</code> to <code>peer_id</code> mapping</a></h3>
<p><code>ColAccountAnouncements</code> -&gt; Stores a mapping from <code>account_id</code> to a tuple
(<code>account_id</code>, <code>peer_id</code>, <code>epoch_id</code>, <code>signature</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas-cost-parameters"><a class="header" href="#gas-cost-parameters">Gas Cost Parameters</a></h1>
<p>Gas in NEAR Protocol solves two problems.</p>
<ol>
<li>To avoid spam, validator nodes only perform work if a user's tokens are
burned. Tokens are automatically converted to gas using the current gas
price.</li>
<li>To synchronize shards, they must all produce chunks following a strict
schedule of 1 second execution time. Gas is used to measure how heavy the
workload of a transaction is, so that the number of transactions that fit in
a block can be deterministically computed by all nodes.</li>
</ol>
<p>In other words, each transaction costs a fixed amount of gas. This gas cost
determines how much a user has to pay and how much time nearcore has to execute
the transaction.</p>
<p>What happens if nearcore executes a transaction too slowly? Chunk production for
the shard gets delayed, which delays block production for the entire blockchain,
increasing latency and reducing throughput for everybody. If the chunk is really
late, the block producer will decide to not include the chunk at all and inserts
an empty chunk. The chunk may be included in the next block.</p>
<p>By now, you probably wonder how we can know the time it takes to execute a
transaction, given that validators use hardware of their choice. Getting these
timings right is indeed a difficult problem. Or flipping the problem, assuming
the timings are already known, then we must implement nearcore such that it
guarantees to operate within the given time constraints. How we tackle this is
the topic of this chapter.</p>
<p>If you want to learn more about Gas from a user perspective, 
<a href="https://docs.near.org/concepts/basics/transactions/gas">Gas basic concepts</a>,
<a href="https://docs.near.org/concepts/basics/transactions/gas-advanced">Gas advanced concepts</a>,
and <a href="https://nomicon.io/RuntimeSpec/Fees/">the runtime fee specification</a> are
good places to dig deeper.</p>
<h2 id="hardware-and-timing-assumptions"><a class="header" href="#hardware-and-timing-assumptions">Hardware and Timing Assumptions</a></h2>
<p>For timing to make sense at all, we must first define hardware constraints. The
official hardware requirements for a validator are published on
<a href="https://near-nodes.io/validator/hardware-validator">near-nodes.io/validator/hardware-validator</a>. They
may change over time but the main principle is that a moderately configured,
cloud-hosted virtual machine suffices.</p>
<p>For our gas computation, we assume the minimum required hardware. Then we define
10<sup>15</sup> gas to be executed in at most 1s. We commonly use 1 Tgas (=
10<sup>12</sup> gas) in conversation, which corresponds to 1ms execution time.</p>
<p>Obviously, this definition means that a validator running more powerful hardware
will execute the transactions faster. That is perfectly okay, as far as the
protocol is concerned we just need to make sure the chunk is available in time.
If it is ready in even less time, no problem.</p>
<p>Less obviously, this means that even a minimally configured validator is often
idle. Why is that? Well, the hardware must be prepared to execute chunks that
are always full. But that is rarely the case, as the gas price increases
exponentially when chunks are full, which would cause traffic to go back
eventually.</p>
<p>Furthermore, the hardware has to be ready for transactions of all types,
including transactions chosen by a malicious actor selecting only the most
complex transactions. Those transactions can also be unbalanced in what
bottlenecks they hit. For example, a chunk can be filled with transactions that
fully utilize the CPU's floating point units. Or they could be using all the
available disk IO bandwidth.</p>
<p>Because the minimum required hardware needs to meet the timing requirements for
any of those scenarios, the typical, more balanced case is usually computed
faster than the gas rule states.</p>
<h2 id="transaction-gas-cost-model"><a class="header" href="#transaction-gas-cost-model">Transaction Gas Cost Model</a></h2>
<p>A transaction is essentially just a list of actions to be executed on the same
account. For example it could be <code>CreateAccount</code> combined with
<code>FunctionCall(&quot;hello_world&quot;)</code>.</p>
<p>The <a href="https://nomicon.io/RuntimeSpec/Actions">reference for available actions</a>
shows the conclusive list of possible actions. The protocol defines fixed fees
for each of them. More details on <a href="architecture/gas/index.html#action-costs">actions fees</a> follow below.</p>
<p>Fixed fees are an important design decision. It means that a given action will
always cost the exact same amount of gas, no matter on what hardware it
executes. But the content of the action can impact the cost, for example a
<code>DeployContract</code> action's cost scales with the size of the contract code.</p>
<p>So, to be more precise, the protocol defines fixed gas cost <em>parameters</em> for
each action, together with a formula to compute the gas cost for the action. All
actions today either use a single fixed gas cost or they use a base cost and a
linear scaling parameter. With one important exception, <code>FunctionCall</code>, which
shall be discussed <a href="architecture/gas/index.html#fn-call-costs">further below</a>.</p>
<p>There is an entire section on <a href="architecture/gas/./parameter_definition.html">Parameter Definitions</a>
that explains how to find the source of truth for parameter values in the
nearcore repository, how they can be referenced in code, and what steps are
necessary to add a new parameter.</p>
<p>Let us dwell a bit more on the linear scaling factors. The fact that contract
deployment cost, which includes code compilation, scales linearly limits the
compiler to use only algorithms of linear complexity. Either that, or the
parameters must be set to match the 1ms = 1Tgas rule at the largest possible
contract size. Today, we limit ourselves to linear-time algorithms in the
compiler.</p>
<p>Likewise, an action that has no scaling parameters must only use constant time
to execute. Taking the <code>CreateAccount</code> action as an example, with a cost of 0.1
Tgas, it has to execute within 0.1ms. Technically, the execution time depends
ever so slightly on the account name length. But there is a fairly low upper
limit on that length and it makes sense to absorb all the cost in the constant
base cost.</p>
<p>This concept of picking parameters according to algorithmic complexity is key.
If you understand this, you know how to think about gas as a nearcore developer.
This should be enough background to understand what the estimator does.</p>
<p>The <a href="architecture/gas/./estimator.html">runtime parameter estimator</a> is a separate binary within
the nearcore repository. It contains benchmarking-like code used to validate
existing parameter values against the 1ms = 1 Tgas rule. When implementing new
features, code should be added there to estimate the safe values of the new
parameters. This section is for you if you are adding new features such as a new
pre-compiled method or other host functions.</p>
<p>Next up are more details on the specific costs that occur when executing NEAR
transactions, which help to understand existing parameters and how they are
organized.</p>
<h2 id="action-costs"><a class="header" href="#action-costs">Action Costs</a></h2>
<p>Actions are executed in two steps. First, an action is verified and inserted to
an action receipt, which is sent to the receiver of the action. The <code>send</code> fee
is paid for this. It is charged either in <code>fn process_transaction(..)</code> if the
action is part of a fresh transaction, or inside
<a href="https://github.com/near/nearcore/blob/14b8ae2c7465444c9b672a23b044c00be98f6e34/runtime/near-vm-logic/src/logic.rs">logic.rs</a>
through <code>fn pay_action_base(..)</code> if the action is generated by a function call.
The send fee is meant to cover the cost to validate an action and transmit it
over the network.</p>
<p>The second step is action execution. It is charged in <code>fn apply_action(..)</code>.
The execution cost has to cover everything required to apply the action to the
blockchain's state.</p>
<p>These two steps are done on the same shard for local receipts. Local receipts
are defined as those where the sender account is also the receiver, abbreviated
as <code>sir</code> which stands for &quot;sender is receiver&quot;.</p>
<p>For remote receipts, which is any receipt where the sender and receiver accounts
are different, we charge a different fee since sending between shards is extra
work. Notably, we charge that extra work even if the accounts are on the same
shard. In terms of gas costs, each account is conceptually its own shard. This
makes dynamic resharding possible without user-observable impact.</p>
<p>When the send step is performed, the minimum required gas to start execution of
that action is known. Thus, if the receipt does not have enough gas, it can be aborted
instead of forwarding it. Here we have to introduce the concept of used gas.</p>
<p><code>gas_used</code> is different from <code>gas_burnt</code>. The former includes the gas that needs
to be reserved for the execution step whereas the latter only includes the gas
that has been burnt in the current chunk. The difference between the two is
sometimes also called prepaid gas, as this amount of gas is paid for during the
send step and it is available in the execution step for free.</p>
<p>If execution fails, the prepaid cost that has not been burned will be refunded.
But this is not the reason why it must burn on the receiver shard instead of the
sender shard. The reason is that we want to properly compute the gas limits on
the chunk that does the execution work.</p>
<p>In conclusion, each action parameter is split into three costs, <code>send_sir</code>,
<code>send_not_sir</code>, and <code>execution</code>. Local receipts charge the first and last
parameters, remote receipts charge the second and third. They should be
estimated, defined, and charged separately. But the reality is that today almost
all actions are estimated as a whole and the parameters are split 50/50 between
send and execution cost, without discrimination on local vs remote receipts
i.e. <code>send_sir</code> cost is the same as <code>send_not_sir</code>.</p>
<p>The <a href="architecture/gas/./gas_profile.html">Gas Profile</a> section goes into more details on how gas
costs of a transaction are tracked in nearcore.</p>
<h2 id="dynamic-function-call-costs"><a class="header" href="#dynamic-function-call-costs">Dynamic Function Call Costs</a></h2>
<p><a name="fn-call-costs"></a></p>
<p>Costs that occur while executing a function call on a deployed WASM app (a.k.a.
smart contract) are charged only at the receiver. Thus, they have only one value
to define them, in contrast to action costs.</p>
<p>The most fundamental dynamic gas cost is <code>wasm_regular_op_cost</code>. It is
multiplied by the exact number of WASM operations executed. You can read about
<a href="https://nomicon.io/RuntimeSpec/Preparation#gas-instrumentation">Gas Instrumentation</a>
if you are curious how we count WASM ops.</p>
<p>Currently, all operations are charged the same, although it could be more
efficient to charge less for opcodes like <code>i32.add</code> compared to <code>f64.sqrt</code>.</p>
<p>The remaining dynamic costs are for work done during host function calls. Each
host function charges a base cost. Either the general <code>wasm_base</code> cost, or a
specific cost such as <code>wasm_utf8_decoding_base</code>, or sometimes both. New host
function calls should define a separate base cost and not charge <code>wasm_base</code>.</p>
<p>Additional host-side costs can be scaled per input byte, such as
<code>wasm_sha256_byte</code>, or costs related to moving data between host and guest, or
any other cost that is specific to the host function. Each host function must
clearly define what its costs are and how they depend on the input.</p>
<h2 id="non-gas-parameters"><a class="header" href="#non-gas-parameters">Non-gas parameters</a></h2>
<p>Not all runtime parameters are directly related to gas costs. Here is a brief
overview.</p>
<ul>
<li><strong>Gas economics config:</strong> Defines the conversion rate when purchasing gas with
NEAR tokens and how gas rewards are split.</li>
<li><strong>Storage usage config:</strong> Costs in tokens, not gas, for storing data on chain.</li>
<li><strong>Account creation config:</strong> Rules for account creation.</li>
<li><strong>Smart contract limits:</strong> Rules for WASM execution.</li>
</ul>
<p>None of the above define any gas costs directly. But there can be interplay
between those parameters and gas costs. For example, the limits on smart
contracts changes the assumptions for how slow a contract compilation could be,
hence it affects the deploy action costs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameter-definitions"><a class="header" href="#parameter-definitions">Parameter Definitions</a></h1>
<p>Gas parameters are a subset of runtime parameters that are defined in
<a href="architecture/gas/../../../core/parameters/res/runtime_configs/parameters.yaml">runtime_configs/parameters.yaml</a>.
<strong>IMPORTANT:</strong> This is not the final list of parameters, it contains the base
values which can be overwritten per protocol version. For example,
<a href="architecture/gas/../../../core/parameters/res/runtime_configs/53.yaml">53.yaml</a>
changes several parameters starting from version 53. You can see the final list
of parameters in
<a href="architecture/gas/../../../core/parameters/res/runtime_configs/parameters.snap">runtime_configs/parameters.snap</a>.
This file is automatically updated whenever any of the parameters changes. To
see all parameter values for a specific version, check out the list of JSON
snapshots generated in this directory:
<a href="architecture/gas/../../../core/parameters/src/snapshots">parameters/src/snapshots</a>.</p>
<h2 id="using-parameters-in-code"><a class="header" href="#using-parameters-in-code">Using Parameters in Code</a></h2>
<p>As the introduction on this page already hints at it, parameter values are
versioned. In other words, they can change if the protocol version changes. A
nearcore binary has to support multiple versions and choose the correct
parameter value at runtime.</p>
<p>To make this easy, there is
<a href="https://github.com/near/nearcore/blob/a8964d200b3938a63d389263bc39c1bcd75b1de4/core/primitives/src/runtime/config_store.rs#L43"><code>RuntimeConfigStore</code></a>.
It contains a sparse map from protocol versions to complete runtime
configurations (<code>BTreeMap&lt;ProtocolVersion, Arc&lt;RuntimeConfig&gt;&gt;</code>).
The runtime then uses <code>store.get_config(protocol_version)</code> to access a runtime
configuration for a specific version.</p>
<p>It is crucial to always use this runtime config store. Never hard-code parameter
values. Never look them up in a different way.</p>
<p>In practice, this usually translates to a <code>&amp;RuntimeConfig</code> argument for any
function that depends on parameter values. This config object implicitly defines
the protocol version. It should therefore not be cached. It should be read from
the store once per chunk and then passed down to all functions that need it.</p>
<h2 id="how-to-add-a-new-parameter"><a class="header" href="#how-to-add-a-new-parameter">How to Add a New Parameter</a></h2>
<p>First and foremost, if you are feeling lost, open a topic in our Zulip chat
(<a href="https://near.zulipchat.com/#narrow/stream/295306-pagoda.2Fcontract-runtime">pagoda/contract-runtime</a>).
We are here to help.</p>
<h3 id="principles"><a class="header" href="#principles">Principles</a></h3>
<p>Before adding anything, please review the basic principles for gas parameters.</p>
<ul>
<li>A parameter must correspond to a clearly defined workload.</li>
<li>When the workload is scalable by a factor <code>N</code> that depends on user input,
it will likely require a base parameter and a second parameter that is
multiplied by <code>N</code>. (Example: <code>N</code> = number of bytes when reading a value from
storage.)</li>
<li>Charge gas before executing the workload.</li>
<li>Parameters should be independent of specific implementation choices in
nearcore.</li>
<li>Ideally, contract developers can easily understand what the cost is simply by
reading the name in a gas profile.</li>
</ul>
<p>The section on <a href="architecture/gas/./gas_profile.html#charging-gas">Gas Profiles</a> explains how to
charge gas, please also consider that when defining a new parameter.</p>
<h3 id="necessary-code-changes"><a class="header" href="#necessary-code-changes">Necessary Code Changes</a></h3>
<p>Adding the parameter in code involves several steps.</p>
<ol>
<li>Define the parameter by adding it to the list in <code>core/primitives/res/runtime_configs/parameters.yaml.</code></li>
<li>Update the Rust view of parameters by adding a variant to <code>enum Parameter</code>
in <code>core/primitives-core/src/parameter.rs</code>. In the same file, update
<code>enum FeeParameter</code> if you add an action cost or update <code>ext_costs()</code>
if you add a cost inside function calls.</li>
<li>Update <code>RuntimeConfig</code>, the configuration used to reference parameters in
code. Depending on the type of parameter, you will need to update
<code>RuntimeFeesConfig</code> (for action costs) or <code>ExtCostsConfig</code> (for gas costs).</li>
<li>Update the list used for gas profiles. This is defined by <code>enum Cost</code> in
<code>core/primitives-core/src/profile.rs</code>. You need to add a variant to either
<code>enum ActionCosts</code> or <code>enum ExtCost</code>. Please also update <code>fn index()</code> that
maps each profile entry to a unique position in serialized gas profiles.</li>
<li>The parameter should be available to use in the code section you need it in.
Now is a good time to ensure <code>cargo check</code> and <code>cargo test --no-run</code> pass.
Most likely you have to update some testing code, such as
<code>ExtCostsConfig::test()</code>.</li>
<li>To merge your changes into nearcore, you will have to hide your parameter
behind a feature flag. Add the feature to the <code>Cargo.toml</code> of each crate
touched in steps 3 and 4 and hide the code behind <code>#[cfg(feature = &quot;protocol_feature_MY_NEW_FEATURE&quot;)]</code>. Do not hide code in step 2 so that
non-nightly builds can still read <code>parameters.yaml</code>. Also, add your feature as
a dependency on <code>nightly</code> in <code>core/primitives/Cargo.toml</code> to make sure it
gets included when compiling for nightly. After that, check <code>cargo check</code> and
<code>cargo test --no-run</code> with and without <code>features=nightly</code>.</li>
</ol>
<h3 id="what-gas-value-should-the-parameter-have"><a class="header" href="#what-gas-value-should-the-parameter-have">What Gas Value Should the Parameter Have?</a></h3>
<p>For a first draft, the exact gas value used in the parameter is not crucial.
Make sure the right set of parameters exists and try to set a number that roughly
makes sense. This should be enough to enable discussions on the NEP around the
feasibility and usefulness of the proposed feature. If you are not sure, a good
rule of thumb is 0.1 Tgas for each disk operation and at least 1 Tgas for each
ms of CPU time. Then round it up generously.</p>
<p>The value will have to be refined later. This is usually the last step after
the implementation is complete and reviewed. Have a look at the section on
<a href="architecture/gas/./estimator.html">estimating gas parameters</a> in the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas-profile"><a class="header" href="#gas-profile">Gas Profile</a></h1>
<p>What if you want to understand the exact gas spending of a smart contract call?
It would be very complicated to predict exactly how much gas executing a piece
of WASM code will require, including all host function calls and actions. An
easier approach is to just run the code on testnet and see how much gas it
burns. Gas profiles allow one to dig deeper and understand the breakdown of the
gas costs per parameter.</p>
<p><strong>Gas profiles are not very reliable</strong>, in that they are often incomplete and the
details of how they are computed can change without a protocol version bump.</p>
<h2 id="example-transaction-gas-profile"><a class="header" href="#example-transaction-gas-profile">Example Transaction Gas Profile</a></h2>
<p>You can query the gas profile of a transaction with
<a href="https://docs.near.org/tools/near-cli">NEAR CLI</a>.</p>
<pre><code class="language-bash">NEAR_ENV=mainnet near tx-status 8vYxsqYp5Kkfe8j9LsTqZRsEupNkAs1WvgcGcUE4MUUw  \
  --accountId app.nearcrowd.near  \
  --nodeUrl https://archival-rpc.mainnet.near.org  # Allows to retrieve older transactions.
</code></pre>
<pre><code>Transaction app.nearcrowd.near:8vYxsqYp5Kkfe8j9LsTqZRsEupNkAs1WvgcGcUE4MUUw
{
  receipts_outcome: [
    {
      block_hash: '2UVQKpxH6PhEqiKr6zMggqux4hwMrqqjpsbKrJG3vFXW',
      id: '14bwmJF21PXY9YWGYN1jpjF3BRuyCKzgVWfhXhZBKH4u',
      outcome: {
        executor_id: 'app.nearcrowd.near',
        gas_burnt: 5302170867180,
        logs: [],
        metadata: {
          gas_profile: [
            {
              cost: 'BASE',
              cost_category: 'WASM_HOST_COST',
              gas_used: '15091782327'
            },
            {
              cost: 'CONTRACT_LOADING_BASE',
              cost_category: 'WASM_HOST_COST',
              gas_used: '35445963'
            },
            {
              cost: 'CONTRACT_LOADING_BYTES',
              cost_category: 'WASM_HOST_COST',
              gas_used: '117474381750'
            },
            {
              cost: 'READ_CACHED_TRIE_NODE',
              cost_category: 'WASM_HOST_COST',
              gas_used: '615600000000'
            },
            # ...
            # skipping entries for presentation brevity
            # ...
            {
              cost: 'WRITE_REGISTER_BASE',
              cost_category: 'WASM_HOST_COST',
              gas_used: '48713882262'
            },
            {
              cost: 'WRITE_REGISTER_BYTE',
              cost_category: 'WASM_HOST_COST',
              gas_used: '4797573768'
            }
          ],
          version: 2
        },
        receipt_ids: [ '46Qsorkr6hy36ZzWmjPkjbgG28ko1iwz1NT25gvia51G' ],
        status: { SuccessValue: 'ZmFsc2U=' },
        tokens_burnt: '530217086718000000000'
      },
      proof: [ ... ]
    },
    { ... }
  ],
  status: { SuccessValue: 'ZmFsc2U=' },
  transaction: { ... },
  transaction_outcome: {
    block_hash: '7MgTTVi3aMG9LiGV8ezrNvoorUwQ7TwkJ4Wkbk3Fq5Uq',
    id: '8vYxsqYp5Kkfe8j9LsTqZRsEupNkAs1WvgcGcUE4MUUw',
    outcome: {
      executor_id: 'evgeniya.near',
      gas_burnt: 2428068571644,
      ...
      tokens_burnt: '242806857164400000000'
    },
  }
}
</code></pre>
<p>The gas profile is in <code>receipts_outcome.outcome.metadata.gas_profile</code>. It shows
gas costs per parameter and with associated categories such as <code>WASM_HOST_COST</code>
or <code>ACTION_COST</code>. In the example, all costs are of the former category, which is
gas expended on smart contract execution. The latter is for gas spent on
actions.</p>
<p>To be complete, the output above should also have a gas profile entry for the
function call action. But currently this is not included since gas profiles only
work properly on function call receipts. Improving this is planned, see
<a href="https://github.com/near/nearcore/issues/8261">nearcore#8261</a>.</p>
<p>The <code>tx-status</code> query returns one gas profile for each receipt. The output above
contains a single gas profile because the transaction only spawned one receipt.
If there was a chain of cross contract calls, there would be multiple profiles.</p>
<p>Besides receipts, also note the <code>transaction_outcome</code> in the output. It contains
the gas cost for converting the transaction into a receipt. To calculate the
full gas cost, add up the transaction cost with all receipt costs.</p>
<p>The transaction outcome currently does not have a gas profile, it only shows the
total gas spent converting the transaction. Arguably, it is not necessary to
provide the gas profile since the costs only depend on the list of actions. With
sufficient understanding of the protocol, one could reverse-engineer the exact
breakdown simply by looking at the action list. But adding the profile would
still make sense to make it easier to understand.</p>
<h2 id="gas-profile-versions"><a class="header" href="#gas-profile-versions">Gas Profile Versions</a></h2>
<p>Depending on the version in <code>receipts_outcome.outcome.metadata.version</code>, you
should expect a different format of the gas profile. Version 1 has no profile
data at all. Version 2 has a detailed profile but some parameters are conflated,
so you cannot extract the exact gas spending in some cases. Version 3 will have
the cost exactly per parameter.</p>
<p>Which version of the profile an RPC node returns depends on the version it had
when it first processed the transaction. The profiles are stored in the database
with one version and never updated. Therefore, older transactions will usually
only have old profiles. However, one could replay the chain from genesis with a
new nearcore client and generate the newest profile for all transactions in this
way.</p>
<p>Note: Due to bugs, some nodes will claim they send version 1 but actually
send version 2. (Did I mention that profiles are unreliable?)</p>
<h2 id="how-gas-profiles-are-created"><a class="header" href="#how-gas-profiles-are-created">How Gas Profiles are Created</a></h2>
<p>The transaction runtime charges gas in various places around the code.
<code>ActionResult</code> keeps a summary of all costs for an action. The <code>gas_burnt</code> and
<code>gas_used</code> fields track the total gas burned and reserved for spawned receipts.
These two fields are crucial for the protocol to function correctly, as they are
used to determine when execution runs out of gas.</p>
<p>Additionally, <code>ActionResult</code> also has a <code>profile</code> field which keeps a detailed
breakdown of the gas spending per parameter. Profiles are not stored on chain
but RPC nodes and archival nodes keep them in their databases. This is mostly a
debug tool and has no direct impact on the correct functioning of the protocol.</p>
<h2 id="charging-gas"><a class="header" href="#charging-gas">Charging Gas</a></h2>
<p>Generally speaking, gas is charged right before the computation that it pays for
is executed. It has to be before to avoid cheap resource exhaustion attacks.
Imagine the user has only 1 gas unit left, but if we start executing an expensive
step, we would waste a significant duration of computation on all validators
without anyone paying for it.</p>
<p>When charging gas for an action, the <code>ActionResult</code> can be updated directly. But
when charging WASM costs, it would be too slow to do a context switch each time,
Therefore, a fast gas counter exists that can be updated from within the VM.
(See
<a href="https://github.com/near/nearcore/blob/06711f8460f946b8d2042aa1df6abe03c5184767/runtime/near-vm-logic/src/gas_counter.rs">gas_counter.rs</a>)
At the end of a function call execution, the gas counter is read by the host and
merged into the <code>ActionResult</code>.</p>
<!-- 
TODO: We can expand a bit more on how profiles are created and how it interacts 
with gas charging after merging https://github.com/near/nearcore/issues/8033
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-parameter-estimator"><a class="header" href="#runtime-parameter-estimator">Runtime Parameter Estimator</a></h1>
<p>The runtime parameter estimator is a byzantine benchmarking suite. Byzantine
benchmarking is not a commonly used term but I feel it describes it quite
well. It measures the performance assuming that up to a third of validators and
all users collude to make the system as slow as possible.</p>
<p>This benchmarking suite is used to check that the gas parameters defined in the
protocol are correct. Correct in this context means, a chunk filled with 1 Pgas
(<strong>P</strong>eta gas) will take at most 1 second to be applied. Or more generally,
per 1 Tgas of execution, we spend no more than 1ms wall-clock time.</p>
<p>For now, nearcore timing is the only one that matters. Things will become more
complicated once there are multiple client implementations. But knowing that
nearcore can serve requests fast enough proves that it is possible to be at
least as fast. However, we should be careful not to couple costs too tightly
with the specific implementation of nearcore to allow for innovation in new
clients.</p>
<p>The estimator code is part of the nearcore repository in the directory
<a href="https://github.com/near/nearcore/tree/master/runtime/runtime-params-estimator">runtime/runtime-params-estimator</a>.</p>
<p>For a practical guide on how to run the estimator, please take a look at
<a href="architecture/gas/../../practices/workflows/gas_estimations.html">Running the Estimator</a> in the
workflows chapter.</p>
<h2 id="code-structure"><a class="header" href="#code-structure">Code Structure</a></h2>
<p>The estimator contains a binary and a library module. The
<a href="https://github.com/near/nearcore/blob/e40863c9ba61a0de140c869583b2113358605771/runtime/runtime-params-estimator/src/main.rs">main.rs</a>
contains the CLI arguments parsing code and logic to fill the test database.</p>
<p>The interesting code lives in
<a href="https://github.com/near/nearcore/blob/e40863c9ba61a0de140c869583b2113358605771/runtime/runtime-params-estimator/src/lib.rs">lib.rs</a>
and its submodules. The comments at the top of that file provide a
high-level overview of how estimations work. More details on specific
estimations are available as comments on the enum variants of <code>Cost</code> in
<a href="https://github.com/near/nearcore/blob/e40863c9ba61a0de140c869583b2113358605771/runtime/runtime-params-estimator/src/cost.rs#L9">costs.rs</a>.</p>
<p>If you roughly understand the three files above, you already have a great
overview of the estimator.
<a href="https://github.com/near/nearcore/blob/e40863c9ba61a0de140c869583b2113358605771/runtime/runtime-params-estimator/src/estimator_context.rs">estimator_context.rs</a>
is another central file. A full estimation run creates a single
<code>EstimatorContext</code>. Each estimation will use it to spawn a new <code>Testbed</code>
with a fresh database that contains the same data as the setup in the
estimator context.</p>
<p>Most estimations fill blocks with transactions to be executed and hand them to
<code>Testbed::measure_blocks</code>. To allow for easy repetitions, the block is usually
filled by an instance of the
<a href="https://github.com/near/nearcore/blob/e40863c9ba61a0de140c869583b2113358605771/runtime/runtime-params-estimator/src/transaction_builder.rs"><code>TransactionBuilder</code></a>,
which can be retrieved from a testbed.</p>
<p>But even filling blocks with transactions becomes repetitive since many
parameters are estimated similarly.
<a href="https://github.com/near/nearcore/blob/master/runtime/runtime-params-estimator/src/utils.rs">utils.rs</a>
has a collection of helpful functions that let you write estimations very
quickly.</p>
<h2 id="estimation-metrics"><a class="header" href="#estimation-metrics">Estimation Metrics</a></h2>
<p>The estimation code is generally not concerned with the metric used to estimate
gas. We use <code>let clock = GasCost::measure();</code> and <code>clock.elapsed()</code> to measure
the cost in whatever metric has been specified in the CLI argument <code>--metric</code>.
But when you run estimations and especially when you want to interpret the
results, you want to understand the metric used. Available metrics are <code>time</code>
and <code>icount</code>.</p>
<p>Starting with <code>time</code>, this is a simple wall-clock time measurement. At the end
of the day, this is what counts in a validator setup. But unfortunately, this
metric is very dependent on the specific hardware and what else is running on
that hardware right now. Dynamic voltage and frequency scaling (DVFS) also plays
a role here. To a certain degree, all these factors can be controlled. But it
requires full control over a system (often not the case when running on
cloud-hosted VMs) and manual labor to set it up.</p>
<p>The other supported metric <code>icount</code> is much more stable. It uses
<a href="https://www.qemu.org/">qemu</a> to emulate an x86 CPU. We then insert a custom
<a href="https://www.qemu.org/docs/master/devel/tcg-plugins.html">TCG plugin</a>
(<a href="https://github.com/near/nearcore/blob/08c4a1bd4b16847eb1c2fccee36bf16f6efb71fd/runtime/runtime-params-estimator/emu-cost/counter_plugin/counter.c">counter.c</a>)
that counts the number of executed x86 instructions. It also intercepts system
calls and counts the number of bytes seen in <code>sys_read</code>, <code>sys_write</code> and their
variations. This gives an approximation for IO bytes, as seen on the interface
between the operating system and nearcore. To convert to gas, we use three
constants to multiply with instruction count, read bytes, and write bytes.</p>
<p>We run qemu inside a Docker container using the Podman runtime, to make sure the qemu and qemu
plugin versions match with system libraries. Make sure to add <code>--containerize</code> when running with
<code>--metric icount</code>.</p>
<p>The great thing about <code>icount</code> is that you can run it on different machines and
it will always return the same result. It is not 100% deterministic but very
close, so it can usually detect code changes that degrade performance in major
ways.</p>
<p>The problem with <code>icount</code> is how unrepresentative it is for real-life
performance. First, <code>x86</code> instructions are not all equally complex. Second, how
many of them are executed per cycle depends on instruction level pipelining,
branch prediction, memory prefetching, and more CPU features like that which are
just not captured by an emulator like qemu. Third, the time it takes to serve
bytes in system calls depends less on the sum of all bytes and more on data
locality and how it can be cached in the OS page cache. But regardless of all
these inaccuracies, it can still be useful to compare different implementations
both measured using <code>icount</code>.</p>
<h2 id="from-estimations-to-parameter-values"><a class="header" href="#from-estimations-to-parameter-values">From Estimations to Parameter Values</a></h2>
<p>To calculate the final gas parameter values, there is more to be done than just
running a single command. After all, these parameters are part of the protocol
specification. They cannot be changed easily. And setting them to a wrong value
can cause severe system instability.</p>
<p>Our current strategy is to run estimations with two different metrics and do so
on standardized cloud hardware. The output is then sanity checked manually by
several people. Based on that, the final gas parameter value is determined.
Usually, it will be the higher output of the two metrics rounded up.</p>
<p>The PR <a href="https://github.com/near/nearcore/pull/8031">#8031</a> to set the ed25519
verification gas parameters is a good example of how such an analysis and
report could look like.</p>
<p>More details on the process will be added to this document
in due time.</p>
<!-- TODO: how to add a new host function estimation -->
<!-- TODO: state of IO estimations -->
<!-- TODO: CE and Warehouse -->
<!-- TODO: ... -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-2"><a class="header" href="#overview-2">Overview</a></h1>
<p>This chapter describes various development processes and best practices employed
at nearcore.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-"><a class="header" href="#rust-">Rust 🦀</a></h1>
<p>This short chapter collects various useful general resources about the Rust
programming language. If you are already familiar with Rust, skip this
chapter. Otherwise, this chapter is for you!</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>Rust community actively encourages beginners to ask questions, take advantage of that!</p>
<p>We have a dedicated stream for Rust questions on our Zulip: <a href="https://near.zulipchat.com/#narrow/stream/300659-Rust-.F0.9F.A6.80">Rust
🦀</a>.</p>
<p>There's a general Rust forum at <a href="https://users.rust-lang.org">https://users.rust-lang.org</a>.</p>
<p>For a more interactive chat, take a look at Discord:
<a href="https://discord.com/invite/rust-lang">https://discord.com/invite/rust-lang</a>.</p>
<h2 id="reference-material"><a class="header" href="#reference-material">Reference Material</a></h2>
<p>Rust is <em>very</em> well documented. It's possible to learn the whole language and
most of the idioms by just reading the official docs. Starting points are</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Book</a> (any resemblance to &quot;Guide to
Nearcore Development&quot; is purely coincidental)</li>
<li><a href="https://doc.rust-lang.org/stable/std/">Standard Library API</a></li>
</ul>
<p>Alternatives are:</p>
<ul>
<li><a href="https://www.amazon.com/Programming-Rust-Fast-Systems-Development/dp/1491927283">Programming
Rust</a>
is an alternative book that moves a bit faster.</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a> is a great
resource for learning by doing.</li>
</ul>
<p>Rust has some great tooling, which is also documented:</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/">Cargo</a>, the build system. Worth at least skimming through!</li>
<li>For IDE support, see <a href="https://www.jetbrains.com/rust/">IntelliJ Rust</a> if you
like JetBrains products or
<a href="https://rust-analyzer.github.io/manual.html">rust-analyzer</a> if you use any
other editor (fun fact: NEAR was one of the sponsors of rust-analyzer!).</li>
<li><a href="https://rust-lang.github.io/rustup/">Rustup</a> manages versions of Rust
itself. It's unobtrusive, so feel free to skip this.</li>
</ul>
<h2 id="cheat-sheet"><a class="header" href="#cheat-sheet">Cheat Sheet</a></h2>
<p>This is a thing in its category, do check it out:</p>
<p><a href="https://cheats.rs">https://cheats.rs</a></p>
<h2 id="language-mastery"><a class="header" href="#language-mastery">Language Mastery</a></h2>
<ul>
<li><a href="https://nostarch.com/rust-rustaceans">Rust for Rustaceans</a> — the book to read
after &quot;The Book&quot;.</li>
<li><a href="https://tokio.rs/tokio/tutorial">Tokio docs</a> explain asynchronous programming
in Rust (async/await).</li>
<li><a href="https://rust-lang.github.io/api-guidelines/about.html">Rust API Guidelines</a>
codify rules for idiomatic Rust APIs. Note that guidelines apply to <em>semver
surface</em> of libraries, and most of the code in nearcore is not on the semver
boundary. Still, a lot of insight there!</li>
<li><a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a> explains <code>unsafe</code>. (any
resemblance to <a href="https://nomicon.io">https://nomicon.io</a> is purely coincidental)</li>
</ul>
<h2 id="selected-blog-posts"><a class="header" href="#selected-blog-posts">Selected Blog Posts</a></h2>
<p>A lot of finer knowledge is hidden away in various dusty corners of Web-2.0.
Here are some favorites:</p>
<ul>
<li><a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html">https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html</a></li>
<li><a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html">https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2018/02/01/in-rust-ordinary-vectors-are-values/">https://smallcultfollowing.com/babysteps/blog/2018/02/01/in-rust-ordinary-vectors-are-values/</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2016/10/02/observational-equivalence-and-unsafe-code/">https://smallcultfollowing.com/babysteps/blog/2016/10/02/observational-equivalence-and-unsafe-code/</a></li>
<li><a href="https://matklad.github.io/2021/09/05/Rust100k.html">https://matklad.github.io/2021/09/05/Rust100k.html</a></li>
</ul>
<p>And on the easiest topic of error handling specifically:</p>
<ul>
<li><a href="http://sled.rs/errors.html">http://sled.rs/errors.html</a></li>
<li><a href="https://kazlauskas.me/entries/errors">https://kazlauskas.me/entries/errors</a></li>
<li><a href="http://joeduffyblog.com/2016/02/07/the-error-model/">http://joeduffyblog.com/2016/02/07/the-error-model/</a></li>
<li><a href="https://blog.burntsushi.net/rust-error-handling/">https://blog.burntsushi.net/rust-error-handling/</a></li>
</ul>
<p>Finally, as a dessert, the first rust slide deck:
<a href="http://venge.net/graydon/talks/rust-2012.pdf">http://venge.net/graydon/talks/rust-2012.pdf</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflows"><a class="header" href="#workflows">Workflows</a></h1>
<p>This chapter documents various ways you can run <code>neard</code> during development:
running a local net, joining a test net, doing benchmarking and load testing. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-a-node"><a class="header" href="#run-a-node">Run a Node</a></h1>
<p>This chapter focuses on the basics of running a node you've just built from
source. It tries to explain how the thing works under the hood and pays
relatively little attention to the various shortcuts we have.</p>
<h2 id="building-the-node"><a class="header" href="#building-the-node">Building the Node</a></h2>
<p>Start with the following command:</p>
<pre><code class="language-console">$ cargo run --profile dev-release -p neard -- --help
</code></pre>
<p>This command builds <code>neard</code> and asks it to show <code>--help</code>. Building <code>neard</code> takes
a while, take a look at <a href="practices/workflows/../fast_builds.html">Fast Builds</a> chapter to learn how to
speed it up.</p>
<p>Let's dissect the command:</p>
<ul>
<li><code>cargo run</code> asks <code>Cargo</code>, the package manager/build tool, to run our
application. If you don't have <code>cargo</code>, install it via <a href="https://rustup.rs">https://rustup.rs</a></li>
<li><code>--profile dev-release</code> is our
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html#custom-profiles">custom profile</a>
to build a somewhat optimized version of the code. The default debug
profile is faster to compile, but produces a node that is too slow to
participate in a real network. The <code>--release</code> profile produces a fully
optimized node, but that's very slow to compile. So <code>--dev-release</code>
is a sweet spot for us! However, never use it for actual production nodes.</li>
<li><code>-p neard</code> asks to build the <code>neard</code> package. We use
<a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">cargo workspaces</a>
to organize our code. The <code>neard</code> package in the top-level <code>/neard</code> directory
is the final binary that ties everything together.</li>
<li><code>--</code> tells cargo to pass the rest of the arguments through to <code>neard</code>.</li>
<li><code>--help</code> instructs <code>neard</code> to list available CLI arguments and subcommands.</li>
</ul>
<p><strong>Note:</strong> Building <code>neard</code> might fail with an openssl or CC error. This means
that you lack some non-rust dependencies we use (openssl and rocksdb mainly). We
currently don't have docs on how to install those, but (basically) you want to
<code>sudo apt install</code> (or whichever distro/package manager you use) missing bits.</p>
<h2 id="preparing-tiny-network"><a class="header" href="#preparing-tiny-network">Preparing Tiny Network</a></h2>
<p>Typically, you want <code>neard</code> to connect to some network, like <code>mainnet</code> or
<code>testnet</code>. We'll get there in time, but we'll start small. For the current
chapter, we will run a network consisting of just a single node -- our own.</p>
<p>The first step there is creating the required configuration. Run the <code>init</code>
command to create config files:</p>
<pre><code class="language-console">$ cargo run --profile dev-release -p neard -- init
INFO neard: version=&quot;trunk&quot; build=&quot;1.1.0-3091-ga8964d200-modified&quot; latest_protocol=57
INFO near: Using key ed25519:B41GMfqE2jWHVwrPLbD7YmjZxxeQE9WA9Ua2jffP5dVQ for test.near
INFO near: Using key ed25519:34d4aFJEmc2A96UXMa9kQCF8g2EfzZG9gCkBAPcsVZaz for node
INFO near: Generated node key, validator key, genesis file in ~/.near
</code></pre>
<p>As the log output says, we are just generating <em>some things</em> in <code>~/.near</code>.
Let's take a look:</p>
<pre><code class="language-console">$ ls ~/.near
config.json
genesis.json
node_key.json
validator_key.json
</code></pre>
<p>The most interesting file here is perhaps <code>genesis.json</code> -- it specifies the
initial state of our blockchain. There are a bunch of hugely important fields
there, which we'll ignore here. The part we'll look at is the <code>.records</code>, which
contains the actual initial data:</p>
<pre><code class="language-console">$ cat ~/.near/genesis.json | jq '.records'
[
  {
    &quot;Account&quot;: {
      &quot;account_id&quot;: &quot;test.near&quot;,
      &quot;account&quot;: {
        &quot;amount&quot;: &quot;1000000000000000000000000000000000&quot;,
        &quot;locked&quot;: &quot;50000000000000000000000000000000&quot;,
        &quot;code_hash&quot;: &quot;11111111111111111111111111111111&quot;,
        &quot;storage_usage&quot;: 0,
        &quot;version&quot;: &quot;V1&quot;
      }
    }
  },
  {
    &quot;AccessKey&quot;: {
      &quot;account_id&quot;: &quot;test.near&quot;,
      &quot;public_key&quot;: &quot;ed25519:B41GMfqE2jWHVwrPLbD7YmjZxxeQE9WA9Ua2jffP5dVQ&quot;,
      &quot;access_key&quot;: {
        &quot;nonce&quot;: 0,
        &quot;permission&quot;: &quot;FullAccess&quot;
      }
    }
  },
  {
    &quot;Account&quot;: {
      &quot;account_id&quot;: &quot;near&quot;,
      &quot;account&quot;: {
        &quot;amount&quot;: &quot;1000000000000000000000000000000000&quot;,
        &quot;locked&quot;: &quot;0&quot;,
        &quot;code_hash&quot;: &quot;11111111111111111111111111111111&quot;,
        &quot;storage_usage&quot;: 0,
        &quot;version&quot;: &quot;V1&quot;
      }
    }
  },
  {
    &quot;AccessKey&quot;: {
      &quot;account_id&quot;: &quot;near&quot;,
      &quot;public_key&quot;: &quot;ed25519:546XB2oHhj7PzUKHiH9Xve3Ze5q1JiW2WTh6abXFED3c&quot;,
      &quot;access_key&quot;: {
        &quot;nonce&quot;: 0,
        &quot;permission&quot;: &quot;FullAccess&quot;
      }
    }
  }
</code></pre>
<p>(I am using the <a href="https://stedolan.github.io/jq/">jq</a> utility here)</p>
<p>We see that we have two accounts here, and we also see their public keys (but
not the private ones).</p>
<p>One of these accounts is a validator:</p>
<pre><code>$ cat ~/.near/genesis.json | jq '.validators'
[
  {
    &quot;account_id&quot;: &quot;test.near&quot;,
    &quot;public_key&quot;: &quot;ed25519:B41GMfqE2jWHVwrPLbD7YmjZxxeQE9WA9Ua2jffP5dVQ&quot;,
    &quot;amount&quot;: &quot;50000000000000000000000000000000&quot;
  }
]
</code></pre>
<p>Now, if we</p>
<pre><code class="language-console">$ cat ~/.near/validator_key.json
</code></pre>
<p>we'll see</p>
<pre><code class="language-json">{
  &quot;account_id&quot;: &quot;test.near&quot;,
  &quot;public_key&quot;: &quot;ed25519:B41GMfqE2jWHVwrPLbD7YmjZxxeQE9WA9Ua2jffP5dVQ&quot;,
  &quot;secret_key&quot;: &quot;ed25519:3x2dUQgBoEqNvKwPjfDE8zDVJgM8ysqb641PYHV28mGPu61WWv332p8keMDKHUEdf7GVBm4f6z4D1XRgBxnGPd7L&quot;
}
</code></pre>
<p>That is, we have a secret key for the sole validator in our network, how
convenient.</p>
<p>To recap, <code>neard init</code> without arguments creates a config for a new network
that starts with a single validator, for which we have the keys.</p>
<p>You might be wondering what <code>~/.near/node_key.json</code> is. That's not too
important, but, in our network, there's no 1-1 correspondence between machines
participating in the peer-to-peer network and accounts on the blockchain. So the
<code>node_key</code> specifies the keypair we'll use when signing network packets. These
packets internally will contain messages signed with the validator's key, and
these internal messages will drive the evolution of the blockchain state.</p>
<p>Finally, <code>~/.near/config.json</code> contains various configs for the node itself.
These are configs that don't affect the rules guiding the evolution of the
blockchain state, but rather things like timeouts, database settings and
such.</p>
<p>The only field we'll look at is <code>boot_nodes</code>:</p>
<pre><code class="language-console">$ cat ~/.near/config.json | jq '.network.boot_nodes'
&quot;&quot;
</code></pre>
<p>It's empty! The <code>boot_nodes</code> specify IPs of the initial nodes our node will
try to connect to on startup. As we are looking into running a single-node
network, we want to leave it empty. But, if you would like to connect to
mainnet, you'd have to set this to some nodes from the mainnet you already know.
You'd also have to ensure that you use the same genesis as the mainnet though
-- if the node tries to connect to a network with a different genesis, it
is rejected.</p>
<h2 id="running-the-network"><a class="header" href="#running-the-network">Running the Network</a></h2>
<p>Finally,</p>
<pre><code class="language-console">$ cargo run --profile dev-release -p neard -- run
INFO neard: version=&quot;trunk&quot; build=&quot;1.1.0-3091-ga8964d200-modified&quot; latest_protocol=57
INFO near: Creating a new RocksDB database path=/home/matklad/.near/data
INFO db: Created a new RocksDB instance. num_instances=1
INFO stats: #       0 4xecSHqTKx2q8JNQNapVEi5jxzewjxAnVFhMd4v5LqNh Validator | 1 validator 0 peers ⬇ 0 B/s ⬆ 0 B/s NaN bps 0 gas/s CPU: 0%, Mem: 50.8 MB
INFO near_chain::doomslug: ready to produce block @ 1, has enough approvals for 59.907µs, has enough chunks
INFO near_chain::doomslug: ready to produce block @ 2, has enough approvals for 40.732µs, has enough chunks
INFO near_chain::doomslug: ready to produce block @ 3, has enough approvals for 65.341µs, has enough chunks
INFO near_chain::doomslug: ready to produce block @ 4, has enough approvals for 51.916µs, has enough chunks
INFO near_chain::doomslug: ready to produce block @ 5, has enough approvals for 37.155µs, has enough chunks
...
</code></pre>
<p>🎉 it's alive!</p>
<p>So, what's going on here?</p>
<p>Our node is running a single-node network. As the network only has a single
validator, and the node has the keys for the validator, the node can produce
blocks by itself. Note the increasing <code>@ 1</code>, <code>@ 2</code>, ... numbers. That
means that our network grows.</p>
<p>Let's stop the node with <code>^C</code> and look around</p>
<pre><code class="language-console">INFO near_chain::doomslug: ready to produce block @ 42, has enough approvals for 56.759µs, has enough chunks
^C WARN neard: SIGINT, stopping... this may take a few minutes.
INFO neard: Waiting for RocksDB to gracefully shutdown
INFO db: Waiting for remaining RocksDB instances to shut down num_instances=1
INFO db: All RocksDB instances shut down
$
</code></pre>
<p>The main change now is that we have a <code>~/.near/data</code> directory which holds the
state of the network in various rocksdb tables:</p>
<pre><code class="language-console">$ ls ~/.near/data
 000004.log
 CURRENT
 IDENTITY
 LOCK
 LOG
 MANIFEST-000005
 OPTIONS-000107
 OPTIONS-000109
</code></pre>
<p>It doesn't matter what those are, &quot;rocksdb stuff&quot; is a fine level of understanding
here. The important bit here is that the node remembers the state of the network,
so, when we restart it, it continues from around the last block:</p>
<pre><code class="language-console">$ cargo run --profile dev-release -p neard -- run
INFO neard: version=&quot;trunk&quot; build=&quot;1.1.0-3091-ga8964d200-modified&quot; latest_protocol=57
INFO db: Created a new RocksDB instance. num_instances=1
INFO db: Dropped a RocksDB instance. num_instances=0
INFO near: Opening an existing RocksDB database path=/home/matklad/.near/data
INFO db: Created a new RocksDB instance. num_instances=1
INFO stats: #       5 Cfba39eH7cyNfKn9GoKTyRg8YrhoY1nQxQs66tLBYwRH Validator | 1 validator 0 peers ⬇ 0 B/s ⬆ 0 B/s NaN bps 0 gas/s CPU: 0%, Mem: 49.4 MB
INFO near_chain::doomslug: not ready to produce block @ 43, need to wait 366.58789ms, has enough approvals for 78.776µs
INFO near_chain::doomslug: not ready to produce block @ 43, need to wait 265.547148ms, has enough approvals for 101.119518ms
INFO near_chain::doomslug: not ready to produce block @ 43, need to wait 164.509153ms, has enough approvals for 202.157513ms
INFO near_chain::doomslug: not ready to produce block @ 43, need to wait 63.176926ms, has enough approvals for 303.48974ms
INFO near_chain::doomslug: ready to produce block @ 43, has enough approvals for 404.41498ms, does not have enough chunks
INFO near_chain::doomslug: ready to produce block @ 44, has enough approvals for 50.07µs, has enough chunks
INFO near_chain::doomslug: ready to produce block @ 45, has enough approvals for 45.093µs, has enough chunks
</code></pre>
<h2 id="interacting-with-the-node"><a class="header" href="#interacting-with-the-node">Interacting With the Node</a></h2>
<p>Ok, now our node is running, let's poke it! The node exposes a JSON RPC interface
which can be used to interact with the node itself (to, e.g., do a health check)
or with the blockchain (to query information about the blockchain state or to
submit a transaction).</p>
<pre><code class="language-console">$ http get http://localhost:3030/status
HTTP/1.1 200 OK
access-control-allow-credentials: true
access-control-expose-headers: accept-encoding, accept, connection, host, user-agent
content-length: 1010
content-type: application/json
date: Tue, 15 Nov 2022 13:58:13 GMT
vary: Origin, Access-Control-Request-Method, Access-Control-Request-Headers

{
    &quot;chain_id&quot;: &quot;test-chain-rR8Ct&quot;,
    &quot;latest_protocol_version&quot;: 57,
    &quot;node_key&quot;: &quot;ed25519:71QRP9qKcYRUYXTLNnrmRc1NZSdBaBo9nKZ88DK5USNf&quot;,
    &quot;node_public_key&quot;: &quot;ed25519:5A5QHyLayA9zksJZGBzveTgBRecpsVS4ohuxujMAFLLa&quot;,
    &quot;protocol_version&quot;: 57,
    &quot;rpc_addr&quot;: &quot;0.0.0.0:3030&quot;,
    &quot;sync_info&quot;: {
        &quot;earliest_block_hash&quot;: &quot;6gJLCnThQENYFbnFQeqQvFvRsTS5w87bf3xf8WN1CMUX&quot;,
        &quot;earliest_block_height&quot;: 0,
        &quot;earliest_block_time&quot;: &quot;2022-11-15T13:45:53.062613669Z&quot;,
        &quot;epoch_id&quot;: &quot;6gJLCnThQENYFbnFQeqQvFvRsTS5w87bf3xf8WN1CMUX&quot;,
        &quot;epoch_start_height&quot;: 501,
        &quot;latest_block_hash&quot;: &quot;9JC9o3rZrDLubNxVr91qMYvaDiumzwtQybj1ZZR9dhbK&quot;,
        &quot;latest_block_height&quot;: 952,
        &quot;latest_block_time&quot;: &quot;2022-11-15T13:58:13.185721125Z&quot;,
        &quot;latest_state_root&quot;: &quot;9kEYQtWczrdzKCCuFzPDX3Vtar1pFPXMdLU5HJyF8Ght&quot;,
        &quot;syncing&quot;: false
    },
    &quot;uptime_sec&quot;: 570,
    &quot;validator_account_id&quot;: &quot;test.near&quot;,
    &quot;validator_public_key&quot;: &quot;ed25519:71QRP9qKcYRUYXTLNnrmRc1NZSdBaBo9nKZ88DK5USNf&quot;,
    &quot;validators&quot;: [
        {
            &quot;account_id&quot;: &quot;test.near&quot;,
            &quot;is_slashed&quot;: false
        }
    ],
    &quot;version&quot;: {
        &quot;build&quot;: &quot;1.1.0-3091-ga8964d200-modified&quot;,
        &quot;rustc_version&quot;: &quot;1.65.0&quot;,
        &quot;version&quot;: &quot;trunk&quot;
    }
}
</code></pre>
<p>(I am using <a href="https://httpie.io/cli">HTTPie here</a>)</p>
<p>Note how <code>&quot;latest_block_height&quot;: 952</code> corresponds to <code>@ 952</code> we see in the logs.</p>
<p>Let's query the blockchain state:</p>
<pre><code>$ http post http://localhost:3030/ method=query jsonrpc=2.0 id=1 \
     params:='{&quot;request_type&quot;: &quot;view_account&quot;, &quot;finality&quot;: &quot;final&quot;, &quot;account_id&quot;: &quot;test.near&quot;}'
λ http post http://localhost:3030/ method=query jsonrpc=2.0 id=1 \
           params:='{&quot;request_type&quot;: &quot;view_account&quot;, &quot;finality&quot;: &quot;final&quot;, &quot;account_id&quot;: &quot;test.near&quot;}'

HTTP/1.1 200 OK
access-control-allow-credentials: true
access-control-expose-headers: content-length, accept, connection, user-agent, accept-encoding, content-type, host
content-length: 294
content-type: application/json
date: Tue, 15 Nov 2022 14:04:54 GMT
vary: Origin, Access-Control-Request-Method, Access-Control-Request-Headers

{
    &quot;id&quot;: &quot;1&quot;,
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;result&quot;: {
        &quot;amount&quot;: &quot;1000000000000000000000000000000000&quot;,
        &quot;block_hash&quot;: &quot;Hn4v5CpfWf141AJi166gdDK3e3khCxgfeDJ9dSXGpAVi&quot;,
        &quot;block_height&quot;: 1611,
        &quot;code_hash&quot;: &quot;11111111111111111111111111111111&quot;,
        &quot;locked&quot;: &quot;50003138579594550524246699058859&quot;,
        &quot;storage_paid_at&quot;: 0,
        &quot;storage_usage&quot;: 182
    }
}
</code></pre>
<p>Note how we use an HTTP <code>post</code> method when we interact with the blockchain RPC.
The full set of RPC endpoints is documented at</p>
<p><a href="https://docs.near.org/api/rpc/introduction">https://docs.near.org/api/rpc/introduction</a></p>
<h2 id="sending-transactions"><a class="header" href="#sending-transactions">Sending Transactions</a></h2>
<p>Transactions are submitted via RPC as well. Submitting a transaction manually
with <code>http</code> is going to be cumbersome though — transactions are borsh encoded
to bytes, then signed, then encoded in base64 for JSON.</p>
<p>So we will use the official <a href="https://docs.near.org/tools/near-cli">NEAR CLI</a> utility.</p>
<p>Install it via <code>npm</code>:</p>
<pre><code class="language-console">$ npm install -g near-cli
$ near -h
Usage: near &lt;command&gt; [options]

Commands:
  near create-account &lt;accountId&gt;    create a new developer account
....
</code></pre>
<p>Note that, although you install <code>near-cli</code>, the name of the utility is <code>near</code>.</p>
<p>As a first step, let's redo the <code>view_account</code> call we did with raw <code>httpie</code>
with <code>near-cli</code>:</p>
<pre><code class="language-console">$ NEAR_ENV=local near state test.near
Loaded master account test.near key from ~/.near/validator_key.json with public key = ed25519:71QRP9qKcYRUYXTLNnrmRc1NZSdBaBo9nKZ88DK5USNf
Account test.near
{
  amount: '1000000000000000000000000000000000',
  block_hash: 'ESGN7H1kVLp566CTQ9zkBocooUFWNMhjKwqHg4uCh2Sg',
  block_height: 2110,
  code_hash: '11111111111111111111111111111111',
  locked: '50005124762657986708532525400812',
  storage_paid_at: 0,
  storage_usage: 182,
  formattedAmount: '1,000,000,000'
}
</code></pre>
<p><code>NEAR_ENV=local</code> tells <code>near-cli</code> to use our local network, rather than the
<code>mainnet</code>.</p>
<p>Now, let's create a couple of accounts and send tokes between them:</p>
<pre><code>$ NEAR_ENV=local near create-account alice.test.near --masterAccount test.near
NOTE: In most cases, when connected to network &quot;local&quot;, masterAccount will end in &quot;.node0&quot;
Loaded master account test.near key from /home/matklad/.near/validator_key.json with public key = ed25519:71QRP9qKcYRUYXTLNnrmRc1NZSdBaBo9nKZ88DK5USNf
Saving key to 'undefined/local/alice.test.near.json'
Account alice.test.near for network &quot;local&quot; was created.

$ NEAR_ENV=local near create-account bob.test.near --masterAccount test.near
NOTE: In most cases, when connected to network &quot;local&quot;, masterAccount will end in &quot;.node0&quot;
Loaded master account test.near key from /home/matklad/.near/validator_key.json with public key = ed25519:71QRP9qKcYRUYXTLNnrmRc1NZSdBaBo9nKZ88DK5USNf
Saving key to 'undefined/local/bob.test.near.json'
Account bob.test.near for network &quot;local&quot; was created.

$ NEAR_ENV=local near send alice.test.near bob.test.near 10
Sending 10 NEAR to bob.test.near from alice.test.near
Loaded master account test.near key from /home/matklad/.near/validator_key.json with public key = ed25519:71QRP9qKcYRUYXTLNnrmRc1NZSdBaBo9nKZ88DK5USNf
Transaction Id BBPndo6gR4X8pzoDK7UQfoUXp5J8WDxkf8Sq75tK5FFT
To see the transaction in the transaction explorer, please open this url in your browser
http://localhost:9001/transactions/BBPndo6gR4X8pzoDK7UQfoUXp5J8WDxkf8Sq75tK5FFT
</code></pre>
<p><strong>Note:</strong> You can export the variable <code>NEAR_ENV</code> in your shell if you are planning
to do multiple commands to avoid repetition:</p>
<pre><code class="language-console">$ export NEAR_ENV=local
</code></pre>
<p>NEAR CLI printouts are not always the most useful or accurate, but this seems to
work.</p>
<p>Note that <code>near</code> automatically creates keypairs and stores them at
<code>.near-credentials</code>:</p>
<pre><code class="language-console">$ ls ~/.near-credentials/local
  alice.test.near.json
  bob.test.near.json
</code></pre>
<p>To verify that this did work, and that <code>near-cli</code> didn't cheat us, let's
query the state of accounts manually:</p>
<pre><code class="language-console">$ http post http://localhost:3030/ method=query jsonrpc=2.0 id=1 \
    params:='{&quot;request_type&quot;: &quot;view_account&quot;, &quot;finality&quot;: &quot;final&quot;, &quot;account_id&quot;: &quot;alice.test.near&quot;}' \
    | jq '.result.amount'
&quot;89999955363487500000000000&quot;

14:30:52|~
λ http post http://localhost:3030/ method=query jsonrpc=2.0 id=1 \
    params:='{&quot;request_type&quot;: &quot;view_account&quot;, &quot;finality&quot;: &quot;final&quot;, &quot;account_id&quot;: &quot;bob.test.near&quot;}' \
    | jq '.result.amount'
&quot;110000000000000000000000000&quot;
</code></pre>
<p>Indeed, some amount of tokes was transferred from <code>alice</code> to <code>bob</code>, and then
some amount of tokens was deducted to account for transaction fees.</p>
<h2 id="recap"><a class="header" href="#recap">Recap</a></h2>
<p>Great! So we've learned how to run our very own single-node NEAR network using a
binary we've built from source. The steps are:</p>
<ul>
<li>Create configs with <code>cargo run --profile dev-release -p neard -- init</code></li>
<li>Run the node with <code>cargo run --profile dev-release -p neard -- run</code></li>
<li>Poke the node with <code>httpie</code> or</li>
<li>Install <code>near-cli</code> via <code>npm install -g near-cli</code></li>
<li>Submit transactions via <code>NEAR_ENV=local near create-account ...</code></li>
</ul>
<p>In the <a href="practices/workflows/./deploy_a_contract.html">next chapter</a>, we'll learn how to deploy a simple
WASM contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy-a-contract"><a class="header" href="#deploy-a-contract">Deploy a Contract</a></h1>
<p>In this chapter, we'll learn how to build, deploy, and call a minimal smart
contract on our local node.</p>
<h2 id="preparing-ground"><a class="header" href="#preparing-ground">Preparing Ground</a></h2>
<p>Let's start with creating a fresh local network with an account to which we'll
deploy a contract. You might want to re-read <a href="practices/workflows/./run_a_node.html">how to run a node</a>
to understand what's going on here:</p>
<pre><code class="language-console">$ cargo run --profile dev-release -p neard -- init
$ cargo run --profile dev-release -p neard -- run
$ NEAR_ENV=local near create-account alice.test.near --masterAccount test.near
</code></pre>
<p>As a sanity check, querying the state of <code>alice.test.near</code> account should work:</p>
<pre><code class="language-console">$ NEAR_ENV=local near state alice.test.near
Loaded master account test.near key from /home/matklad/.near/validator_key.json with public key = ed25519:7tU4NtFozPWLotcfhbT9KfBbR3TJHPfKJeCri8Me6jU7
Account alice.test.near
{
  amount: '100000000000000000000000000',
  block_hash: 'EEMiLrk4ZiRzjNJXGdhWPJfKXey667YBnSRoJZicFGy9',
  block_height: 24,
  code_hash: '11111111111111111111111111111111',
  locked: '0',
  storage_paid_at: 0,
  storage_usage: 182,
  formattedAmount: '100'
}
</code></pre>
<h2 id="minimal-contract"><a class="header" href="#minimal-contract">Minimal Contract</a></h2>
<p>NEAR contracts are <a href="https://webassembly.org">WebAssembly</a> blobs of bytes. To
create a contract, a contract developer typically uses an SDK for some
high-level programming language, such as JavaScript, which takes care of
producing the right <code>.wasm</code>.</p>
<p>In this guide, we are interested in how things work under the hood, so we'll
do everything manually, and implement a contract in Rust without any help from
SDKs.</p>
<p>As we are looking for something simple, let's create a contract with a single
&quot;method&quot;, <code>hello</code>, which returns a <code>&quot;hello world&quot;</code> string. To &quot;define a method&quot;,
a wasm module should export a function. To &quot;return a value&quot;, the contract needs
to interact with the environment to say &quot;hey, this is the value I am returning&quot;.
Such &quot;interactions&quot; are carried through host functions, which are quite a bit
like syscalls in traditional operating systems.</p>
<p>The set of host functions that the contract can import is defined in
<a href="https://github.com/near/nearcore/blob/aeccaaab334275f6d0a62deabd184675bc3c6a23/runtime/near-vm-runner/src/imports.rs#L71-L242"><code>imports.rs</code></a>.</p>
<p>In this particular case, we need the <code>value_return</code> function:</p>
<pre><code>value_return&lt;[value_len: u64, value_ptr: u64] -&gt; []&gt;
</code></pre>
<p>This means that the <code>value_return</code> function takes a pointer to a slice of bytes,
the length of the slice, and returns nothing. If the contract calls this function,
the slice would be considered a result of the function.</p>
<p>To recap, we want to produce a <code>.wasm</code> file with roughly the following content:</p>
<pre><code class="language-wasm">(module
  (import &quot;env&quot; &quot;value_return&quot; (func $value_return (param i64 i64)))
  (func (export &quot;hello&quot;) ... ))
</code></pre>
<h2 id="cargo-boilerplate"><a class="header" href="#cargo-boilerplate">Cargo Boilerplate</a></h2>
<p>Armed with this knowledge, we can write Rust code to produce the required WASM.
Before we start doing that, some amount of setup code is required.</p>
<p>Let's start with creating a new crate:</p>
<pre><code class="language-console">$ cargo new hello-near --lib
</code></pre>
<p>To compile to wasm, we also need to add a relevant rustup toolchain:</p>
<pre><code class="language-console">$ rustup toolchain add wasm32-unknown-unknown
</code></pre>
<p>Then, we need to tell Cargo that the final artifact we want to get is a
WebAssembly module.</p>
<p>This requires the following cryptic spell in Cargo.toml:</p>
<pre><code class="language-toml"># hello-near/Cargo.toml

[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>Here, we ask Cargo to build a &quot;C dynamic library&quot;. When compiling for wasm,
that'll give us a <code>.wasm</code> module. This part is a bit confusing, sorry about
that :(</p>
<p>Next, as we are aiming for minimalism here, we need to disable optional bits
of the Rust runtime. Namely, we want to make our crate <code>no_std</code> (this means
that we are not going to use the Rust standard library), set <code>panic=abort</code>
as our panic strategy and define a panic handler to abort execution.</p>
<pre><code class="language-toml"># hello-near/Cargo.toml

[package]
name = &quot;hello-near&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[profile.release]
panic = &quot;abort&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello-near/src/lib.rs

#![no_std]

#[panic_handler]
fn panic_handler(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    core::arch::wasm32::unreachable()
}
<span class="boring">}
</span></code></pre></pre>
<p>At this point, we should be able to compile our code to wasm, and it should be
fairly small. Let's do that:</p>
<pre><code class="language-console">$ cargo b -r --target wasm32-unknown-unknown
   Compiling hello-near v0.1.0 (~/hello-near)
    Finished release [optimized] target(s) in 0.24s
$ ls target/wasm32-unknown-unknown/release/hello_near.wasm
.rwxr-xr-x 106 matklad 15 Nov 15:34 target/wasm32-unknown-unknown/release/hello_near.wasm
</code></pre>
<p>106 bytes is pretty small! Let's see what's inside. For that, we'll use
the <code>wasm-tools</code> suite of CLI utilities.</p>
<pre><code class="language-console">$ cargo install wasm-tools
λ wasm-tools print target/wasm32-unknown-unknown/release/hello_near.wasm
(module
  (memory (;0;) 16)
  (global $__stack_pointer (;0;) (mut i32) i32.const 1048576)
  (global (;1;) i32 i32.const 1048576)
  (global (;2;) i32 i32.const 1048576)
  (export &quot;memory&quot; (memory 0))
  (export &quot;__data_end&quot; (global 1))
  (export &quot;__heap_base&quot; (global 2))
)
</code></pre>
<h2 id="rust-contract"><a class="header" href="#rust-contract">Rust Contract</a></h2>
<p>Finally, let's implement an actual contract. We'll need an <code>extern &quot;C&quot;</code> block to
declare the <code>value_return</code> import, and a <code>#[unsafe(no_mangle)] extern &quot;C&quot;</code> function to
declare the <code>hello</code> export:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello-near/src/lib.rs

#![no_std]

extern &quot;C&quot; {
    fn value_return(len: u64, ptr: u64);
}

#[unsafe(no_mangle)]
pub extern &quot;C&quot; fn hello() {
    let msg = &quot;hello world&quot;;
    unsafe { value_return(msg.len() as u64, msg.as_ptr() as u64) }
}

#[panic_handler]
fn panic_handler(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    core::arch::wasm32::unreachable()
}
<span class="boring">}
</span></code></pre></pre>
<p>After building the contract, the output wasm shows us that it's roughly what we
want:</p>
<pre><code class="language-console">$ cargo b -r --target wasm32-unknown-unknown
   Compiling hello-near v0.1.0 (/home/matklad/hello-near)
    Finished release [optimized] target(s) in 0.05s
$ wasm-tools print target/wasm32-unknown-unknown/release/hello_near.wasm
(module
  (type (;0;) (func (param i64 i64)))
  (type (;1;) (func))
  (import &quot;env&quot; &quot;value_return&quot;        (; &lt;- Here's our import. ;)
    (func $value_return (;0;) (type 0)))
  (func $hello (;1;) (type 1)
    i64.const 11
    i32.const 1048576
    i64.extend_i32_u
    call $value_return
  )
  (memory (;0;) 17)
  (global $__stack_pointer (;0;) (mut i32) i32.const 1048576)
  (global (;1;) i32 i32.const 1048587)
  (global (;2;) i32 i32.const 1048592)
  (export &quot;memory&quot; (memory 0))
  (export &quot;hello&quot; (func $hello))      (; &lt;- And export! ;)
  (export &quot;__data_end&quot; (global 1))
  (export &quot;__heap_base&quot; (global 2))
  (data $.rodata (;0;) (i32.const 1048576) &quot;hello world&quot;)
)
</code></pre>
<h2 id="deploying-the-contract"><a class="header" href="#deploying-the-contract">Deploying the Contract</a></h2>
<p>Now that we have the WASM, let's deploy it!</p>
<pre><code class="language-console">$ NEAR_ENV=local near deploy alice.test.near \
    ./target/wasm32-unknown-unknown/release/hello_near.wasm
Loaded master account test.near key from /home/matklad/.near/validator_key.json with public key = ed25519:ChLD1qYic3G9qKyzgFG3PifrJs49CDYeERGsG58yaSoL
Starting deployment. Account id: alice.test.near, node: http://127.0.0.1:3030, helper: http://localhost:3000, file: ./target/wasm32-unknown-unknown/release/hello_near.wasm
Transaction Id GDbTLUGeVaddhcdrQScVauYvgGXxSssEPGUSUVAhMWw8
To see the transaction in the transaction explorer, please open this url in your browser
http://localhost:9001/transactions/GDbTLUGeVaddhcdrQScVauYvgGXxSssEPGUSUVAhMWw8
Done deploying to alice.test.near
</code></pre>
<p>And, finally, let's call our contract:</p>
<pre><code class="language-console">$ NEAR_ENV=local $near call alice.test.near hello --accountId alice.test.near
Scheduling a call: alice.test.near.hello()
Loaded master account test.near key from /home/matklad/.near/validator_key.json with public key = ed25519:ChLD1qYic3G9qKyzgFG3PifrJs49CDYeERGsG58yaSoL
Doing account.functionCall()
Transaction Id 9WMwmTf6pnFMtj1KBqjJtkKvdFXS4kt3DHnYRnbFpJ9e
To see the transaction in the transaction explorer, please open this url in your browser
http://localhost:9001/transactions/9WMwmTf6pnFMtj1KBqjJtkKvdFXS4kt3DHnYRnbFpJ9e
'hello world'
</code></pre>
<p>Note that we pass <code>alice.test.near</code> twice: the first time to specify which contract
we are calling, the second time to determine who calls the contract. That is,
the second account is the one that spends tokens. In the following example <code>bob</code>
spends NEAR to call the contact deployed to the <code>alice</code> account:</p>
<pre><code class="language-console">$ NEAR_ENV=local $near call alice.test.near hello --accountId bob.test.near
Scheduling a call: alice.test.near.hello()
Loaded master account test.near key from /home/matklad/.near/validator_key.json with public key = ed25519:ChLD1qYic3G9qKyzgFG3PifrJs49CDYeERGsG58yaSoL
Doing account.functionCall()
Transaction Id 4vQKtP6zmcR4Xaebw8NLF6L5YS96gt5mCxc5BUqUcC41
To see the transaction in the transaction explorer, please open this url in your browser
http://localhost:9001/transactions/4vQKtP6zmcR4Xaebw8NLF6L5YS96gt5mCxc5BUqUcC41
'hello world'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-estimator"><a class="header" href="#running-the-estimator">Running the Estimator</a></h1>
<p>This workflow describes how to run the gas estimator byzantine-benchmark suite.
To learn about its background and purpose, refer to <a href="practices/workflows/../../architecture/gas/estimator.html">Runtime Parameter
Estimator</a> in the architecture chapter.</p>
<p>Type this in your console to quickly run estimations on a couple of action costs.</p>
<pre><code class="language-bash">cargo run -p runtime-params-estimator --features required -- \
    --accounts-num 20000 --additional-accounts-num 20000 \
    --iters 3 --warmup-iters 1 --metric time \
    --costs=ActionReceiptCreation,ActionTransfer,ActionCreateAccount,ActionFunctionCallBase
</code></pre>
<p>You should get an output like this.</p>
<pre><code>[elapsed 00:00:17 remaining 00:00:00] Writing into storage ████████████████████   20000/20000
ActionReceiptCreation         4_499_673_502_000 gas [  4.499674ms]    (computed in 7.22s)
ActionTransfer                  410_122_090_000 gas [   410.122µs]    (computed in 4.71s)
ActionCreateAccount             237_495_890_000 gas [   237.496µs]    (computed in 4.64s)
ActionFunctionCallBase          770_989_128_914 gas [   770.989µs]    (computed in 4.65s)


Finished in 40.11s, output saved to:

    /home/you/near/nearcore/costs-2022-11-11T11:11:11Z-e40863c9b.txt
</code></pre>
<p>This shows how much gas a parameter should cost to satisfy the 1ms = 1Tgas rule.
It also shows how much time that corresponds to and how long it took to compute
each of the estimations.</p>
<p>Note that the above does not produce very accurate results and it can have high
variance as well. It runs an unoptimized binary, the state is small, and the
metric used is wall-clock time which is always prone to variance in hardware and
can be affected by other processes currently running on your system.</p>
<p>Once your estimation code is ready, it is better to run it with a larger state
and an optimized binary.</p>
<pre><code class="language-bash">cargo run --release -p runtime-params-estimator --features required -- \
    --accounts-num 20000 --additional-accounts-num 2000000 \
    --iters 3 --warmup-iters 1 --metric time \
    --costs=ActionReceiptCreation,ActionTransfer,ActionCreateAccount,ActionFunctionCallBase
</code></pre>
<p>You might also want to run a hardware-agnostic estimation using the following
command. It uses <code>podman</code> and <code>qemu</code> under the hood, so it will be quite a bit
slower. You will need to install <code>podman</code> to run this command.</p>
<pre><code class="language-bash">cargo run --release -p runtime-params-estimator --features required -- \
    --accounts-num 20000 --additional-accounts-num 2000000 \
    --iters 3 --warmup-iters 1 --metric icount --containerize \
    --costs=ActionReceiptCreation,ActionTransfer,ActionCreateAccount,ActionFunctionCallBase
</code></pre>
<p>Note how the output looks a bit different now. The <code>i</code>, <code>r</code> and <code>w</code> values show
instruction count, read IO bytes, and write IO bytes respectively. The IO byte
count is known to be inaccurate.</p>
<pre><code>+ /host/nearcore/runtime/runtime-params-estimator/emu-cost/counter_plugin/qemu-x86_64 -plugin file=/host/nearcore/runtime/runtime-params-estimator/emu-cost/counter_plugin/libcounter.so -cpu Haswell-v4 /host/nearcore/target/release/runtime-params-estimator --home /.near --accounts-num 20000 --iters 3 --warmup-iters 1 --metric icount --costs=ActionReceiptCreation,ActionTransfer,ActionCreateAccount,ActionFunctionCallBase --skip-build-test-contract --additional-accounts-num 0 --in-memory-db
ActionReceiptCreation         214_581_685_500 gas [  1716653.48i 0.00r 0.00w]     (computed in 6.11s)
ActionTransfer                 21_528_212_916 gas [   172225.70i 0.00r 0.00w]     (computed in 4.71s)
ActionCreateAccount            26_608_336_250 gas [   212866.69i 0.00r 0.00w]     (computed in 4.67s)
ActionFunctionCallBase         12_193_364_898 gas [    97546.92i 0.00r 0.00w]     (computed in 2.39s)


Finished in 17.92s, output saved to:

    /host/nearcore/costs-2022-11-01T16:27:36Z-e40863c9b.txt
</code></pre>
<p>The difference between the metrics is discussed in the <a href="practices/workflows/../../architecture/gas/estimator.html#estimation-metrics">Estimation
Metrics</a> chapter.</p>
<p>You should now be all set up for running estimations on your local machine. Also,
check <code>cargo run -p runtime-params-estimator --features required -- --help</code> for
the list of available options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-near-localnet-on-2-machines"><a class="header" href="#running-near-localnet-on-2-machines">Running near localnet on 2 machines</a></h1>
<p>Quick instructions on how to run a localnet on 2 separate machines.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<ul>
<li>Machine1: &quot;pc&quot; - 192.168.0.1</li>
<li>Machine2: &quot;laptop&quot; - 192.168.0.2</li>
</ul>
<p>Run on both machines (make sure that they are using the same version of the code):</p>
<pre><code>cargo build -p neard
</code></pre>
<p>Then on machine1 run the command below, which will generate the configurations:</p>
<pre><code>./target/debug/neard --home ~/.near/localnet_multi localnet --shards 3 --v 2
</code></pre>
<p>This command has generated configuration for 3 shards and 2 validators (in directories ~/.near/localnet_multi/node0 and ~/.near/localnet_multi/node1).</p>
<p>Now - copy the contents of node1 directory to the machine2</p>
<pre><code>rsync -r ~/.near/localnet_multi/node1 192.168.0.2:~/.near/localnet_multi/node1
</code></pre>
<p>Now open the config.json file on both machines (node0/config.json on machine1 and node1/config.json on machine2) and:</p>
<ul>
<li>for rpc-&gt;addr and network-&gt;addr:
<ul>
<li>Change the address from 127.0.0.1 to 0.0.0.0 (this means that the port will be accessible from other computers)</li>
<li>Remember the port numbers (they are generated randomly). </li>
</ul>
</li>
<li>Also write down the node0's node_key (it is probably: &quot;ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX&quot;)</li>
</ul>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<p>On machine1:</p>
<pre><code>./target/debug/neard --home ~/.near/localnet_multi/node0 run
</code></pre>
<p>On machine2:</p>
<pre><code>./target/debug/neard --home ~/.near/localnet_multi/node1 run --boot-nodes ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX@192.168.0.1:37665
</code></pre>
<p>The boot node address should be the IP of the machine1 + the network addr port <strong>from the node0/config.json</strong></p>
<p>And if everything goes well, the nodes should communicate and start producing blocks.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>The debug mode is enabled by default, so you should be able to see what's going on by going to <code>http://machine1:RPC_ADDR_PORT/debug</code> </p>
<h3 id="if-node-keeps-saying-waiting-for-peers"><a class="header" href="#if-node-keeps-saying-waiting-for-peers">If node keeps saying &quot;waiting for peers&quot;</a></h3>
<p>See if you can see the machine1's debug page from machine2. (if not - there might be a firewall blocking the connection).</p>
<p>Make sure that you set the right ports (it should use node0's NETWORK port) and that you set the ip add there to 0.0.0.0</p>
<h3 id="resetting-the-state"><a class="header" href="#resetting-the-state">Resetting the state</a></h3>
<p>Simply stop both nodes, and remove the <code>data</code> subdirectory (~/.near/localnet_multi/node0/data and ~/.near/localnet_multi/node1/data).</p>
<p>Then after restart, the nodes will start the blockchain from scratch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-tracing"><a class="header" href="#io-tracing">IO tracing</a></h1>
<h2 id="when-should-i-use-io-traces"><a class="header" href="#when-should-i-use-io-traces">When should I use IO traces?</a></h2>
<p>IO traces can be used to identify slow receipts and to understand why they
are slow. Or to detect general inefficiencies in how we use the DB.</p>
<p>The results give you counts of DB requests and some useful statistics such as
trie node cache hits. It will NOT give you time measurements, use Graphana to
observe those.</p>
<p>The main use cases in the past were to estimate the performance of new storage
features (prefetcher, flat state) and to find out why specific contracts produce
slow receipts.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>When compiling neard (or the parameter estimator) with <code>feature=io_trace</code> it
instruments the binary code with fine-grained database operations tracking.</p>
<p><em>Aside: We don't enable it by default because we are afraid the overhead could be
too much, since we store some information for very hot paths such as trie node
cache hits. Although we haven't properly evaluated if it really is a performance
problem.</em></p>
<p>This allows using the <code>--record-io-trace=/path/to/output.io_trace</code> CLI flag on
neard. Run it in combination with the subcommands <code>neard run</code>, <code>neard view-state</code>, or <code>runtime-params-estimator</code> and it will record an IO trace. Make
sure to provide the flag to <code>neard</code> itself, however, not to the subcommands.
(See examples below)</p>
<pre><code class="language-bash"># Example command for normal node
# (Careful! This will quickly fill your disk if you let it run.)
cargo build --release -p neard --features=io_trace
target/release/neard \
    --record-io-trace=/mnt/disks/some_disk_with_enough_space/my.io_trace \
    run
</code></pre>
<pre><code class="language-bash"># Example command for state viewer, applying a range of chunks in shard 0
cargo build --release -p neard --features=io_trace
target/release/neard \
    --record-io-trace=75220100-75220101.s0.io_trace \
    view-state apply-range --start-index 75220100 --end-index 75220101 \
    --shard-id 0 sequential
</code></pre>
<pre><code class="language-bash"># Example command for params estimator
cargo run --release -p runtime-params-estimator --features=required,io_trace \
-- --accounts-num 200000 --additional-accounts-num 200000 \
--iters 3 --warmup-iters 1 --metric time \
--record-io-trace=tmp.io \
--costs ActionReceiptCreation
</code></pre>
<h2 id="io-trace-content"><a class="header" href="#io-trace-content">IO trace content</a></h2>
<p>Once you have collected an IO trace, you can inspect its content manually, or
use existing tools to extract statistics. Let's start with the manual approach.</p>
<h3 id="simple-example-trace-estimator"><a class="header" href="#simple-example-trace-estimator">Simple example trace: Estimator</a></h3>
<p>An estimator trace typically starts something like this:</p>
<pre><code>commit
  SET DbVersion &quot;'VERSION'&quot; size=2
commit
  SET DbVersion &quot;'KIND'&quot; size=3
apply num_transactions=0 shard_cache_miss=7
  GET State &quot;AAAAAAAAAAB3I0MYevRcExi1ql5PSQX+fuObsPH30yswS7ytGPCgyw==&quot; size=46
  GET State &quot;AAAAAAAAAACGDsmYvNoBGZnc8PzDKoF4F2Dvw3N6XoAlRrg8ezA8FA==&quot; size=107
  GET State &quot;AAAAAAAAAAB3I0MYevRcExi1ql5PSQX+fuObsPH30yswS7ytGPCgyw==&quot; size=46
  GET State &quot;AAAAAAAAAACGDsmYvNoBGZnc8PzDKoF4F2Dvw3N6XoAlRrg8ezA8FA==&quot; size=107
  GET State &quot;AAAAAAAAAAB3I0MYevRcExi1ql5PSQX+fuObsPH30yswS7ytGPCgyw==&quot; size=46
  GET State &quot;AAAAAAAAAACGDsmYvNoBGZnc8PzDKoF4F2Dvw3N6XoAlRrg8ezA8FA==&quot; size=107
  GET State &quot;AAAAAAAAAAB3I0MYevRcExi1ql5PSQX+fuObsPH30yswS7ytGPCgyw==&quot; size=46
...
</code></pre>
<p>Depending on the source, traces look a bit different at the start. But you
should always see some setup at the beginning and per-chunk workload later on.</p>
<p>Indentation is used to display the call hierarchy. The <code>commit</code> keyword shows
when a commit starts, and all <code>SET</code> and <code>UPDATE_RC</code> commands that follow with
one level deeper indentation belong to that same database transaction commit.</p>
<p>Later, you see a group that starts with an <code>apply</code> header. It groups all IO
requests that were performed for a call to <a href="https://github.com/near/nearcore/blob/d38c94ac8e78a5a71c592125dfd47803beff58ce/runtime/runtime/src/lib.rs#L1172"><code>fn apply</code></a>
that applies transactions and receipts of a chunk to the previous state root.</p>
<p>In the example, you see a list of <code>GET</code> requests that belong to that <code>apply</code>,
each with the DB key used and the size of the value read. Further, you can read
in the trace that this specific chunk had 0 transactions and that it
cache-missed all 7 of the DB requests it performed to apply this empty chunk.</p>
<h3 id="example-trace-full-mainnet-node"><a class="header" href="#example-trace-full-mainnet-node">Example trace: Full mainnet node</a></h3>
<p>Next let's look at an excerpt of an IO trace from a real node on mainnet.</p>
<pre><code>...
GET State &quot;AQAAAAMAAACm9DRx/dU8UFEfbumiRhDjbPjcyhE6CB1rv+8fnu81bw==&quot; size=9
GET State &quot;AQAAAAAAAACLFgzRCUR3inMDpkApdLxFTSxRvprJ51eMvh3WbJWe0A==&quot; size=203
GET State &quot;AQAAAAIAAACXlEo0t345S6PHsvX1BLaGw6NFDXYzeE+tlY2srjKv8w==&quot; size=299
apply_transactions shard_id=3
  process_state_update 
    apply num_transactions=3 shard_cache_hit=207
      process_transaction tx_hash=C4itKVLP5gBoAPsEXyEbi67Gg5dvQVugdMjrWBBLprzB shard_cache_hit=57
        GET FlatState &quot;AGxlb25hcmRvX2RheS12aW5jaGlrLm5lYXI=&quot; size=36
        GET FlatState &quot;Amxlb25hcmRvX2RheS12aW5jaGlrLm5lYXICANLByB1merOzxcGB1HI9/L60QvONzOE6ovF3hjYUbhA8&quot; size=36
      process_transaction tx_hash=GRSXC4QCBJHN4hmJiATAbFGt9g5PiksQDNNRaSk666WX shard_cache_miss=3 prefetch_pending=3 shard_cache_hit=35
        GET FlatState &quot;AnJlbGF5LmF1cm9yYQIA5iq407bcLgisCKxQQi47TByaFNe9FOgQg5y2gpU4lEM=&quot; size=36
      process_transaction tx_hash=6bDPeat12pGqA3KEyyg4tJ35kBtRCuFQ7HtCpWoxr8qx shard_cache_miss=2 prefetch_pending=1 shard_cache_hit=21 prefetch_hit=1
        GET FlatState &quot;AnJlbGF5LmF1cm9yYQIAyKT1vEHVesMEvbp2ICA33x6zxfmBJiLzHey0ZxauO1k=&quot; size=36
      process_receipt receipt_id=GRB3skohuShBvdGAoEoR3SdJJw7MwCxxscJHKLdPoYUC predecessor=1663adeba849fb7c26195678e1c5378278e5caa6325d4672246821d8e61bb160 receiver=token.sweat id=GRB3skohuShBvdGAoEoR3SdJJw7MwCxxscJHKLdPoYUC shard_cache_too_large=1 shard_cache_miss=1 shard_cache_hit=38
        GET FlatState &quot;AXRva2VuLnN3ZWF0&quot; size=36
        GET State &quot;AQAAAAMAAADVYp4vtlIbDoVhji22CZOEaxVWVTJKASq3iMvpNEQVDQ==&quot; size=206835
        input 
        register_len 
        read_register 
        storage_read READ key='STATE' size=70 tn_db_reads=20 tn_mem_reads=0 shard_cache_hit=21
        register_len 
        read_register 
        attached_deposit 
        predecessor_account_id 
        register_len 
        read_register 
        sha256 
        read_register 
        storage_read READ key=dAAxagYMOEb01+56sl9vOM0yHbZRPSaYSL3zBXIfCOi7ow== size=16 tn_db_reads=10 tn_mem_reads=19 shard_cache_hit=11
          GET FlatState &quot;CXRva2VuLnN3ZWF0LHQAMWoGDDhG9NfuerJfbzjNMh22UT0mmEi98wVyHwjou6M=&quot; size=36
        register_len 
        read_register 
        sha256 
        read_register 
        storage_write WRITE key=dAAxagYMOEb01+56sl9vOM0yHbZRPSaYSL3zBXIfCOi7ow== size=16 tn_db_reads=0 tn_mem_reads=30
        ...
</code></pre>
<p>Maybe that's a bit much. Let's break it down into pieces.</p>
<p>It start with a few DB get requests that are outside of applying a chunk. It's
quite common that we have these kinds of constant overhead requests that are
independent of what's inside a chunk. If we see too many such requests, we
should take a close look to see if we are wasting performance.</p>
<pre><code>GET State &quot;AQAAAAMAAACm9DRx/dU8UFEfbumiRhDjbPjcyhE6CB1rv+8fnu81bw==&quot; size=9
GET State &quot;AQAAAAAAAACLFgzRCUR3inMDpkApdLxFTSxRvprJ51eMvh3WbJWe0A==&quot; size=203
GET State &quot;AQAAAAIAAACXlEo0t345S6PHsvX1BLaGw6NFDXYzeE+tlY2srjKv8w==&quot; size=299
</code></pre>
<p>Next let's look at <code>apply_transactions</code> but limit the depth of items to 3
levels.</p>
<pre><code>apply_transactions shard_id=3
  process_state_update 
    apply num_transactions=3 shard_cache_hit=207
      process_transaction tx_hash=C4itKVLP5gBoAPsEXyEbi67Gg5dvQVugdMjrWBBLprzB shard_cache_hit=57
      process_transaction tx_hash=GRSXC4QCBJHN4hmJiATAbFGt9g5PiksQDNNRaSk666WX shard_cache_miss=3 prefetch_pending=3 shard_cache_hit=35
      process_transaction tx_hash=6bDPeat12pGqA3KEyyg4tJ35kBtRCuFQ7HtCpWoxr8qx shard_cache_miss=2 prefetch_pending=1 shard_cache_hit=21 prefetch_hit=1
      process_receipt receipt_id=GRB3skohuShBvdGAoEoR3SdJJw7MwCxxscJHKLdPoYUC predecessor=1663adeba849fb7c26195678e1c5378278e5caa6325d4672246821d8e61bb160 receiver=token.sweat id=GRB3skohuShBvdGAoEoR3SdJJw7MwCxxscJHKLdPoYUC shard_cache_too_large=1 shard_cache_miss=1 shard_cache_hit=38
</code></pre>
<p>Here you can see that before we even get to <code>apply</code>, we go through
<code>apply_transactions</code> and <code>process_state_update</code>. The excerpt does not show it
but there are DB requests listed further below that belong to these levels but
not to <code>apply</code>.</p>
<p>Inside <code>apply</code>, we see 3 transactions being converted to receipts as part of
this chunk, and one already existing action receipt getting processed. </p>
<p>Cache hit statistics for each level are also displayed. For example, the first
transaction has 57 read requests and all of them hit in the shard cache. For
the second transaction, we miss the cache 3 times but the values were already in the
process of being prefetched. This would be account data which we fetch in
parallel for all transactions in the chunk.</p>
<p>Finally, there are several <code>process_receipt</code> groups, although the excerpt was
cut to display only one. Here we see the receiving account
(<code>receiver=token.sweat</code>) and the receipt ID to potentially look it up on an
explorer, or dig deeper using state viewer commands.</p>
<p>Again, cache hit statistics are included. Here you can see one value
missed the cache because it was too large. Usually that's a contract code. We do
not include it in the shard cache because it would take up too much space.</p>
<p>Zooming in a bit further, let's look at the DB request at the start of the
receipt.</p>
<pre><code>    GET FlatState &quot;AXRva2VuLnN3ZWF0&quot; size=36
    GET State &quot;AQAAAAMAAADVYp4vtlIbDoVhji22CZOEaxVWVTJKASq3iMvpNEQVDQ==&quot; size=206835
    input 
    register_len 
    read_register 
    storage_read READ key='STATE' size=70 tn_db_reads=20 tn_mem_reads=0 shard_cache_hit=21
    register_len 
    read_register 
</code></pre>
<p><code>FlatState &quot;AXRva2VuLnN3ZWF0&quot;</code> reads the <code>ValueRef</code> of the contract code, which
is 36 bytes in its serialized format. Then, the <code>ValueRef</code> is dereferenced to
read the actual code, which happens to be 206kB in size. This happens in the
<code>State</code> column because at the time of writing, we still read the actual values
from the trie, not from flat state.</p>
<p>What follows are host function calls performed by the SDK. It uses <code>input</code> to
check the function call arguments and copies it from a register into WASM
memory.</p>
<p>Then the SDK reads the serialized contract state from the hardcoded key
<code>&quot;STATE&quot;</code>. Note that we charge 20 <code>tn_db_reads</code> for it, since we missed the
accounting cache, but we hit everything in the shard cache. Thus, there are no DB
requests. If there were DB requests for this <code>tn_db_reads</code>, you would see them
listed.</p>
<p>The returned 70 bytes are again copied into WASM memory. Knowing the SDK code a
little bit, we can guess that the data is then deserialized into the struct used
by the contract for its root state. That's not visible on the trace though, as
this happens completely inside the WASM VM.</p>
<p>Next we start executing the actual contract code, which again calls a bunch of
host functions. Apparently the code starts by reading the attached deposit and
the predecessor account id, presumably to perform some checks.</p>
<p>The <code>sha256</code> call here is used to shorten implicit account ids.
(<a href="https://github.com/sweatco/near-sdk-rs/blob/af6ba3cb75e0bbfc26e346e61aa3a0d1d7f5ac7b/near-contract-standards/src/fungible_token/core_impl.rs#L249-L259">Link to code for comparison</a>).</p>
<p>Afterwards, a value with 16 bytes (a <code>u128</code>) is fetched from the trie state.
To serve this, it required reading 30 trie nodes, 19 of them were cached in the
accounting cache and were not charged the full gas cost. And the remaining 11
missed the accounting cache but they hit the shard cache. Nothing needed to be
fetched from DB because the Sweatcoin specific prefetcher has already loaded
everything into the shard cache.</p>
<p><em>Note: We see trie node requests despite flat state being used. This is because
the trace was collected with a binary that performed a read on both the trie and
flat state to do some correctness checks.</em></p>
<pre><code>    attached_deposit 
    predecessor_account_id 
    register_len 
    read_register 
    sha256 
    read_register 
    storage_read READ key=dAAxagYMOEb01+56sl9vOM0yHbZRPSaYSL3zBXIfCOi7ow== size=16 tn_db_reads=10 tn_mem_reads=19 shard_cache_hit=11
        GET FlatState &quot;CXRva2VuLnN3ZWF0LHQAMWoGDDhG9NfuerJfbzjNMh22UT0mmEi98wVyHwjou6M=&quot; size=36
</code></pre>
<p>So that is how to read these traces and dig deep. But maybe you
want aggregated statistics instead? Then please continue reading.</p>
<h2 id="evaluating-an-io-trace"><a class="header" href="#evaluating-an-io-trace">Evaluating an IO trace</a></h2>
<p>When you collect an IO trace over an hour of mainnet traffic, it can quickly be
above 1GB in uncompressed size. You might be able to sample a few receipts and
eyeball them to get a feeling for what's going on. But you can't understand the
whole trace without additional tooling.</p>
<p>The parameter estimator command <code>replay</code> can help with that. (See also <a href="https://github.com/near/nearcore/tree/master/runtime/runtime-params-estimator/README.md">this
readme</a>)
Run the following command to see an overview of available commands.</p>
<pre><code class="language-bash"># will print the help page for the IO trace replay command
cargo run --profile dev-release -p runtime-params-estimator -- \
  replay --help
</code></pre>
<p>All commands aggregate the information of a trace. Either globally, per chunk,
or per receipt. For example, below is the output that gives a list of RocksDB
columns that were accessed and how many times, aggregated by chunk.</p>
<pre><code class="language-bash">cargo run --profile dev-release -p runtime-params-estimator -- \
  replay  ./path/to/my.io_trace  chunk-db-stats
</code></pre>
<pre><code>apply_transactions shard_id=3 block=DajBgxTgV8NewTJBsR5sTgPhVZqaEv9xGAKVnCiMiDxV
  GET   12 FlatState  4 State  

apply_transactions shard_id=0 block=DajBgxTgV8NewTJBsR5sTgPhVZqaEv9xGAKVnCiMiDxV
  GET   14 FlatState  8 State  

apply_transactions shard_id=2 block=HTptJFZKGfmeWs7y229df6WjMQ3FGfhiqsmXnbL2tpz8
  GET   2 FlatState  

apply_transactions shard_id=3 block=HTptJFZKGfmeWs7y229df6WjMQ3FGfhiqsmXnbL2tpz8
  GET   6 FlatState  2 State  

apply_transactions shard_id=1 block=HTptJFZKGfmeWs7y229df6WjMQ3FGfhiqsmXnbL2tpz8
  GET   50 FlatState  5 State  

...

apply_transactions shard_id=3 block=AUcauGxisMqNmZu5Ln7LLu8Li31H1sYD7wgd7AP6nQZR
  GET   17 FlatState  3 State  

top-level:
  GET   8854 Block  981 BlockHeader  16556 BlockHeight  59155 BlockInfo  2 BlockMerkleTree  330009 BlockMisc  1 BlockOrdinal  31924 BlockPerHeight  863 BlockRefCount  1609 BlocksToCatchup  1557 ChallengedBlocks  4 ChunkExtra  5135 ChunkHashesByHeight  128788 Chunks  35 EpochInfo  1 EpochStart  98361 FlatState  1150 HeaderHashesByHeight  8113 InvalidChunks  263 NextBlockHashes  22 OutgoingReceipts  131114 PartialChunks  1116 ProcessedBlockHeights  968698 State  
  SET   865 BlockHeight  1026 BlockMerkleTree  12428 BlockMisc  1636 BlockOrdinal  865 BlockPerHeight  865 BlockRefCount  3460 ChunkExtra  3446 ChunkHashesByHeight  339142 FlatState  3460 FlatStateDeltas  3460 FlatStateMisc  865 HeaderHashesByHeight  3460 IncomingReceipts  865 NextBlockHashes  3442 OutcomeIds  3442 OutgoingReceipts  863 ProcessedBlockHeights  340093 StateChanges  3460 TrieChanges  
</code></pre>
<p>The output contains one <code>apply_transactions</code> for each chunk, with the block hash
and the shard id. Then it prints one line for each DB operations observed
(GET,SET,...) together with a list of columns and an OP count.</p>
<p>See the <code>top-level</code> output at the end? These are all the DB requests that could
not be assigned to specific chunks. The way we currently count write operations
(SET, UPDATE_RC) they are never assigned to a specific chunk and instead only
show up in the top-level list. Clearly, there is some room for improvement here.
So far we simply haven't worried about RocksDB write performance so the tooling
to debug write performance is naturally lacking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiling-neard"><a class="header" href="#profiling-neard">Profiling neard</a></h1>
<h2 id="sampling-performance-profiling"><a class="header" href="#sampling-performance-profiling">Sampling performance profiling</a></h2>
<p>It is a common task to need to look where <code>neard</code> is spending time. Outside of instrumentation
we've also been successfully using sampling profilers to gain an intuition over how the code works
and where it spends time. It is a very quick way to get some baseline understanding of the
performance characteristics, but due to its probabilistic nature it is also not particularly precise
when it comes to small details.</p>
<p>Linux's <code>perf</code> has been a tool of choice in most cases, although tools like Intel VTune could be
used too. In order to use either, first prepare your system:</p>
<pre><code class="language-command">$ sudo sysctl kernel.perf_event_paranoid=0
$ sudo sysctl kernel.kptr_restrict=0
</code></pre>
<blockquote style="background: rgba(255, 200, 0, 0.1); border: 5px solid rgba(255, 200, 0, 0.4);">
<p>Beware that this gives access to certain kernel state and environment to the unprivileged user.
Once investigation is over either set these properties back to the more restricted settings or,
better yet, reboot.</p>
<p>Definitely do not run untrusted code after running these commands.</p>
</blockquote>
<p>Then collect a profile as such:</p>
<pre><code class="language-command">$ perf record -e cpu-clock -F1000 -g --call-graph dwarf,65528 YOUR_COMMAND_HERE
# or attach to a running process:
$ perf record -e cpu-clock -F1000 -g --call-graph dwarf,65528 -p NEARD_PID
</code></pre>
<p>This command will use the CPU time clock to determine when to trigger a sampling process and will
do such sampling roughly 1000 times (the <code>-F</code> argument) every CPU second.</p>
<p>Once terminated, this command will produce a profile file in the current working directory.
Although you can inspect the profile already with <code>perf report</code>, we've had much better experience
with using <a href="https://profiler.firefox.com/">Firefox Profiler</a> as the viewer. Although Firefox
Profiler supports <code>perf</code> and many other different data formats, for <code>perf</code> in particular a
conversion step is necessary:</p>
<pre><code class="language-command">$ perf script -F +pid &gt; mylittleprofile.script
</code></pre>
<p>Then, load this <code>mylittleprofile.script</code> file with the profiler.</p>
<h3 id="low-overhead-stack-frame-collection"><a class="header" href="#low-overhead-stack-frame-collection">Low overhead stack frame collection</a></h3>
<p>The command above uses <code>-g --call-graph dwarf,65528</code> parameter to instruct <code>perf</code> to collect
stack trace for each sample using DWARF unwinding metadata. This will work no matter how <code>neard</code> is
built, but is expensive and not super precise (e.g. it has trouble with JIT code.) If you have an
ability to build a profiling-tuned build of <code>neard</code>, you can use higher quality stack frame
collection.</p>
<pre><code class="language-command">$ cargo build --release --config .cargo/config.profiling.toml -p neard
</code></pre>
<p>Then, replace the <code>--call-graph dwarf</code> with <code>--call-graph fp</code>:</p>
<pre><code class="language-command">$ perf record -e cpu-clock -F1000 -g --call-graph fp,65528 YOUR_COMMAND_HERE
</code></pre>
<h3 id="profiling-with-hardware-counters"><a class="header" href="#profiling-with-hardware-counters">Profiling with hardware counters</a></h3>
<p>As mentioned earlier, sampling profiler is probabilistic and the data it produces is only really
suitable for a broad overview. Any attempt to analyze the performance of the code at the
microarchitectural level (which you might want to do if investigating how to speed up a small but
frequently invoked function) will be severely hampered by the low quality of data.</p>
<p>For a long time now, CPUs are able to expose information about how it operates on the code at a
very fine grained level: how many cycles have passed, how many instructions have been processed,
how many branches have been taken, how many predictions were incorrect, how many cycles were spent
waiting of a memory accesses and many more. These allow a much better look at how the code behaves.</p>
<p>Until recently, use of these detailed counters was still sampling based -- the CPU would produce
some information at a certain cadence of these counters (e.g. every 1000 instructions or cycles)
which still shares a fair number of the same downsides as sampling <code>cpu-clock</code>. In order to address
this downside, recent CPUs from both Intel and AMD have implemented a list of recent branches taken
-- <a href="https://lwn.net/Articles/680985/">Last Branch Record</a> or LBR. This is available on reasonably
recent Intel architectures as well as starting with Zen 4 on the side of AMD. With LBRs profilers
are able to gather information about the cycle counts between each branch, giving an accurate and
precise evaluation of the performance at a <a href="https://en.wikipedia.org/wiki/Basic_block">basic block</a>
or function call level.</p>
<p>It all sounds really nice, so why are we not using these mechanisms all the time? That's because
GCP VMs don't allow access to these counters! In order to access them the code has to be run on
your own hardware, or a VM instance that provides direct access to the hardware, such as the (quite
expensive) <code>c3-highcpu-192-metal</code> type.</p>
<p>Once everything is set up, though, the following command can gather some interesting information
for you.</p>
<pre><code class="language-command">$ perf record -e cycles:u -b -g --call-graph fp,65528 YOUR_COMMAND_HERE
</code></pre>
<p>Analyzing this data is, unfortunately, not as easy as chucking it away to Firefox Profiler. I'm not
aware of any other ways to inspect the data other than using <code>perf report</code>:</p>
<pre><code class="language-command">$ perf report -g --branch-history
$ perf report -g --branch-stack
</code></pre>
<p>You may also be able to gather some interesting results if you use <code>--call-graph lbr</code> and the
relevant reporting options as well.</p>
<h2 id="memory-usage-profiling"><a class="header" href="#memory-usage-profiling">Memory usage profiling</a></h2>
<p><code>neard</code> is a pretty memory-intensive application with many allocations occurring constantly.
Although Rust makes it pretty hard to introduce memory problems, it is still possible to leak
memory or to inadvertently retain too much of it.</p>
<p>Unfortunately, “just” throwing a random profiler at neard does not work for many reasons. Valgrind
for example is introducing enough slowdown to significantly alter the behaviour of the run, not to
mention that to run it successfully and without crashing it will be necessary to comment out
<code>neard</code>’s use of <code>jemalloc</code> for yet another substantial slowdown.</p>
<p>So far the only tool that worked out well out of the box was
<a href="https://github.com/koute/bytehound"><code>bytehound</code></a>. Using it is quite straightforward, but needs
Linux, and ability to execute privileged commands.</p>
<p>First, checkout and build the profiler (you will need to have nodejs <code>yarn</code> thing available as
well):</p>
<pre><code class="language-command">$ git clone git@github.com:koute/bytehound.git
$ cargo build --release -p bytehound-preload
$ cargo build --release -p bytehound-cli
</code></pre>
<p>You will also need a build of your <code>neard</code>, once you have that, give it some ambient capabilities
necessary for profiling:</p>
<pre><code class="language-command">$ sudo sysctl kernel.perf_event_paranoid=0
$ sudo setcap 'CAP_SYS_ADMIN+ep' /path/to/neard
$ sudo setcap 'CAP_SYS_ADMIN+ep' /path/to/libbytehound.so
</code></pre>
<p>And finally run the program with the profiler enabled (in this case <code>neard run</code> command is used):</p>
<pre><code class="language-command">$ /lib64/ld-linux-x86-64.so.2 --preload /path/to/libbytehound.so /path/to/neard run
</code></pre>
<h3 id="viewing-the-profile"><a class="header" href="#viewing-the-profile">Viewing the profile</a></h3>
<blockquote style="background: rgba(255, 200, 0, 0.1); border: 5px solid rgba(255, 200, 0, 0.4);">
<p>Do note that you will need about twice the amount of RAM as the size of the input file in order to
load it successfully.</p>
</blockquote>
<p>Once enough profiling data has been gathered, terminate the program. Use the <code>bytehound</code> CLI tool
to operate on the profile. I recommend <code>bytehound server</code> over directly converting to e.g. heaptrack
format using other subcommands as each invocation will read and parse the profile data from
scratch. This process can take quite some time. <code>server</code> parses the inputs once and makes
conversions and other introspection available as interactive steps.</p>
<p>You can use <code>server</code> interface to inspect the profile in one of the few ways, download a flamegraph
or a heaptrack file. Heaptrack in particular provides some interesting additional visualizations
and has an ability to show memory use over time from different allocation sources.</p>
<p>I personally found it a bit troublesome to figure out how to open the heaptrack file from the GUI.
However, <code>heaptrack myexportedfile</code> worked perfectly. I recommend opening the file exactly this way.</p>
<h3 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h3>
<h4 id="no-output-file"><a class="header" href="#no-output-file">No output file</a></h4>
<ol>
<li>Set a higher profiler logging level. Verify that the profiler gets loaded at all. If you're not
seeing any log messages, then something about your working environment is preventing the loader
from including the profiler library.</li>
<li>Try specifying an exact output file with e.g. environment variables that the profiler reads.</li>
</ol>
<h4 id="crashes"><a class="header" href="#crashes">Crashes</a></h4>
<p>If the profiled <code>neard</code> crashes in your tests, there are a couple of things you can try to get past
it. First, make sure your binary has the necessary ambient capabilities (<code>setcap</code> command above
needs to be executed every time binary is replaced!)</p>
<p>Another thing to try is disabling <code>jemalloc</code>. Comment out this code in <code>neard/src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[global_allocator]
static ALLOC: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;
<span class="boring">}
</span></code></pre></pre>
<p>The other thing you can try is different profilers, different versions of the profilers or
different options made available (in particular disabling the shadow stack in bytehound), although
I don't have specific recommendations here.</p>
<p>We don't know what exactly it is about neard that leads to it crashing under the profiler as easily
as it does. I have seen valgrind reporting that we have libraries that are deallocating with a
wrong size class, so that might be the reason? Do definitely look into this if you have time.</p>
<h2 id="what-to-profile"><a class="header" href="#what-to-profile">What to profile?</a></h2>
<p>This section provides some ideas on programs you could consider profiling if you are not sure where
to start.</p>
<p>First and foremost you could go shotgun and profile a full running <code>neard</code> node that's operating on
mainnet or testnet traffic. There are a couple ways to set up such a node: search for
<a href="https://docs.nearone.org/doc/my-own-mainnettestnet-MZTRLQjXCz">my-own-mainnet</a> or a forknet based
tooling.</p>
<p>From there either attach to a running <code>neard run</code> process or stop the running one and start a new
instance under the profiler.</p>
<p>This approach will give you a good overview of the entire system, but at the same time the
information might be so dense, it might be difficult to derive any signal from the noise. There are
alternatives that isolate certain components of the runtime:</p>
<h3 id="runtimeapply"><a class="header" href="#runtimeapply"><code>Runtime::apply</code></a></h3>
<p>Profiling just the <code>Runtime::apply</code> is going to include the work done by transaction runtime and
the contract runtime only. A smart use of the tools already present in the <code>neard</code> binary can
achieve that today.</p>
<p>First, make sure all deltas in flat storage are applied and written:</p>
<pre><code>neard view-state --readwrite apply-range --shard-id $SHARD_ID --storage flat sequential
</code></pre>
<p>You will need to do this for all shards you're interested in profiling. Then pick a block or a
range of blocks you want to re-apply and set the flat head to the specified height:</p>
<pre><code>neard flat-storage move-flat-head --shard-id 0 --version 0 back --blocks 17
</code></pre>
<p>Finally the following commands will apply the block or blocks from the height in various different
ways. Experiment with the different modes and flags to find the best fit for your task. Don't
forget to run these commands under the profiler :)</p>
<pre><code># Apply blocks from current flat head to the highest known block height in sequence
# using the memtrie storage (note that after this you will need to move the flat head again)
neard view-state --readwrite apply-range --shard-id 0 --storage memtrie sequential
# Same but with flat storage
neard view-state --readwrite apply-range --shard-id 0 --storage flat sequential

# Repeatedly apply a single block at the flat head using the memtrie storage.
# Will not modify the storage on the disk.
neard view-state apply-range --shard-id 0 --storage memtrie benchmark
# Same but with flat storage
neard view-state apply-range --shard-id 0 --storage flat benchmark
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-opentelemetry-traces"><a class="header" href="#working-with-opentelemetry-traces">Working with OpenTelemetry Traces</a></h1>
<p><code>neard</code> is instrumented in a few different ways. From the code perspective we have two major ways
of instrumenting code:</p>
<ul>
<li>Prometheus metrics – by computing various metrics in code and exposing them via the <code>prometheus</code>
crate.</li>
<li>Execution tracing – this shows up in the code as invocations of functionality provided by the
<code>tracing</code> crate.</li>
</ul>
<p>The focus of this document is to provide information on how to effectively work with the data
collected by the execution tracing approach to instrumentation.</p>
<h2 id="gathering-and-viewing-the-traces"><a class="header" href="#gathering-and-viewing-the-traces">Gathering and Viewing the Traces</a></h2>
<p>Tracing the execution of the code produces two distinct types of data: spans and events. These then
are exposed as either logs (representing mostly the events) seen in the standard output of the
<code>neard</code> process or sent onwards to an <a href="https://opentelemetry.io/docs/collector/">opentelemetry collector</a>.</p>
<p>When deciding how to instrument a specific part of the code, consider the following decision tree:</p>
<ol>
<li>Do I need execution timing information? If so, use a span; otherwise</li>
<li>Do I need call stack information? If so, use a span; otherwise</li>
<li>Do I need to preserve information about inputs or outputs to a specific section of the code? If
so, use key-values on a pre-existing span or an event; otherwise</li>
<li>Use an event if it represents information applicable to a single point of execution trace.</li>
</ol>
<p>As of writing (February 2024) our codebase uses spans somewhat sparsely and relies on events
heavily to expose information about the execution of the code. This is largely a historical
accident due to the fact that for a long time stdout logs were the only reasonable way to extract
information out of the running executable.</p>
<p>Today we have more tools available to us. In production environments and environments replicating
said environment (i.e. GCP environments such as mocknet) there's the ability to push this data to
Grafana Loki (for events) and <a href="https://grafana.com/oss/tempo/">Tempo</a> (for spans and events alike), so long as the amount of data
is within reason. For that reason it is critical that the event and span levels are chosen
appropriately and in consideration with the frequency of invocations. In local environments
developers can use projects like <a href="https://www.jaegertracing.io/">Jaeger</a>, or set up the Grafana stack if they wish to use a
consistent interfaces.</p>
<p>It is still more straightforward to skip all the setup necessary for tracing, but relying
exclusively on logs only increases noise for the other developers and makes it ever so slightly
harder to extract signal in the future. Keep this trade off in mind.</p>
<h3 id="spans"><a class="header" href="#spans">Spans</a></h3>
<p>We have a <a href="practices/workflows/../style.html#spans">style guide section on the use of Spans</a>, please make yourself
familiar with it.</p>
<p>Every <code>tracing::debug_span!()</code> creates a new span, and usually it is attached to its parent
automatically.</p>
<p>However, a few corner cases exist.</p>
<ul>
<li>
<p><code>do_apply_chunks()</code> starts 4 sub-tasks in parallel and waits for their completion. To make it
work, the parent span is passed explicitly to the sub-tasks.</p>
</li>
<li>
<p>Messages to actix workers. If you do nothing, that the traces are limited to work done in a
single actor. But that is very restrictive and not useful enough. To workaround that, each actix
message gets attached <code>opentelemetry::Context</code>. That context somehow represents the information
about the parent span. This mechanism is the reason you see annoying <code>.with_span_context()</code>
function calls whenever you send a message to an actix Actor.</p>
</li>
<li>
<p>Inter-process tracing is theoretically available, but I have never tested it. The plan was to
test it as soon as the Canary images get updated 😭 Therefore it most likely doesn’t work. Each
<code>PeerMessage</code> is injected with <code>TraceContext</code> (1, 2) and the receiving node extracts that context
and all spans generated in handling that message should be parented to the trace from another node.</p>
</li>
<li>
<p>Some spans are created using <code>info_span!()</code> but they are few and mostly for the logs. Exporting
only info-level spans doesn’t give any useful tracing information in Grafana.</p>
</li>
<li>
<p><code>actix::Actor::handle()</code> deserves a special note. The design choice was to provide a macro that
lets us easily annotate every implementation of <code>actix::Actor::handle()</code>. This macro sets the
following span attributes:</p>
<ul>
<li><code>actor</code> to the name of the struct that implements actix::Actor</li>
<li><code>handler</code> to the name of the message struct</li>
</ul>
<p>And it lets you provide more span attributes. In the example, ClientActor specifies <code>msg_type</code>,
which in all cases is identical to <code>handler</code>.</p>
</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p><a href="https://nearone.getoutline.com/doc/tracing-in-grafana-RgJUJZF2C0">The Tracing documentation page in nearone's
Outline</a> documents the steps
necessary to start moving the trace data from the node to Nearone's Grafana Cloud instance. Once
you set up your nodes, you can use the explore page to verify that the traces are coming through.</p>
<p><img src="practices/workflows/../../images/explore-traces.png" alt="Image displaying the Grafana explore page interacting with the grafana-nearinc-traces data source, with Service Name filter set to =~&quot;neard:mocknet-mainnet-94194484-nagisa-10402-test-vzx2.near|neard:mocknet-mainnet-94194484-nagisa-10402-test-xdwp.near&quot; and showing some traces having been found" /></p>
<p>If the traces are not coming through quite yet, consider using the ability to set logging
configuration at runtime. Create <code>$NEARD_HOME/log_config.json</code> file with the following contents:</p>
<pre><code class="language-json">{ &quot;opentelemetry&quot;: &quot;info&quot; }
</code></pre>
<p>Or optionally with <code>rust_log</code> setting to reduce logging on stdout:</p>
<pre><code class="language-json">{ &quot;opentelemetry&quot;: &quot;info&quot;, &quot;rust_log&quot;: &quot;WARN&quot; }
</code></pre>
<p>and invoke <code>sudo pkill -HUP neard</code>. Double check that the collector is running as well.</p>
<blockquote style="background: rgba(255, 200, 0, 0.1); border: 5px solid rgba(255, 200, 0, 0.4);">
<p><strong>Good to know</strong>: You can modify the event/span/log targets you’re interested in just like when
setting the <code>RUST_LOG</code> environment variable, including target filters. If you're setting verbose
levels, consider selecting specific targets you're interested in too. This will help to keep trace
ingest costs down.</p>
<p>For more information about the dynamic settings refer to <code>core/dyn-configs</code> code in the repository.</p>
</blockquote>
<h3 id="local-development"><a class="header" href="#local-development">Local development</a></h3>
<blockquote style="background: rgba(255, 200, 0, 0.1); border: 5px solid rgba(255, 200, 0, 0.4);">
<p><strong>TODO</strong>: the setup is going to depend on whether one would like to use grafana stack or just
jaeger or something else. We should document setting either of these up, including the otel
collector and such for a full end-to-end setup. Success criteria: running integration tests should
allow you to see the traces in your grafana/jaeger. This may require code changes as well.</p>
</blockquote>
<p>Using the Grafana Stack here gives the benefit of all of the visualizations that are built-in. Any
dashboards you build are also portable between the local environment and the Grafana Cloud
instance. Jaeger may give a nicer interactive exploration ability. You can also set up both if you
wish.</p>
<h2 id="visualization"><a class="header" href="#visualization">Visualization</a></h2>
<p>Now that the data is arriving into the databases, it is time to visualize the data to determine
what you want to know about the node. The only general advise I have here is to check that the data
source is indeed tempo or loki.</p>
<h3 id="explore"><a class="header" href="#explore">Explore</a></h3>
<p>Initial exploration is best done with Grafana's Explore tool or some other mechanism to query and
display individual traces.</p>
<p>The query builder available in Grafana makes the process quite straightforward to start with, but
is also somewhat limited. Underlying <a href="https://grafana.com/docs/tempo/latest/traceql/">TraceQL has many more
features</a> that are not available through the
builder. For example, you can query data in somewhat of a relational manner, such as this query
below queries only spans named <code>process_receipt</code> that take 50ms when run as part of <code>new_chunk</code>
processing for shard 3!</p>
<pre><code>{ name=&quot;new_chunk&quot; &amp;&amp; span.shard_id = &quot;3&quot; } &gt;&gt; { name=&quot;process_receipt&quot; &amp;&amp; duration &gt; 50ms }
</code></pre>
<blockquote style="background: rgba(255, 200, 0, 0.1); border: 5px solid rgba(255, 200, 0, 0.4);">
<p><strong>Good to know</strong>: When querying, keep in mind the &quot;Options&quot; dropdown that allows you to specify the
limit of results and the format in which these results are presented! In particular, the
&quot;Traces/Spans&quot; toggle will affect the durations shown in the result table.</p>
</blockquote>
<p>Once you click on a span of interest, Grafana will open you a view with the trace that contains
said span, where you can inspect both the overall trace and the properties of the span:</p>
<p><img src="practices/workflows/../../images/span-details.png" alt="Image displaying a specific trace with two of the spans expanded to show their details" /></p>
<h3 id="dashboards"><a class="header" href="#dashboards">Dashboards</a></h3>
<p>Once you have arrived at an interesting query, you may be inclined to create a dashboard that
summarizes the data without having to dig into individual traces and spans.</p>
<p>As an example the author was interested in checking the execution speed before and after a change
in a component. To make the comparison visual, the span of interest was graphed using the histogram
visualization in order to obtain the following result. In this graph the Y axis displays the number
of occurrences for spans that took X-axis long to complete.</p>
<div id="image-comparison">
<img src="practices/workflows/../../images/compile-and-load-before.png" class="before" />
<img src="practices/workflows/../../images/compile-and-load-after.png" class="after" />
</div>
<style>
#image-comparison {
    position: relative;
}
#image-comparison>.before {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
    opacity: 0;
    transition: opacity 250ms;
}
#image-comparison>.before:hover {
    opacity: 1;
}
</style>
<p>In general most of the panels work with tracing results directly but some of the most interesting
ones do not. It is necessary to experiment with certain options and settings to have grafana panels
start showing data. Some notable examples:</p>
<ol>
<li>Time series – a “Prepare time series” data transformation with “Multi-frame time series” has to
be added;</li>
<li>Histogram – make sure to use &quot;spans&quot; table format option;</li>
<li>Heatmap - set “Calculate from data” option to “Yes”;</li>
<li>Bar chart – works out of the box, but x axis won't be readable ever.</li>
</ol>
<p>You can also add a panel that shows all the trace events in a log-like representation using the log
or table visualization.</p>
<h3 id="multiple-nodes"><a class="header" href="#multiple-nodes">Multiple nodes</a></h3>
<p>One frequently asked question is whether Grafana lets you distinguish between nodes that export
tracing information.</p>
<p>The answer is yes.</p>
<p>In addition to span attributes, each span has resource attributes. There you'll find properties
like <code>node_id</code> which uniquely identify a node.</p>
<ul>
<li><code>account_id</code> is the <code>account_id</code> from <code>validator_key.json</code>;</li>
<li><code>chain_id</code> is taken from <code>genesis.json</code>;</li>
<li><code>node_id</code> is the public key from <code>node_key.json</code>;</li>
<li><code>service.name</code> is <code>account_id</code> if that is available, otherwise it is <code>node_id</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-style"><a class="header" href="#code-style">Code Style</a></h1>
<p>This document specifies the code style to use in the nearcore repository. The
primary goal here is to achieve consistency, maintain it over time, and cut down
on the mental overhead related to style choices.</p>
<p>Right now, <code>nearcore</code> codebase is not perfectly consistent, and the style
acknowledges this. It guides newly written code and serves as a tie breaker for
decisions. Rewriting existing code to conform 100% to the style is not a goal.
Local consistency is more important: if new code is added to a specific file,
it's more important to be consistent with the file rather than with this style
guide.</p>
<p>This is a live document, which intentionally starts in a minimal case. When
doing code-reviews, consider if some recurring advice you give could be moved
into this document.</p>
<h2 id="formatting"><a class="header" href="#formatting">Formatting</a></h2>
<p>Use <code>rustfmt</code> for minor code formatting decisions. This rule is enforced by CI</p>
<p><strong>Rationale:</strong> <code>rustfmt</code> style is almost always good enough, even if not always
perfect. The amount of bikeshedding saved by <code>rustfmt</code> far outweighs any
imperfections.</p>
<h2 id="idiomatic-rust"><a class="header" href="#idiomatic-rust">Idiomatic Rust</a></h2>
<p>While the most important thing is to solve the problem at hand, we strive to
implement the solution in idiomatic Rust, if possible. To learn what is
considered idiomatic Rust, a good start are the
<a href="https://rust-lang.github.io/api-guidelines/about.html">Rust API guidelines</a>
(but keep in mind that <code>nearcore</code> is not a library with public API, not all
advice applies literally).</p>
<p>When in doubt, ask question in the <a href="https://near.zulipchat.com/#narrow/stream/300659-Rust-.F0.9F.A6.80">Rust
🦀</a> Zulip
stream or during code review.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li><em>Consistency</em>: there's usually only one idiomatic solution amidst many
non-idiomatic ones.</li>
<li><em>Predictability</em>: you can use the APIs without consulting documentation.</li>
<li><em>Performance, ergonomics and correctness</em>: language idioms usually reflect
learned truths, which might not be immediately obvious.</li>
</ul>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>This section documents all micro-rules which are not otherwise enforced by
<code>rustfmt</code>.</p>
<h3 id="avoid-asrefas_ref"><a class="header" href="#avoid-asrefas_ref">Avoid <code>AsRef::as_ref</code></a></h3>
<p>When you have some concrete type, prefer <code>.as_str</code>, <code>.as_bytes</code>, <code>.as_path</code> over
generic <code>.as_ref</code>. Only use <code>.as_ref</code> when the type in question is a generic
<code>T: AsRef&lt;U&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD
fn log_validator(account_id: AccountId) {
    metric_for(account_id.as_str())
       .increment()
}

// BAD
fn log_validator(account_id: AccountId) {
    metric_for(account_id.as_ref())
       .increment()
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that <code>Option::as_ref</code>, <code>Result::as_ref</code> are great, do use them!</p>
<p><strong>Rationale:</strong> Readability and churn-resistance. There might be more than one
<code>AsRef&lt;U&gt;</code> implementation for a given type (with different <code>U</code>s). If a new
implementation is added, some of the <code>.as_ref()</code> calls might break. See also
this <a href="https://github.com/rust-lang/rust/issues/62586">issue</a>.</p>
<h3 id="avoid-references-to-copy-types"><a class="header" href="#avoid-references-to-copy-types">Avoid references to <code>Copy</code>-types</a></h3>
<p>Various generic APIs in Rust often return references to data (<code>&amp;T</code>). When <code>T</code> is
a small <code>Copy</code> type like <code>i32</code>, you end up with <code>&amp;i32</code> while many API expect
<code>i32</code>, so dereference has to happen <em>somewhere</em>. Prefer dereferencing as early
as possible, typically in a pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD
fn compute(map: HashMap&lt;&amp;'str, i32&gt;) {
    if let Some(&amp;value) = map.get(&quot;key&quot;) {
        process(value)
    }
}
fn process(value: i32) { ... }

// BAD
fn compute(map: HashMap&lt;&amp;'str, i32&gt;) {
    if let Some(value) = map.get(&quot;key&quot;) {
        process(*value)
    }
}
fn process(value: i32) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>Rationale:</strong> If the value is used multiple times, dereferencing in the pattern
saves keystrokes. If the value is used exactly once, we just want to be
consistent. Additional benefit of early deref is reduced scope of borrow.</p>
<p>Note that for some <em>big</em> <code>Copy</code> types, notably <code>CryptoHash</code>, we sometimes use
references for performance reasons. As a rule of thumb, <code>T</code> is considered <em>big</em> if
<code>size_of::&lt;T&gt;() &gt; 2 * size_of::&lt;usize&gt;()</code>.</p>
<h3 id="prefer-for-loops-over-for_each-and-try_for_each-methods"><a class="header" href="#prefer-for-loops-over-for_each-and-try_for_each-methods">Prefer for loops over <code>for_each</code> and <code>try_for_each</code> methods</a></h3>
<p>Iterators offer <code>for_each</code> and <code>try_for_each</code> methods which allow executing
a closure over all items of the iterator. This is similar to using a for loop
but comes with various complications and may lead to less readable code.  Prefer
using a loop rather than those methods, for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD
for outcome_with_id in result? {
    *total_gas_burnt =
        safe_add_gas(*total_gas_burnt, outcome_with_id.outcome.gas_burnt)?;
    outcomes.push(outcome_with_id);
}

// BAD
result?.into_iter().try_for_each(
    |outcome_with_id: ExecutionOutcomeWithId| -&gt; Result&lt;(), RuntimeError&gt; {
        *total_gas_burnt =
            safe_add_gas(*total_gas_burnt, outcome_with_id.outcome.gas_burnt)?;
        outcomes.push(outcome_with_id);
        Ok(())
    },
)?;
<span class="boring">}
</span></code></pre></pre>
<p><strong>Rationale:</strong> The <code>for_each</code> and <code>try_for_each</code> method don’t play nice with
<code>break</code> and <code>continue</code> statements nor do they mesh well with async IO (since
<code>.await</code> inside of the closure isn’t possible). And while <code>try_for_each</code> allows
for the use of question mark operator, one may end up having to uses it twice:
once inside the closure and second time outside the call to <code>try_for_each</code>.
Furthermore, usage of the functions often introduce some minor syntax noise.</p>
<p>There are situations when those methods may lead to more readable code. Common
example are long call chains. Even then such code may evolve with the closure
growing and leading to less readable code. If advantages of using the methods
aren’t clear cut, it’s usually better to err on side of more imperative style.</p>
<p>Lastly, anecdotally the methods (e.g. when used with <code>chain</code> or <code>flat_map</code>) may
lead to faster code. This intuitively makes sense but it’s worth to keep in
mind that compilers are pretty good at optimising and in practice may generate
optimal code anyway. Furthermore, optimising code for readability may be more
important (especially outside of hot path) than small performance gains.</p>
<h3 id="prefer-to_string-to-format"><a class="header" href="#prefer-to_string-to-format">Prefer <code>to_string</code> to <code>format!(&quot;{}&quot;)</code></a></h3>
<p>Prefer calling <code>to_string</code> method on an object rather than passing it through
<code>format!(&quot;{}&quot;)</code> if all you’re doing is converting it to a <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD
let hash = block_hash.to_string();
let msg = format!(&quot;{}: failed to open&quot;, path.display());

// BAD
let hash = format!(&quot;{block_hash}&quot;);
let msg = path.display() + &quot;: failed to open&quot;;
<span class="boring">}
</span></code></pre></pre>
<p><strong>Rationale:</strong> <code>to_string</code> is shorter to type and also faster.</p>
<h3 id="import-granularity"><a class="header" href="#import-granularity">Import Granularity</a></h3>
<p>Group imports by module, but not deeper:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD
use std::collections::{hash_map, BTreeSet};
use std::sync::Arc;

// BAD - nested groups.
use std::{
    collections::{hash_map, BTreeSet},
    sync::Arc,
};

// BAD - not grouped together.
use std::collections::BTreeSet;
use std::collections::hash_map;
use std::sync::Arc;
<span class="boring">}
</span></code></pre></pre>
<p>This corresponds to <code>&quot;rust-analyzer.imports.granularity.group&quot;: &quot;module&quot;</code> setting
in rust-analyzer
(<a href="https://rust-analyzer.github.io/manual.html#rust-analyzer.imports.granularity.group">docs</a>).</p>
<p><strong>Rationale:</strong> Consistency, matches existing practice.</p>
<h3 id="import-blocks"><a class="header" href="#import-blocks">Import Blocks</a></h3>
<p>Do not separate imports into groups with blank lines. Write a single block of
imports and rely on <code>rustfmt</code> to sort them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD
use crate::types::KnownPeerState;
use borsh::BorshSerialize;
use near_primitives::utils::to_timestamp;
use near_store::{DBCol::Peers, Store};
use rand::seq::SliceRandom;
use std::collections::HashMap;
use std::net::SocketAddr;

// BAD -- several groups of imports
use std::collections::HashMap;
use std::net::SocketAddr;

use borsh::BorshSerialize;
use rand::seq::SliceRandom;

use near_primitives::utils::to_timestamp;
use near_store::{DBCol::Peers, Store};

use crate::types::KnownPeerState;
<span class="boring">}
</span></code></pre></pre>
<p><strong>Rationale:</strong> Consistency, ease of automatic enforcement. Today, stable rustfmt
can't split imports into groups automatically, and doing that manually
consistently is a chore.</p>
<h3 id="derives"><a class="header" href="#derives">Derives</a></h3>
<p>When deriving an implementation of a trait, specify a full path to the traits provided by the
external libraries:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD
#[derive(Copy, Clone, serde::Serialize, thiserror::Error, strum::Display)]
struct Grapefruit;

// BAD
use serde::Serialize;
use thiserror::Error;
use strum::Display;

#[derive(Copy, Clone, Serialize, Error, Display)]
struct Banana;
<span class="boring">}
</span></code></pre></pre>
<p>As an exception to this rule, it is okay to use either style when the derived trait already
includes the name of the library (as would be the case for <code>borsh::BorshSerialize</code>.)</p>
<p><strong>Rationale:</strong> Specifying a full path to the externally provided derivations here makes it
straightforward to differentiate between the built-in derivations and those provided by the
external crates. The surprise factor for derivations sharing a name with the standard
library traits (<code>Display</code>) is reduced and it also acts as natural mechanism to tell apart names
prone to collision (<code>Serialize</code>), all without needing to look up the list of imports.</p>
<h3 id="arithmetic-integer-operations"><a class="header" href="#arithmetic-integer-operations">Arithmetic integer operations</a></h3>
<p>Use methods with an appropriate overflow handling over plain arithmetic operators (<code>+-*/%</code>) when
dealing with integers.</p>
<pre><code>// GOOD
a.wrapping_add(b);
c.saturating_sub(2);
d.widening_mul(3);   // NB: unstable at the time of writing
e.overflowing_div(5);
f.checked_rem(7);

// BAD
a + b
c - 2
d * 3
e / 5
f % 7
</code></pre>
<p>If you’re confident the arithmetic operation cannot fail,
<code>x.checked_[add|sub|mul|div](y).expect(&quot;explanation why the operation is safe&quot;)</code> is a great
alternative, as it neatly documents not just the infallibility, but also <em>why</em> that is the case.</p>
<p>This convention may be enforced by the <code>clippy::arithmetic_side_effects</code> and
<code>clippy::integer_arithmetic</code> lints.</p>
<p><strong>Rationale:</strong> By default the outcome of an overflowing computation in Rust depends on a few
factors, most notably the compilation flags used. The quick explanation is that in debug mode the
computations may panic (cause side effects) if the result has overflowed, and when built with
optimizations enabled, these computations will wrap-around instead.</p>
<p>For nearcore and neard we have opted to enable the panicking behaviour regardless of the
optimization level. By doing it this we hope to prevent accidental stabilization of protocol
mis-features that depend on incorrect handling of these overflows or similarly scary silent bugs.
The downside to this approach is that any such arithmetic operation now may cause a node to crash,
much like indexing a vector with <code>a[idx]</code> may cause a crash when <code>idx</code> is out-of-bounds. Unlike
indexing, however, developers and reviewers are not used to treating integer arithmetic operations
with the due suspicion. Having to make a choice, and explicitly spell out, how an overflow case
ought to be handled will result in an easier to review and understand code and a more resilient
project overall.</p>
<h2 id="standard-naming"><a class="header" href="#standard-naming">Standard Naming</a></h2>
<ul>
<li>Use <code>-</code> rather than <code>_</code> in crate names and in corresponding folder names.</li>
<li>Avoid single-letter variable names especially in long functions.  Common <code>i</code>,
<code>j</code> etc. loop variables are somewhat of an exception but since Rust encourages
use of iterators those cases aren’t that common anyway.</li>
<li>Follow standard <a href="https://rust-lang.github.io/api-guidelines/naming.html">Rust naming patterns</a> such as:
<ul>
<li>Don’t use <code>get_</code> prefix for getter methods.  A getter method is one which
returns (a reference to) a field of an object.</li>
<li>Use <code>set_</code> prefix for setter methods.  An exception are builder objects
which may use different a naming style.</li>
<li>Use <code>into_</code> prefix for methods which consume <code>self</code> and <code>to_</code> prefix for
methods which don’t.</li>
</ul>
</li>
<li>Use <code>get_block_header</code> rather than <code>get_header</code> for methods which return
a block header.</li>
<li>Don’t use <code>_by_hash</code> suffix for methods which lookup chain objects (blocks,
chunks, block headers etc.) by their hash (i.e. their primary identifier).</li>
<li>Use <code>_by_height</code> and similar suffixes for methods which lookup chain objects
(blocks, chunks, block headers etc.) by their height or other property which
is not their hash.</li>
</ul>
<p><strong>Rationale:</strong> Consistency.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>When writing documentation in <code>.md</code> files, wrap lines at approximately 80
columns.</p>
<pre><code class="language-markdown">&lt;!-- GOOD --&gt;
Manually reflowing paragraphs is tedious. Luckily, most editors have this
functionality built in or available via extensions. For example, in Emacs you
can use `fill-paragraph` (&lt;kbd&gt;M-q&lt;/kbd&gt;), (neo)vim allows rewrapping with `gq`,
and VS Code has `stkb.rewrap` extension.

&lt;!-- BAD --&gt;
One sentence per-line is also occasionally used for technical writing.
We avoid that format though.
While convenient for editing, it may be poorly legible in unrendered form

&lt;!-- BAD --&gt;
Definitely don't use soft-wrapping. While markdown mostly ignores source level line breaks, relying on soft wrap makes the source completely unreadable, especially on modern wide displays.
</code></pre>
<h2 id="tracing"><a class="header" href="#tracing"><a href="https://tracing.rs">Tracing</a></a></h2>
<p>When emitting events and spans with <code>tracing</code> prefer adding variable data via
<a href="https://docs.rs/tracing/latest/tracing/#recording-fields"><code>tracing</code>'s field mechanism</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD
debug!(
    target: &quot;client&quot;,
    validator_id = self.client.validator_signer.get().map(|vs| {
        tracing::field::display(vs.validator_id())
    }),
    %hash,
    &quot;block.previous_hash&quot; = %block.header().prev_hash(),
    &quot;block.height&quot; = block.header().height(),
    %peer_id,
    was_requested,
    &quot;Received block&quot;,
);
<span class="boring">}
</span></code></pre></pre>
<p>Most apparent violation of this rule will be when the event message utilizes any
form of formatting, as seen in the following example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD
debug!(
    target: &quot;client&quot;,
    &quot;{:?} Received block {} &lt;- {} at {} from {}, requested: {}&quot;,
    self.client.validator_signer.get().map(|vs| vs.validator_id()),
    hash,
    block.header().prev_hash(),
    block.header().height(),
    peer_id,
    was_requested
);
<span class="boring">}
</span></code></pre></pre>
<p>Always specify the <code>target</code> explicitly. A good default value to use is the crate
name, or the module path (e.g. <code>chain::client</code>) so that events and spans common
to a topic can be grouped together. This grouping can later be used for
customizing which events to output.</p>
<p><strong>Rationale:</strong> This makes the events structured – one of the major value add
propositions of the tracing ecosystem. Structured events allow for immediately
actionable data without additional post-processing, especially when using some
of the more advanced tracing subscribers. Of particular interest would be those
that output events as JSON, or those that publish data to distributed event
collection systems such as opentelemetry. Maintaining this rule will also
usually result in faster execution (when logs at the relevant level are enabled.)</p>
<h3 id="spans-1"><a class="header" href="#spans-1">Spans</a></h3>
<p>Use the <a href="https://docs.rs/tracing/latest/tracing/#spans">spans</a> to introduce
context and grouping to and between events instead of manually adding such
information as part of the events themselves. Most of the subscribers ingesting
spans also provide a built-in timing facility, so prefer using spans for measuring
the amount of time a section of code needs to execute.</p>
<p>Give spans simple names that make them both easy to trace back to code, and to
find a particular span in logs or other tools ingesting the span data. If a
span begins at the top of a function, prefer giving it a name of that function,
otherwise prefer a <code>snake_case</code> name.</p>
<p>When instrumenting asynchronous functions the <a href="https://docs.rs/tracing-attributes/latest/tracing_attributes/attr.instrument.html"><code>#[tracing::instrument]</code></a> macro or the
<code>Future::instrument</code> is <strong>required</strong>. Using <code>Span::entered</code> or a similar method that is not aware
of yield points will result in incorrect span data and could lead to difficult to troubleshoot
issues such as stack overflows.</p>
<p>Always explicitly specify the <code>level</code>, <code>target</code>, and <code>skip_all</code> options and do not rely on the
default values. <code>skip_all</code> avoids adding all function arguments as span fields which can lead
recording potentially unnecessary and expensive information. Carefully consider which information
needs recording and the cost of recording the information when using the <code>fields</code> option.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tracing::instrument(
    level = &quot;trace&quot;,
    target = &quot;network&quot;,
    &quot;handle_sync_routing_table&quot;,
    skip_all
)]
async fn handle_sync_routing_table(
    clock: &amp;time::Clock,
    network_state: &amp;Arc&lt;NetworkState&gt;,
    conn: Arc&lt;connection::Connection&gt;,
    rtu: RoutingTableUpdate,
) {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>In regular synchronous code it is fine to use the regular span API if you need to instrument
portions of a function without affecting the code structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compile_and_serialize_wasmer(code: &amp;[u8]) -&gt; Result&lt;wasmer::Module&gt; {
    // Some code...
    {
        let _span = tracing::debug_span!(target: &quot;vm&quot;, &quot;compile_wasmer&quot;).entered();
        // ...
        // _span will be dropped when this scope ends, terminating the span created above.
        // You can also `drop` it manually, to end the span early with `drop(_span)`.
    }
    // Some more code...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Rationale:</strong> Much as with events, this makes the information provided by spans
structured and contextual. This information can then be output to tooling in an
industry standard format, and can be interpreted by an extensive ecosystem of
<code>tracing</code> subscribers.</p>
<h3 id="event-and-span-levels"><a class="header" href="#event-and-span-levels">Event and span levels</a></h3>
<p>The <code>INFO</code> level is enabled by default, use it for information useful for node
operators. The <code>DEBUG</code> level is enabled on the canary nodes, use it for
information useful in debugging testnet failures. The <code>TRACE</code> level is not
generally enabled, use it for arbitrary debug output.</p>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<p>Consider adding metrics to new functionality. For example, how often each type
of error was triggered, how often each message type was processed.</p>
<p><strong>Rationale:</strong> Metrics are cheap to increment, and they often provide a significant
insight into operation of the code, almost as much as logging. But unlike logging
metrics don't incur a significant runtime cost.</p>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<p>Prefix all <code>nearcore</code> metrics with <code>near_</code>. Follow the
<a href="https://prometheus.io/docs/practices/naming/">Prometheus naming convention</a>
for new metrics.</p>
<p><strong>Rationale:</strong> The <code>near_</code> prefix makes it trivial to separate metrics exported
by <code>nearcore</code> from other metrics, such as metrics about the state of the machine
that runs <code>neard</code>.</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>In most cases incrementing a metric is cheap enough never to give it a second
thought. However accessing a metric with labels on a hot path needs to be done
carefully.</p>
<p>If a label is based on an integer, use a faster way of converting an integer
to the label, such as the <code>itoa</code> crate.</p>
<p>For hot code paths, re-use results of <code>with_label_values()</code> as much as possible.</p>
<p><strong>Rationale:</strong> We've encountered issues caused by the runtime costs of
incrementing metrics before. Avoid runtime costs of incrementing metrics too
often.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-1"><a class="header" href="#documentation-1">Documentation</a></h1>
<p>This chapter describes nearcore's approach to documentation. There are three
primary types of documentation to keep in mind:</p>
<ul>
<li><a href="https://nomicon.io"><strong>The NEAR Protocol Specification</strong></a>
(<a href="https://github.com/near/NEPs">source code</a>) is the formal description of
the NEAR protocol. The reference nearcore implementation and any other NEAR
client implementations must follow this specification.</li>
<li><a href="https://docs.near.org"><strong>User docs</strong></a> (<a href="https://github.com/near/docs">source code</a>)
explain what is NEAR and how to participate in the network. In particular,
they contain information pertinent to the users of NEAR: validators and
smart contract developers.</li>
<li><a href="https://near.github.io/nearcore/"><strong>Documentation for nearcore developers</strong></a>
(<a href="https://github.com/near/nearcore/tree/master/docs">source code</a>) is the
book you are reading right now! The target audience here is the contributors
to the main implementation of the NEAR protocol (nearcore).</li>
</ul>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The bulk of the internal docs is within this book. If you want to write some
kind of document, add it here! The <a href="practices/../architecture/">architecture</a> and
<a href="practices/../practices/">practices</a> chapters are intended for somewhat up-to-date
normative documents. The <a href="practices/../misc/">misc</a> chapter holds everything else.</p>
<p>This book is not intended for user-facing documentation, so don't worry about
proper English, typos, or beautiful diagrams -- just write stuff! It can easily
be improved over time with pull requests. For docs, we use a lightweight review
process and try to merge any improvement as quickly as possible. Rather than
blocking a PR on some stylistic changes, just merge it and submit a follow-up.</p>
<p>Note the &quot;edit&quot; button at the top-right corner -- super useful for fixing any
typos you spot!</p>
<p>In addition to the book, we also have some &quot;inline&quot; documentation in the code.
For Rust, it is customary to have a per-crate <code>README.md</code> file and include it as
a doc comment via <code>#![doc = include_str!(&quot;../README.md&quot;)]</code> in <code>lib.rs</code>. We don't
<em>require</em> every item to be documented, but we certainly encourage documenting as
much as possible. If you spend some time refactoring or fixing a function,
consider adding a doc comment (<code>///</code>) to it as a drive-by improvement.</p>
<p>We currently don't render <code>rustdoc</code>, see <a href="https://github.com/near/nearcore/issues/7836">#7836</a>.</p>
<h2 id="book-how-to"><a class="header" href="#book-how-to">Book How To</a></h2>
<p>We use mdBook to render a bunch of markdown files as a static website with a table
of contents, search and themes. Full docs are <a href="https://rust-lang.github.io/mdBook/">here</a>,
but the basics are very simple.</p>
<p>To add a new page to the book:</p>
<ol>
<li>Add a <code>.md</code> file somewhere in the
<a href="https://github.com/near/nearcore/tree/master/docs"><code>./docs</code></a> folder.</li>
<li>Add a link to that page to the
<a href="https://github.com/near/nearcore/blob/master/docs/SUMMARY.md"><code>SUMMARY.md</code></a>.</li>
<li>Submit a PR (again, we promise to merge it without much ceremony).</li>
</ol>
<p>The doc itself is in vanilla markdown.</p>
<p>To render documentation locally:</p>
<pre><code class="language-console"># Install mdBook
$ cargo install mdbook
$ mdbook serve --open ./docs
</code></pre>
<p>This will generate the book from the docs folder, open it in a browser and
start a file watcher to rebuild the book every time the source files change.</p>
<p>Note that GitHub's default rendering mostly works just as well, so you don't
need to go out of your way to preview your changes when drafting a page or
reviewing pull requests to this book.</p>
<p>The book is deployed via the
<a href="https://github.com/near/nearcore/blob/master/.github/workflows/book.yml">book GitHub Action workflow</a>.
This workflow runs mdBook and then deploys the result to
<a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">GitHub Pages</a>.</p>
<p>For internal docs, you often want to have pretty pictures. We don't currently
have a recommended workflow, but here are some tips:</p>
<ul>
<li>
<p>Don't add binary media files to Git to avoid inflating repository size.
Rather, upload images as comments to this super-secret issue
<a href="https://github.com/near/nearcore/issues/7821">#7821</a>, and then link to
the images as</p>
<pre><code>![image](https://user-images.githubusercontent.com/1711539/195626792-7697129b-7f9c-4953-b939-0b9bcacaf72c.png)
</code></pre>
<p>Use a single comment per page with multiple images.</p>
</li>
<li>
<p>Google Docs is an OK way to create technical drawings, you can add a link to
the doc with source to that secret issue as well.</p>
</li>
<li>
<p>There's some momentum around using mermaid.js for diagramming, and there's
an appropriate <a href="https://github.com/badboy/mdbook-mermaid">plugin</a> for that.
Consider if that's something you might want to use.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracking-issues"><a class="header" href="#tracking-issues">Tracking issues</a></h1>
<p><code>nearcore</code> uses so-called &quot;tracking issues&quot; to coordinate larger pieces of work
(e.g. implementation of new NEPs).  Such issues are tagged with the
<a href="https://github.com/near/nearcore/issues?q=is%3Aopen+is%3Aissue+label%3AC-tracking-issue"><code>C-tracking-issue</code>
label</a>.</p>
<p>The goal of tracking issues is to serve as a coordination point. They can help
new contributors and other interested parties come up to speed with the current
state of projects. As such, they should link to things like design docs,
todo-lists of sub-issues, existing implementation PRs, etc.</p>
<p>One can further use tracking issues to:</p>
<ul>
<li>get a feeling for what's happening in <code>nearcore</code> by looking at the set of
open tracking issues.</li>
<li>find larger efforts to contribute to as tracking issues usually contain
up-for-grab to-do lists.</li>
<li>follow the progress of specific features by subscribing to the issue on GitHub.</li>
</ul>
<p>If you are leading or participating in a larger effort, please create a tracking
issue for your work.</p>
<h2 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h2>
<ul>
<li>Tracking issues should be maintained in the <code>nearcore</code> repository. If the
projects are security sensitive, then they should be maintained in the
<code>nearcore-private</code> repository.</li>
<li>The issues should be kept up-to-date. At a minimum, all new context
should be added as comments, but preferably the original description should be
edited to reflect the current status.</li>
<li>The issues should contain links to all the relevant design documents
which should also be kept up-to-date.</li>
<li>The issues should link to any relevant NEP if applicable.</li>
<li>The issues should contain a list of to-do tasks that should be kept
up-to-date as new work items are discovered and other items are done. This
helps others gauge progress and helps lower the barrier of entry for others to
participate.</li>
<li>The issues should contain links to relevant Zulip discussions. Prefer
open forums like Zulip for discussions. When necessary, closed forums like
video calls can also be used but care should be taken to document a summary of
the discussions.</li>
<li>For security-sensitive discussions, use the appropriate private Zulip streams.</li>
</ul>
<p><a href="https://github.com/near/nearcore/issues/7670">This issue</a> is a good example of
how tracking issues should be maintained.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>The idea of tracking issues is also used to track project work in the Rust
language. See <a href="https://internals.rust-lang.org/t/how-the-rust-issue-tracker-works/3951">this
post</a>
for a rough description and
<a href="https://github.com/rust-lang/rust/issues/101840">these</a>
<a href="https://github.com/rust-lang/rust/issues/100717">issues</a> for how they are used
in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="security-vulnerabilities"><a class="header" href="#security-vulnerabilities">Security Vulnerabilities</a></h2>
<blockquote style="background: rgba(255, 200, 0, 0.1); border: 5px solid rgba(255, 200, 0, 0.4);">
<p>The intended audience of the information presented here is developers working
on the implementation of NEAR.</p>
<p>Are you a security researcher? Please report security vulnerabilities to
<a href="mailto:security@near.org">security@near.org</a>.</p>
</blockquote>
<p>As nearcore is open source, all of its issues and pull requests are also
publicly tracked on GitHub. However, from time to time, if a security-sensitive
issue is discovered, it cannot be tracked publicly on GitHub. However, we
should promote as similar a development process to work on such issues as
possible. To enable this, below is the high-level process for working on
security-sensitive issues.</p>
<ol>
<li>
<p>There is a <a href="https://github.com/near/nearcore-private">private fork of
nearcore</a> on GitHub. Access to
this repository is restricted to the set of people who are trusted to work on
and have knowledge about security-sensitive issues in nearcore.</p>
<p>This repository can be manually synced with the public nearcore repository
using the following commands:</p>
<pre><code class="language-console">$ git remote add nearcore-public git@github.com:near/nearcore
$ git remote add nearcore-private git@github.com:near/nearcore-private
$ git fetch nearcore-public
$ git push nearcore-private nearcore-public/master:master
</code></pre>
</li>
<li>
<p>All security-sensitive issues must be created on the private nearcore
repository. You must also assign one of the <code>[P-S0, P-S1]</code> labels to the
issue to indicate the severity of the issue. The two criteria to use to help
you judge the severity are the ease of carrying out the attack and the impact
of the attack. An attack that is easy to do or can have a huge impact should
have the <code>P-S0</code> label and <code>P-S1</code> otherwise.</p>
</li>
<li>
<p>All security-sensitive pull requests should also be created on the private
nearcore repository. Note that once a PR has been approved, it should not be
merged into the private repository. Instead, it should be first merged into
the public repository and then the private fork should be updated using the
steps above.</p>
</li>
<li>
<p>Once work on a security issue is finished, it needs to be deployed to all the
impacted networks. Please contact the node team for help with this.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-builds"><a class="header" href="#fast-builds">Fast Builds</a></h1>
<p>nearcore is implemented in Rust and is a fairly sizable project, so it takes a
while to build. This chapter collects various tips to make the development
process faster.</p>
<p>Optimizing build times is a bit of a black art, so please do benchmarks on your
machine to verify that the improvements work for you. Changing some configuration
and making a typo, which prevents it from improving build times is an
extremely common failure mode!</p>
<p><a href="https://nnethercote.github.io/perf-book/compile-times.html">Rust Perf Book</a>
contains a section on compilation times as well!</p>
<h2 id="release-builds-and-link-time-optimization"><a class="header" href="#release-builds-and-link-time-optimization">Release Builds and Link Time Optimization</a></h2>
<p><code>cargo build --release</code> is obviously slower than <code>cargo build</code>. We enable full
lto (link-time optimization), so our <code>-r</code> builds are very slow, use a lot of
RAM, and don't utilize the available parallelism fully.</p>
<p>As debug builds are much too slow at runtime for many purposes, we have a custom
profile <code>--profile dev-release</code> which is equivalent to <code>-r</code>, except that the
time-consuming options such as LTO are disabled, and debug assertions are enabled.</p>
<p>Use <code>--profile dev-release</code> for most local development, or when connecting a
locally built node to a network. Use <code>-r</code> for production, or if you want to get
absolute performance numbers.</p>
<h2 id="linker"><a class="header" href="#linker">Linker</a></h2>
<p>By default, <code>rustc</code> uses the default system linker, which tends to be quite
slow. Using <code>lld</code> (LLVM linker) or <code>mold</code> (very new, very fast linker) provides
big wins for many setups.</p>
<p>I don't know what's the official source of truth for using alternative linkers,
I usually refer to <a href="https://github.com/rust-lang/rust/issues/39915#issuecomment-538049306">this
comment</a>.</p>
<p>Usually, adding</p>
<pre><code class="language-toml">[build]
rustflags = [&quot;-C&quot;, &quot;link-arg=-fuse-ld=lld&quot;]
</code></pre>
<p>to <code>~/.cargo/config</code> is the most convenient approach.</p>
<p><code>lld</code> itself can be installed with <code>sudo apt install lld</code> (or the equivalent in 
the distro/package manager of your choice).</p>
<h2 id="prebuilt-rocksdb"><a class="header" href="#prebuilt-rocksdb">Prebuilt RocksDB</a></h2>
<p>By default, we compile RocksDB (a C++ project) from source during the neard
build. By linking to a prebuilt copy of RocksDB this work can be avoided
entirely. This is a huge win, especially if you clean the <code>./target</code> directory
frequently.</p>
<p>To use a prebuilt RocksDB, set the <code>ROCKSDB_LIB_DIR</code> environment variable to
a location containing <code>librocksdb.a</code>:</p>
<pre><code class="language-console">$ export ROCKSDB_LIB_DIR=/usr/lib/x86_64-linux-gnu
$ cargo build -p neard
</code></pre>
<p>Note, that the system must provide a recent version of the library which,
depending on which operating system you’re using, may require installing packages
from a testing branch. For example, on Debian it requires installing
<code>librocksdb-dev</code> from the <code>experimental</code> repository:</p>
<p><strong>Note:</strong> Based on which distro you are using this process will look different.
Please refer to the documentation of the package manager you are using.</p>
<pre><code class="language-bash">echo 'deb http://ftp.debian.org/debian experimental main contrib non-free' |
    sudo tee -a /etc/apt/sources.list
sudo apt update
sudo apt -t experimental install librocksdb-dev

ROCKSDB_LIB_DIR=/usr/lib/x86_64-linux-gnu
export ROCKSDB_LIB_DIR
</code></pre>
<h2 id="global-compilation-cache"><a class="header" href="#global-compilation-cache">Global Compilation Cache</a></h2>
<p>By default, Rust compiles incrementally, with the incremental cache and
intermediate outputs stored in the project-local <code>./target</code> directory.</p>
<p>The <a href="https://github.com/mozilla/sccache"><code>sccache</code></a> utility can be used to share
these artifacts between machines or checkouts within the same machine. <code>sccache</code>
works by intercepting calls to <code>rustc</code> and will fetch the cached outputs from
the global cache whenever possible. This tool can be set up as such:</p>
<pre><code class="language-console">$ cargo install sccache
$ export RUSTC_WRAPPER=&quot;sccache&quot;
$ export SCCACHE_CACHE_SIZE=&quot;30G&quot;
$ cargo build -p neard
</code></pre>
<p>Refer to the <a href="https://github.com/mozilla/sccache">project’s README</a> for further
configuration options.</p>
<h2 id="ides-are-bad-for-environment-handling"><a class="header" href="#ides-are-bad-for-environment-handling">IDEs Are Bad For Environment Handling</a></h2>
<p>Generally, the knobs in this section are controlled either via global
configuration in <code>~/.cargo/config</code> or environment variables.</p>
<p>Environment variables are notoriously easy to lose, especially if you are
working both from a command line and a graphical IDE. Double-check that the
environment within which builds are executed is identical to avoid nasty
failure modes such as full cache invalidation when switching from the
CLI to an IDE or vice-versa.</p>
<p><a href="https://direnv.net"><code>direnv</code></a> sometimes can be used to conveniently manage
project-specific environment variables.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-principles"><a class="header" href="#general-principles">General principles</a></h1>
<ol>
<li>Every PR needs to have test coverage in place. Sending the code change and
deferring tests for a future change is not acceptable.</li>
<li>Tests need to either be sufficiently simple to follow or have good
documentation to explain why certain actions are made and conditions are
expected.</li>
<li>When implementing a PR, <strong>make sure to run the new tests with the change
disabled and confirm that they fail</strong>! It is extremely common to have tests
that pass without the change that is being tested.</li>
<li>The general rule of thumb for a reviewer is to first review the tests, and
ensure that they can convince themselves that the code change that passes the
tests must be correct. Only then the code should be reviewed.</li>
<li>Have the assertions in the tests as specific as possible,
however do not make the tests change-detectors of the concrete implementation.
(assert only properties which are required for correctness).
For example, do not do <code>assert!(result.is_err())</code>, expect the specific error instead.</li>
</ol>
<h1 id="tests-hierarchy"><a class="header" href="#tests-hierarchy">Tests hierarchy</a></h1>
<p>In the NEAR Reference Client we largely split tests into three categories:</p>
<ol>
<li><strong>Relatively cheap sanity or fast fuzz tests:</strong> It includes all the <code>#[test]</code>
Rust tests not decorated by features. Our repo is configured in such a way
that all such tests are run on every PR and failing at least one of them is
blocking the PR from being merged.</li>
</ol>
<p>To run such tests locally run <code>cargo nextest run --all</code>.
It requires nextest harness which can be installed by running <code>cargo install cargo-nextest</code> first.</p>
<ol start="2">
<li><strong>Expensive tests:</strong> This includes all the fuzzy tests that run many iterations,
as well as tests that spin up multiple nodes and run them until they reach a
certain condition. Such tests are decorated with
<code>#[cfg(feature=&quot;expensive-tests&quot;)]</code>. It is not trivial to enable features
that are not declared in the top-level crate, and thus the easiest way to run
such tests is to enable all the features by passing <code>--all-features</code> to
<code>cargo nextest run</code>, e.g:</li>
</ol>
<p><code>cargo nextest run --package near-client -E 'test(=tests::cross_shard_tx::test_cross_shard_tx)' --all-features</code></p>
<ol start="3">
<li><strong>Python tests:</strong> We have an infrastructure to spin up nodes, both locally and
remotely, in python, and interact with them using RPC. The infrastructure and
the tests are located in the <code>pytest</code> folder. The infrastructure is relatively
straightforward, see for example <code>block_production.py</code>
<a href="https://github.com/near/nearcore/blob/master/pytest/tests/sanity/block_production.py">here</a>.
See the <code>Test infrastructure</code> section below for details.</li>
</ol>
<p>Expensive and python tests are not part of CI, and are run by a custom nightly
runner. The results of the latest runs are available
<a href="https://nayduck.nearone.org/#/">here</a>. Today, test runs launch approximately
every 5-6 hours. For the latest results look at the <strong>second</strong> run, since the
first one has some tests still scheduled to run.</p>
<h1 id="test-infrastructure"><a class="header" href="#test-infrastructure">Test infrastructure</a></h1>
<p>Different levels of the reference implementation have different infrastructures
available to test them.</p>
<h2 id="client"><a class="header" href="#client">Client</a></h2>
<p>The Client is separated from the runtime via a <code>RuntimeAdapter</code> trait.
In production, it uses <code>NightshadeRuntime</code> which uses real runtime and epoch managers.
To test the client without instantiating runtime and epoch manager, we have a mock runtime
<code>KeyValueRuntime</code>.</p>
<p>Most of the tests in the client work by setting up either a single node (via
<code>setup_mock()</code>) or multiple nodes (via <code>setup_mock_all_validators()</code>) and then
launching the nodes and waiting for a particular message to occur, with a
predefined timeout.</p>
<p>For the most basic example of using this infrastructure see <code>produce_two_blocks</code>
in
<a href="https://github.com/near/nearcore/blob/master/chain/client/src/tests/process_blocks.rs"><code>tests/process_blocks.rs</code></a>.</p>
<ol>
<li>The callback (<code>Box::new(move |msg, _ctx, _| { ...</code>) is what is executed
whenever the client sends a message. The return value of the callback is sent
back to the client, which allows for testing relatively complex scenarios. The
tests generally expect a particular message to occur, in this case, the tests
expect two blocks to be produced. <code>System::current().stop();</code> is the way to
stop the test and mark it as passed.</li>
<li><code>near_network::test_utils::wait_or_panic(5000);</code> is how the timeout for the
test is set (in milliseconds).</li>
</ol>
<p>For an example of a test that launches multiple nodes, see
<code>chunks_produced_and_distributed_common</code> in
<a href="https://github.com/near/nearcore/blob/master/chain/client/src/tests/chunks_management.rs">tests/chunks_management.rs</a>.
The <code>setup_mock_all_validators</code> function is the key piece of infrastructure here.</p>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p>Tests for Runtime are listed in
<a href="https://github.com/near/nearcore/blob/master/integration-tests/src/tests/standard_cases/runtime.rs">tests/test_cases_runtime.rs</a>.</p>
<p>To run a test, usually, a mock <code>RuntimeNode</code> is created via <code>create_runtime_node()</code>.
In its constructor, the <code>Runtime</code> is created in the
<code>get_runtime_and_trie_from_genesis</code> function.</p>
<p>Inside a test, an abstracted <code>User</code> is used for sending specific actions to the
runtime client. The helper functions <code>function_call</code>, <code>deploy_contract</code>, etc.
eventually lead to the <code>Runtime.apply</code> method call.</p>
<p>For setting usernames during playing with transactions, use default names
<code>alice_account</code>, <code>bob_account</code>, <code>eve_dot_alice_account</code>, etc.</p>
<h2 id="network"><a class="header" href="#network">Network</a></h2>
<!-- TODO: Explain the `runner` here -->
<h2 id="chain-epoch-manager-runtime-and-other-low-level-changes"><a class="header" href="#chain-epoch-manager-runtime-and-other-low-level-changes">Chain, Epoch Manager, Runtime and other low-level changes</a></h2>
<p>When building new features in the <code>chain</code>, <code>epoch_manager</code> and <code>network</code> crates,
make sure to build new components sufficiently abstract so that they can be tested
without relying on other components.</p>
<p>For example, see tests for doomslug
<a href="https://github.com/near/nearcore/blob/master/chain/chain/src/tests/doomslug.rs">here</a>,
for network cache
<a href="https://github.com/near/nearcore/blob/master/chain/network/src/routing/edge_cache/tests.rs">here</a>,
or for promises in runtime
<a href="https://github.com/near/nearcore/blob/master/runtime/near-vm-runner/src/logic/tests/promises.rs">here</a>.</p>
<h2 id="python-tests"><a class="header" href="#python-tests">Python tests</a></h2>
<p>See
<a href="practices/testing/python_tests.html">this page</a>
for detailed coverage of how to write a python test.</p>
<p>We have a python library that allows one to create and run python tests.</p>
<p>To run python tests, from the <code>nearcore</code> repo the first time, do the following:</p>
<pre><code class="language-shell">cd pytest
virtualenv . --python=python3
. .env/bin/activate
pip install -r requirements.txt
python tests/sanity/block_production.py
</code></pre>
<p>This will create a python virtual environment, activate the environment, install
all the required packages specified in the <code>requirements.txt</code> file and run the
<code>tests/sanity/block_production.py</code> file. After the first time, we only need to
activate the environment and can then run the tests:</p>
<pre><code class="language-shell">cd pytest
. .env/bin/activate
python tests/sanity/block_production.py
</code></pre>
<p>Use <code>pytest/tests/sanity/block_production.py</code> as the basic example of starting a
cluster with multiple nodes, and doing RPC calls.</p>
<p>See <code>pytest/tests/sanity/deploy_call_smart_contract.py</code> to see how contracts can
be deployed, or transactions called.</p>
<p>See <code>pytest/tests/sanity/staking1.py</code> to see how staking transactions can be
issued.</p>
<p>See <code>pytest/tests/sanity/state_sync.py</code> to see how to delay the launch of the
whole cluster by using <code>init_cluster</code> instead of <code>start_cluster</code>, and then
launching nodes manually.</p>
<h3 id="enabling-adversarial-behavior"><a class="header" href="#enabling-adversarial-behavior">Enabling adversarial behavior</a></h3>
<p>To allow testing adversarial behavior, or generally, behaviors that a node should
not normally exercise, we have certain features in the code decorated with
<code>#[cfg(feature=&quot;adversarial&quot;)]</code>. The binary normally is compiled with the
feature disabled, and when compiled with the feature enabled, it traces a
warning on launch.</p>
<p>The nightly runner runs all the python tests against the binary compiled with
the feature enabled, and thus the python tests can make the binary perform
actions that it normally would not perform.</p>
<p>The actions can include lying about the known chain height, producing multiple
blocks for the same height, or disabling doomslug.</p>
<p>See all the tests under <code>pytest/tests/adversarial</code> for some examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-tests-1"><a class="header" href="#python-tests-1">Python Tests</a></h1>
<p>To simplify writing integration tests for nearcore we have a python
infrastructure that allows writing a large variety of tests that run small local
clusters, remove clusters, or run against full-scale live deployments.</p>
<p>Such tests are written in python and not in Rust (in which the nearcore itself,
and most of the sanity and fuzz tests, are written) due to the availability of
libraries to easily connect to, remove nodes and orchestrate cloud instances.</p>
<p>Nearcore itself has several features guarded by a
<a href="https://doc.rust-lang.org/1.29.0/book/first-edition/conditional-compilation.html">feature flag</a>
that allows the python tests to invoke behaviors otherwise impossible to be
exercised by an honest actor.</p>
<h1 id="basics-1"><a class="header" href="#basics-1">Basics</a></h1>
<p>The infrastructure is located in <code>{nearcore}/pytest/lib</code> and the tests themselves
are in subdirectories of <code>{nearcore}/pytest/tests</code>. To prepare the local machine to
run the tests you'd need python3 (python 3.7), and have several dependencies
installed, for which we recommend using virtualenv:</p>
<pre><code>cd pytest
virtualenv .env --python=python3
. .env/bin/activate
pip install -r requirements.txt
</code></pre>
<p>The tests are expected to be ran from the <code>pytest</code> dir itself. For example, once
the virtualenv is configured:</p>
<pre><code>cd pytest
. .env/bin/activate
python tests/sanity/block_production.py
</code></pre>
<p>This will run the most basic tests that spin up a small cluster locally and wait
until it produces several blocks.</p>
<h2 id="compiling-the-client-for-tests"><a class="header" href="#compiling-the-client-for-tests">Compiling the client for tests</a></h2>
<p>The local tests by default expect the binary to be in the default location for a
debug build (<code>{nearcore}/target/debug</code>). Some tests might also expect
test-specific features guarded by a feature flag to be available. To compile the
binary with such features run:</p>
<pre><code>cargo build -p neard --features=adversarial
</code></pre>
<p>The feature is called <code>adversarial</code> to highlight that the many functions it enables,
outside of tests, would constitute malicious behavior. The node compiled with
such a flag will not start unless an environment variable <code>ADVERSARY_CONSENT=1</code>
is set and prints a noticeable warning when it starts, thus minimizing the chance
that an honest participant accidentally launches a node compiled with such
functionality.</p>
<p>You can change the way the tests run (locally or using Google Cloud), and where
the local tests look for the binary by supplying a config file. For example, if you
want to run tests against a release build, you can create a file with the
following config:</p>
<pre><code class="language-json">{&quot;local&quot;: true, &quot;near_root&quot;: &quot;../target/release/&quot;}
</code></pre>
<p>and run the test with the following command:</p>
<pre><code class="language-shell">NEAR_PYTEST_CONFIG=&lt;path to config&gt; python tests/sanity/block_production.py
</code></pre>
<h1 id="writing-tests"><a class="header" href="#writing-tests">Writing tests</a></h1>
<p>We differentiate between &quot;regular&quot; tests, or tests that spin up their cluster,
either local or on the cloud, and &quot;mocknet&quot; tests, or tests that run against
an existing live deployment of NEAR.</p>
<p>In both cases, the test starts by importing the infrastructure and starting or
connecting to a cluster</p>
<h2 id="starting-a-cluster"><a class="header" href="#starting-a-cluster">Starting a cluster</a></h2>
<p>In the simplest case a regular test starts by starting a cluster. The cluster
will run locally by default but can be spun up on the cloud by supplying the
corresponding config.</p>
<pre><code class="language-python">import sys
sys.path.append('lib')
from cluster import start_cluster

nodes = start_cluster(4, 0, 4, None, [[&quot;epoch_length&quot;, 10], [&quot;block_producer_kickout_threshold&quot;, 80]], {})
</code></pre>
<p>In the example above the first three parameters are <code>num_validating_nodes</code>,
<code>num_observers</code> and <code>num_shards</code>. The third parameter is a config, which generally
should be <code>None</code>, in which case the config is picked up from the environment
variable as shown above.</p>
<p><code>start_cluster</code> will spin up <code>num_validating_nodes</code> nodes that are block
producers (with pre-staked tokens), <code>num_observers</code> non-validating nodes and
will configure the system to have <code>num_shards</code> shards. The fifth argument
changes the genesis config. Each element is a list of some length <code>n</code> where the
first <code>n-1</code> elements are a path in the genesis JSON file, and the last element
is the value. You'd often want to significantly reduce the epoch length, so that
your test triggers epoch switches, and reduce the kick-out threshold since with
shorter epochs it is easier for a block producer to get kicked out.</p>
<p>The last parameter is a dictionary from the node ordinal to changes to their
local config.</p>
<p>Note that <code>start_cluster</code> spins up all the nodes right away. Some tests (e.g.
tests that test syncing) might want to configure the nodes but delay their
start. In such a case you will initialize the cluster by calling
<code>init_cluster</code> and will run the nodes manually, for example, see
<a href="https://github.com/near/nearcore/blob/master/pytest/tests/sanity/state_sync.py"><code>state_sync.py</code></a></p>
<h2 id="connecting-to-a-mocknet"><a class="header" href="#connecting-to-a-mocknet">Connecting to a mocknet</a></h2>
<p>Nodes that run against a mocknet would connect to an existing cluster instead of
running their own.</p>
<pre><code class="language-python">import sys
sys.path.append('lib')
from cluster import connect_to_mocknet

nodes, accounts = connect_to_mocknet(None)
</code></pre>
<p>The only parameter is a config, with <code>None</code> meaning to use the config from the
environment variable. The config should have the following format:</p>
<pre><code class="language-json">{
    &quot;nodes&quot;: [
        {&quot;ip&quot;: &quot;(some_ip)&quot;, &quot;port&quot;: 3030},
        {&quot;ip&quot;: &quot;(some_ip)&quot;, &quot;port&quot;: 3030},
        {&quot;ip&quot;: &quot;(some_ip)&quot;, &quot;port&quot;: 3030},
        {&quot;ip&quot;: &quot;(some_ip)&quot;, &quot;port&quot;: 3030}
    ],
    &quot;accounts&quot;: [
        {&quot;account_id&quot;: &quot;node1&quot;, &quot;pk&quot;: &quot;ed25519:&lt;public key&gt;&quot;, &quot;sk&quot;: &quot;edd25519:&lt;secret key&gt;&quot;},
        {&quot;account_id&quot;: &quot;node2&quot;, &quot;pk&quot;: &quot;ed25519:&lt;public key&gt;&quot;, &quot;sk&quot;: &quot;edd25519:&lt;secret key&gt;&quot;}
    ]
}
</code></pre>
<h2 id="manipulating-nodes"><a class="header" href="#manipulating-nodes">Manipulating nodes</a></h2>
<p>The nodes returned by <code>start_cluster</code> and <code>init_cluster</code> have certain
convenience functions. You can see the full interface in
<code>{nearcore}/pytest/lib/cluster.py</code>.</p>
<p><code>start(boot_public_key, (boot_ip, boot_port))</code> starts the node. If both
arguments are <code>None</code>, the node will start as a boot node (note that the concept
of a &quot;boot node&quot; is relatively vague in a decentralized system, and from the
perspective of the tests the only requirement is that the graph of &quot;node A
booted from node B&quot; is connected).</p>
<p>The particular way to get the <code>boot_ip</code> and <code>boot_port</code> when launching <code>node1</code>
with <code>node2</code> being its boot node is the following:</p>
<pre><code class="language-python">node1.start(node2.node_key.pk, node2.addr())
</code></pre>
<p><code>kill()</code> shuts down the node by sending it <code>SIGKILL</code></p>
<p><code>reset_data()</code> cleans up the data dir, which could be handy between the calls to
<code>kill</code> and <code>start</code> to see if a node can start from a clean state.</p>
<p>Nodes on the mocknet do not expose <code>start</code>, <code>kill</code> and <code>reset_data</code>.</p>
<h2 id="issuing-rpc-calls"><a class="header" href="#issuing-rpc-calls">Issuing RPC calls</a></h2>
<p>Nodes in both regular and mocknet tests expose an interface to issue RPC calls.
In the most generic case, one can just issue raw JSON RPC calls by calling the
<code>json_rpc</code> method:</p>
<pre><code class="language-python">validator_info = nodes[0].json_rpc('validators', [&lt;some block_hash&gt;])
</code></pre>
<p>For the most popular calls, there are convenience functions:</p>
<ul>
<li><code>send_tx</code> sends a signed transaction asynchronously</li>
<li><code>send_tx_and_wait</code> sends a signed transaction synchronously</li>
<li><code>get_status</code> returns the current status (the output of the <code>/status/endpoint</code>),
which contains e.g. last block hash and height</li>
<li><code>get_tx</code> returns a transaction by the transaction hash and the recipient ID.</li>
</ul>
<p>See all the methods in <code>{nearcore}/pytest/lib/cluster.rs</code> after the definition
of the <code>json_rpc</code> method.</p>
<h3 id="signing-and-sending-transactions"><a class="header" href="#signing-and-sending-transactions">Signing and sending transactions</a></h3>
<p>There are two ways to send a transaction. A synchronous way (<code>send_tx_and_wait</code>)
sends a tx and blocks the test execution until either the TX is finished, or the
timeout is hit. An asynchronous way (<code>send_tx</code> + <code>get_tx</code>) sends a TX and then
verifies its result later. Here's an end-to-end example of sending a
transaction:</p>
<pre><code class="language-python"># the tx needs to include one of the recent hashes
last_block_hash = nodes[0].get_status()['sync_info']['latest_block_hash']
last_block_hash_decoded = base58.b58decode(last_block_hash.encode('utf8'))

# sign the actual transaction
# `fr` and `to` in this case are instances of class `Key`.
# In mocknet tests the list `Key`s for all the accounts are returned by `connect_to_mocknet`
# In regular tests each node is associated with a single account, and its key is stored in the
# `signer_key` field (e.g. `nodes[0].signer_key`)
# `15` in the example below is the nonce. Nonces needs to increase for consecutive transactions
# for the same sender account.
tx = sign_payment_tx(fr, to.account_id, 100, 15, last_block_hash_decoded)

# Sending the transaction synchronously. `10` is the timeout in seconds. If after 10 seconds the
# outcome is not ready, throws an exception
if want_sync:
    outcome = nodes[0].send_tx_and_wait(tx, 10)

# Sending the transaction asynchronously.
if want_async:
    tx_hash = nodes[from_ordinal % len(nodes)].send_tx(tx)['result']

    # and then sometime later fetch the result...
    resp = nodes[0].get_tx(tx_hash, to.account_id, timeout=1)
    # and see if the tx has finished
    finished = 'result' in resp and 'receipts_outcome' in resp['result'] and len(resp['result']['receipts_outcome']) &gt; 0
</code></pre>
<p>See
<a href="https://github.com/near/nearcore/blob/master/pytest/tests/sanity/rpc_tx_forwarding.py">rpc_tx_forwarding.py</a>
for an example of signing and submitting a transaction.</p>
<h2 id="adversarial-behavior"><a class="header" href="#adversarial-behavior">Adversarial behavior</a></h2>
<p>Some tests need certain nodes in the cluster to exercise behavior that is
impossible to be invoked by an honest node. For such tests, we provide
functionality that is protected by an &quot;adversarial&quot; feature flag.</p>
<p>It's an advanced feature, and more thorough documentation is a TODO. Most of the
tests that depend on the feature flag enabled are under
<code>{nearcore}/pytest/tests/adversarial</code>, refer to them for how such features can
be used. Search for code in the <code>nearcore</code> codebase guarded by the &quot;adversarial&quot;
feature flag for an example of how such features are added and exposed.</p>
<h2 id="interfering-with-the-network"><a class="header" href="#interfering-with-the-network">Interfering with the network</a></h2>
<p>We have a library that allows running a proxy in front of each node that would
intercept all the messages between nodes, deserialize them in python and run a
handler on each one. The handler can then either let the message pass (<code>return True</code>), drop it (<code>return False</code>) or replace it (<code>return &lt;new message&gt;</code>).</p>
<p>This technique can be used to both interfere with the network (by dropping or
replacing messages), and to inspect messages that flow through the network
without interfering with them. For the latter, note that the handler for each node
runs in a separate <code>Process</code>, and thus you need to use <code>multiprocessing</code>
primitives if you want the handlers to exchange information with the main test
process, or between each other.</p>
<p>See the tests that match <code>tests/sanity/proxy_*.py</code> for examples.</p>
<h1 id="contributing-tests"><a class="header" href="#contributing-tests">Contributing tests</a></h1>
<p>We always welcome new tests, especially python tests that use the above
infrastructure. We have a list of test requests
<a href="https://github.com/nearprotocol/nearcore/issues?q=is%3Aissue+is%3Aopen+label%3A%22A-testing%22">here</a>,
but also welcome any other tests that test aspects of the network we haven't
thought about.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cheat-sheetoverview-of-testing-utils"><a class="header" href="#cheat-sheetoverview-of-testing-utils">Cheat sheet/overview of testing utils</a></h1>
<p>This page covers the different testing utils/libraries that we have for easier
unit testing in Rust.</p>
<h2 id="basics-2"><a class="header" href="#basics-2">Basics</a></h2>
<h3 id="cryptohash"><a class="header" href="#cryptohash">CryptoHash</a></h3>
<p>To create a new crypto hash:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&quot;ADns6sqVyFLRZbSMCGdzUiUPaDDtjTmKCWzR8HxWsfDU&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h3 id="account"><a class="header" href="#account">Account</a></h3>
<p>Also, prefer doing parse + unwrap:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let alice: AccountId = &quot;alice.near&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h3 id="signatures"><a class="header" href="#signatures">Signatures</a></h3>
<p>In memory signer (generates the key based on a seed). There is a slight preference
to use the seed that is matching the account name.</p>
<p>This will create a signer for account 'test' using 'test' as a seed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let signer: InMemoryValidatorSigner = create_test_signer(&quot;test&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="block"><a class="header" href="#block">Block</a></h3>
<p>Use <code>TestBlockBuilder</code> to create the block that you need. This class allows you to set custom values for most of the fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let test_block = test_utils::TestBlockBuilder::new(prev, signer).height(33).build();
<span class="boring">}
</span></code></pre></pre>
<h2 id="store"><a class="header" href="#store">Store</a></h2>
<p>Use the in-memory test store in tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let store = create_test_store();
<span class="boring">}
</span></code></pre></pre>
<h2 id="epochmanager"><a class="header" href="#epochmanager">EpochManager</a></h2>
<p>See usages of MockEpochManager. Note that this is deprecated. Try to use
EpochManager itself wherever possible.</p>
<h2 id="runtime-1"><a class="header" href="#runtime-1">Runtime</a></h2>
<p>You can use the KeyValueRuntime (instead of the Nightshade one):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>KeyValueRuntime::new(store, &amp;epoch_manager);
<span class="boring">}
</span></code></pre></pre>
<h2 id="chain"><a class="header" href="#chain">Chain</a></h2>
<p>No fakes or mocks.</p>
<h2 id="client-1"><a class="header" href="#client-1">Client</a></h2>
<p>TestEnv - for testing multiple clients (without network):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TestEnvBuilder::new(genesis).client(vec![&quot;aa&quot;]).validators(..).epoch_managers(..).build();
<span class="boring">}
</span></code></pre></pre>
<h2 id="network-1"><a class="header" href="#network-1">Network</a></h2>
<h3 id="peermanager"><a class="header" href="#peermanager">PeerManager</a></h3>
<p>To create a PeerManager handler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pm = peer_manager::testonly::start(...).await;
<span class="boring">}
</span></code></pre></pre>
<p>To connect to others:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pm.connect_to(&amp;pm2.peer_info).await;
<span class="boring">}
</span></code></pre></pre>
<h3 id="events-handling"><a class="header" href="#events-handling">Events handling</a></h3>
<p>To wait/handle a given event (as a lot of network code is running in an async fashion):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pm.events.recv_util(|event| match event {...}).await;
<span class="boring">}
</span></code></pre></pre>
<h2 id="end-to-end"><a class="header" href="#end-to-end">End to End</a></h2>
<h3 id="chain-runtime-signer"><a class="header" href="#chain-runtime-signer">chain, runtime, signer</a></h3>
<p>In chain/chain/src/test_utils.rs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Creates 1-validator (test):  chain, KVRuntime and a signer
let (chain, runtime, signer) = setup();
<span class="boring">}
</span></code></pre></pre>
<h3 id="block-client-actor-view-client"><a class="header" href="#block-client-actor-view-client">block, client actor, view client</a></h3>
<p>In chain/client/src/test_utils.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (block, client, view_client) = setup(MANY_FIELDS);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h1>
<p>In order to focus the testing effort where it is most needed, we have a few
ways we track test coverage.</p>
<h2 id="codecov"><a class="header" href="#codecov">Codecov</a></h2>
<p>The main one is Codecov. Coverage is visible <a href="https://app.codecov.io/gh/near/nearcore">on this
webpage</a>, and displays the total
coverage, including unit and integration tests. Codecov is especially
interesting for <a href="https://github.com/near/nearcore/pull/10731#issuecomment-1985356880">its PR
comments</a>.
The PR comments, in particular, can easily show which diff lines are being
tested and which are not.</p>
<p>However, sometimes Codecov gives too rough estimates, and this is where
artifact results come in.</p>
<h2 id="artifact-results"><a class="header" href="#artifact-results">Artifact Results</a></h2>
<p>We also push artifacts, as a result of each CI run. You can access them here:</p>
<ol>
<li>Click &quot;Details&quot; on one of the CI actions run on your PR (literally any one
of the actions is fine, you can also access CI actions runs on any CI)</li>
<li>Click &quot;Summary&quot; on the top left of the opening page</li>
<li>Scroll to the bottom of the page</li>
<li>In the &quot;Artifacts&quot; section, just above the &quot;Summary&quot; section, there is a
<code>coverage-html</code> link (there is also <code>coverage-lcov</code> for people who use eg.
the coverage gutters vscode integration)</li>
<li>Downloading it will give you a zip file with the interesting files.</li>
</ol>
<p>In there, you can find:</p>
<ul>
<li>Two <code>-diff</code> files, that contain code coverage for the diff of your PR, to
easily see exactly which lines are covered and which are not</li>
<li>Two <code>-full</code> folders, that contain code coverage for the whole repository</li>
<li>Each of these exists in one <code>unit-</code> variant, that only contains the unit
tests, and one <code>integration-</code> variant, that contains all the tests we
currently have</li>
</ul>
<p><strong>To check that your PR is properly tested</strong>, if you want better quality
coverage than what codecov &quot;requires,&quot; you can have a look at <code>unit-diff</code>,
because we agreed that we want unit tests to be able to detect most bugs
due to the troubles of debugging failing integration tests.</p>
<p><strong>To find a place that would deserve adding more tests</strong>, look at one of the
<code>-full</code> directories on master, pick one not-well-tested file, and add (ideally
unit) tests for the lines that are missing.</p>
<p>The presentation is unfortunately less easy to access than codecov, and less
eye-catchy. On the other hand, it should be more precise. In particular, the
<code>-full</code> variants show region-based coverage. It can tell you that eg. the <code>?</code>
branch is not covered properly by highlighting it red.</p>
<p>One caveat to be aware of: the <code>-full</code> variants do not highlight covered lines
in green, they just highlight non-covered lines in red.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="protocol-upgrade"><a class="header" href="#protocol-upgrade">Protocol Upgrade</a></h2>
<p>This document describes the entire cycle of how a protocol upgrade is done, from
the initial PR to the final release. It is important for everyone who
contributes to the development of the protocol and its client(s) to understand
this process.</p>
<h3 id="background-1"><a class="header" href="#background-1">Background</a></h3>
<p>At NEAR, we use the term protocol version to mean the version of the blockchain
protocol and is separate from the version of some specific client (such as nearcore),
since the protocol version defines the protocol rather than some specific
implementation of the protocol. More concretely, for each epoch, there is a
corresponding protocol version that is agreed upon by validators through
<a href="https://github.com/near/NEPs/blob/master/specs/ChainSpec/Upgradability.md">a voting mechanism</a>.
Our upgrade scheme dictates that protocol version X is backward compatible with
protocol version X-1 so that nodes in the network can seamlessly upgrade to
the new protocol. However, there is <strong>no guarantee</strong> that protocol version X is
backward compatible with protocol version X-2.</p>
<p>Despite the upgrade mechanism, rolling out a protocol change can be scary,
especially if the change is invasive. For those changes, we may want to have
several months of testing before we are confident that the change itself works
and that it doesn't break other parts of the system.</p>
<h3 id="protocol-version-voting-and-upgrade"><a class="header" href="#protocol-version-voting-and-upgrade">Protocol version voting and upgrade</a></h3>
<p>When a new neard version, containing a new protocol version, is released, all node maintainers need 
to upgrade their binary. That typically means stopping neard, downloading or compiling the new neard
binary and restarting neard. However the protocol version of the whole network is not immediately 
bumped to the new protocol version. Instead a process called voting takes place and determines if and 
when the protocol version upgrade will take place. </p>
<p>Voting is a fully automated process in which all block producers across the network vote in support 
or against upgrading the protocol version. The voting happens in the last block every epoch. Upgraded
nodes will begin voting in favour of the new protocol version after a predetermined date. The voting 
date is configured by the release owner <a href="https://github.com/near/nearcore/commit/9b0275de057a01f87c259580f93e58f746da75aa">like this</a>. 
Once at least 80% of the stake votes in favour of the protocol change in the last block of epoch X, the 
protocol version will be upgraded in the first block of epoch X+2. </p>
<p>For mainnet releases, the release on github typically happens on a Monday or Tuesday, the voting 
typically happens a week later and the protocol version upgrade happens 1-2 epochs after the voting. This 
gives the node maintainers enough time to upgrade their neard nodes. The node maintainers can upgrade
their nodes at any time between the release and the voting but it is recommended to upgrade soon after the
release. This is to accommodate for any database migrations or miscellaneous delays. </p>
<p>Starting a neard node with protocol version voting in the future in a network that is already operating 
at that protocol version is supported as well. This is useful in the scenario where there is a mainnet 
security release where mainnet has not yet voted or upgraded to the new version. That same binary with
protocol voting date in the future can be released in testnet even though it has already upgraded to 
the new protocol version.</p>
<h3 id="nightly-protocol-features"><a class="header" href="#nightly-protocol-features">Nightly Protocol features</a></h3>
<p>To make protocol upgrades more robust, we introduce the concept of a nightly
protocol version together with the protocol feature flags to allow easy testing
of the cutting-edge protocol changes without jeopardizing the stability of the
codebase overall. The use of the nightly and nightly_protocol for new features
is mandatory while the use of dedicated rust features for new protocol features 
is optional and only recommended when necessary. Adding rust features leads to 
conditional compilation which is generally not developer friendly. In <code>Cargo.toml</code>
file of the crates we have in nearcore, we introduce rust compile-time features
<code>nightly_protocol</code> and <code>nightly</code>:</p>
<pre><code class="language-toml">nightly_protocol = []
nightly = [
    &quot;nightly_protocol&quot;,
    ...
]
</code></pre>
<p>where <code>nightly_protocol</code> is a marker feature that indicates that we are on
nightly protocol whereas <code>nightly</code> is a collection of new protocol features
which also implies <code>nightly_protocol</code>. </p>
<p>When it is not necessary to use a rust feature for the new protocol feature 
the Cargo.toml file will remain unchanged.</p>
<p>When it is necessary to use a rust feature for the new protocol feature, it 
can be added to the Cargo.toml, to the nightly features. For example, when
we introduce EVM as a new protocol change, suppose the current protocol
version is 40, then we would do the following change in Cargo.toml:</p>
<pre><code class="language-toml">nightly_protocol = []
nightly = [
    &quot;nightly_protocol&quot;,
    &quot;protocol_features_evm&quot;,
    ...
]
</code></pre>
<p>In <a href="https://github.com/near/nearcore/blob/master/core/primitives/src/version.rs">core/primitives/src/version.rs</a>, we would
change the protocol version by:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = “nightly_protocol”)]
pub const PROTOCOL_VERSION: u32 = 100;
#[cfg(not(feature = “nightly_protocol”)]
pub const PROTOCOL_VERSION: u32 = 40;
<span class="boring">}
</span></code></pre></pre>
<p>This way the stable versions remain unaffected after the change. Note that
nightly protocol version intentionally starts at a much higher number to make
the distinction between the stable protocol and nightly protocol clearer.</p>
<p>To determine whether a protocol feature is enabled, we do the following:</p>
<ul>
<li>We maintain a <code>ProtocolFeature</code> enum where each variant corresponds to some
protocol feature. For nightly protocol features, the variant may optionally
be gated by the corresponding rust compile-time feature.</li>
<li>We implement a function <code>protocol_version</code> to return, for each variant, the
corresponding protocol version in which the feature is enabled.</li>
<li>When we need to decide whether to use the new feature based on the protocol
version of the current network, we can simply compare it to the protocol
version of the feature. To make this simpler, we also introduced a macro
<code>checked_feature</code></li>
</ul>
<p>For more details, please refer to
<a href="https://github.com/near/nearcore/blob/master/core/primitives/src/version.rs">core/primitives/src/version.rs</a>.</p>
<h3 id="feature-gating"><a class="header" href="#feature-gating">Feature Gating</a></h3>
<p>It is worth mentioning that there are two types of checks related to protocol features:</p>
<ul>
<li>Runtime checks that compare the protocol version of the current epoch and
the protocol version of the feature. Those runtime checks must be used for
both stable and nightly features.</li>
<li>Compile time checks that check if the rust feature corresponding with the
protocol feature is enabled. This check is optional and can only be used for
nightly features.</li>
</ul>
<h3 id="testing-1"><a class="header" href="#testing-1">Testing</a></h3>
<p>Nightly protocol features allow us to enable the most bleeding-edge code in some
testing environments. We can choose to enable all nightly protocol features by</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo build -p neard --release --features nightly
<span class="boring">}
</span></code></pre></pre>
<p>or enable some specific protocol feature by</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo build -p neard --release --features nightly_protocol,&lt;protocol_feature&gt;
<span class="boring">}
</span></code></pre></pre>
<p>In practice, we have all nightly protocol features enabled for Nayduck tests and
on betanet, which is updated daily.</p>
<h3 id="feature-stabilization"><a class="header" href="#feature-stabilization">Feature Stabilization</a></h3>
<p>New protocol features are introduced first as nightly features and when the
author of the feature thinks that the feature is ready to be stabilized, they
should submit a pull request to stabilize the feature using
<a href="practices/../../.github/PULL_REQUEST_TEMPLATE/feature_stabilization.html">this template</a>.
In this pull request, they should do the feature gating, increase the
<code>PROTOCOL_VERSION</code> constant (if it hasn't been increased since the last
release), and change the <code>protocol_version</code> implementation to map the
stabilized features to the new protocol version.</p>
<p>A feature stabilization request must be approved by at least <strong>two</strong>
<a href="https://github.com/orgs/near/teams/nearcore-codeowners">nearcore code owners</a>.
Unless it is a security-related fix, a protocol feature cannot be included in
any release until at least <strong>one</strong> week after its stabilization. This is to ensure
that feature implementation and stabilization are not rushed.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This document describes the advanced network options that you can configure
by modifying the &quot;network&quot; section of your &quot;config.json&quot; file:</p>
<pre><code>{
  // ...
  &quot;network&quot;: {
    // ...
    &quot;public_addrs&quot;: [],
    &quot;allow_private_ip_in_public_addrs&quot;: false,
    &quot;experimental&quot;: {
      &quot;inbound_disabled&quot;: false,
      &quot;connect_only_to_boot_nodes&quot;: false,
      &quot;skip_sending_tombstones_seconds&quot;: 0,
      &quot;tier1_enable_inbound&quot;: true,
      &quot;tier1_enable_outbound&quot;: false,
      &quot;tier1_connect_interval&quot;: {
        &quot;secs&quot;: 60,
        &quot;nanos&quot;: 0
      },
      &quot;tier1_new_connections_per_attempt&quot;: 50
    }
  },
  // ...
}
</code></pre>
<h3 id="tier1-network"><a class="header" href="#tier1-network">TIER1 network</a></h3>
<p>Participants of the BFT consensus (block &amp; chunk producers) now can establish
direct (aka TIER1) connections between each other, which will optimize the
communication latency and minimize the number of dropped chunks. If you are a
validator, you can enable TIER1 connections by setting the following fields in the config:</p>
<ul>
<li><a href="https://github.com/near/nearcore/blob/d95a5f58d998c69cb8d4e965ad6b0a440cf3f233/chain/network/src/config_json.rs#L154">public_addrs</a>
<ul>
<li>this is a list of the public addresses (in the format <code>&quot;&lt;node public key&gt;@&lt;IP&gt;:&lt;port&gt;&quot;</code>)
of trusted nodes, which are willing to route messages to your node</li>
<li>this list will be broadcasted to the network so that other validator nodes can connect
to your node.</li>
<li>if your node has a static public IP, set <code>public_addrs</code> to a list with a single entry
with the public key and address of your node, for example:
<code>&quot;public_addrs&quot;: [&quot;ed25519:86EtEy7epneKyrcJwSWP7zsisTkfDRH5CFVszt4qiQYw@31.192.22.209:24567&quot;]</code>.</li>
<li>if your node doesn't have a public IP (for example, it is hidden behind a NAT), set
<code>public_addrs</code> to a list (&lt;=10 entries) of proxy nodes that you trust (arbitrary nodes
with static public IPs).</li>
<li>support for nodes with dynamic public IPs is not implemented yet.</li>
</ul>
</li>
<li><a href="https://github.com/near/nearcore/blob/d95a5f58d998c69cb8d4e965ad6b0a440cf3f233/chain/network/src/config_json.rs#L213">experimental.tier1_enable_outbound</a>
<ul>
<li>makes your node actively try to establish outbound TIER1 connections (recommended)
once it learns about the public addresses of other validator nodes. If disabled, your
node won't try to establish outbound TIER1 connections, but it still may accept
incoming TIER1 connections from other nodes.</li>
<li>currently <code>false</code> by default, but will be changed to <code>true</code> by default in the future</li>
</ul>
</li>
<li><a href="https://github.com/near/nearcore/blob/d95a5f58d998c69cb8d4e965ad6b0a440cf3f233/chain/network/src/config_json.rs#L209">experimental.tier1_enable_inbound</a>
<ul>
<li>makes your node accept inbound TIER1 connections from other validator nodes.</li>
<li>disable both <code>tier1_enable_inbound</code> and <code>tier1_enable_outbound</code> if you want to opt-out
from the TIER1 communication entirely</li>
<li>disable <code>tier1_enable_inbound</code> if you are not a validator AND you don't want your
node to act as a proxy for validators.</li>
<li><code>true</code> by default</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starting-a-test-chain-from-state-taken-from-mainnet-or-testnet"><a class="header" href="#starting-a-test-chain-from-state-taken-from-mainnet-or-testnet">Starting a test chain from state taken from mainnet or testnet</a></h1>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>For testing purposes, it is often desirable to start a test chain with
a starting state that looks like mainnet or testnet. This is usually
done for the purpose of testing changes to neard itself, but it's also
possible to do this if you're a contract developer and want to see
what a change to your contract would look like on top of the current
mainnet state. At the end of the process described here, you'll have
a set of genesis records that can be used to start your own test chain,
that'll be like any other test chain like the ones generated by the
<code>neard localnet</code> command, except with account balances and data taken
from mainnet</p>
<h2 id="how-to"><a class="header" href="#how-to">How-to</a></h2>
<p>The first step is to obtain an RPC node home directory for the chain
you'd like to spoon. So if you want to use mainnet state, you can
follow the instructions
<a href="https://near-nodes.io/rpc/run-rpc-node-without-nearup#5-get-data-backup-1">here</a>
to obtain a recent snapshot of a mainnet node's home directory. Once
you have your node's home directory set up, run the following
<code>state-viewer</code> command to generate a dump of the chain's state:</p>
<pre><code class="language-shell">$ neard --home $NEAR_HOME_DIRECTORY view-state dump-state --stream
</code></pre>
<p>This command will take a while (possibly many hours) to run. But at the
end you should have <code>genesis.json</code> and <code>records.json</code> files in
<code>$NEAR_HOME_DIRECTORY/output</code>. This records file represents all of the
chain's current state, and is what we'll use to start our chain.</p>
<p>From here, we need to make some changes to the <code>genesis.json</code> that was
generated in <code>$NEAR_HOME_DIRECTORY/output</code>. To see why, note that the
validators field of this genesis file lists all the current mainnet
validators and their keys. So that means if we were to try and start a
test chain from the generated genesis and records files as-is, it
would work, but our node would expect the current mainnet validators
to be producing blocks and chunks (which they definitely won't be!
Because we're the only ones who know or care about this new test
chain).</p>
<p>So we need to select a new list of validators to start off our
chain. Suppose that we want our chain to have two validators,
<code>validator0.near</code> and <code>validator1.near</code>. Let's make a new directory
where we'll be storing intermediate files during this process:</p>
<pre><code class="language-shell">$ mkdir ~/test-chain-scratch
</code></pre>
<p>then using your favorite editor, lay out the validators you want in
the test chain as a JSON list in the same format as the <code>validators</code>
field in <code>genesis.json</code>, maybe in the file
<code>~/test-chain-scratch/validators.json</code></p>
<pre><code class="language-json">[
  {
    &quot;account_id&quot;: &quot;validator0.near&quot;,
    &quot;public_key&quot;: &quot;ed25519:GRAFkrqEkJAbdbWUgc6fDnNpCTE83C3pzdJpjAHkMEhq&quot;,
    &quot;amount&quot;: &quot;100000000000000000000000000000000&quot;
  },
  {
    &quot;account_id&quot;: &quot;validator1.near&quot;,
    &quot;public_key&quot;: &quot;ed25519:5FxQQTC9mk5kLAhTF9ffDMTXiyYrDXyGYskgz46kHMdd&quot;,
    &quot;amount&quot;: &quot;100000000000000000000000000000000&quot;
  }
]
</code></pre>
<p>These validator keys should be keys you've already generated. So for
the rest of this document, we'll assume you've run:</p>
<pre><code class="language-shell">$ neard --home ~/near-test-chain/validator0 init --account-id validator0.near
$ neard --home ~/near-test-chain/validator1 init --account-id validator1.near
</code></pre>
<p>This is also a good time to think about what extra accounts you might
want in your test chain. Since all accounts in the test chain will
have the same keys as they do on mainnet, you'll only have access to
the accounts that you have access to on mainnet. If you want to add an
account with a large balance to properly test things out, you can
write them out in a file as a JSON list of state records (in the same
format as they appear in <code>records.json</code>). For example, you could put
the following in <code>~/test-chain-scratch/extra-records.json</code>:</p>
<pre><code class="language-json">[
  {
    &quot;Account&quot;: {
      &quot;account_id&quot;: &quot;my-test-account.near&quot;,
      &quot;account&quot;: {
        &quot;amount&quot;: &quot;10000000000000000000000000000000000&quot;,
        &quot;locked&quot;: &quot;0&quot;,
        &quot;code_hash&quot;: &quot;11111111111111111111111111111111&quot;,
        &quot;storage_usage&quot;: 182,
        &quot;version&quot;: &quot;V1&quot;
      }
    }
  },
  {
    &quot;AccessKey&quot;: {
      &quot;account_id&quot;: &quot;my-test-account.near&quot;,
      &quot;public_key&quot;: &quot;ed25519:Eo9W44tRMwcYcoua11yM7Xfr1DjgR4EWQFM3RU27MEX8&quot;,
      &quot;access_key&quot;: {
        &quot;nonce&quot;: 0,
        &quot;permission&quot;: &quot;FullAccess&quot;
      }
    }
  }
]
</code></pre>
<p>You'll want to include an access key here, otherwise you won't be able
to do anything with the account. Note that here you can also add
access keys for any mainnet account you want, so you'll be able to
control it in the test chain.</p>
<p>Now to make these changes to the genesis and records files, you can
use the <code>neard amend-genesis</code> command like so:</p>
<pre><code class="language-shell"># mkdir ~/near-test-chain/
$ neard amend-genesis --genesis-file-in $NEAR_HOME_DIRECTORY/output/genesis.json --records-file-in $NEAR_HOME_DIRECTORY/output/records.json --validators ~/test-chain-scratch/validators.json --extra-records ~/test-chain-scratch/extra-records.json --chain-id $TEST_CHAIN_ID --records-file-out ~/near-test-chain/records.json --genesis-file-out ~/near-test-chain/genesis.json
</code></pre>
<h2 id="starting-the-network"><a class="header" href="#starting-the-network">Starting the network</a></h2>
<p>After running the previous steps you should have the files
<code>genesis.json</code> and <code>records.json</code> in <code>~/near-test-chain/</code>. Assuming
you've started it with the two validators <code>validator0.near</code> and
<code>validator1.near</code> as described above, you'll want to run at least two
nodes, one for each of these validator accounts. If you're working
with multiple computers or VMs that can connect to each other over the
internet, you'll be able to run your test network over the internet as
is done with the &quot;real&quot; networks (mainnet, testnet, etc.). But for now
let's assume that you want to run this on only one machine.</p>
<p>So assuming you've initialized home directories for each of the
validators with the <code>init</code> command described above, you'll want to
copy the records and genesis files generated in the previous step to
each of these:</p>
<pre><code class="language-shell">$ cp ~/near-test-chain/records.json ~/near-test-chain/validator0
$ cp ~/near-test-chain/genesis.json ~/near-test-chain/validator0
$ cp ~/near-test-chain/records.json ~/near-test-chain/validator1
$ cp ~/near-test-chain/genesis.json ~/near-test-chain/validator1
</code></pre>
<p>Now we'll need to make a few config changes to each of
<code>~/near-test-chain/validator0/config.json</code> and
<code>~/near-test-chain/validator1/config.json</code>:</p>
<p>changes to <code>~/near-test-chain/validator0/config.json</code>:</p>
<pre><code class="language-json">{
  &quot;genesis_records_file&quot;: &quot;records.json&quot;,
  &quot;rpc&quot;: {
    &quot;addr&quot;: &quot;0.0.0.0:3030&quot;
  },
  &quot;network&quot;: {
    &quot;addr&quot;: &quot;0.0.0.0:24567&quot;,
    &quot;boot_nodes&quot;: &quot;ed25519:Dk4A7NPBYFPwKWouiSUoyZ15igbLSrcPEJqUqDX4grb7@127.0.0.1:24568&quot;,
    &quot;skip_sync_wait&quot;: false,
  },
  &quot;consensus&quot;: {
    &quot;min_num_peers&quot;: 1
  },
  &quot;tracked_shards&quot;: [0],
}
</code></pre>
<p>changes to <code>~/near-test-chain/validator1/config.json</code>:</p>
<pre><code class="language-json">{
  &quot;genesis_records_file&quot;: &quot;records.json&quot;,
  &quot;rpc&quot;: {
    &quot;addr&quot;: &quot;0.0.0.0:3031&quot;
  },
  &quot;network&quot;: {
    &quot;addr&quot;: &quot;0.0.0.0:24568&quot;,
    &quot;boot_nodes&quot;: &quot;ed25519:6aR4xVQedQ7Z9URrASgwBY8bedpaYzgH8u5NqEHp2hBv@127.0.0.1:24567&quot;,
    &quot;skip_sync_wait&quot;: false,
  },
  &quot;consensus&quot;: {
    &quot;min_num_peers&quot;: 1
  },
  &quot;tracked_shards&quot;: [0],
}
</code></pre>
<p>Here we make sure to have each node listen on different ports, while
telling each about the other via <code>network.boot_nodes</code>. In this
<code>boot_nodes</code> string, we set the public key not to the validator key,
but to whatever key is present in the <code>node_key.json</code> file you got
when you initialized the home directory. So for <code>validator0</code>'s config,
we set its boot node to <code>validator1</code>'s node key, followed by the
address of the socket it should be listening on. We also want to drop
the minimum required number of peers, since we're just running a small
test network locally. We set <code>skip_sync_wait</code> to <code>false</code>, because
otherwise we get strange behavior that will often make your network
stall.</p>
<p>After making these changes, you can try running one neard process for
each of your validators:</p>
<pre><code class="language-shell">$ neard --home ~/near-test-chain/validator0 run
$ neard --home ~/near-test-chain/validator1 run
</code></pre>
<p>Now these nodes will begin by taking the records laid out in
<code>records.json</code> and turning them into a genesis state. At the time of
this writing, using the latest nearcore version from the master
branch, this will take a couple hours. But your validators should
begin producing blocks after that's done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-4"><a class="header" href="#overview-4">Overview</a></h1>
<p>This chapter holds various assorted bits of docs. If you want to document
something, but don't know where to put it, put it here!</p>
<h2 id="crate-versioning-and-publishing"><a class="header" href="#crate-versioning-and-publishing">Crate Versioning and Publishing</a></h2>
<p>While all the crates in the workspace are directly unversioned (<code>v0.0.0</code>), they
all share a unified variable version in the <a href="misc/../../Cargo.toml">workspace manifest</a>.
This keeps versions consistent across the workspace and informs their versions
at the moment of publishing.</p>
<p>We also have CI infrastructure set up to automate the publishing process to
crates.io. So, on every merge to master, if there's a version change, it is
automatically applied to all the crates in the workspace and it attempts to
publish the new versions of all non-private crates. All crates that should be
exempt from this process should be marked <code>private</code>. That is, they should have
the <code>publish = false</code> specification in their package manifest.</p>
<p>This process is managed by
<a href="https://github.com/pksunkara/cargo-workspaces">cargo-workspaces</a>, with a
<a href="https://github.com/pksunkara/cargo-workspaces/compare/master...miraclx:grouping-and-exclusion#files_bucket">bit of magic</a>
sprinkled on top.</p>
<h2 id="issue-labels"><a class="header" href="#issue-labels">Issue Labels</a></h2>
<p>Issue labels are of the following format <code>&lt;type&gt;-&lt;content&gt;</code> where <code>&lt;type&gt;</code> is a
capital letter indicating the type of the label and <code>&lt;content&gt;</code> is a hyphened
phrase indicating what this label is about. For example, in the label <code>C-bug</code>,
<code>C</code> means category and <code>bug</code> means that the label is about bugs. Common types
include <code>C</code>, which means category, <code>A</code>, which means area and <code>T</code>, which means team.</p>
<p>An issue can have multiple labels including which area it touches, which team
should be responsible for the issue, and so on. Each issue should have at least
one label attached to it after it is triaged and the label could be a general
one, such as <code>C-enhancement</code> or <code>C-bug</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="experimental-dump-state-to-external-storage"><a class="header" href="#experimental-dump-state-to-external-storage">Experimental: Dump State to External Storage</a></h1>
<h2 id="purpose-1"><a class="header" href="#purpose-1">Purpose</a></h2>
<p><a href="misc/../architecture/how/sync.html#step-2-state-sync-normal-node">State Sync</a> is being
reworked.</p>
<p>A new version is available for experimental use. This version gets state parts
from external storage. The following kinds of external storage are supported:</p>
<ul>
<li>Local filesystem</li>
<li>Google Cloud Storage</li>
<li>Amazon S3</li>
</ul>
<p>A new version of decentralized state sync is work in progress.</p>
<h2 id="how-to-1"><a class="header" href="#how-to-1">How-to</a></h2>
<p>neard release <code>1.36.0-rc.1</code> adds an experimental option to sync state from
external storage.</p>
<p>See <a href="misc/state_sync_from_external_storage.html">how-to</a> how to configure your node to
State Sync from External Storage.</p>
<p>In case you would like to manage your own dumps of State, keep reading.</p>
<h3 id="google-cloud-storage"><a class="header" href="#google-cloud-storage">Google Cloud Storage</a></h3>
<p>To enable Google Cloud Storage as your external storage, add this to your
<code>config.json</code> file:</p>
<pre><code class="language-json">&quot;state_sync&quot;: {
  &quot;dump&quot;: {
    &quot;location&quot;: {
      &quot;GCS&quot;: {
        &quot;bucket&quot;: &quot;my-gcs-bucket&quot;,
      }
    }
  }
}
</code></pre>
<p>And run your node with an environment variable <code>SERVICE_ACCOUNT</code> or
<code>GOOGLE_APPLICATION_CREDENTIALS</code> pointing to the credentials json file</p>
<pre><code class="language-shell">SERVICE_ACCOUNT=/path/to/file ./neard run
</code></pre>
<h3 id="amazon-s3"><a class="header" href="#amazon-s3">Amazon S3</a></h3>
<p>To enable Amazon S3 as your external storage, add this to your <code>config.json</code>
file:</p>
<pre><code class="language-json">&quot;state_sync&quot;: {
  &quot;dump&quot;: {
    &quot;location&quot;: {
      &quot;S3&quot;: {
        &quot;bucket&quot;: &quot;my-aws-bucket&quot;,
        &quot;region&quot;: &quot;my-aws-region&quot;
      }
    }    
  }
}
</code></pre>
<p>And run your node with environment variables <code>AWS_ACCESS_KEY_ID</code> and
<code>AWS_SECRET_ACCESS_KEY</code>:</p>
<pre><code class="language-shell">AWS_ACCESS_KEY_ID=&quot;MY_ACCESS_KEY&quot; AWS_SECRET_ACCESS_KEY=&quot;MY_AWS_SECRET_ACCESS_KEY&quot; ./neard run
</code></pre>
<h2 id="dump-to-a-local-filesystem"><a class="header" href="#dump-to-a-local-filesystem">Dump to a local filesystem</a></h2>
<p>Add this to your <code>config.json</code> file to dump state of every epoch to local
filesystem:</p>
<pre><code class="language-json">&quot;state_sync&quot;: {
  &quot;dump&quot;: {
    &quot;location&quot;: {
      &quot;Filesystem&quot;: {
        &quot;root_dir&quot;: &quot;/tmp/state-dump&quot;
      }
    }    
  }
}
</code></pre>
<p>In this case you don't need any extra environment variables. Simply run your
node:</p>
<pre><code class="language-shell">./neard run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archival-node---recovery-of-missing-data"><a class="header" href="#archival-node---recovery-of-missing-data">Archival node - Recovery of missing data</a></h1>
<h1 id="incident-description"><a class="header" href="#incident-description">Incident description</a></h1>
<p>In early 2024 there have been a few incidents on archival node storage. As result of these incidents archival node might have lost some data from January to March.</p>
<p>The practical effect of this issue is that requests querying the state of an account may fail, returning instead an internal server error.</p>
<h1 id="check-if-my-node-has-been-impacted"><a class="header" href="#check-if-my-node-has-been-impacted">Check if my node has been impacted</a></h1>
<p>The simplest way to check whether or not a node has suffered data loss is to run one of the following queries:</p>
<p><em>replace &lt;RPC_URL&gt; with the correct URL (example: http://localhost:3030)</em></p>
<pre><code class="language-bash">curl -X POST &lt;RPC_URL&gt; \
        -H &quot;Content-Type: application/json&quot; \
        -d '
        { &quot;id&quot;: &quot;dontcare&quot;, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;query&quot;, &quot;params&quot;: { &quot;account_id&quot;: &quot;b001b461c65aca5968a0afab3302a5387d128178c99ff5b2592796963407560a&quot;, &quot;block_id&quot;: 109913260, &quot;request_type&quot;: &quot;view_account&quot; } }'
</code></pre>
<pre><code class="language-bash">curl -X POST &lt;RPC_URL&gt; \
        -H &quot;Content-Type: application/json&quot; \
        -d '
        { &quot;id&quot;: &quot;dontcare&quot;, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;query&quot;, &quot;params&quot;: { &quot;account_id&quot;: &quot;token2.near&quot;, &quot;block_id&quot;: 114580308, &quot;request_type&quot;: &quot;view_account&quot; } }'
</code></pre>
<pre><code class="language-bash">curl -X POST &lt;RPC_URL&gt; \
        -H &quot;Content-Type: application/json&quot; \
        -d '
        { &quot;id&quot;: &quot;dontcare&quot;, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;query&quot;, &quot;params&quot;: { &quot;account_id&quot;: &quot;timpanic.tg&quot;, &quot;block_id&quot;: 115185110, &quot;request_type&quot;: &quot;view_account&quot; } }'
</code></pre>
<pre><code class="language-bash">curl -X POST &lt;RPC_URL&gt; \
        -H &quot;Content-Type: application/json&quot; \
        -d '
        { &quot;id&quot;: &quot;dontcare&quot;, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;query&quot;, &quot;params&quot;: { &quot;account_id&quot;: &quot;01.near&quot;, &quot;block_id&quot;: 115514400, &quot;request_type&quot;: &quot;view_account&quot; } }'
</code></pre>
<p>If for any of the above requests you get an error of the kind <code>MissingTrieValue</code> it means that the node presents the issue.</p>
<h1 id="remediation-steps"><a class="header" href="#remediation-steps">Remediation steps</a></h1>
<h2 id="option-a-recommended-download-a-new-db-snapshot"><a class="header" href="#option-a-recommended-download-a-new-db-snapshot">Option A (recommended): download a new DB snapshot</a></h2>
<ol>
<li>
<p>Stop <code>neard</code></p>
</li>
<li>
<p>Delete the existing <code>hot</code> and <code>cold</code> databases. Example assuming default configuration:</p>
<pre><code class="language-bash">rm -rf ~/.near/hot-data &amp;&amp; rm -rf ~/.near/cold-data
</code></pre>
</li>
<li>
<p>Download an up-to-date snapshot, following this guide: <a href="https://near-nodes.io/archival/split-storage-archival#S3%20migration">Storage snapshots</a></p>
</li>
</ol>
<h2 id="option-b-manually-run-recovery-commands"><a class="header" href="#option-b-manually-run-recovery-commands">Option B: manually run recovery commands</a></h2>
<p>Follow the instructions below if, for any reason, you prefer to perform the manual recovery steps on your node instead of downloading a new snapshot.</p>
<p><strong>Requirements:</strong></p>
<ul>
<li><code>neard</code> must be stopped while recovering data</li>
<li><code>cold</code> storage must be mounted on an SSD disk or better</li>
<li>The config <code>resharding_config.batch_delay</code> must be set to 0.</li>
</ul>
<p>After the recovery is finished the configuration changes can be undone and a hard disk drive can be used to mount the <code>cold</code> storage.</p>
<p><strong>Important considerations:</strong></p>
<ul>
<li>The recovery procedure will, most likely, take more than one week
<ul>
<li>Since <code>neard</code> must be stopped in order to execute the commands, the node won't be functional during this period of time</li>
</ul>
</li>
<li>The node must catch up to the chain's head after completing the data recovery, this could take days as well
<ul>
<li>During catch up the node can answer RPC queries. However, the chain head is still at the point where the node was stopped; for this reason recent blocks won't be available immediately</li>
</ul>
</li>
</ul>
<p>We published a <a href="https://github.com/near/nearcore/blob/master/scripts/recover_missing_archival_data.sh">reference recovery script</a> in the <code>nearcore</code> repository. Your <code>neard</code> setup might be different, so the advice is to thoroughly check the script before running it. For completeness, here we include the set of commands to run:</p>
<pre><code class="language-bash">neard view-state -t cold --readwrite apply-range --start-index 109913254 --end-index 110050000 --shard-id 2 --storage trie-free --save-state cold sequential
</code></pre>
<pre><code class="language-bash">RUST_LOG=debug neard database resharding --height 114580307 --shard-id 0 --restore
</code></pre>
<pre><code class="language-bash">RUST_LOG=debug neard database resharding --height 114580307 --shard-id 1 --restore
</code></pre>
<pre><code class="language-bash">RUST_LOG=debug neard database resharding --height 114580307 --shard-id 2 --restore
</code></pre>
<pre><code class="language-bash">RUST_LOG=debug neard database resharding --height 114580307 --shard-id 3 --restore
</code></pre>
<pre><code class="language-bash">RUST_LOG=debug neard database resharding --height 115185107 --shard-id 0 --restore
</code></pre>
<pre><code class="language-bash">RUST_LOG=debug neard database resharding --height 115185107 --shard-id 1 --restore
</code></pre>
<pre><code class="language-bash">RUST_LOG=debug neard database resharding --height 115185107 --shard-id 2 --restore
</code></pre>
<pre><code class="language-bash">RUST_LOG=debug neard database resharding --height 115185107 --shard-id 3 --restore
</code></pre>
<pre><code class="language-bash">RUST_LOG=debug neard database resharding --height 115185107 --shard-id 4 --restore
</code></pre>
<h2 id="verify-if-remediation-has-been-successful"><a class="header" href="#verify-if-remediation-has-been-successful">Verify if remediation has been successful</a></h2>
<p>Run the queries specified in the section: <a href="https://docs.nearone.org/doc/archival-node-recovery-of-missing-data-speQFTJc0L#h-check-if-my-node-has-been-impacted">Check if my node has been impacted</a>. All of them should return a successful response now.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
