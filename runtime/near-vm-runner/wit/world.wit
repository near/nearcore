package near:nearcore@0.1.0;

interface finite-wasm {
   gas-exhausted: func();
   stack-exhausted: func();
   burn-gas: func(gas: u64);
}

interface runtime {
   variant value-or-register {
     value(list<u8>),
     register(u64),
   }

   enum ecrecover-malleability {
      no-extra-checks,
      rejecting-upper-range,
   }

   record u128 {
     lo: u64,
     hi: u64,
   }

   resource account-id {
      from-string: static func(account-id: string) -> result<account-id>;
      to-string: func() -> string;
   }

   resource public-key {
      from-string: static func(public-key: string) -> result<public-key>;
      to-string: func() -> string;
      to-bytes: func() -> list<u8>;
   }

   // Reads the entire content from the register `register-id`
   read-register: func(register-id: u64) -> list<u8>;

   // Returns the size of the blob stored in the given register.
   // If register is not used, returns `none`.
   register-len: func(register-id: u64) -> option<u64>;

   // Copies `data` into the register. If register is unused will initialize
   // it. If register has larger capacity than needed for `data` will not re-allocate it. The
   // register will lose the pre-existing data if any.
   write-register: func(register-id: u64, data: list<u8>);

   // The id of the account that owns the current contract.
   current-account-id: func() -> account-id;

   // The id of the account that either signed the original transaction or issued the initial
   // cross-contract call.
   signer-account-id: func() -> account-id;

   // The public key of the account that did the signing.
   signer-account-pk: func() -> public-key;

   // The id of the account that was the previous contract in the chain of cross-contract calls.
   // If this is the first contract, it is equal to `signer_account_id`.
   predecessor-account-id: func() -> account-id;

   // The input to the contract call serialized as bytes.
   input: func() -> list<u8>;

   // Returns the current block height.
   block-height: func() -> u64;

   // Returns the current block timestamp (number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC).
   block-timestamp: func() -> u64;

   // Returns the current epoch height.
   epoch-height: func() -> u64;

   // Returns the number of bytes used by the contract if it was saved to the trie as of the
   // invocation. This includes:
   // * The data written with storage_* functions during current and previous execution;
   // * The bytes needed to store the access keys of the given account.
   // * The contract code size
   // * A small fixed overhead for account metadata.
   storage-usage: func() -> u64;

   // The current balance of the given account. This includes the attached_deposit that was
   // attached to the transaction.
   account-balance: func() -> u128;

   // The current amount of tokens locked due to staking.
   account-locked-balance: func() -> u128;

   // The balance that was attached to the call that will be immediately deposited before the
   // contract execution starts.
   attached-deposit: func() -> u128;

   // The amount of gas attached to the call that can be used to pay for the gas fees.
   prepaid-gas: func() -> u64;

   // The gas that was already burnt during the contract execution (cannot exceed `prepaid_gas`)
   used-gas: func() -> u64;

   // Returns the random seed from the current block. This 32 byte hash is based on the VRF value from
   // the block. This value is not modified in any way each time this function is called within the
   // same method/block.
   random-seed: func() -> list<u8>;

   // Hashes the given value using sha256 and returns it into `register-id`.
   sha256: func(value: value-or-register, register-id: u64);

   // Hashes the given value using keccak256 and returns it into `register_id`.
   keccak256: func(value: value-or-register, register-id: u64);

   // Hashes the given value using keccak512 and returns it into `register_id`.
   keccak512: func(value: value-or-register, register-id: u64);

   // Verify an ED25519 signature given a message and a public key.
   //
   // Returns a bool indicating success or failure.
   ed25519-verify: func(signature: value-or-register, message: list<u8>, public-key: borrow<public-key>) -> bool;

   // Hashes the given value using RIPEMD-160 and returns it into `register_id`.
   ripemd160: func(value: value-or-register, register-id: u64);

   // Recovers an ECDSA signer address and returns it into `register_id`.
   //
   // Takes in an additional flag to check for malleability of the signature
   // which is generally only ideal for transactions.
   //
   // Returns a bool indicating success or failure.
   ecrecover: func(hash: value-or-register, sig: value-or-register, v: u8, malleability: ecrecover-malleability, register-id: u64)-> bool;

   // Sets the blob of data as the return value of the contract.
   value-return: func(value: value-or-register);

   // Panics with the string.
   panic: func(s: option<string>);

   // Logs the string.
   log: func(s: string);

   // TODO: Document promise API

   resource promise-action {}

   resource promise {
      constructor(account-id: borrow<account-id>);
      then: func(account-id: borrow<account-id>) -> promise;
      and: static func(promises: list<borrow<promise>>) -> promise;
      set-refund-to: func(account-id: borrow<account-id>);
      state-init: func(code-hash: value-or-register, amount: u128) -> promise-action;
      state-init-by-account-id: func(account-id: borrow<account-id>, amount: u128) -> promise-action;
      set-state-init-data-entry: func(action: promise-action, key: value-or-register, value: value-or-register);


      create-account: func();
      deploy-contract: func(code: value-or-register);
      deploy-global-contract: func(code: value-or-register);
      deploy-global-contract-by-account-id: func(code: value-or-register);
      use-global-contract: func(code-hash: value-or-register);
      use-global-contract-by-account-id: func(account-id: borrow<account-id>);
      function-call: func(method: value-or-register, arguments: value-or-register, amount: u128, gas: u64, gas-weight: u64);
      transfer: func(amount: u128);
      stake: func(amount: u128, public-key: borrow<public-key>);
      add-key-with-full-access: func(public-key: borrow<public-key>, nonce: u64);
      add-key-with-function-call: func(public-key: borrow<public-key>, nonce: u64, allowance: u128, receiver-id: borrow<account-id>, method-names: value-or-register);
      delete-key: func(public-key: borrow<public-key>);
      delete-account: func(beneficiary-id: borrow<account-id>);

      yield-create: static func(method-name: value-or-register, arguments: value-or-register, gas: u64, gas-weight: u64, register-id: u64) -> promise;
      yield-resume: static func(data-id: value-or-register, payload: value-or-register) -> bool;


      // If the current function is invoked by a callback we can access the execution results of the
      // promises that caused the callback. This function returns the number of complete and
      // incomplete callbacks.
      //
      // Note, we are only going to have incomplete callbacks once we have promise_or combinator.
      //
      // * If there is only one callback returns `1`;
      // * If there are multiple callbacks (e.g. created through `promise_and`) returns their number;
      // * If the function was called not through the callback returns `0`.
      get-results-count: static func() -> u64;

      // If the current function is invoked by a callback we can access the execution results of the
      // promises that caused the callback. This function returns the result in blob format and
      // places it into the register.
      //
      // * If promise result is complete and successful copies its blob into the register;
      // * If promise result is complete and failed or incomplete keeps register unused;
      //
      // # Returns
      //
      // * If promise result is not complete returns `none`;
      // * If promise result is complete and successful returns `some(ok)`;
      // * If promise result is complete and failed returns `some(err)`.
      get-result: static func(idx: u64, register-id: u64) -> option<result>;

      // When this promise finishes executing its result is considered to be the result of
      // the current function.
      return: func();
   }

   enum contract-code-kind {
      local,
      global,
      global-by-account,
   }

   // Populates a register with the ID of an account which would receive a refund.
   current-contract-code: func(register-id: u64) -> option<contract-code-kind>;

   // Populates a register with the ID of an account which would receive a refund.
   refund-to-account-id: func(register-id: u64);

   // Writes key-value into storage.
   // * If key is not in use it inserts the key-value pair and does not modify the register. Returns `false`;
   // * If key is in use it inserts the key-value and copies the old value into the `register-id`. Returns `true`.
   //
   storage-write: func(key: value-or-register, value: value-or-register, register-id: u64) -> bool;

   // Reads the value stored under the given key.
   // * If key is used copies the content of the value into the `register-id`, even if the content
   //   is zero bytes. Returns `true`;
   // * If key is not present then does not modify the register. Returns `false`;
   storage-read: func(key: value-or-register, register-id: u64) -> bool;

   // Removes the value stored under the given key.
   // * If key is used, removes the key-value from the trie and copies the content of the value
   //   into the `register_id`, even if the content is zero bytes. Returns `true`;
   // * If key is not present then does not modify the register. Returns `false`.
   storage-remove: func(key: value-or-register, register-id: u64) -> bool;

   // Checks if there is a key-value pair.
   // * If key is used returns `true`, even if the value is zero bytes;
   // * Otherwise returns `false`.
   storage-has-key: func(key: value-or-register) -> bool;

   // Get the stake of an account, if the account is currently a validator.
   validator-stake: func(account-id: borrow<account-id>) -> u128;

   // Get the total validator stake of the current epoch.
   validator-total-stake: func() -> u128;

   // Computes multiexp on alt_bn128 curve using Pippenger's algorithm \sum_i
   // mul_i g_{1 i} should be equal result.
   alt-bn128-g1-multiexp: func(value: value-or-register, register-id: u64);

   // Computes sum for signed g1 group elements on alt_bn128 curve \sum_i
   // (-1)^{sign_i} g_{1 i} should be equal result.
   alt-bn128-g1-sum: func(value: value-or-register, register-id: u64);

   // Computes pairing check on alt_bn128 curve.
   // \sum_i e(g_{1 i}, g_{2 i}) should be equal one (in additive notation), e(g1, g2) is Ate pairing
   alt-bn128-pairing-check: func(value: value-or-register) -> bool;

   bls12381-p1-sum: func(value: value-or-register, register-id: u64) -> result;

   bls12381-p2-sum: func(value: value-or-register, register-id: u64) -> result;

   bls12381-g1-multiexp: func(value: value-or-register, register-id: u64) -> result;

   bls12381-g2-multiexp: func(value: value-or-register, register-id: u64) -> result;

   bls12381-map-fp-to-g1: func(value: value-or-register, register-id: u64) -> result;

   bls12381-map-fp2-to-g2: func(value: value-or-register, register-id: u64) -> result;

   bls12381-pairing-check: func(value: value-or-register) -> result<bool>;

   bls12381-p1-decompress: func(value: value-or-register, register-id: u64) -> result;

   bls12381-p2-decompress: func(value: value-or-register, register-id: u64) -> result;
}

world imports {
    import finite-wasm;

    import runtime;
}
