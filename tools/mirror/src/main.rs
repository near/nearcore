use anyhow::Context;
use clap::Parser;
use mirror::TxMirror;
use std::cell::Cell;
use std::path::PathBuf;

#[derive(Parser)]
struct Cli {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

#[derive(Parser)]
enum SubCommand {
    Prepare(PrepareCmd),
    Run(RunCmd),
}

/// Start two NEAR nodes, one for each chain, and try to mirror
/// transactions from the source chain to the target chain.
#[derive(Parser)]
struct RunCmd {
    /// source chain home dir
    #[clap(long)]
    source_home: PathBuf,
    /// target chain home dir
    #[clap(long)]
    target_home: PathBuf,
    /// file containing an optional secret as generated by the `prepare` command
    #[clap(long)]
    secret_file: PathBuf,
}

impl RunCmd {
    fn run(self, runtime: tokio::runtime::Runtime) -> anyhow::Result<()> {
        openssl_probe::init_ssl_cert_env_vars();

        let system = new_actix_system(runtime);
        let res: anyhow::Result<()> = system.block_on(async move {
            let m = TxMirror::new(&self.source_home, &self.target_home, &self.secret_file)?;
            actix::spawn(m.run());
            Ok(())
        });
        res.context("failed to start main loop future")?;
        system.run()?;
        Ok(())
    }
}

/// Write a new genesis records file where the public keys have been
/// altered so that this binary can sign transactions when mirroring
/// them from the source chain to the target chain
#[derive(Parser)]
struct PrepareCmd {
    /// A genesis records file as output by `neard view-state
    /// dump-state --stream`
    #[clap(long)]
    records_file_in: PathBuf,
    /// Path to the new records file with updated public keys
    #[clap(long)]
    records_file_out: PathBuf,
    /// If this is provided, don't use a secret when mapping public
    /// keys to new source chain private keys. This means that anyone
    /// will be able to sign transactions for the accounts in the
    /// target chain corresponding to accounts in the source chain. If
    /// that is okay, then --no-secret will make the code run slightly
    /// faster, and you won't have to take care to not lose the
    /// secret.
    #[clap(long)]
    no_secret: bool,
    /// Path to the secret. Note that if you don't pass --no-secret,
    /// this secret is required to sign transactions for the accounts
    /// in the target chain corresponding to accounts in the source
    /// chain. This means that if you lose this secret, you will no
    /// longer be able to mirror any traffic.
    #[clap(long)]
    secret_file_out: PathBuf,
}

impl PrepareCmd {
    fn run(self) -> anyhow::Result<()> {
        mirror::genesis::map_records(
            &self.records_file_in,
            &self.records_file_out,
            self.no_secret,
            &self.secret_file_out,
        )
    }
}

// copied from neard/src/cli.rs
fn new_actix_system(runtime: tokio::runtime::Runtime) -> actix::SystemRunner {
    // `with_tokio_rt()` accepts an `Fn()->Runtime`, however we know that this function is called exactly once.
    // This makes it safe to move out of the captured variable `runtime`, which is done by a trick
    // using a `swap` of `Cell<Option<Runtime>>`s.
    let runtime_cell = Cell::new(Some(runtime));
    actix::System::with_tokio_rt(|| {
        let r = Cell::new(None);
        runtime_cell.swap(&r);
        r.into_inner().unwrap()
    })
}

fn main() -> anyhow::Result<()> {
    let args = Cli::parse();

    let runtime = tokio::runtime::Runtime::new().context("failed to start tokio runtime")?;
    let _subscriber = runtime.block_on(async {
        near_o11y::default_subscriber(
            near_o11y::EnvFilterBuilder::from_env().finish().unwrap(),
            &Default::default(),
        )
        .await
        .global()
    });

    match args.subcmd {
        SubCommand::Prepare(r) => r.run(),
        SubCommand::Run(r) => r.run(runtime),
    }
}
