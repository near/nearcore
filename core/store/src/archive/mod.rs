use std::{io, sync::Arc};

use cold_storage::update_cold_db;
use external_storage::update_external_storage;
use near_primitives::block::Tip;
use near_primitives::shard_layout::{ShardLayout, ShardUId};
use near_primitives::types::BlockHeight;

use crate::Store;
use crate::archive::cold_storage::get_cold_head;
use crate::db::ColdDB;

pub mod cold_storage;
mod external_storage;

/// Trait for external storage operation.
///
/// The storage abstracts writing blobs of data (byte array) as a filesystem-like structure,
/// where each blob of data is mapped to a path (generated by the `ArchivalStore`) and the storage
/// implementation is expected to persist the given value (byte array) at the given path.
/// The path is relative, the implementation is expected to map the given path to the absolute path.
pub(crate) trait ExternalStorage: Sync + Send {
    /// Stores the `value` at the given path.
    fn put(&self, path: &std::path::Path, value: &[u8]) -> io::Result<()>;

    /// Reads the value at the given path.
    ///
    /// Returns `None` if there is no value at the given path.
    #[allow(dead_code)]
    fn get(&self, path: &std::path::Path) -> io::Result<Option<Vec<u8>>>;
}

/// Represents the storage for archival data.
#[derive(Clone)]
enum ArchivalStorage {
    /// Use the ColdDB (RocksDB) to store the archival data.
    #[allow(dead_code)]
    ColdDB(Arc<ColdDB>),
    /// Use an external storage to store the archival data.
    #[allow(dead_code)]
    External(Arc<dyn ExternalStorage>),
}

#[derive(Clone)]
pub struct ArchivalStore {
    /// Target storage for persisting the archival data.
    storage: ArchivalStorage,
}

impl ArchivalStore {
    /// Saves the archival data associated with the block at the given height.
    pub fn archive_block(
        &self,
        hot_store: &Store,
        shard_layout: &ShardLayout,
        tracked_shards: &Vec<ShardUId>,
        height: &BlockHeight,
        is_resharding_boundary: bool,
        num_threads: usize,
    ) -> io::Result<()> {
        // If the archival storage is ColdDB, use the old algorithm to copy the block data, otherwise use the new algorithm.
        match self.storage {
            ArchivalStorage::ColdDB(ref cold_db) => update_cold_db(
                cold_db.as_ref(),
                hot_store,
                shard_layout,
                tracked_shards,
                height,
                is_resharding_boundary,
                num_threads,
            ),
            ArchivalStorage::External(ref storage) => update_external_storage(
                storage.as_ref(),
                hot_store,
                &shard_layout,
                height,
                num_threads,
            ),
        }
    }

    /// Returns the ColdDB associated with the archival storage, if the target storage is ColdDB.
    /// Otherwise (if external storage is used), returns None.
    pub fn cold_db(&self) -> Option<&Arc<ColdDB>> {
        if let ArchivalStorage::ColdDB(cold_db) = &self.storage { Some(cold_db) } else { None }
    }

    /// Returns the head of the archival data.
    pub fn get_head(&self) -> io::Result<Option<Tip>> {
        match self.storage {
            ArchivalStorage::ColdDB(ref cold_db) => get_cold_head(cold_db),
            ArchivalStorage::External(ref storage) => self.get_external_head(storage.as_ref()),
        }
    }

    pub fn update_head(&self, _hot_store: &Store, height: &BlockHeight) -> io::Result<()> {
        tracing::debug!(target: "cold_store", "update HEAD of archival data to {}", height);
        panic!("not implemented")
    }

    /// Reads the head from the external storage.
    fn get_external_head(&self, _storage: &dyn ExternalStorage) -> io::Result<Option<Tip>> {
        panic!("not implemented")
    }
}
