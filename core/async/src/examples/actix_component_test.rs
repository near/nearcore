use super::actix_component::{
    ExampleComponent, ExampleComponentAdapterMessage, OuterComponent, PeriodicRequest,
};
use crate::futures::FutureSpawnerExt;
use crate::messaging::{IntoMultiSender, IntoSender};
use crate::test_loop::event_handler::{capture_events, LoopEventHandler};
use crate::test_loop::futures::{
    drive_delayed_action_runners, drive_futures, TestLoopDelayedActionEvent, TestLoopTask,
};
use crate::test_loop::TestLoopBuilder;
use derive_enum_from_into::{EnumFrom, EnumTryInto};
use std::sync::Arc;
use time::Duration;

#[derive(derive_more::AsMut, derive_more::AsRef)]
struct ExampleComponentTestData {
    dummy: (),
    example: ExampleComponent,
    outer: OuterComponent,
    periodic_requests_captured: Vec<PeriodicRequest>,
}

#[derive(Debug, EnumTryInto, EnumFrom)]
enum ExampleComponentTestEvent {
    PeriodicRequest(PeriodicRequest),
    ExampleRequest(ExampleComponentAdapterMessage),
    // Needed to support DelayedActionRunner on the ExampleComponent.
    DelayedAction(TestLoopDelayedActionEvent<ExampleComponent>),
    // Arc<TestLoopTask> is needed to support futures.
    Task(Arc<TestLoopTask>),
}

fn example_handler() -> LoopEventHandler<ExampleComponent, ExampleComponentAdapterMessage> {
    LoopEventHandler::new_simple(
        |event: ExampleComponentAdapterMessage, data: &mut ExampleComponent| match event {
            ExampleComponentAdapterMessage::_example(request) => {
                let response = data.process_request(request.message);
                (request.callback)(Ok(response));
            }
        },
    )
}

#[test]
fn test_actix_component() {
    let builder = TestLoopBuilder::<ExampleComponentTestEvent>::new();
    let sender = builder.sender();
    let mut test = builder.build(ExampleComponentTestData {
        dummy: (),
        example: ExampleComponent::new(sender.clone().into_sender()),
        outer: OuterComponent::new(
            // We need to specify the explicit type here because this is a
            // three-step conversion. First, we're converting the
            // `DelaySender<ExampleComponentTestEvent>` into a
            // `Sender<ExampleComponentAdapterMessage>`, which is a single
            // sender that accepts an enum (generated by MultiSendMessage)
            // that contains every type of message that can be sent to
            // ExampleComponent. Then, we break it apart so that it becomes
            // something that can send any of the messages that the enum
            // contains, and finally we convert it a multisender
            // ExampleComponentAdapter.
            IntoSender::<ExampleComponentAdapterMessage>::into_sender(sender)
                .break_apart()
                .into_multi_sender(),
        ),
        periodic_requests_captured: vec![],
    });
    // This is to allow futures to be used in the test even though the
    // test itself is synchronous.
    test.register_handler(drive_futures().widen());
    // This is to allow the ExampleComponent to run delayed actions (timers).
    test.register_handler(drive_delayed_action_runners::<ExampleComponent>().widen());
    // This is to capture the periodic requests sent by the ExampleComponent
    // so we can assert against it.
    test.register_handler(capture_events::<PeriodicRequest>().widen());
    // This is to handle the ExampleComponentAdapterMessage events by
    // forwarding them to the ExampleComponent.
    test.register_handler(example_handler().widen());

    // We need to redo whatever the ExampleActor does in its `started` method.
    test.data.example.start(&mut test.delayed_action_runner());
    // Send some requests; this can be done in the asynchronous context.
    test.future_spawner().spawn("wait for 5", {
        let res = test.data.outer.call_example_component_for_response(5);
        async move {
            assert_eq!(res.await, 5);
        }
    });
    test.future_spawner().spawn("wait for 6", {
        let res = test.data.outer.call_example_component_for_response(6);
        async move {
            assert_eq!(res.await, 6);
        }
    });
    // Run for 3 seconds (not real time, but in the test loop time).
    // It should result in sending 3 periodic requests.
    test.run_for(Duration::seconds(3));
    assert_eq!(
        test.data.periodic_requests_captured,
        vec![PeriodicRequest { id: 0 }, PeriodicRequest { id: 1 }, PeriodicRequest { id: 2 },]
    );
}
