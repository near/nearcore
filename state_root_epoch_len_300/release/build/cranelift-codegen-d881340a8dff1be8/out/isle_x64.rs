// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_lower.isle
// - src/isa/x64/inst.isle
// - src/isa/x64/lower.isle
// - /Users/xiangyiz/workspace/near/nearcore_fork/state_root_epoch_len_300/release/build/cranelift-codegen-d881340a8dff1be8/out/clif_lower.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> Option<u32>;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_as_u32(&mut self, arg0: u8) -> Option<u32>;
    fn u8_as_u64(&mut self, arg0: u8) -> Option<u64>;
    fn u16_as_u64(&mut self, arg0: u16) -> Option<u64>;
    fn u32_as_u64(&mut self, arg0: u32) -> Option<u64>;
    fn i64_as_u64(&mut self, arg0: i64) -> Option<u64>;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_not(&mut self, arg0: u64) -> Option<u64>;
    fn u64_sextend_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u64_uextend_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> Option<bool>;
    fn ty_bits(&mut self, arg0: Type) -> Option<u8>;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Option<Imm64>;
    fn u64_from_ieee32(&mut self, arg0: Ieee32) -> u64;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    fn value_reg(&mut self, arg0: Reg) -> ValueRegs;
    fn value_regs(&mut self, arg0: Reg, arg1: Reg) -> ValueRegs;
    fn value_regs_invalid(&mut self) -> ValueRegs;
    fn output_none(&mut self) -> InstOutput;
    fn output(&mut self, arg0: ValueRegs) -> InstOutput;
    fn output_pair(&mut self, arg0: ValueRegs, arg1: ValueRegs) -> InstOutput;
    fn output_builder_new(&mut self) -> InstOutputBuilder;
    fn output_builder_push(&mut self, arg0: &InstOutputBuilder, arg1: ValueRegs) -> Unit;
    fn output_builder_finish(&mut self, arg0: &InstOutputBuilder) -> InstOutput;
    fn temp_writable_reg(&mut self, arg0: Type) -> WritableReg;
    fn is_valid_reg(&mut self, arg0: Reg) -> bool;
    fn invalid_reg(&mut self) -> Reg;
    fn mark_value_used(&mut self, arg0: Value) -> Unit;
    fn put_in_reg(&mut self, arg0: Value) -> Reg;
    fn put_in_regs(&mut self, arg0: Value) -> ValueRegs;
    fn ensure_in_vreg(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn value_regs_get(&mut self, arg0: ValueRegs, arg1: usize) -> Reg;
    fn value_regs_len(&mut self, arg0: ValueRegs) -> usize;
    fn preg_to_reg(&mut self, arg0: PReg) -> Reg;
    fn value_list_slice(&mut self, arg0: ValueList) -> ValueSlice;
    fn value_slice_empty(&mut self, arg0: ValueSlice) -> Option<()>;
    fn value_slice_unwrap(&mut self, arg0: ValueSlice) -> Option<(Value, ValueSlice)>;
    fn value_slice_len(&mut self, arg0: ValueSlice) -> usize;
    fn value_slice_get(&mut self, arg0: ValueSlice, arg1: usize) -> Value;
    fn same_value(&mut self, arg0: Value, arg1: Value) -> Option<Value>;
    fn writable_reg_to_reg(&mut self, arg0: WritableReg) -> Reg;
    fn inst_results(&mut self, arg0: Inst) -> ValueSlice;
    fn first_result(&mut self, arg0: Inst) -> Option<Value>;
    fn inst_data(&mut self, arg0: Inst) -> InstructionData;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn def_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn zero_value(&mut self, arg0: Value) -> Option<Value>;
    fn is_sinkable_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn emit(&mut self, arg0: &MInst) -> Unit;
    fn sink_inst(&mut self, arg0: Inst) -> Unit;
    fn emit_u64_le_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u128_le_const(&mut self, arg0: u128) -> VCodeConstant;
    fn const_to_vconst(&mut self, arg0: Constant) -> VCodeConstant;
    fn intcc_reverse(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_inverse(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_reverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_inverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn avoid_div_traps(&mut self, arg0: Type) -> Option<()>;
    fn tls_model(&mut self, arg0: Type) -> TlsModel;
    fn tls_model_is_elf_gd(&mut self) -> Option<Unit>;
    fn tls_model_is_macho(&mut self) -> Option<Unit>;
    fn tls_model_is_coff(&mut self) -> Option<Unit>;
    fn preserve_frame_pointers(&mut self) -> Option<Unit>;
    fn box_external_name(&mut self, arg0: ExternalName) -> BoxExternalName;
    fn func_ref_data(&mut self, arg0: FuncRef) -> (SigRef, ExternalName, RelocDistance);
    fn symbol_value_data(
        &mut self,
        arg0: GlobalValue,
    ) -> Option<(ExternalName, RelocDistance, i64)>;
    fn reloc_distance_near(&mut self, arg0: RelocDistance) -> Option<()>;
    fn vec_mask_from_immediate(&mut self, arg0: Immediate) -> Option<VecMask>;
    fn u128_from_immediate(&mut self, arg0: Immediate) -> Option<u128>;
    fn u128_from_constant(&mut self, arg0: Constant) -> Option<u128>;
    fn u64_from_constant(&mut self, arg0: Constant) -> Option<u64>;
    fn only_writable_reg(&mut self, arg0: WritableValueRegs) -> Option<WritableReg>;
    fn writable_regs_get(&mut self, arg0: WritableValueRegs, arg1: usize) -> WritableReg;
    fn abi_num_args(&mut self, arg0: &Sig) -> usize;
    fn abi_get_arg(&mut self, arg0: &Sig, arg1: usize) -> ABIArg;
    fn abi_num_rets(&mut self, arg0: &Sig) -> usize;
    fn abi_get_ret(&mut self, arg0: &Sig, arg1: usize) -> ABIArg;
    fn abi_ret_arg(&mut self, arg0: &Sig) -> Option<ABIArg>;
    fn abi_no_ret_arg(&mut self, arg0: &Sig) -> Option<()>;
    fn abi_sized_stack_arg_space(&mut self, arg0: &Sig) -> i64;
    fn abi_sized_stack_ret_space(&mut self, arg0: &Sig) -> i64;
    fn abi_stackslot_addr(&mut self, arg0: WritableReg, arg1: StackSlot, arg2: Offset32) -> MInst;
    fn abi_dynamic_stackslot_addr(&mut self, arg0: WritableReg, arg1: DynamicStackSlot) -> MInst;
    fn abi_arg_only_slot(&mut self, arg0: &ABIArg) -> Option<ABIArgSlot>;
    fn abi_arg_struct_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, u64)>;
    fn abi_arg_implicit_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, Type)>;
    fn real_reg_to_reg(&mut self, arg0: RealReg) -> Reg;
    fn real_reg_to_writable_reg(&mut self, arg0: RealReg) -> WritableReg;
    fn gen_move(&mut self, arg0: Type, arg1: WritableReg, arg2: Reg) -> MInst;
    fn gen_return(&mut self, arg0: ValueSlice) -> Unit;
    fn jump_table_size(&mut self, arg0: &BoxVecMachLabel) -> u32;
    fn single_target(&mut self, arg0: &MachLabelSlice) -> Option<MachLabel>;
    fn two_targets(&mut self, arg0: &MachLabelSlice) -> Option<(MachLabel, MachLabel)>;
    fn jump_table_targets(&mut self, arg0: &MachLabelSlice)
        -> Option<(MachLabel, BoxVecMachLabel)>;
    fn operand_size_of_type_32_64(&mut self, arg0: Type) -> OperandSize;
    fn raw_operand_size_of_type(&mut self, arg0: Type) -> OperandSize;
    fn put_in_reg_mem_imm(&mut self, arg0: Value) -> RegMemImm;
    fn put_in_reg_mem(&mut self, arg0: Value) -> RegMem;
    fn synthetic_amode_to_reg_mem(&mut self, arg0: &SyntheticAmode) -> RegMem;
    fn amode_to_synthetic_amode(&mut self, arg0: &Amode) -> SyntheticAmode;
    fn amode_with_flags(&mut self, arg0: &Amode, arg1: MemFlags) -> Amode;
    fn amode_imm_reg(&mut self, arg0: u32, arg1: Gpr) -> Amode;
    fn amode_imm_reg_reg_shift(&mut self, arg0: u32, arg1: Gpr, arg2: Gpr, arg3: u8) -> Amode;
    fn sum_extend_fits_in_32_bits(
        &mut self,
        arg0: Type,
        arg1: Imm64,
        arg2: Offset32,
    ) -> Option<u32>;
    fn amode_offset(&mut self, arg0: &Amode, arg1: u32) -> Amode;
    fn zero_offset(&mut self) -> Offset32;
    fn intcc_to_cc(&mut self, arg0: &IntCC) -> CC;
    fn cc_invert(&mut self, arg0: &CC) -> CC;
    fn cc_nz_or_z(&mut self, arg0: &CC) -> Option<CC>;
    fn encode_fcmp_imm(&mut self, arg0: &FcmpImm) -> u8;
    fn encode_round_imm(&mut self, arg0: &RoundImm) -> u8;
    fn imm8_reg_to_imm8_gpr(&mut self, arg0: &Imm8Reg) -> Imm8Gpr;
    fn writable_gpr_to_reg(&mut self, arg0: WritableGpr) -> WritableReg;
    fn writable_xmm_to_reg(&mut self, arg0: WritableXmm) -> WritableReg;
    fn writable_reg_to_xmm(&mut self, arg0: WritableReg) -> WritableXmm;
    fn writable_xmm_to_xmm(&mut self, arg0: WritableXmm) -> Xmm;
    fn writable_gpr_to_gpr(&mut self, arg0: WritableGpr) -> Gpr;
    fn gpr_to_reg(&mut self, arg0: Gpr) -> Reg;
    fn gpr_to_gpr_mem(&mut self, arg0: Gpr) -> GprMem;
    fn gpr_to_gpr_mem_imm(&mut self, arg0: Gpr) -> GprMemImm;
    fn xmm_to_reg(&mut self, arg0: Xmm) -> Reg;
    fn xmm_to_xmm_mem_imm(&mut self, arg0: Xmm) -> XmmMemImm;
    fn temp_writable_gpr(&mut self) -> WritableGpr;
    fn temp_writable_xmm(&mut self) -> WritableXmm;
    fn reg_mem_to_xmm_mem(&mut self, arg0: &RegMem) -> XmmMem;
    fn reg_to_reg_mem_imm(&mut self, arg0: Reg) -> RegMemImm;
    fn gpr_mem_imm_new(&mut self, arg0: &RegMemImm) -> GprMemImm;
    fn xmm_mem_imm_new(&mut self, arg0: &RegMemImm) -> XmmMemImm;
    fn xmm_to_xmm_mem(&mut self, arg0: Xmm) -> XmmMem;
    fn xmm_mem_to_reg_mem(&mut self, arg0: &XmmMem) -> RegMem;
    fn gpr_mem_to_reg_mem(&mut self, arg0: &GprMem) -> RegMem;
    fn xmm_new(&mut self, arg0: Reg) -> Xmm;
    fn gpr_new(&mut self, arg0: Reg) -> Gpr;
    fn reg_mem_to_gpr_mem(&mut self, arg0: &RegMem) -> GprMem;
    fn reg_to_gpr_mem(&mut self, arg0: Reg) -> GprMem;
    fn put_in_xmm_mem(&mut self, arg0: Value) -> XmmMem;
    fn put_in_xmm_mem_imm(&mut self, arg0: Value) -> XmmMemImm;
    fn gpr_to_imm8_gpr(&mut self, arg0: Gpr) -> Imm8Gpr;
    fn imm8_to_imm8_gpr(&mut self, arg0: u8) -> Imm8Gpr;
    fn intcc_without_eq(&mut self, arg0: &IntCC) -> IntCC;
    fn type_register_class(&mut self, arg0: Type) -> Option<RegisterClass>;
    fn avx512vl_enabled(&mut self, arg0: Type) -> bool;
    fn avx512dq_enabled(&mut self, arg0: Type) -> bool;
    fn avx512f_enabled(&mut self, arg0: Type) -> bool;
    fn avx512bitalg_enabled(&mut self, arg0: Type) -> bool;
    fn avx512vbmi_enabled(&mut self, arg0: Type) -> bool;
    fn use_lzcnt(&mut self, arg0: Type) -> bool;
    fn use_bmi1(&mut self, arg0: Type) -> bool;
    fn use_popcnt(&mut self, arg0: Type) -> bool;
    fn use_fma(&mut self, arg0: Type) -> bool;
    fn use_sse41(&mut self, arg0: Type) -> bool;
    fn imm8_from_value(&mut self, arg0: Value) -> Option<Imm8Reg>;
    fn const_to_type_masked_imm8(&mut self, arg0: u64, arg1: Type) -> Imm8Gpr;
    fn shift_mask(&mut self, arg0: Type) -> u32;
    fn simm32_from_value(&mut self, arg0: Value) -> Option<GprMemImm>;
    fn simm32_from_imm64(&mut self, arg0: Imm64) -> Option<GprMemImm>;
    fn sinkable_load(&mut self, arg0: Value) -> Option<SinkableLoad>;
    fn sink_load(&mut self, arg0: &SinkableLoad) -> RegMem;
    fn ext_mode(&mut self, arg0: u16, arg1: u16) -> ExtMode;
    fn gen_call(
        &mut self,
        arg0: SigRef,
        arg1: ExternalName,
        arg2: RelocDistance,
        arg3: ValueSlice,
    ) -> InstOutput;
    fn gen_call_indirect(&mut self, arg0: SigRef, arg1: Value, arg2: ValueSlice) -> InstOutput;
    fn nonzero_u64_fits_in_u32(&mut self, arg0: u64) -> Option<u64>;
    fn fcvt_uint_mask_const(&mut self) -> VCodeConstant;
    fn fcvt_uint_mask_high_const(&mut self) -> VCodeConstant;
    fn iadd_pairwise_mul_const_16(&mut self) -> VCodeConstant;
    fn iadd_pairwise_mul_const_32(&mut self) -> VCodeConstant;
    fn iadd_pairwise_xor_const_32(&mut self) -> VCodeConstant;
    fn iadd_pairwise_addd_const_32(&mut self) -> VCodeConstant;
    fn snarrow_umax_mask(&mut self) -> VCodeConstant;
    fn ty_int_bool_or_ref(&mut self, arg0: Type) -> Option<()>;
    fn atomic_rmw_op_to_mach_atomic_rmw_op(&mut self, arg0: &AtomicRmwOp) -> MachAtomicRmwOp;
    fn emit_div_or_rem(
        &mut self,
        arg0: &DivOrRemKind,
        arg1: Type,
        arg2: WritableGpr,
        arg3: Gpr,
        arg4: Gpr,
    ) -> Unit;
    fn shuffle_0_31_mask(&mut self, arg0: &VecMask) -> VCodeConstant;
    fn shuffle_0_15_mask(&mut self, arg0: &VecMask) -> VCodeConstant;
    fn shuffle_16_31_mask(&mut self, arg0: &VecMask) -> VCodeConstant;
    fn perm_from_mask(&mut self, arg0: &VecMask) -> VCodeConstant;
    fn perm_from_mask_with_zeros(
        &mut self,
        arg0: &VecMask,
    ) -> Option<(VCodeConstant, VCodeConstant)>;
    fn swizzle_zero_mask(&mut self) -> VCodeConstant;
    fn sqmul_round_sat_mask(&mut self) -> VCodeConstant;
    fn uunarrow_umax_mask(&mut self) -> VCodeConstant;
    fn uunarrow_uint_mask(&mut self) -> VCodeConstant;
    fn const_to_synthetic_amode(&mut self, arg0: VCodeConstant) -> SyntheticAmode;
    fn preg_rbp(&mut self) -> PReg;
    fn preg_rsp(&mut self) -> PReg;
    fn preg_pinned(&mut self) -> PReg;
    fn libcall_1(&mut self, arg0: &LibCall, arg1: Reg) -> Reg;
    fn libcall_3(&mut self, arg0: &LibCall, arg1: Reg, arg2: Reg, arg3: Reg) -> Reg;
    fn ishl_i8x16_mask_for_const(&mut self, arg0: u32) -> SyntheticAmode;
    fn ishl_i8x16_mask_table(&mut self) -> SyntheticAmode;
    fn ushr_i8x16_mask_for_const(&mut self, arg0: u32) -> SyntheticAmode;
    fn ushr_i8x16_mask_table(&mut self) -> SyntheticAmode;
    fn vconst_all_ones_or_all_zeros(&mut self, arg0: Constant) -> Option<()>;
    fn sse_insertps_lane_imm(&mut self, arg0: u8) -> u8;
    fn popcount_4bit_table(&mut self) -> VCodeConstant;
    fn popcount_low_mask(&mut self) -> VCodeConstant;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

/// Internal type SideEffectNoResult: defined at src/prelude_lower.isle line 290.
#[derive(Clone, Debug)]
pub enum SideEffectNoResult {
    Inst {
        inst: MInst,
    },
    Inst2 {
        inst1: MInst,
        inst2: MInst,
    },
    Inst3 {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
    },
}

/// Internal type ProducesFlags: defined at src/prelude_lower.isle line 346.
#[derive(Clone, Debug)]
pub enum ProducesFlags {
    AlreadyExistingFlags,
    ProducesFlagsSideEffect { inst: MInst },
    ProducesFlagsTwiceSideEffect { inst1: MInst, inst2: MInst },
    ProducesFlagsReturnsReg { inst: MInst, result: Reg },
    ProducesFlagsReturnsResultWithConsumer { inst: MInst, result: Reg },
}

/// Internal type ConsumesFlags: defined at src/prelude_lower.isle line 368.
#[derive(Clone, Debug)]
pub enum ConsumesFlags {
    ConsumesFlagsSideEffect {
        inst: MInst,
    },
    ConsumesFlagsSideEffect2 {
        inst1: MInst,
        inst2: MInst,
    },
    ConsumesFlagsReturnsResultWithProducer {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsTwiceReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        result: ValueRegs,
    },
    ConsumesFlagsFourTimesReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
        inst4: MInst,
        result: ValueRegs,
    },
}

/// Internal type MInst: defined at src/isa/x64/inst.isle line 8.
#[derive(Clone)]
pub enum MInst {
    Nop {
        len: u8,
    },
    AluRmiR {
        size: OperandSize,
        op: AluRmiROpcode,
        src1: Gpr,
        src2: GprMemImm,
        dst: WritableGpr,
    },
    AluRM {
        size: OperandSize,
        op: AluRmiROpcode,
        src1_dst: SyntheticAmode,
        src2: Gpr,
    },
    UnaryRmR {
        size: OperandSize,
        op: UnaryRmROpcode,
        src: GprMem,
        dst: WritableGpr,
    },
    Not {
        size: OperandSize,
        src: Gpr,
        dst: WritableGpr,
    },
    Neg {
        size: OperandSize,
        src: Gpr,
        dst: WritableGpr,
    },
    Div {
        size: OperandSize,
        signed: bool,
        divisor: GprMem,
        dividend_lo: Gpr,
        dividend_hi: Gpr,
        dst_quotient: WritableGpr,
        dst_remainder: WritableGpr,
    },
    MulHi {
        size: OperandSize,
        signed: bool,
        src1: Gpr,
        src2: GprMem,
        dst_lo: WritableGpr,
        dst_hi: WritableGpr,
    },
    CheckedDivOrRemSeq {
        kind: DivOrRemKind,
        size: OperandSize,
        dividend_lo: Gpr,
        dividend_hi: Gpr,
        divisor: Gpr,
        dst_quotient: WritableGpr,
        dst_remainder: WritableGpr,
        tmp: OptionWritableGpr,
    },
    SignExtendData {
        size: OperandSize,
        src: Gpr,
        dst: WritableGpr,
    },
    Imm {
        dst_size: OperandSize,
        simm64: u64,
        dst: WritableGpr,
    },
    MovRR {
        size: OperandSize,
        src: Gpr,
        dst: WritableGpr,
    },
    MovFromPReg {
        src: PReg,
        dst: WritableGpr,
    },
    MovToPReg {
        src: Gpr,
        dst: PReg,
    },
    MovzxRmR {
        ext_mode: ExtMode,
        src: GprMem,
        dst: WritableGpr,
    },
    Mov64MR {
        src: SyntheticAmode,
        dst: WritableGpr,
    },
    LoadEffectiveAddress {
        addr: SyntheticAmode,
        dst: WritableGpr,
    },
    MovsxRmR {
        ext_mode: ExtMode,
        src: GprMem,
        dst: WritableGpr,
    },
    MovRM {
        size: OperandSize,
        src: Gpr,
        dst: SyntheticAmode,
    },
    ShiftR {
        size: OperandSize,
        kind: ShiftKind,
        src: Gpr,
        num_bits: Imm8Gpr,
        dst: WritableGpr,
    },
    XmmRmiReg {
        opcode: SseOpcode,
        src1: Xmm,
        src2: XmmMemImm,
        dst: WritableXmm,
    },
    CmpRmiR {
        size: OperandSize,
        opcode: CmpOpcode,
        src: GprMemImm,
        dst: Gpr,
    },
    Setcc {
        cc: CC,
        dst: WritableGpr,
    },
    Bswap {
        size: OperandSize,
        src: Gpr,
        dst: WritableGpr,
    },
    Cmove {
        size: OperandSize,
        cc: CC,
        consequent: GprMem,
        alternative: Gpr,
        dst: WritableGpr,
    },
    XmmCmove {
        ty: Type,
        cc: CC,
        consequent: XmmMem,
        alternative: Xmm,
        dst: WritableXmm,
    },
    Push64 {
        src: GprMemImm,
    },
    Pop64 {
        dst: WritableGpr,
    },
    StackProbeLoop {
        tmp: WritableReg,
        frame_size: u32,
        guard_size: u32,
    },
    XmmRmR {
        op: SseOpcode,
        src1: Xmm,
        src2: XmmMem,
        dst: WritableXmm,
    },
    XmmRmRBlend {
        op: SseOpcode,
        src1: Xmm,
        src2: XmmMem,
        mask: Xmm,
        dst: WritableXmm,
    },
    XmmRmRVex {
        op: AvxOpcode,
        src1: Xmm,
        src2: Xmm,
        src3: XmmMem,
        dst: WritableXmm,
    },
    XmmRmREvex {
        op: Avx512Opcode,
        src1: XmmMem,
        src2: Xmm,
        dst: WritableXmm,
    },
    XmmRmREvex3 {
        op: Avx512Opcode,
        src1: XmmMem,
        src2: Xmm,
        src3: Xmm,
        dst: WritableXmm,
    },
    XmmUnaryRmR {
        op: SseOpcode,
        src: XmmMem,
        dst: WritableXmm,
    },
    XmmUnaryRmRImm {
        op: SseOpcode,
        src: XmmMem,
        imm: u8,
        dst: WritableXmm,
    },
    XmmUnaryRmREvex {
        op: Avx512Opcode,
        src: XmmMem,
        dst: WritableXmm,
    },
    XmmMovRM {
        op: SseOpcode,
        src: Reg,
        dst: SyntheticAmode,
    },
    XmmToGpr {
        op: SseOpcode,
        src: Xmm,
        dst: WritableGpr,
        dst_size: OperandSize,
    },
    GprToXmm {
        op: SseOpcode,
        src: GprMem,
        dst: WritableXmm,
        src_size: OperandSize,
    },
    CvtUint64ToFloatSeq {
        dst_size: OperandSize,
        src: Gpr,
        dst: WritableXmm,
        tmp_gpr1: WritableGpr,
        tmp_gpr2: WritableGpr,
    },
    CvtFloatToSintSeq {
        dst_size: OperandSize,
        src_size: OperandSize,
        is_saturating: bool,
        src: Xmm,
        dst: WritableGpr,
        tmp_gpr: WritableGpr,
        tmp_xmm: WritableXmm,
    },
    CvtFloatToUintSeq {
        dst_size: OperandSize,
        src_size: OperandSize,
        is_saturating: bool,
        src: Xmm,
        dst: WritableGpr,
        tmp_gpr: WritableGpr,
        tmp_xmm: WritableXmm,
        tmp_xmm2: WritableXmm,
    },
    XmmMinMaxSeq {
        size: OperandSize,
        is_min: bool,
        lhs: Xmm,
        rhs: Xmm,
        dst: WritableXmm,
    },
    XmmCmpRmR {
        op: SseOpcode,
        src: XmmMem,
        dst: Xmm,
    },
    XmmRmRImm {
        op: SseOpcode,
        src1: Reg,
        src2: RegMem,
        dst: WritableReg,
        imm: u8,
        size: OperandSize,
    },
    CallKnown {
        dest: ExternalName,
        info: BoxCallInfo,
    },
    CallUnknown {
        dest: RegMem,
        info: BoxCallInfo,
    },
    Args {
        args: VecArgPair,
    },
    Ret {
        rets: VecRetPair,
    },
    JmpKnown {
        dst: MachLabel,
    },
    JmpIf {
        cc: CC,
        taken: MachLabel,
    },
    JmpCond {
        cc: CC,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    JmpTableSeq {
        idx: Reg,
        tmp1: WritableReg,
        tmp2: WritableReg,
        default_target: MachLabel,
        targets: BoxVecMachLabel,
    },
    JmpUnknown {
        target: RegMem,
    },
    TrapIf {
        cc: CC,
        trap_code: TrapCode,
    },
    TrapIfAnd {
        cc1: CC,
        cc2: CC,
        trap_code: TrapCode,
    },
    TrapIfOr {
        cc1: CC,
        cc2: CC,
        trap_code: TrapCode,
    },
    Hlt,
    Ud2 {
        trap_code: TrapCode,
    },
    LoadExtName {
        dst: WritableReg,
        name: BoxExternalName,
        offset: i64,
    },
    LockCmpxchg {
        ty: Type,
        replacement: Reg,
        expected: Reg,
        mem: SyntheticAmode,
        dst_old: WritableReg,
    },
    AtomicRmwSeq {
        ty: Type,
        op: MachAtomicRmwOp,
        mem: SyntheticAmode,
        operand: Reg,
        temp: WritableReg,
        dst_old: WritableReg,
    },
    Fence {
        kind: FenceKind,
    },
    VirtualSPOffsetAdj {
        offset: i64,
    },
    XmmUninitializedValue {
        dst: WritableXmm,
    },
    ElfTlsGetAddr {
        symbol: ExternalName,
        dst: WritableGpr,
    },
    MachOTlsGetAddr {
        symbol: ExternalName,
        dst: WritableGpr,
    },
    CoffTlsGetAddr {
        symbol: ExternalName,
        dst: WritableGpr,
        tmp: WritableGpr,
    },
    Unwind {
        inst: UnwindInst,
    },
    DummyUse {
        reg: Reg,
    },
}

/// Internal type Amode: defined at src/isa/x64/inst.isle line 827.
#[derive(Clone, Debug)]
pub enum Amode {
    ImmReg {
        simm32: u32,
        base: Reg,
        flags: MemFlags,
    },
    ImmRegRegShift {
        simm32: u32,
        base: Gpr,
        index: Gpr,
        shift: u8,
        flags: MemFlags,
    },
    RipRelative {
        target: MachLabel,
    },
}

/// Internal type RegisterClass: defined at src/isa/x64/inst.isle line 1370.
#[derive(Clone, Debug)]
pub enum RegisterClass {
    Gpr { single_register: bool },
    Xmm,
}

/// Internal type ExtendKind: defined at src/isa/x64/inst.isle line 1480.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ExtendKind {
    Sign,
    Zero,
}

/// Internal type IcmpCondResult: defined at src/isa/x64/inst.isle line 3422.
#[derive(Clone, Debug)]
pub enum IcmpCondResult {
    Condition { producer: ProducesFlags, cc: CC },
}

/// Internal type FcmpCondResult: defined at src/isa/x64/inst.isle line 3524.
#[derive(Clone, Debug)]
pub enum FcmpCondResult {
    Condition {
        producer: ProducesFlags,
        cc: CC,
    },
    AndCondition {
        producer: ProducesFlags,
        cc1: CC,
        cc2: CC,
    },
    OrCondition {
        producer: ProducesFlags,
        cc1: CC,
        cc2: CC,
    },
}

// Generated as internal constructor for term output_reg.
pub fn constructor_output_reg<C: Context>(ctx: &mut C, arg0: Reg) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 60.
    let expr0_0 = C::value_reg(ctx, pattern0_0);
    let expr1_0 = C::output(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term output_value.
pub fn constructor_output_value<C: Context>(ctx: &mut C, arg0: Value) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 64.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0 = C::output(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term temp_reg.
pub fn constructor_temp_reg<C: Context>(ctx: &mut C, arg0: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 84.
    let expr0_0 = C::temp_writable_reg(ctx, pattern0_0);
    let expr1_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term value_regs_range.
pub fn constructor_value_regs_range<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Option<Range> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 133.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_len(ctx, pattern0_0);
    let expr2_0 = C::range(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term lo_reg.
pub fn constructor_lo_reg<C: Context>(ctx: &mut C, arg0: Value) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 144.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term side_effect.
pub fn constructor_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &SideEffectNoResult::Inst {
            inst: ref pattern1_0,
        } => {
            // Rule at src/prelude_lower.isle line 301.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::output_none(ctx);
            return Some(expr1_0);
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            // Rule at src/prelude_lower.isle line 304.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::emit(ctx, pattern1_1);
            let expr2_0 = C::output_none(ctx);
            return Some(expr2_0);
        }
        &SideEffectNoResult::Inst3 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
            inst3: ref pattern1_2,
        } => {
            // Rule at src/prelude_lower.isle line 308.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::emit(ctx, pattern1_1);
            let expr2_0 = C::emit(ctx, pattern1_2);
            let expr3_0 = C::output_none(ctx);
            return Some(expr3_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term side_effect_concat.
pub fn constructor_side_effect_concat<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
    arg1: &SideEffectNoResult,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &SideEffectNoResult::Inst {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &SideEffectNoResult::Inst {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 315.
                    let expr0_0 = SideEffectNoResult::Inst2 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                    };
                    return Some(expr0_0);
                }
                &SideEffectNoResult::Inst2 {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 317.
                    let expr0_0 = SideEffectNoResult::Inst3 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                        inst3: pattern3_1.clone(),
                    };
                    return Some(expr0_0);
                }
                _ => {}
            }
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &SideEffectNoResult::Inst {
                inst: ref pattern3_0,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 319.
                let expr0_0 = SideEffectNoResult::Inst3 {
                    inst1: pattern1_0.clone(),
                    inst2: pattern1_1.clone(),
                    inst3: pattern3_0.clone(),
                };
                return Some(expr0_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term produces_flags_append.
pub fn constructor_produces_flags_append<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &MInst,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    if let &ProducesFlags::ProducesFlagsSideEffect {
        inst: ref pattern1_0,
    } = pattern0_0
    {
        let pattern2_0 = arg1;
        // Rule at src/prelude_lower.isle line 361.
        let expr0_0 = ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: pattern1_0.clone(),
            inst2: pattern2_0.clone(),
        };
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term produces_flags_get_reg.
pub fn constructor_produces_flags_get_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    if let &ProducesFlags::ProducesFlagsReturnsReg {
        inst: ref pattern1_0,
        result: pattern1_1,
    } = pattern0_0
    {
        // Rule at src/prelude_lower.isle line 386.
        return Some(pattern1_1);
    }
    return None;
}

// Generated as internal constructor for term produces_flags_ignore.
pub fn constructor_produces_flags_ignore<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            // Rule at src/prelude_lower.isle line 391.
            let expr0_0 = ProducesFlags::ProducesFlagsSideEffect {
                inst: pattern1_0.clone(),
            };
            return Some(expr0_0);
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            // Rule at src/prelude_lower.isle line 393.
            let expr0_0 = ProducesFlags::ProducesFlagsSideEffect {
                inst: pattern1_0.clone(),
            };
            return Some(expr0_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term consumes_flags_concat.
pub fn constructor_consumes_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
    arg1: &ConsumesFlags,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ConsumesFlags::ConsumesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref pattern3_0,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 406.
                let expr0_0 = ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: pattern1_0.clone(),
                    inst2: pattern3_0.clone(),
                };
                return Some(expr0_0);
            }
        }
        &ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: ref pattern3_0,
                result: pattern3_1,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 400.
                let expr0_0 = C::value_regs(ctx, pattern1_1, pattern3_1);
                let expr1_0 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: pattern1_0.clone(),
                    inst2: pattern3_0.clone(),
                    result: expr0_0,
                };
                return Some(expr1_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term with_flags.
pub fn constructor_with_flags<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 437.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_reg(ctx, pattern3_1);
                    return Some(expr2_0);
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    result: pattern3_2,
                } => {
                    // Rule at src/prelude_lower.isle line 443.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::emit(ctx, pattern3_1);
                    return Some(pattern3_2);
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    inst3: ref pattern3_2,
                    inst4: ref pattern3_3,
                    result: pattern3_4,
                } => {
                    // Rule at src/prelude_lower.isle line 455.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::emit(ctx, pattern3_1);
                    let expr3_0 = C::emit(ctx, pattern3_2);
                    let expr4_0 = C::emit(ctx, pattern3_3);
                    return Some(pattern3_4);
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 431.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_reg(ctx, pattern1_1);
                    return Some(expr2_0);
                }
                &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 423.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_regs(ctx, pattern1_1, pattern3_1);
                    return Some(expr2_0);
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 471.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern1_1);
                    let expr2_0 = C::emit(ctx, pattern3_0);
                    let expr3_0 = C::value_reg(ctx, pattern3_1);
                    return Some(expr3_0);
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    result: pattern3_2,
                } => {
                    // Rule at src/prelude_lower.isle line 478.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern1_1);
                    let expr2_0 = C::emit(ctx, pattern3_0);
                    let expr3_0 = C::emit(ctx, pattern3_1);
                    return Some(pattern3_2);
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    inst3: ref pattern3_2,
                    inst4: ref pattern3_3,
                    result: pattern3_4,
                } => {
                    // Rule at src/prelude_lower.isle line 491.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern1_1);
                    let expr2_0 = C::emit(ctx, pattern3_0);
                    let expr3_0 = C::emit(ctx, pattern3_1);
                    let expr4_0 = C::emit(ctx, pattern3_2);
                    let expr5_0 = C::emit(ctx, pattern3_3);
                    return Some(pattern3_4);
                }
                _ => {}
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term with_flags_reg.
pub fn constructor_with_flags_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/prelude_lower.isle line 509.
    let expr0_0 = constructor_with_flags(ctx, pattern0_0, pattern1_0)?;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term flags_to_producesflags.
pub fn constructor_flags_to_producesflags<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 516.
    let expr0_0 = C::mark_value_used(ctx, pattern0_0);
    let expr1_0 = ProducesFlags::AlreadyExistingFlags;
    return Some(expr1_0);
}

// Generated as internal constructor for term with_flags_side_effect.
pub fn constructor_with_flags_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::AlreadyExistingFlags => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 527.
                    let expr0_0 = SideEffectNoResult::Inst {
                        inst: pattern3_0.clone(),
                    };
                    return Some(expr0_0);
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 532.
                    let expr0_0 = SideEffectNoResult::Inst2 {
                        inst1: pattern3_0.clone(),
                        inst2: pattern3_1.clone(),
                    };
                    return Some(expr0_0);
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 537.
                    let expr0_0 = SideEffectNoResult::Inst2 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                    };
                    return Some(expr0_0);
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 542.
                    let expr0_0 = SideEffectNoResult::Inst3 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                        inst3: pattern3_1.clone(),
                    };
                    return Some(expr0_0);
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref pattern3_0,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 547.
                let expr0_0 = SideEffectNoResult::Inst3 {
                    inst1: pattern1_0.clone(),
                    inst2: pattern1_1.clone(),
                    inst3: pattern3_0.clone(),
                };
                return Some(expr0_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term lower_return.
pub fn constructor_lower_return<C: Context>(
    ctx: &mut C,
    arg0: Range,
    arg1: ValueSlice,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/prelude_lower.isle line 727.
    let expr0_0 = C::gen_return(ctx, pattern1_0);
    let expr1_0 = C::output_none(ctx);
    return Some(expr1_0);
}

// Generated as internal constructor for term operand_size_bits.
pub fn constructor_operand_size_bits<C: Context>(ctx: &mut C, arg0: &OperandSize) -> Option<u16> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &OperandSize::Size8 => {
            // Rule at src/isa/x64/inst.isle line 569.
            let expr0_0: u16 = 8i128 as u16;
            return Some(expr0_0);
        }
        &OperandSize::Size16 => {
            // Rule at src/isa/x64/inst.isle line 570.
            let expr0_0: u16 = 16i128 as u16;
            return Some(expr0_0);
        }
        &OperandSize::Size32 => {
            // Rule at src/isa/x64/inst.isle line 571.
            let expr0_0: u16 = 32i128 as u16;
            return Some(expr0_0);
        }
        &OperandSize::Size64 => {
            // Rule at src/isa/x64/inst.isle line 572.
            let expr0_0: u16 = 64i128 as u16;
            return Some(expr0_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term reg_mem_to_reg_mem_imm.
pub fn constructor_reg_mem_to_reg_mem_imm<C: Context>(
    ctx: &mut C,
    arg0: &RegMem,
) -> Option<RegMemImm> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &RegMem::Reg { reg: pattern1_0 } => {
            // Rule at src/isa/x64/inst.isle line 801.
            let expr0_0 = RegMemImm::Reg { reg: pattern1_0 };
            return Some(expr0_0);
        }
        &RegMem::Mem {
            addr: ref pattern1_0,
        } => {
            // Rule at src/isa/x64/inst.isle line 803.
            let expr0_0 = RegMemImm::Mem {
                addr: pattern1_0.clone(),
            };
            return Some(expr0_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term amode_imm_reg_flags.
pub fn constructor_amode_imm_reg_flags<C: Context>(
    ctx: &mut C,
    arg0: u32,
    arg1: Gpr,
    arg2: MemFlags,
) -> Option<Amode> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 855.
    let expr0_0 = C::amode_imm_reg(ctx, pattern0_0, pattern1_0);
    let expr1_0 = C::amode_with_flags(ctx, &expr0_0, pattern2_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term amode_imm_reg_reg_shift_flags.
pub fn constructor_amode_imm_reg_reg_shift_flags<C: Context>(
    ctx: &mut C,
    arg0: u32,
    arg1: Gpr,
    arg2: Gpr,
    arg3: u8,
    arg4: MemFlags,
) -> Option<Amode> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/x64/inst.isle line 862.
    let expr0_0 = C::amode_imm_reg_reg_shift(ctx, pattern0_0, pattern1_0, pattern2_0, pattern3_0);
    let expr1_0 = C::amode_with_flags(ctx, &expr0_0, pattern4_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term to_amode.
pub fn constructor_to_amode<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Offset32,
) -> Option<Amode> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1038.
    let expr0_0 = constructor_amode_initial(ctx, pattern0_0, pattern2_0)?;
    let expr1_0 = constructor_amode_add(ctx, &expr0_0, pattern1_0)?;
    let expr2_0 = constructor_amode_finalize(ctx, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term amode_initial.
pub fn constructor_amode_initial<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Offset32,
) -> Option<Amode> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::offset32(ctx, pattern1_0) {
        // Rule at src/isa/x64/inst.isle line 932.
        let expr0_0 = C::invalid_reg(ctx);
        let expr1_0 = Amode::ImmReg {
            simm32: pattern2_0,
            base: expr0_0,
            flags: pattern0_0,
        };
        return Some(expr1_0);
    }
    return None;
}

// Generated as internal constructor for term amode_add.
pub fn constructor_amode_add<C: Context>(ctx: &mut C, arg0: &Amode, arg1: Value) -> Option<Amode> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &Amode::ImmReg {
            simm32: pattern1_0,
            base: pattern1_1,
            flags: pattern1_2,
        } => {
            let pattern2_0 = C::is_valid_reg(ctx, pattern1_1);
            if pattern2_0 == true {
                let pattern4_0 = arg1;
                if let Some(pattern5_0) = C::def_inst(ctx, pattern4_0) {
                    let pattern6_0 = C::inst_data(ctx, pattern5_0);
                    if let &InstructionData::Unary {
                        opcode: ref pattern7_0,
                        arg: pattern7_1,
                    } = &pattern6_0
                    {
                        if let &Opcode::Uextend = pattern7_0 {
                            if let Some(pattern9_0) = C::def_inst(ctx, pattern7_1) {
                                let pattern10_0 = C::inst_data(ctx, pattern9_0);
                                if let &InstructionData::Binary {
                                    opcode: ref pattern11_0,
                                    args: ref pattern11_1,
                                } = &pattern10_0
                                {
                                    if let &Opcode::Ishl = pattern11_0 {
                                        let (pattern13_0, pattern13_1) =
                                            C::unpack_value_array_2(ctx, pattern11_1);
                                        if let Some(pattern14_0) = C::def_inst(ctx, pattern13_0) {
                                            let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                            if let &InstructionData::Binary {
                                                opcode: ref pattern16_0,
                                                args: ref pattern16_1,
                                            } = &pattern15_0
                                            {
                                                if let &Opcode::Iadd = pattern16_0 {
                                                    let (pattern18_0, pattern18_1) =
                                                        C::unpack_value_array_2(ctx, pattern16_1);
                                                    if let Some(pattern19_0) =
                                                        C::def_inst(ctx, pattern13_1)
                                                    {
                                                        let pattern20_0 =
                                                            C::inst_data(ctx, pattern19_0);
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref pattern21_0,
                                                            imm: pattern21_1,
                                                        } = &pattern20_0
                                                        {
                                                            if let &Opcode::Iconst = pattern21_0 {
                                                                if let Some(pattern23_0) =
                                                                    C::uimm8(ctx, pattern21_1)
                                                                {
                                                                    let mut closure24 = || {
                                                                        let expr0_0 = C::u8_as_u32(
                                                                            ctx,
                                                                            pattern23_0,
                                                                        )?;
                                                                        let expr1_0: u32 =
                                                                            3i128 as u32;
                                                                        let expr2_0 = C::u32_lteq(
                                                                            ctx, expr0_0, expr1_0,
                                                                        )?;
                                                                        return Some(expr2_0);
                                                                    };
                                                                    if let Some(pattern24_0) =
                                                                        closure24()
                                                                    {
                                                                        // Rule at src/isa/x64/inst.isle line 983.
                                                                        let expr0_0 = C::gpr_new(
                                                                            ctx, pattern1_1,
                                                                        );
                                                                        let expr1_0 =
                                                                            constructor_put_in_gpr(
                                                                                ctx,
                                                                                pattern13_0,
                                                                            )?;
                                                                        let expr2_0 =
                                                                            Amode::ImmRegRegShift {
                                                                                simm32: pattern1_0,
                                                                                base: expr0_0,
                                                                                index: expr1_0,
                                                                                shift: pattern23_0,
                                                                                flags: pattern1_2,
                                                                            };
                                                                        return Some(expr2_0);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let pattern2_0 = arg1;
            if let Some(pattern3_0) = C::def_inst(ctx, pattern2_0) {
                let pattern4_0 = C::inst_data(ctx, pattern3_0);
                match &pattern4_0 {
                    &InstructionData::Unary {
                        opcode: ref pattern5_0,
                        arg: pattern5_1,
                    } => {
                        match pattern5_0 {
                            &Opcode::Uextend => {
                                if let Some(pattern7_0) = C::def_inst(ctx, pattern5_1) {
                                    let pattern8_0 = C::inst_data(ctx, pattern7_0);
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern9_0,
                                        imm: pattern9_1,
                                    } = &pattern8_0
                                    {
                                        if let &Opcode::Iconst = pattern9_0 {
                                            if let Some(pattern11_0) = C::simm32(ctx, pattern9_1) {
                                                if let Some(pattern12_0) =
                                                    C::u32_nonnegative(ctx, pattern11_0)
                                                {
                                                    let mut closure13 = || {
                                                        let expr0_0 = C::s32_add_fallible(
                                                            ctx,
                                                            pattern1_0,
                                                            pattern12_0,
                                                        )?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern13_0) = closure13() {
                                                        // Rule at src/isa/x64/inst.isle line 1009.
                                                        let expr0_0 = Amode::ImmReg {
                                                            simm32: pattern13_0,
                                                            base: pattern1_1,
                                                            flags: pattern1_2,
                                                        };
                                                        return Some(expr0_0);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Sextend => {
                                if let Some(pattern7_0) = C::def_inst(ctx, pattern5_1) {
                                    let pattern8_0 = C::inst_data(ctx, pattern7_0);
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern9_0,
                                        imm: pattern9_1,
                                    } = &pattern8_0
                                    {
                                        if let &Opcode::Iconst = pattern9_0 {
                                            if let Some(pattern11_0) = C::simm32(ctx, pattern9_1) {
                                                let mut closure12 = || {
                                                    let expr0_0 = C::s32_add_fallible(
                                                        ctx,
                                                        pattern1_0,
                                                        pattern11_0,
                                                    )?;
                                                    return Some(expr0_0);
                                                };
                                                if let Some(pattern12_0) = closure12() {
                                                    // Rule at src/isa/x64/inst.isle line 1019.
                                                    let expr0_0 = Amode::ImmReg {
                                                        simm32: pattern12_0,
                                                        base: pattern1_1,
                                                        flags: pattern1_2,
                                                    };
                                                    return Some(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &InstructionData::UnaryImm {
                        opcode: ref pattern5_0,
                        imm: pattern5_1,
                    } => {
                        if let &Opcode::Iconst = pattern5_0 {
                            if let Some(pattern7_0) = C::simm32(ctx, pattern5_1) {
                                let mut closure8 = || {
                                    let expr0_0 = C::s32_add_fallible(ctx, pattern1_0, pattern7_0)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern8_0) = closure8() {
                                    // Rule at src/isa/x64/inst.isle line 996.
                                    let expr0_0 = Amode::ImmReg {
                                        simm32: pattern8_0,
                                        base: pattern1_1,
                                        flags: pattern1_2,
                                    };
                                    return Some(expr0_0);
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        &Amode::ImmRegRegShift {
            simm32: pattern1_0,
            base: pattern1_1,
            index: pattern1_2,
            shift: pattern1_3,
            flags: pattern1_4,
        } => {
            let pattern2_0 = arg1;
            if let Some(pattern3_0) = C::def_inst(ctx, pattern2_0) {
                let pattern4_0 = C::inst_data(ctx, pattern3_0);
                match &pattern4_0 {
                    &InstructionData::Unary {
                        opcode: ref pattern5_0,
                        arg: pattern5_1,
                    } => {
                        match pattern5_0 {
                            &Opcode::Uextend => {
                                if let Some(pattern7_0) = C::def_inst(ctx, pattern5_1) {
                                    let pattern8_0 = C::inst_data(ctx, pattern7_0);
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern9_0,
                                        imm: pattern9_1,
                                    } = &pattern8_0
                                    {
                                        if let &Opcode::Iconst = pattern9_0 {
                                            if let Some(pattern11_0) = C::simm32(ctx, pattern9_1) {
                                                if let Some(pattern12_0) =
                                                    C::u32_nonnegative(ctx, pattern11_0)
                                                {
                                                    let mut closure13 = || {
                                                        let expr0_0 = C::s32_add_fallible(
                                                            ctx,
                                                            pattern1_0,
                                                            pattern12_0,
                                                        )?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern13_0) = closure13() {
                                                        // Rule at src/isa/x64/inst.isle line 1013.
                                                        let expr0_0 = Amode::ImmRegRegShift {
                                                            simm32: pattern13_0,
                                                            base: pattern1_1,
                                                            index: pattern1_2,
                                                            shift: pattern1_3,
                                                            flags: pattern1_4,
                                                        };
                                                        return Some(expr0_0);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &Opcode::Sextend => {
                                if let Some(pattern7_0) = C::def_inst(ctx, pattern5_1) {
                                    let pattern8_0 = C::inst_data(ctx, pattern7_0);
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern9_0,
                                        imm: pattern9_1,
                                    } = &pattern8_0
                                    {
                                        if let &Opcode::Iconst = pattern9_0 {
                                            if let Some(pattern11_0) = C::simm32(ctx, pattern9_1) {
                                                let mut closure12 = || {
                                                    let expr0_0 = C::s32_add_fallible(
                                                        ctx,
                                                        pattern1_0,
                                                        pattern11_0,
                                                    )?;
                                                    return Some(expr0_0);
                                                };
                                                if let Some(pattern12_0) = closure12() {
                                                    // Rule at src/isa/x64/inst.isle line 1023.
                                                    let expr0_0 = Amode::ImmRegRegShift {
                                                        simm32: pattern12_0,
                                                        base: pattern1_1,
                                                        index: pattern1_2,
                                                        shift: pattern1_3,
                                                        flags: pattern1_4,
                                                    };
                                                    return Some(expr0_0);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &InstructionData::UnaryImm {
                        opcode: ref pattern5_0,
                        imm: pattern5_1,
                    } => {
                        if let &Opcode::Iconst = pattern5_0 {
                            if let Some(pattern7_0) = C::simm32(ctx, pattern5_1) {
                                let mut closure8 = || {
                                    let expr0_0 = C::s32_add_fallible(ctx, pattern1_0, pattern7_0)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern8_0) = closure8() {
                                    // Rule at src/isa/x64/inst.isle line 1000.
                                    let expr0_0 = Amode::ImmRegRegShift {
                                        simm32: pattern8_0,
                                        base: pattern1_1,
                                        index: pattern1_2,
                                        shift: pattern1_3,
                                        flags: pattern1_4,
                                    };
                                    return Some(expr0_0);
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let &Amode::ImmReg {
        simm32: pattern1_0,
        base: pattern1_1,
        flags: pattern1_2,
    } = pattern0_0
    {
        let pattern2_0 = C::is_valid_reg(ctx, pattern1_1);
        if pattern2_0 == true {
            let pattern4_0 = arg1;
            if let Some(pattern5_0) = C::def_inst(ctx, pattern4_0) {
                let pattern6_0 = C::inst_data(ctx, pattern5_0);
                match &pattern6_0 {
                    &InstructionData::Unary {
                        opcode: ref pattern7_0,
                        arg: pattern7_1,
                    } => {
                        if let &Opcode::Uextend = pattern7_0 {
                            if let Some(pattern9_0) = C::def_inst(ctx, pattern7_1) {
                                let pattern10_0 = C::inst_data(ctx, pattern9_0);
                                if let &InstructionData::Binary {
                                    opcode: ref pattern11_0,
                                    args: ref pattern11_1,
                                } = &pattern10_0
                                {
                                    if let &Opcode::Ishl = pattern11_0 {
                                        let (pattern13_0, pattern13_1) =
                                            C::unpack_value_array_2(ctx, pattern11_1);
                                        if let Some(pattern14_0) = C::def_inst(ctx, pattern13_1) {
                                            let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref pattern16_0,
                                                imm: pattern16_1,
                                            } = &pattern15_0
                                            {
                                                if let &Opcode::Iconst = pattern16_0 {
                                                    if let Some(pattern18_0) =
                                                        C::uimm8(ctx, pattern16_1)
                                                    {
                                                        let mut closure19 = || {
                                                            let expr0_0 =
                                                                C::u8_as_u32(ctx, pattern18_0)?;
                                                            let expr1_0: u32 = 3i128 as u32;
                                                            let expr2_0 =
                                                                C::u32_lteq(ctx, expr0_0, expr1_0)?;
                                                            return Some(expr2_0);
                                                        };
                                                        if let Some(pattern19_0) = closure19() {
                                                            // Rule at src/isa/x64/inst.isle line 973.
                                                            let expr0_0 =
                                                                C::gpr_new(ctx, pattern1_1);
                                                            let expr1_0: Type = I64;
                                                            let expr2_0 = ExtendKind::Zero;
                                                            let expr3_0 =
                                                                constructor_extend_to_gpr(
                                                                    ctx,
                                                                    pattern13_0,
                                                                    expr1_0,
                                                                    &expr2_0,
                                                                )?;
                                                            let expr4_0 = Amode::ImmRegRegShift {
                                                                simm32: pattern1_0,
                                                                base: expr0_0,
                                                                index: expr3_0,
                                                                shift: pattern18_0,
                                                                flags: pattern1_2,
                                                            };
                                                            return Some(expr4_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &InstructionData::Binary {
                        opcode: ref pattern7_0,
                        args: ref pattern7_1,
                    } => {
                        if let &Opcode::Ishl = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_value_array_2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::def_inst(ctx, pattern9_1) {
                                let pattern11_0 = C::inst_data(ctx, pattern10_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern12_0,
                                    imm: pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &Opcode::Iconst = pattern12_0 {
                                        if let Some(pattern14_0) = C::uimm8(ctx, pattern12_1) {
                                            let mut closure15 = || {
                                                let expr0_0 = C::u8_as_u32(ctx, pattern14_0)?;
                                                let expr1_0: u32 = 3i128 as u32;
                                                let expr2_0 = C::u32_lteq(ctx, expr0_0, expr1_0)?;
                                                return Some(expr2_0);
                                            };
                                            if let Some(pattern15_0) = closure15() {
                                                // Rule at src/isa/x64/inst.isle line 970.
                                                let expr0_0 = C::gpr_new(ctx, pattern1_1);
                                                let expr1_0 =
                                                    constructor_put_in_gpr(ctx, pattern9_0)?;
                                                let expr2_0 = Amode::ImmRegRegShift {
                                                    simm32: pattern1_0,
                                                    base: expr0_0,
                                                    index: expr1_0,
                                                    shift: pattern14_0,
                                                    flags: pattern1_2,
                                                };
                                                return Some(expr2_0);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::def_inst(ctx, pattern1_0) {
        let pattern3_0 = C::inst_data(ctx, pattern2_0);
        if let &InstructionData::Binary {
            opcode: ref pattern4_0,
            args: ref pattern4_1,
        } = &pattern3_0
        {
            if let &Opcode::Iadd = pattern4_0 {
                let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                // Rule at src/isa/x64/inst.isle line 946.
                let expr0_0 = constructor_amode_add(ctx, pattern0_0, pattern6_0)?;
                let expr1_0 = constructor_amode_add(ctx, &expr0_0, pattern6_1)?;
                return Some(expr1_0);
            }
        }
    }
    let pattern0_0 = arg0;
    match pattern0_0 {
        &Amode::ImmReg {
            simm32: pattern1_0,
            base: pattern1_1,
            flags: pattern1_2,
        } => {
            let pattern2_0 = C::is_valid_reg(ctx, pattern1_1);
            if pattern2_0 == true {
                let pattern4_0 = arg1;
                // Rule at src/isa/x64/inst.isle line 961.
                let expr0_0 = C::gpr_new(ctx, pattern1_1);
                let expr1_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                let expr2_0: u8 = 0i128 as u8;
                let expr3_0 = Amode::ImmRegRegShift {
                    simm32: pattern1_0,
                    base: expr0_0,
                    index: expr1_0,
                    shift: expr2_0,
                    flags: pattern1_2,
                };
                return Some(expr3_0);
            }
            if pattern2_0 == false {
                let pattern4_0 = arg1;
                // Rule at src/isa/x64/inst.isle line 955.
                let expr0_0 = C::put_in_reg(ctx, pattern4_0);
                let expr1_0 = Amode::ImmReg {
                    simm32: pattern1_0,
                    base: expr0_0,
                    flags: pattern1_2,
                };
                return Some(expr1_0);
            }
        }
        &Amode::ImmRegRegShift {
            simm32: pattern1_0,
            base: pattern1_1,
            index: pattern1_2,
            shift: pattern1_3,
            flags: pattern1_4,
        } => {
            let pattern2_0 = arg1;
            // Rule at src/isa/x64/inst.isle line 1033.
            let expr0_0: Type = I64;
            let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern2_0)?;
            let expr2_0 = constructor_x64_add(ctx, expr0_0, pattern1_1, &expr1_0)?;
            let expr3_0 = Amode::ImmRegRegShift {
                simm32: pattern1_0,
                base: expr2_0,
                index: pattern1_2,
                shift: pattern1_3,
                flags: pattern1_4,
            };
            return Some(expr3_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term amode_finalize.
pub fn constructor_amode_finalize<C: Context>(ctx: &mut C, arg0: &Amode) -> Option<Amode> {
    let pattern0_0 = arg0;
    if let &Amode::ImmReg {
        simm32: pattern1_0,
        base: pattern1_1,
        flags: pattern1_2,
    } = pattern0_0
    {
        let pattern2_0 = C::is_valid_reg(ctx, pattern1_1);
        if pattern2_0 == false {
            // Rule at src/isa/x64/inst.isle line 1045.
            let expr0_0: Type = I64;
            let expr1_0: u64 = 0i128 as u64;
            let expr2_0 = constructor_imm(ctx, expr0_0, expr1_0)?;
            let expr3_0 = Amode::ImmReg {
                simm32: pattern1_0,
                base: expr2_0,
                flags: pattern1_2,
            };
            return Some(expr3_0);
        }
    }
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1047.
    return Some(pattern0_0.clone());
}

// Generated as internal constructor for term put_masked_in_imm8_gpr.
pub fn constructor_put_masked_in_imm8_gpr<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Type,
) -> Option<Imm8Gpr> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::def_inst(ctx, pattern0_0) {
        let pattern2_0 = C::inst_data(ctx, pattern1_0);
        if let &InstructionData::UnaryImm {
            opcode: ref pattern3_0,
            imm: pattern3_1,
        } = &pattern2_0
        {
            if let &Opcode::Iconst = pattern3_0 {
                let pattern5_0 = C::u64_from_imm64(ctx, pattern3_1);
                let pattern6_0 = arg1;
                // Rule at src/isa/x64/inst.isle line 1082.
                let expr0_0 = C::const_to_type_masked_imm8(ctx, pattern5_0, pattern6_0);
                return Some(expr0_0);
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::fits_in_16(ctx, pattern1_0) {
        // Rule at src/isa/x64/inst.isle line 1084.
        let expr0_0: Type = I64;
        let expr1_0 = C::put_in_regs(ctx, pattern0_0);
        let expr2_0: usize = 0i128 as usize;
        let expr3_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr2_0)?;
        let expr4_0 = C::shift_mask(ctx, pattern2_0);
        let expr5_0 = RegMemImm::Imm { simm32: expr4_0 };
        let expr6_0 = C::gpr_mem_imm_new(ctx, &expr5_0);
        let expr7_0 = constructor_x64_and(ctx, expr0_0, expr3_0, &expr6_0)?;
        let expr8_0 = C::gpr_to_imm8_gpr(ctx, expr7_0);
        return Some(expr8_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1086.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
    let expr3_0 = C::gpr_to_imm8_gpr(ctx, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term reg_to_gpr_mem_imm.
pub fn constructor_reg_to_gpr_mem_imm<C: Context>(ctx: &mut C, arg0: Reg) -> Option<GprMemImm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1282.
    let expr0_0 = C::gpr_new(ctx, pattern0_0);
    let expr1_0 = C::gpr_to_gpr_mem_imm(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term put_in_gpr.
pub fn constructor_put_in_gpr<C: Context>(ctx: &mut C, arg0: Value) -> Option<Gpr> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1289.
    let expr0_0 = C::put_in_reg(ctx, pattern0_0);
    let expr1_0 = C::gpr_new(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term put_in_gpr_mem.
pub fn constructor_put_in_gpr_mem<C: Context>(ctx: &mut C, arg0: Value) -> Option<GprMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1296.
    let expr0_0 = C::put_in_reg_mem(ctx, pattern0_0);
    let expr1_0 = C::reg_mem_to_gpr_mem(ctx, &expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term put_in_gpr_mem_imm.
pub fn constructor_put_in_gpr_mem_imm<C: Context>(ctx: &mut C, arg0: Value) -> Option<GprMemImm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1303.
    let expr0_0 = C::put_in_reg_mem_imm(ctx, pattern0_0);
    let expr1_0 = C::gpr_mem_imm_new(ctx, &expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term put_in_xmm.
pub fn constructor_put_in_xmm<C: Context>(ctx: &mut C, arg0: Value) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1310.
    let expr0_0 = C::put_in_reg(ctx, pattern0_0);
    let expr1_0 = C::xmm_new(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term output_gpr.
pub fn constructor_output_gpr<C: Context>(ctx: &mut C, arg0: Gpr) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1327.
    let expr0_0 = C::gpr_to_reg(ctx, pattern0_0);
    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term value_gprs.
pub fn constructor_value_gprs<C: Context>(ctx: &mut C, arg0: Gpr, arg1: Gpr) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1332.
    let expr0_0 = C::gpr_to_reg(ctx, pattern0_0);
    let expr1_0 = C::gpr_to_reg(ctx, pattern1_0);
    let expr2_0 = C::value_regs(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term output_xmm.
pub fn constructor_output_xmm<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1337.
    let expr0_0 = C::xmm_to_reg(ctx, pattern0_0);
    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term value_regs_get_gpr.
pub fn constructor_value_regs_get_gpr<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: usize,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1344.
    let expr0_0 = C::value_regs_get(ctx, pattern0_0, pattern1_0);
    let expr1_0 = C::gpr_new(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term lo_gpr.
pub fn constructor_lo_gpr<C: Context>(ctx: &mut C, arg0: Value) -> Option<Gpr> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1357.
    let expr0_0 = constructor_lo_reg(ctx, pattern0_0)?;
    let expr1_0 = C::gpr_new(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term sink_load_to_gpr_mem_imm.
pub fn constructor_sink_load_to_gpr_mem_imm<C: Context>(
    ctx: &mut C,
    arg0: &SinkableLoad,
) -> Option<GprMemImm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1466.
    let expr0_0 = C::sink_load(ctx, pattern0_0);
    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
    let expr2_0 = C::gpr_mem_imm_new(ctx, &expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term sink_load_to_xmm_mem.
pub fn constructor_sink_load_to_xmm_mem<C: Context>(
    ctx: &mut C,
    arg0: &SinkableLoad,
) -> Option<XmmMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1470.
    let expr0_0 = C::sink_load(ctx, pattern0_0);
    let expr1_0 = C::reg_mem_to_xmm_mem(ctx, &expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term extend_to_gpr.
pub fn constructor_extend_to_gpr<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Type,
    arg2: &ExtendKind,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = C::value_type(ctx, pattern0_0);
    let pattern2_0 = arg1;
    if pattern2_0 == pattern1_0 {
        let pattern4_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 1495.
        let expr0_0 = constructor_put_in_gpr(ctx, pattern0_0)?;
        return Some(expr0_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::value_type(ctx, pattern0_0);
    let pattern2_0 = arg1;
    let pattern3_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1498.
    let expr0_0 = C::ty_bits_u16(ctx, pattern1_0);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern2_0);
    let expr2_0 = constructor_operand_size_bits(ctx, &expr1_0)?;
    let expr3_0 = C::ext_mode(ctx, expr0_0, expr2_0);
    let expr4_0 = constructor_put_in_gpr_mem(ctx, pattern0_0)?;
    let expr5_0 = constructor_extend(ctx, pattern3_0, pattern2_0, &expr3_0, &expr4_0)?;
    return Some(expr5_0);
}

// Generated as internal constructor for term extend.
pub fn constructor_extend<C: Context>(
    ctx: &mut C,
    arg0: &ExtendKind,
    arg1: Type,
    arg2: &ExtMode,
    arg3: &GprMem,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ExtendKind::Sign => {
            let pattern2_0 = arg1;
            let pattern3_0 = arg2;
            let pattern4_0 = arg3;
            // Rule at src/isa/x64/inst.isle line 1518.
            let expr0_0 = constructor_x64_movsx(ctx, pattern3_0, pattern4_0)?;
            return Some(expr0_0);
        }
        &ExtendKind::Zero => {
            let pattern2_0 = arg1;
            let pattern3_0 = arg2;
            let pattern4_0 = arg3;
            // Rule at src/isa/x64/inst.isle line 1514.
            let expr0_0 = constructor_x64_movzx(ctx, pattern3_0, pattern4_0)?;
            return Some(expr0_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term vec_int_type.
pub fn constructor_vec_int_type<C: Context>(ctx: &mut C, arg0: Type) -> Option<Type> {
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::multi_lane(ctx, pattern0_0) {
        if pattern1_0 == 8i128 as u32 {
            if pattern1_1 == 16i128 as u32 {
                // Rule at src/isa/x64/inst.isle line 1525.
                let expr0_0: Type = I8X16;
                return Some(expr0_0);
            }
        }
        if pattern1_0 == 16i128 as u32 {
            if pattern1_1 == 8i128 as u32 {
                // Rule at src/isa/x64/inst.isle line 1526.
                let expr0_0: Type = I16X8;
                return Some(expr0_0);
            }
        }
        if pattern1_0 == 32i128 as u32 {
            if pattern1_1 == 4i128 as u32 {
                // Rule at src/isa/x64/inst.isle line 1527.
                let expr0_0: Type = I32X4;
                return Some(expr0_0);
            }
        }
        if pattern1_0 == 64i128 as u32 {
            if pattern1_1 == 2i128 as u32 {
                // Rule at src/isa/x64/inst.isle line 1528.
                let expr0_0: Type = I64X2;
                return Some(expr0_0);
            }
        }
    }
    return None;
}

// Generated as internal constructor for term sse_xor_op.
pub fn constructor_sse_xor_op<C: Context>(ctx: &mut C, arg0: Type) -> Option<SseOpcode> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        // Rule at src/isa/x64/inst.isle line 1534.
        let expr0_0 = SseOpcode::Xorps;
        return Some(expr0_0);
    }
    if pattern0_0 == F64 {
        // Rule at src/isa/x64/inst.isle line 1535.
        let expr0_0 = SseOpcode::Xorpd;
        return Some(expr0_0);
    }
    if pattern0_0 == F32X4 {
        // Rule at src/isa/x64/inst.isle line 1532.
        let expr0_0 = SseOpcode::Xorps;
        return Some(expr0_0);
    }
    if pattern0_0 == F64X2 {
        // Rule at src/isa/x64/inst.isle line 1533.
        let expr0_0 = SseOpcode::Xorpd;
        return Some(expr0_0);
    }
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::multi_lane(ctx, pattern0_0) {
        // Rule at src/isa/x64/inst.isle line 1539.
        let expr0_0 = SseOpcode::Pxor;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term sse_xor.
pub fn constructor_sse_xor<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1543.
    let expr0_0 = constructor_sse_xor_op(ctx, pattern0_0)?;
    let expr1_0 = constructor_xmm_rm_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term vector_all_ones.
pub fn constructor_vector_all_ones<C: Context>(ctx: &mut C) -> Option<Xmm> {
    // Rule at src/isa/x64/inst.isle line 1555.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    let expr2_0 = constructor_writable_xmm_to_xmm_mem(ctx, expr0_0)?;
    let expr3_0 = constructor_x64_pcmpeqd(ctx, expr1_0, &expr2_0)?;
    return Some(expr3_0);
}

// Generated as internal constructor for term xmm_uninit_value.
pub fn constructor_xmm_uninit_value<C: Context>(ctx: &mut C) -> Option<Xmm> {
    // Rule at src/isa/x64/inst.isle line 1561.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmUninitializedValue { dst: expr0_0 };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term make_i64x2_from_lanes.
pub fn constructor_make_i64x2_from_lanes<C: Context>(
    ctx: &mut C,
    arg0: &GprMem,
    arg1: &GprMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1568.
    let expr0_0 = constructor_xmm_uninit_value(ctx)?;
    let expr1_0: u8 = 0i128 as u8;
    let expr2_0 = OperandSize::Size64;
    let expr3_0 = constructor_x64_pinsrd(ctx, expr0_0, pattern0_0, expr1_0, &expr2_0)?;
    let expr4_0: u8 = 1i128 as u8;
    let expr5_0 = OperandSize::Size64;
    let expr6_0 = constructor_x64_pinsrd(ctx, expr3_0, pattern1_0, expr4_0, &expr5_0)?;
    return Some(expr6_0);
}

// Generated as internal constructor for term mov_rmi_to_xmm.
pub fn constructor_mov_rmi_to_xmm<C: Context>(ctx: &mut C, arg0: &RegMemImm) -> Option<XmmMemImm> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &RegMemImm::Imm { simm32: pattern1_0 } => {
            // Rule at src/isa/x64/inst.isle line 1577.
            let expr0_0 = C::xmm_mem_imm_new(ctx, pattern0_0);
            return Some(expr0_0);
        }
        &RegMemImm::Reg { reg: pattern1_0 } => {
            // Rule at src/isa/x64/inst.isle line 1578.
            let expr0_0 = SseOpcode::Movd;
            let expr1_0 = C::reg_to_gpr_mem(ctx, pattern1_0);
            let expr2_0 = OperandSize::Size32;
            let expr3_0 = constructor_gpr_to_xmm(ctx, &expr0_0, &expr1_0, &expr2_0)?;
            let expr4_0 = C::xmm_to_xmm_mem_imm(ctx, expr3_0);
            return Some(expr4_0);
        }
        &RegMemImm::Mem {
            addr: ref pattern1_0,
        } => {
            // Rule at src/isa/x64/inst.isle line 1576.
            let expr0_0 = C::xmm_mem_imm_new(ctx, pattern0_0);
            return Some(expr0_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term load_ext_name.
pub fn constructor_load_ext_name<C: Context>(
    ctx: &mut C,
    arg0: ExternalName,
    arg1: i64,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1595.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::writable_gpr_to_reg(ctx, expr0_0);
    let expr2_0 = C::box_external_name(ctx, pattern0_0);
    let expr3_0 = MInst::LoadExtName {
        dst: expr1_0,
        name: expr2_0,
        offset: pattern1_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_load.
pub fn constructor_x64_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &SyntheticAmode,
    arg2: &ExtKind,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 1607.
        let expr0_0 = C::temp_writable_gpr(ctx);
        let expr1_0 = MInst::Mov64MR {
            src: pattern2_0.clone(),
            dst: expr0_0,
        };
        let expr2_0 = C::emit(ctx, &expr1_0);
        let expr3_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
        return Some(expr3_0);
    }
    if pattern0_0 == F32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 1612.
        let expr0_0 = SseOpcode::Movss;
        let expr1_0 = constructor_synthetic_amode_to_xmm_mem(ctx, pattern2_0)?;
        let expr2_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, &expr1_0)?;
        let expr3_0 = C::xmm_to_reg(ctx, expr2_0);
        return Some(expr3_0);
    }
    if pattern0_0 == F64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 1616.
        let expr0_0 = SseOpcode::Movsd;
        let expr1_0 = constructor_synthetic_amode_to_xmm_mem(ctx, pattern2_0)?;
        let expr2_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, &expr1_0)?;
        let expr3_0 = C::xmm_to_reg(ctx, expr2_0);
        return Some(expr3_0);
    }
    if pattern0_0 == F32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 1620.
        let expr0_0 = SseOpcode::Movups;
        let expr1_0 = constructor_synthetic_amode_to_xmm_mem(ctx, pattern2_0)?;
        let expr2_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, &expr1_0)?;
        let expr3_0 = C::xmm_to_reg(ctx, expr2_0);
        return Some(expr3_0);
    }
    if pattern0_0 == F64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 1624.
        let expr0_0 = SseOpcode::Movupd;
        let expr1_0 = constructor_synthetic_amode_to_xmm_mem(ctx, pattern2_0)?;
        let expr2_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, &expr1_0)?;
        let expr3_0 = C::xmm_to_reg(ctx, expr2_0);
        return Some(expr3_0);
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_32(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        if let &ExtKind::SignExtend = pattern3_0 {
            // Rule at src/isa/x64/inst.isle line 1603.
            let expr0_0 = C::ty_bytes(ctx, pattern1_0);
            let expr1_0: u16 = 8i128 as u16;
            let expr2_0 = C::ext_mode(ctx, expr0_0, expr1_0);
            let expr3_0 = constructor_synthetic_amode_to_gpr_mem(ctx, pattern2_0)?;
            let expr4_0 = constructor_x64_movsx(ctx, &expr2_0, &expr3_0)?;
            let expr5_0 = C::gpr_to_reg(ctx, expr4_0);
            return Some(expr5_0);
        }
    }
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::multi_lane(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 1628.
        let expr0_0 = SseOpcode::Movdqu;
        let expr1_0 = constructor_synthetic_amode_to_xmm_mem(ctx, pattern2_0)?;
        let expr2_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, &expr1_0)?;
        let expr3_0 = C::xmm_to_reg(ctx, expr2_0);
        return Some(expr3_0);
    }
    return None;
}

// Generated as internal constructor for term x64_mov.
pub fn constructor_x64_mov<C: Context>(ctx: &mut C, arg0: &Amode) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1632.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::amode_to_synthetic_amode(ctx, pattern0_0);
    let expr2_0 = MInst::Mov64MR {
        src: expr1_0,
        dst: expr0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_movzx.
pub fn constructor_x64_movzx<C: Context>(
    ctx: &mut C,
    arg0: &ExtMode,
    arg1: &GprMem,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1638.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = MInst::MovzxRmR {
        ext_mode: pattern0_0.clone(),
        src: pattern1_0.clone(),
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_movsx.
pub fn constructor_x64_movsx<C: Context>(
    ctx: &mut C,
    arg0: &ExtMode,
    arg1: &GprMem,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1644.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = MInst::MovsxRmR {
        ext_mode: pattern0_0.clone(),
        src: pattern1_0.clone(),
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_movss_load.
pub fn constructor_x64_movss_load<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1650.
    let expr0_0 = SseOpcode::Movss;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_movsd_load.
pub fn constructor_x64_movsd_load<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1654.
    let expr0_0 = SseOpcode::Movsd;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_movups.
pub fn constructor_x64_movups<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1658.
    let expr0_0 = SseOpcode::Movups;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_movupd.
pub fn constructor_x64_movupd<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1662.
    let expr0_0 = SseOpcode::Movupd;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_movd.
pub fn constructor_x64_movd<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Gpr> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1666.
    let expr0_0 = SseOpcode::Movd;
    let expr1_0 = OperandSize::Size32;
    let expr2_0 = constructor_xmm_to_gpr(ctx, &expr0_0, pattern0_0, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_movdqu.
pub fn constructor_x64_movdqu<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1670.
    let expr0_0 = SseOpcode::Movdqu;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_movapd.
pub fn constructor_x64_movapd<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1674.
    let expr0_0 = SseOpcode::Movapd;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pmovsxbw.
pub fn constructor_x64_pmovsxbw<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1678.
    let expr0_0 = SseOpcode::Pmovsxbw;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pmovzxbw.
pub fn constructor_x64_pmovzxbw<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1682.
    let expr0_0 = SseOpcode::Pmovzxbw;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pmovsxwd.
pub fn constructor_x64_pmovsxwd<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1686.
    let expr0_0 = SseOpcode::Pmovsxwd;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pmovzxwd.
pub fn constructor_x64_pmovzxwd<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1690.
    let expr0_0 = SseOpcode::Pmovzxwd;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pmovsxdq.
pub fn constructor_x64_pmovsxdq<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1694.
    let expr0_0 = SseOpcode::Pmovsxdq;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pmovzxdq.
pub fn constructor_x64_pmovzxdq<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 1698.
    let expr0_0 = SseOpcode::Pmovzxdq;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_movrm.
pub fn constructor_x64_movrm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &SyntheticAmode,
    arg2: Gpr,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1702.
    let expr0_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr1_0 = MInst::MovRM {
        size: expr0_0,
        src: pattern2_0,
        dst: pattern1_0.clone(),
    };
    let expr2_0 = SideEffectNoResult::Inst { inst: expr1_0 };
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_xmm_movrm.
pub fn constructor_x64_xmm_movrm<C: Context>(
    ctx: &mut C,
    arg0: &SseOpcode,
    arg1: &SyntheticAmode,
    arg2: Xmm,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1707.
    let expr0_0 = C::xmm_to_reg(ctx, pattern2_0);
    let expr1_0 = MInst::XmmMovRM {
        op: pattern0_0.clone(),
        src: expr0_0,
        dst: pattern1_0.clone(),
    };
    let expr2_0 = SideEffectNoResult::Inst { inst: expr1_0 };
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_xmm_load_const.
pub fn constructor_x64_xmm_load_const<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: VCodeConstant,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1712.
    let expr0_0 = C::const_to_synthetic_amode(ctx, pattern1_0);
    let expr1_0 = ExtKind::None;
    let expr2_0 = constructor_x64_load(ctx, pattern0_0, &expr0_0, &expr1_0)?;
    let expr3_0 = C::xmm_new(ctx, expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term alu_rmi_r.
pub fn constructor_alu_rmi_r<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &AluRmiROpcode,
    arg2: Gpr,
    arg3: &GprMemImm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 1723.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = MInst::AluRmiR {
        size: expr1_0,
        op: pattern1_0.clone(),
        src1: pattern2_0,
        src2: pattern3_0.clone(),
        dst: expr0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_add.
pub fn constructor_x64_add<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1731.
    let expr0_0 = AluRmiROpcode::Add;
    let expr1_0 = constructor_alu_rmi_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_add_with_flags_paired.
pub fn constructor_x64_add_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1739.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = AluRmiROpcode::Add;
    let expr3_0 = MInst::AluRmiR {
        size: expr1_0,
        op: expr2_0,
        src1: pattern1_0,
        src2: pattern2_0.clone(),
        dst: expr0_0,
    };
    let expr4_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr5_0 = ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
        inst: expr3_0,
        result: expr4_0,
    };
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_adc_paired.
pub fn constructor_x64_adc_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1751.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = AluRmiROpcode::Adc;
    let expr3_0 = MInst::AluRmiR {
        size: expr1_0,
        op: expr2_0,
        src1: pattern1_0,
        src2: pattern2_0.clone(),
        dst: expr0_0,
    };
    let expr4_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr5_0 = ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
        inst: expr3_0,
        result: expr4_0,
    };
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_sub.
pub fn constructor_x64_sub<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1763.
    let expr0_0 = AluRmiROpcode::Sub;
    let expr1_0 = constructor_alu_rmi_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_sub_with_flags_paired.
pub fn constructor_x64_sub_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1771.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = AluRmiROpcode::Sub;
    let expr3_0 = MInst::AluRmiR {
        size: expr1_0,
        op: expr2_0,
        src1: pattern1_0,
        src2: pattern2_0.clone(),
        dst: expr0_0,
    };
    let expr4_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr5_0 = ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
        inst: expr3_0,
        result: expr4_0,
    };
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_sbb_paired.
pub fn constructor_x64_sbb_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1783.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = AluRmiROpcode::Sbb;
    let expr3_0 = MInst::AluRmiR {
        size: expr1_0,
        op: expr2_0,
        src1: pattern1_0,
        src2: pattern2_0.clone(),
        dst: expr0_0,
    };
    let expr4_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr5_0 = ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
        inst: expr3_0,
        result: expr4_0,
    };
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_mul.
pub fn constructor_x64_mul<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1795.
    let expr0_0 = AluRmiROpcode::Mul;
    let expr1_0 = constructor_alu_rmi_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_and.
pub fn constructor_x64_and<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1803.
    let expr0_0 = AluRmiROpcode::And;
    let expr1_0 = constructor_alu_rmi_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_and_with_flags_paired.
pub fn constructor_x64_and_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1810.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = AluRmiROpcode::And;
    let expr3_0 = MInst::AluRmiR {
        size: expr1_0,
        op: expr2_0,
        src1: pattern1_0,
        src2: pattern2_0.clone(),
        dst: expr0_0,
    };
    let expr4_0 = ProducesFlags::ProducesFlagsSideEffect { inst: expr3_0 };
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_or.
pub fn constructor_x64_or<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1821.
    let expr0_0 = AluRmiROpcode::Or;
    let expr1_0 = constructor_alu_rmi_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_xor.
pub fn constructor_x64_xor<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMemImm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1829.
    let expr0_0 = AluRmiROpcode::Xor;
    let expr1_0 = constructor_alu_rmi_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term imm_i64.
pub fn constructor_imm_i64<C: Context>(ctx: &mut C, arg0: Type, arg1: i64) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1839.
    let expr0_0 = C::i64_as_u64(ctx, pattern1_0)?;
    let expr1_0 = constructor_imm(ctx, pattern0_0, expr0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term imm.
pub fn constructor_imm<C: Context>(ctx: &mut C, arg0: Type, arg1: u64) -> Option<Reg> {
    let pattern0_0 = arg0;
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        if let Some(pattern3_0) = C::nonzero_u64_fits_in_u32(ctx, pattern2_0) {
            // Rule at src/isa/x64/inst.isle line 1874.
            let expr0_0 = C::temp_writable_gpr(ctx);
            let expr1_0 = OperandSize::Size32;
            let expr2_0 = MInst::Imm {
                dst_size: expr1_0,
                simm64: pattern3_0,
                dst: expr0_0,
            };
            let expr3_0 = C::emit(ctx, &expr2_0);
            let expr4_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
            return Some(expr4_0);
        }
    }
    if pattern0_0 == F32 {
        let pattern2_0 = arg1;
        let pattern3_0 = C::u64_is_zero(ctx, pattern2_0);
        if pattern3_0 == true {
            // Rule at src/isa/x64/inst.isle line 1903.
            let expr0_0 = C::temp_writable_xmm(ctx);
            let expr1_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
            let expr2_0 = SseOpcode::Xorps;
            let expr3_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
            let expr4_0 = MInst::XmmRmR {
                op: expr2_0,
                src1: expr1_0,
                src2: expr3_0,
                dst: expr0_0,
            };
            let expr5_0 = C::emit(ctx, &expr4_0);
            let expr6_0 = C::xmm_to_reg(ctx, expr1_0);
            return Some(expr6_0);
        }
        if pattern3_0 == false {
            // Rule at src/isa/x64/inst.isle line 1861.
            let expr0_0 = SseOpcode::Movd;
            let expr1_0: Type = I32;
            let expr2_0 = constructor_imm(ctx, expr1_0, pattern2_0)?;
            let expr3_0 = C::reg_to_gpr_mem(ctx, expr2_0);
            let expr4_0 = OperandSize::Size32;
            let expr5_0 = constructor_gpr_to_xmm(ctx, &expr0_0, &expr3_0, &expr4_0)?;
            let expr6_0 = C::xmm_to_reg(ctx, expr5_0);
            return Some(expr6_0);
        }
    }
    if pattern0_0 == F64 {
        let pattern2_0 = arg1;
        let pattern3_0 = C::u64_is_zero(ctx, pattern2_0);
        if pattern3_0 == true {
            // Rule at src/isa/x64/inst.isle line 1915.
            let expr0_0 = C::temp_writable_xmm(ctx);
            let expr1_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
            let expr2_0 = SseOpcode::Xorpd;
            let expr3_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
            let expr4_0 = MInst::XmmRmR {
                op: expr2_0,
                src1: expr1_0,
                src2: expr3_0,
                dst: expr0_0,
            };
            let expr5_0 = C::emit(ctx, &expr4_0);
            let expr6_0 = C::xmm_to_reg(ctx, expr1_0);
            return Some(expr6_0);
        }
        if pattern3_0 == false {
            // Rule at src/isa/x64/inst.isle line 1867.
            let expr0_0 = SseOpcode::Movq;
            let expr1_0: Type = I64;
            let expr2_0 = constructor_imm(ctx, expr1_0, pattern2_0)?;
            let expr3_0 = C::reg_to_gpr_mem(ctx, expr2_0);
            let expr4_0 = OperandSize::Size64;
            let expr5_0 = constructor_gpr_to_xmm(ctx, &expr0_0, &expr3_0, &expr4_0)?;
            let expr6_0 = C::xmm_to_reg(ctx, expr5_0);
            return Some(expr6_0);
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        let pattern3_0 = C::u64_is_zero(ctx, pattern2_0);
        if pattern3_0 == true {
            // Rule at src/isa/x64/inst.isle line 1880.
            let expr0_0 = C::temp_writable_gpr(ctx);
            let expr1_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
            let expr2_0 = C::operand_size_of_type_32_64(ctx, pattern1_0);
            let expr3_0 = AluRmiROpcode::Xor;
            let expr4_0 = C::gpr_to_gpr_mem_imm(ctx, expr1_0);
            let expr5_0 = MInst::AluRmiR {
                size: expr2_0,
                op: expr3_0,
                src1: expr1_0,
                src2: expr4_0,
                dst: expr0_0,
            };
            let expr6_0 = C::emit(ctx, &expr5_0);
            let expr7_0 = C::gpr_to_reg(ctx, expr1_0);
            return Some(expr7_0);
        }
        if pattern3_0 == false {
            // Rule at src/isa/x64/inst.isle line 1854.
            let expr0_0 = C::temp_writable_gpr(ctx);
            let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern1_0);
            let expr2_0 = MInst::Imm {
                dst_size: expr1_0,
                simm64: pattern2_0,
                dst: expr0_0,
            };
            let expr3_0 = C::emit(ctx, &expr2_0);
            let expr4_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
            return Some(expr4_0);
        }
    }
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::multi_lane(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        if pattern2_0 == 0i128 as u64 {
            // Rule at src/isa/x64/inst.isle line 1893.
            let expr0_0 = C::temp_writable_xmm(ctx);
            let expr1_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
            let expr2_0 = constructor_sse_xor_op(ctx, pattern0_0)?;
            let expr3_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
            let expr4_0 = MInst::XmmRmR {
                op: expr2_0,
                src1: expr1_0,
                src2: expr3_0,
                dst: expr0_0,
            };
            let expr5_0 = C::emit(ctx, &expr4_0);
            let expr6_0 = C::xmm_to_reg(ctx, expr1_0);
            return Some(expr6_0);
        }
    }
    return None;
}

// Generated as internal constructor for term shift_r.
pub fn constructor_shift_r<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ShiftKind,
    arg2: Gpr,
    arg3: &Imm8Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 1928.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr2_0 = MInst::ShiftR {
        size: expr1_0,
        kind: pattern1_0.clone(),
        src: pattern2_0,
        num_bits: pattern3_0.clone(),
        dst: expr0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_rotl.
pub fn constructor_x64_rotl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &Imm8Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1938.
    let expr0_0 = ShiftKind::RotateLeft;
    let expr1_0 = constructor_shift_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_rotr.
pub fn constructor_x64_rotr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &Imm8Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1943.
    let expr0_0 = ShiftKind::RotateRight;
    let expr1_0 = constructor_shift_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_shl.
pub fn constructor_x64_shl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &Imm8Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1948.
    let expr0_0 = ShiftKind::ShiftLeft;
    let expr1_0 = constructor_shift_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_shr.
pub fn constructor_x64_shr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &Imm8Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1953.
    let expr0_0 = ShiftKind::ShiftRightLogical;
    let expr1_0 = constructor_shift_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_sar.
pub fn constructor_x64_sar<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &Imm8Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1958.
    let expr0_0 = ShiftKind::ShiftRightArithmetic;
    let expr1_0 = constructor_shift_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_bswap.
pub fn constructor_x64_bswap<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 1965.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = MInst::Bswap {
        size: expr1_0,
        src: pattern1_0,
        dst: expr0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term cmp_rmi_r.
pub fn constructor_cmp_rmi_r<C: Context>(
    ctx: &mut C,
    arg0: &OperandSize,
    arg1: &CmpOpcode,
    arg2: &GprMemImm,
    arg3: Gpr,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 1973.
    let expr0_0 = MInst::CmpRmiR {
        size: pattern0_0.clone(),
        opcode: pattern1_0.clone(),
        src: pattern2_0.clone(),
        dst: pattern3_0,
    };
    let expr1_0 = ProducesFlags::ProducesFlagsSideEffect { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_cmp.
pub fn constructor_x64_cmp<C: Context>(
    ctx: &mut C,
    arg0: &OperandSize,
    arg1: &GprMemImm,
    arg2: Gpr,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1982.
    let expr0_0 = CmpOpcode::Cmp;
    let expr1_0 = constructor_cmp_rmi_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_cmp_imm.
pub fn constructor_x64_cmp_imm<C: Context>(
    ctx: &mut C,
    arg0: &OperandSize,
    arg1: u32,
    arg2: Gpr,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1987.
    let expr0_0 = CmpOpcode::Cmp;
    let expr1_0 = RegMemImm::Imm { simm32: pattern1_0 };
    let expr2_0 = C::gpr_mem_imm_new(ctx, &expr1_0);
    let expr3_0 = constructor_cmp_rmi_r(ctx, pattern0_0, &expr0_0, &expr2_0, pattern2_0)?;
    return Some(expr3_0);
}

// Generated as internal constructor for term xmm_cmp_rm_r.
pub fn constructor_xmm_cmp_rm_r<C: Context>(
    ctx: &mut C,
    arg0: &SseOpcode,
    arg1: &XmmMem,
    arg2: Xmm,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 1992.
    let expr0_0 = MInst::XmmCmpRmR {
        op: pattern0_0.clone(),
        src: pattern1_0.clone(),
        dst: pattern2_0,
    };
    let expr1_0 = ProducesFlags::ProducesFlagsSideEffect { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_ucomis.
pub fn constructor_x64_ucomis<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = C::value_type(ctx, pattern0_0);
    if pattern1_0 == F32 {
        let pattern3_0 = arg1;
        // Rule at src/isa/x64/inst.isle line 1998.
        let expr0_0 = SseOpcode::Ucomiss;
        let expr1_0 = constructor_put_in_xmm(ctx, pattern0_0)?;
        let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
        let expr3_0 = constructor_put_in_xmm(ctx, pattern3_0)?;
        let expr4_0 = constructor_xmm_cmp_rm_r(ctx, &expr0_0, &expr2_0, expr3_0)?;
        return Some(expr4_0);
    }
    if pattern1_0 == F64 {
        let pattern3_0 = arg1;
        // Rule at src/isa/x64/inst.isle line 2002.
        let expr0_0 = SseOpcode::Ucomisd;
        let expr1_0 = constructor_put_in_xmm(ctx, pattern0_0)?;
        let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
        let expr3_0 = constructor_put_in_xmm(ctx, pattern3_0)?;
        let expr4_0 = constructor_xmm_cmp_rm_r(ctx, &expr0_0, &expr2_0, expr3_0)?;
        return Some(expr4_0);
    }
    return None;
}

// Generated as internal constructor for term x64_test.
pub fn constructor_x64_test<C: Context>(
    ctx: &mut C,
    arg0: &OperandSize,
    arg1: &GprMemImm,
    arg2: Gpr,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2007.
    let expr0_0 = CmpOpcode::Test;
    let expr1_0 = constructor_cmp_rmi_r(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_ptest.
pub fn constructor_x64_ptest<C: Context>(
    ctx: &mut C,
    arg0: &XmmMem,
    arg1: Xmm,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2012.
    let expr0_0 = SseOpcode::Ptest;
    let expr1_0 = constructor_xmm_cmp_rm_r(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term cmove.
pub fn constructor_cmove<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &CC,
    arg2: &GprMem,
    arg3: Gpr,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 2019.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = MInst::Cmove {
        size: expr1_0,
        cc: pattern1_0.clone(),
        consequent: pattern2_0.clone(),
        alternative: pattern3_0,
        dst: expr0_0,
    };
    let expr3_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr4_0 = ConsumesFlags::ConsumesFlagsReturnsReg {
        inst: expr2_0,
        result: expr3_0,
    };
    return Some(expr4_0);
}

// Generated as internal constructor for term cmove_xmm.
pub fn constructor_cmove_xmm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &CC,
    arg2: &XmmMem,
    arg3: Xmm,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 2027.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmCmove {
        ty: pattern0_0,
        cc: pattern1_0.clone(),
        consequent: pattern2_0.clone(),
        alternative: pattern3_0,
        dst: expr0_0,
    };
    let expr2_0 = constructor_writable_xmm_to_r_reg(ctx, expr0_0)?;
    let expr3_0 = ConsumesFlags::ConsumesFlagsReturnsReg {
        inst: expr1_0,
        result: expr2_0,
    };
    return Some(expr3_0);
}

// Generated as internal constructor for term cmove_from_values.
pub fn constructor_cmove_from_values<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &CC,
    arg2: Value,
    arg3: Value,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::type_register_class(ctx, pattern0_0) {
        match &pattern1_0 {
            &RegisterClass::Xmm => {
                let pattern3_0 = arg1;
                let pattern4_0 = arg2;
                let pattern5_0 = arg3;
                // Rule at src/isa/x64/inst.isle line 2061.
                let expr0_0 = C::put_in_xmm_mem(ctx, pattern4_0);
                let expr1_0 = constructor_put_in_xmm(ctx, pattern5_0)?;
                let expr2_0 =
                    constructor_cmove_xmm(ctx, pattern0_0, pattern3_0, &expr0_0, expr1_0)?;
                return Some(expr2_0);
            }
            &RegisterClass::Gpr {
                single_register: pattern2_0,
            } => {
                if pattern2_0 == true {
                    let pattern4_0 = arg1;
                    let pattern5_0 = arg2;
                    let pattern6_0 = arg3;
                    // Rule at src/isa/x64/inst.isle line 2058.
                    let expr0_0 = constructor_put_in_gpr_mem(ctx, pattern5_0)?;
                    let expr1_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                    let expr2_0 =
                        constructor_cmove(ctx, pattern0_0, pattern4_0, &expr0_0, expr1_0)?;
                    return Some(expr2_0);
                }
                if pattern2_0 == false {
                    if pattern0_0 == I128 {
                        let pattern5_0 = arg1;
                        let pattern6_0 = arg2;
                        let pattern7_0 = arg3;
                        // Rule at src/isa/x64/inst.isle line 2037.
                        let expr0_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr2_0 = C::temp_writable_gpr(ctx);
                        let expr3_0 = C::temp_writable_gpr(ctx);
                        let expr4_0 = OperandSize::Size64;
                        let expr5_0: usize = 0i128 as usize;
                        let expr6_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr5_0)?;
                        let expr7_0 = C::gpr_to_gpr_mem(ctx, expr6_0);
                        let expr8_0: usize = 0i128 as usize;
                        let expr9_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr8_0)?;
                        let expr10_0 = MInst::Cmove {
                            size: expr4_0,
                            cc: pattern5_0.clone(),
                            consequent: expr7_0,
                            alternative: expr9_0,
                            dst: expr2_0,
                        };
                        let expr11_0: usize = 1i128 as usize;
                        let expr12_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr11_0)?;
                        let expr13_0 = C::gpr_to_gpr_mem(ctx, expr12_0);
                        let expr14_0: usize = 1i128 as usize;
                        let expr15_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr14_0)?;
                        let expr16_0 = MInst::Cmove {
                            size: expr4_0,
                            cc: pattern5_0.clone(),
                            consequent: expr13_0,
                            alternative: expr15_0,
                            dst: expr3_0,
                        };
                        let expr17_0 = constructor_writable_gpr_to_r_reg(ctx, expr2_0)?;
                        let expr18_0 = constructor_writable_gpr_to_r_reg(ctx, expr3_0)?;
                        let expr19_0 = C::value_regs(ctx, expr17_0, expr18_0);
                        let expr20_0 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: expr10_0,
                            inst2: expr16_0,
                            result: expr19_0,
                        };
                        return Some(expr20_0);
                    }
                }
            }
            _ => {}
        }
    }
    return None;
}

// Generated as internal constructor for term cmove_or.
pub fn constructor_cmove_or<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &CC,
    arg2: &CC,
    arg3: &GprMem,
    arg4: Gpr,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/x64/inst.isle line 2068.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::temp_writable_gpr(ctx);
    let expr2_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr3_0 = MInst::Cmove {
        size: expr2_0,
        cc: pattern1_0.clone(),
        consequent: pattern3_0.clone(),
        alternative: pattern4_0,
        dst: expr1_0,
    };
    let expr4_0 = C::writable_gpr_to_gpr(ctx, expr1_0);
    let expr5_0 = MInst::Cmove {
        size: expr2_0,
        cc: pattern2_0.clone(),
        consequent: pattern3_0.clone(),
        alternative: expr4_0,
        dst: expr0_0,
    };
    let expr6_0 = constructor_writable_gpr_to_value_regs(ctx, expr0_0)?;
    let expr7_0 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
        inst1: expr3_0,
        inst2: expr5_0,
        result: expr6_0,
    };
    return Some(expr7_0);
}

// Generated as internal constructor for term cmove_or_xmm.
pub fn constructor_cmove_or_xmm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &CC,
    arg2: &CC,
    arg3: &XmmMem,
    arg4: Xmm,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/x64/inst.isle line 2080.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = C::temp_writable_xmm(ctx);
    let expr2_0 = MInst::XmmCmove {
        ty: pattern0_0,
        cc: pattern1_0.clone(),
        consequent: pattern3_0.clone(),
        alternative: pattern4_0,
        dst: expr1_0,
    };
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr1_0);
    let expr4_0 = MInst::XmmCmove {
        ty: pattern0_0,
        cc: pattern2_0.clone(),
        consequent: pattern3_0.clone(),
        alternative: expr3_0,
        dst: expr0_0,
    };
    let expr5_0 = constructor_writable_xmm_to_value_regs(ctx, expr0_0)?;
    let expr6_0 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
        inst1: expr2_0,
        inst2: expr4_0,
        result: expr5_0,
    };
    return Some(expr6_0);
}

// Generated as internal constructor for term cmove_or_from_values.
pub fn constructor_cmove_or_from_values<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &CC,
    arg2: &CC,
    arg3: Value,
    arg4: Value,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::type_register_class(ctx, pattern0_0) {
        match &pattern1_0 {
            &RegisterClass::Xmm => {
                let pattern3_0 = arg1;
                let pattern4_0 = arg2;
                let pattern5_0 = arg3;
                let pattern6_0 = arg4;
                // Rule at src/isa/x64/inst.isle line 2116.
                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_0);
                let expr1_0 = constructor_put_in_xmm(ctx, pattern6_0)?;
                let expr2_0 = constructor_cmove_or_xmm(
                    ctx, pattern0_0, pattern3_0, pattern4_0, &expr0_0, expr1_0,
                )?;
                return Some(expr2_0);
            }
            &RegisterClass::Gpr {
                single_register: pattern2_0,
            } => {
                if pattern2_0 == true {
                    let pattern4_0 = arg1;
                    let pattern5_0 = arg2;
                    let pattern6_0 = arg3;
                    let pattern7_0 = arg4;
                    // Rule at src/isa/x64/inst.isle line 2113.
                    let expr0_0 = constructor_put_in_gpr_mem(ctx, pattern6_0)?;
                    let expr1_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                    let expr2_0 = constructor_cmove_or(
                        ctx, pattern0_0, pattern4_0, pattern5_0, &expr0_0, expr1_0,
                    )?;
                    return Some(expr2_0);
                }
                if pattern2_0 == false {
                    if pattern0_0 == I128 {
                        let pattern5_0 = arg1;
                        let pattern6_0 = arg2;
                        let pattern7_0 = arg3;
                        let pattern8_0 = arg4;
                        // Rule at src/isa/x64/inst.isle line 2094.
                        let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr1_0 = C::put_in_regs(ctx, pattern8_0);
                        let expr2_0 = C::temp_writable_gpr(ctx);
                        let expr3_0 = C::temp_writable_gpr(ctx);
                        let expr4_0 = C::temp_writable_gpr(ctx);
                        let expr5_0 = C::temp_writable_gpr(ctx);
                        let expr6_0 = OperandSize::Size64;
                        let expr7_0: usize = 0i128 as usize;
                        let expr8_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr7_0)?;
                        let expr9_0 = C::gpr_to_gpr_mem(ctx, expr8_0);
                        let expr10_0: usize = 0i128 as usize;
                        let expr11_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr10_0)?;
                        let expr12_0 = MInst::Cmove {
                            size: expr6_0,
                            cc: pattern5_0.clone(),
                            consequent: expr9_0,
                            alternative: expr11_0,
                            dst: expr4_0,
                        };
                        let expr13_0: usize = 0i128 as usize;
                        let expr14_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr13_0)?;
                        let expr15_0 = C::gpr_to_gpr_mem(ctx, expr14_0);
                        let expr16_0 = C::writable_gpr_to_gpr(ctx, expr4_0);
                        let expr17_0 = MInst::Cmove {
                            size: expr6_0,
                            cc: pattern6_0.clone(),
                            consequent: expr15_0,
                            alternative: expr16_0,
                            dst: expr2_0,
                        };
                        let expr18_0: usize = 1i128 as usize;
                        let expr19_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr18_0)?;
                        let expr20_0 = C::gpr_to_gpr_mem(ctx, expr19_0);
                        let expr21_0: usize = 1i128 as usize;
                        let expr22_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr21_0)?;
                        let expr23_0 = MInst::Cmove {
                            size: expr6_0,
                            cc: pattern5_0.clone(),
                            consequent: expr20_0,
                            alternative: expr22_0,
                            dst: expr5_0,
                        };
                        let expr24_0: usize = 1i128 as usize;
                        let expr25_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr24_0)?;
                        let expr26_0 = C::gpr_to_gpr_mem(ctx, expr25_0);
                        let expr27_0 = C::writable_gpr_to_gpr(ctx, expr5_0);
                        let expr28_0 = MInst::Cmove {
                            size: expr6_0,
                            cc: pattern6_0.clone(),
                            consequent: expr26_0,
                            alternative: expr27_0,
                            dst: expr3_0,
                        };
                        let expr29_0 = constructor_writable_gpr_to_r_reg(ctx, expr2_0)?;
                        let expr30_0 = constructor_writable_gpr_to_r_reg(ctx, expr3_0)?;
                        let expr31_0 = C::value_regs(ctx, expr29_0, expr30_0);
                        let expr32_0 = ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: expr12_0,
                            inst2: expr17_0,
                            inst3: expr23_0,
                            inst4: expr28_0,
                            result: expr31_0,
                        };
                        return Some(expr32_0);
                    }
                }
            }
            _ => {}
        }
    }
    return None;
}

// Generated as internal constructor for term x64_setcc.
pub fn constructor_x64_setcc<C: Context>(ctx: &mut C, arg0: &CC) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 2121.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = MInst::Setcc {
        cc: pattern0_0.clone(),
        dst: expr0_0,
    };
    let expr2_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr3_0 = ConsumesFlags::ConsumesFlagsReturnsReg {
        inst: expr1_0,
        result: expr2_0,
    };
    return Some(expr3_0);
}

// Generated as internal constructor for term xmm_rm_r.
pub fn constructor_xmm_rm_r<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &SseOpcode,
    arg2: Xmm,
    arg3: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 2129.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmRmR {
        op: pattern1_0.clone(),
        src1: pattern2_0,
        src2: pattern3_0.clone(),
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_paddb.
pub fn constructor_x64_paddb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2136.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Paddb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_paddw.
pub fn constructor_x64_paddw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2141.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Paddw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_paddd.
pub fn constructor_x64_paddd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2146.
    let expr0_0: Type = I32X4;
    let expr1_0 = SseOpcode::Paddd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_paddq.
pub fn constructor_x64_paddq<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2151.
    let expr0_0: Type = I64X2;
    let expr1_0 = SseOpcode::Paddq;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_paddsb.
pub fn constructor_x64_paddsb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2156.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Paddsb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_paddsw.
pub fn constructor_x64_paddsw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2161.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Paddsw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_paddusb.
pub fn constructor_x64_paddusb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2166.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Paddusb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_paddusw.
pub fn constructor_x64_paddusw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2171.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Paddusw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_psubb.
pub fn constructor_x64_psubb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2176.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Psubb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_psubw.
pub fn constructor_x64_psubw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2181.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Psubw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_psubd.
pub fn constructor_x64_psubd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2186.
    let expr0_0: Type = I32X4;
    let expr1_0 = SseOpcode::Psubd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_psubq.
pub fn constructor_x64_psubq<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2191.
    let expr0_0: Type = I64X2;
    let expr1_0 = SseOpcode::Psubq;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_psubsb.
pub fn constructor_x64_psubsb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2196.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Psubsb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_psubsw.
pub fn constructor_x64_psubsw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2201.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Psubsw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_psubusb.
pub fn constructor_x64_psubusb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2206.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Psubusb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_psubusw.
pub fn constructor_x64_psubusw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2211.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Psubusw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pavgb.
pub fn constructor_x64_pavgb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2216.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pavgb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pavgw.
pub fn constructor_x64_pavgw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2221.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pavgw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pand.
pub fn constructor_x64_pand<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2226.
    let expr0_0: Type = F32X4;
    let expr1_0 = SseOpcode::Pand;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_andps.
pub fn constructor_x64_andps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2231.
    let expr0_0: Type = F32X4;
    let expr1_0 = SseOpcode::Andps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_andpd.
pub fn constructor_x64_andpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2236.
    let expr0_0: Type = F64X2;
    let expr1_0 = SseOpcode::Andpd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_por.
pub fn constructor_x64_por<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2241.
    let expr0_0: Type = F32X4;
    let expr1_0 = SseOpcode::Por;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_orps.
pub fn constructor_x64_orps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2246.
    let expr0_0: Type = F32X4;
    let expr1_0 = SseOpcode::Orps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_orpd.
pub fn constructor_x64_orpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2251.
    let expr0_0: Type = F64X2;
    let expr1_0 = SseOpcode::Orpd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pxor.
pub fn constructor_x64_pxor<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2256.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pxor;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_xorps.
pub fn constructor_x64_xorps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2261.
    let expr0_0: Type = F32X4;
    let expr1_0 = SseOpcode::Xorps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_xorpd.
pub fn constructor_x64_xorpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2266.
    let expr0_0: Type = F64X2;
    let expr1_0 = SseOpcode::Xorpd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmullw.
pub fn constructor_x64_pmullw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2271.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pmullw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmulld.
pub fn constructor_x64_pmulld<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2276.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pmulld;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmulhw.
pub fn constructor_x64_pmulhw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2281.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pmulhw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmulhrsw.
pub fn constructor_x64_pmulhrsw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2286.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pmulhrsw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmulhuw.
pub fn constructor_x64_pmulhuw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2291.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pmulhuw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmuldq.
pub fn constructor_x64_pmuldq<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2296.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pmuldq;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmuludq.
pub fn constructor_x64_pmuludq<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2301.
    let expr0_0: Type = I64X2;
    let expr1_0 = SseOpcode::Pmuludq;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_punpckhwd.
pub fn constructor_x64_punpckhwd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2306.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Punpckhwd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_punpcklwd.
pub fn constructor_x64_punpcklwd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2311.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Punpcklwd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_unpcklps.
pub fn constructor_x64_unpcklps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2316.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Unpcklps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_andnps.
pub fn constructor_x64_andnps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2321.
    let expr0_0: Type = F32X4;
    let expr1_0 = SseOpcode::Andnps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_andnpd.
pub fn constructor_x64_andnpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2326.
    let expr0_0: Type = F64X2;
    let expr1_0 = SseOpcode::Andnpd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pandn.
pub fn constructor_x64_pandn<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2331.
    let expr0_0: Type = F64X2;
    let expr1_0 = SseOpcode::Pandn;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_addss.
pub fn constructor_x64_addss<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2336.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Addss;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_addsd.
pub fn constructor_x64_addsd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2341.
    let expr0_0: Type = F64;
    let expr1_0 = SseOpcode::Addsd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_addps.
pub fn constructor_x64_addps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2346.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Addps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_addpd.
pub fn constructor_x64_addpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2351.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Addpd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_subss.
pub fn constructor_x64_subss<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2356.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Subss;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_subsd.
pub fn constructor_x64_subsd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2361.
    let expr0_0: Type = F64;
    let expr1_0 = SseOpcode::Subsd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_subps.
pub fn constructor_x64_subps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2366.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Subps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_subpd.
pub fn constructor_x64_subpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2371.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Subpd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_mulss.
pub fn constructor_x64_mulss<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2376.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Mulss;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_mulsd.
pub fn constructor_x64_mulsd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2381.
    let expr0_0: Type = F64;
    let expr1_0 = SseOpcode::Mulsd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_mulps.
pub fn constructor_x64_mulps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2386.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Mulps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_mulpd.
pub fn constructor_x64_mulpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2391.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Mulpd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_divss.
pub fn constructor_x64_divss<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2396.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Divss;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_divsd.
pub fn constructor_x64_divsd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2401.
    let expr0_0: Type = F64;
    let expr1_0 = SseOpcode::Divsd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_divps.
pub fn constructor_x64_divps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2406.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Divps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_divpd.
pub fn constructor_x64_divpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2411.
    let expr0_0: Type = F32;
    let expr1_0 = SseOpcode::Divpd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term sse_blend_op.
pub fn constructor_sse_blend_op<C: Context>(ctx: &mut C, arg0: Type) -> Option<SseOpcode> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32X4 {
        // Rule at src/isa/x64/inst.isle line 2415.
        let expr0_0 = SseOpcode::Blendvps;
        return Some(expr0_0);
    }
    if pattern0_0 == F64X2 {
        // Rule at src/isa/x64/inst.isle line 2416.
        let expr0_0 = SseOpcode::Blendvpd;
        return Some(expr0_0);
    }
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::multi_lane(ctx, pattern0_0) {
        // Rule at src/isa/x64/inst.isle line 2419.
        let expr0_0 = SseOpcode::Pblendvb;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term sse_mov_op.
pub fn constructor_sse_mov_op<C: Context>(ctx: &mut C, arg0: Type) -> Option<SseOpcode> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32X4 {
        // Rule at src/isa/x64/inst.isle line 2422.
        let expr0_0 = SseOpcode::Movaps;
        return Some(expr0_0);
    }
    if pattern0_0 == F64X2 {
        // Rule at src/isa/x64/inst.isle line 2423.
        let expr0_0 = SseOpcode::Movapd;
        return Some(expr0_0);
    }
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::multi_lane(ctx, pattern0_0) {
        // Rule at src/isa/x64/inst.isle line 2426.
        let expr0_0 = SseOpcode::Movdqa;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term xmm_rm_r_blend.
pub fn constructor_xmm_rm_r_blend<C: Context>(
    ctx: &mut C,
    arg0: &SseOpcode,
    arg1: Xmm,
    arg2: &XmmMem,
    arg3: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 2429.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmRmRBlend {
        op: pattern0_0.clone(),
        src1: pattern1_0,
        src2: pattern2_0.clone(),
        mask: pattern3_0,
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_blend.
pub fn constructor_x64_blend<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
    arg3: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 2436.
    let expr0_0 = constructor_sse_blend_op(ctx, pattern0_0)?;
    let expr1_0 = constructor_xmm_rm_r_blend(ctx, &expr0_0, pattern3_0, pattern2_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_blendvpd.
pub fn constructor_x64_blendvpd<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &XmmMem,
    arg2: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2441.
    let expr0_0 = SseOpcode::Blendvpd;
    let expr1_0 = constructor_xmm_rm_r_blend(ctx, &expr0_0, pattern0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_movsd_regmove.
pub fn constructor_x64_movsd_regmove<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2446.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Movsd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_movlhps.
pub fn constructor_x64_movlhps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2451.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Movlhps;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmaxs.
pub fn constructor_x64_pmaxs<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == I8X16 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2456.
        let expr0_0 = constructor_x64_pmaxsb(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I16X8 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2457.
        let expr0_0 = constructor_x64_pmaxsw(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2458.
        let expr0_0 = constructor_x64_pmaxsd(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term x64_pmaxsb.
pub fn constructor_x64_pmaxsb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2461.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pmaxsb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmaxsw.
pub fn constructor_x64_pmaxsw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2463.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pmaxsw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmaxsd.
pub fn constructor_x64_pmaxsd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2465.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pmaxsd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmins.
pub fn constructor_x64_pmins<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == I8X16 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2469.
        let expr0_0 = constructor_x64_pminsb(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I16X8 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2470.
        let expr0_0 = constructor_x64_pminsw(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2471.
        let expr0_0 = constructor_x64_pminsd(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term x64_pminsb.
pub fn constructor_x64_pminsb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2474.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pminsb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pminsw.
pub fn constructor_x64_pminsw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2476.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pminsw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pminsd.
pub fn constructor_x64_pminsd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2478.
    let expr0_0: Type = I32X4;
    let expr1_0 = SseOpcode::Pminsd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmaxu.
pub fn constructor_x64_pmaxu<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == I8X16 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2482.
        let expr0_0 = constructor_x64_pmaxub(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I16X8 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2483.
        let expr0_0 = constructor_x64_pmaxuw(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2484.
        let expr0_0 = constructor_x64_pmaxud(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term x64_pmaxub.
pub fn constructor_x64_pmaxub<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2487.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pmaxub;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmaxuw.
pub fn constructor_x64_pmaxuw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2489.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pmaxuw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmaxud.
pub fn constructor_x64_pmaxud<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2491.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pmaxud;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pminu.
pub fn constructor_x64_pminu<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == I8X16 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2495.
        let expr0_0 = constructor_x64_pminub(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I16X8 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2496.
        let expr0_0 = constructor_x64_pminuw(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 2497.
        let expr0_0 = constructor_x64_pminud(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term x64_pminub.
pub fn constructor_x64_pminub<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2500.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pminub;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pminuw.
pub fn constructor_x64_pminuw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2502.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pminuw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pminud.
pub fn constructor_x64_pminud<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2504.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pminud;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_punpcklbw.
pub fn constructor_x64_punpcklbw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2508.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Punpcklbw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_punpckhbw.
pub fn constructor_x64_punpckhbw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2513.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Punpckhbw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_packsswb.
pub fn constructor_x64_packsswb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2518.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Packsswb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_packssdw.
pub fn constructor_x64_packssdw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2523.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Packssdw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_packuswb.
pub fn constructor_x64_packuswb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2528.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Packuswb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_packusdw.
pub fn constructor_x64_packusdw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2533.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Packusdw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term xmm_rm_r_imm.
pub fn constructor_xmm_rm_r_imm<C: Context>(
    ctx: &mut C,
    arg0: &SseOpcode,
    arg1: Reg,
    arg2: &RegMem,
    arg3: u8,
    arg4: &OperandSize,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/x64/inst.isle line 2538.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = C::writable_xmm_to_reg(ctx, expr0_0);
    let expr2_0 = MInst::XmmRmRImm {
        op: pattern0_0.clone(),
        src1: pattern1_0,
        src2: pattern2_0.clone(),
        dst: expr1_0,
        imm: pattern3_0,
        size: pattern4_0.clone(),
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_palignr.
pub fn constructor_x64_palignr<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &XmmMem,
    arg2: u8,
    arg3: &OperandSize,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 2550.
    let expr0_0 = SseOpcode::Palignr;
    let expr1_0 = C::xmm_to_reg(ctx, pattern0_0);
    let expr2_0 = C::xmm_mem_to_reg_mem(ctx, pattern1_0);
    let expr3_0 =
        constructor_xmm_rm_r_imm(ctx, &expr0_0, expr1_0, &expr2_0, pattern2_0, pattern3_0)?;
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_cmpp.
pub fn constructor_x64_cmpp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
    arg3: &FcmpImm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        // Rule at src/isa/x64/inst.isle line 2559.
        let expr0_0 = constructor_x64_cmpps(ctx, pattern2_0, pattern3_0, pattern4_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == F64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        // Rule at src/isa/x64/inst.isle line 2560.
        let expr0_0 = constructor_x64_cmppd(ctx, pattern2_0, pattern3_0, pattern4_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term x64_cmpps.
pub fn constructor_x64_cmpps<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &XmmMem,
    arg2: &FcmpImm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2563.
    let expr0_0 = SseOpcode::Cmpps;
    let expr1_0 = C::xmm_to_reg(ctx, pattern0_0);
    let expr2_0 = C::xmm_mem_to_reg_mem(ctx, pattern1_0);
    let expr3_0 = C::encode_fcmp_imm(ctx, pattern2_0);
    let expr4_0 = OperandSize::Size32;
    let expr5_0 = constructor_xmm_rm_r_imm(ctx, &expr0_0, expr1_0, &expr2_0, expr3_0, &expr4_0)?;
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cmppd.
pub fn constructor_x64_cmppd<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &XmmMem,
    arg2: &FcmpImm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2574.
    let expr0_0 = SseOpcode::Cmppd;
    let expr1_0 = C::xmm_to_reg(ctx, pattern0_0);
    let expr2_0 = C::xmm_mem_to_reg_mem(ctx, pattern1_0);
    let expr3_0 = C::encode_fcmp_imm(ctx, pattern2_0);
    let expr4_0 = OperandSize::Size32;
    let expr5_0 = constructor_xmm_rm_r_imm(ctx, &expr0_0, expr1_0, &expr2_0, expr3_0, &expr4_0)?;
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_pinsrb.
pub fn constructor_x64_pinsrb<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &GprMem,
    arg2: u8,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2583.
    let expr0_0 = SseOpcode::Pinsrb;
    let expr1_0 = C::xmm_to_reg(ctx, pattern0_0);
    let expr2_0 = C::gpr_mem_to_reg_mem(ctx, pattern1_0);
    let expr3_0 = OperandSize::Size32;
    let expr4_0 = constructor_xmm_rm_r_imm(ctx, &expr0_0, expr1_0, &expr2_0, pattern2_0, &expr3_0)?;
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_pinsrw.
pub fn constructor_x64_pinsrw<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &GprMem,
    arg2: u8,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2592.
    let expr0_0 = SseOpcode::Pinsrw;
    let expr1_0 = C::xmm_to_reg(ctx, pattern0_0);
    let expr2_0 = C::gpr_mem_to_reg_mem(ctx, pattern1_0);
    let expr3_0 = OperandSize::Size32;
    let expr4_0 = constructor_xmm_rm_r_imm(ctx, &expr0_0, expr1_0, &expr2_0, pattern2_0, &expr3_0)?;
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_pinsrd.
pub fn constructor_x64_pinsrd<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &GprMem,
    arg2: u8,
    arg3: &OperandSize,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 2601.
    let expr0_0 = SseOpcode::Pinsrd;
    let expr1_0 = C::xmm_to_reg(ctx, pattern0_0);
    let expr2_0 = C::gpr_mem_to_reg_mem(ctx, pattern1_0);
    let expr3_0 =
        constructor_xmm_rm_r_imm(ctx, &expr0_0, expr1_0, &expr2_0, pattern2_0, pattern3_0)?;
    return Some(expr3_0);
}

// Generated as internal constructor for term xmm_unary_rm_r_imm.
pub fn constructor_xmm_unary_rm_r_imm<C: Context>(
    ctx: &mut C,
    arg0: &SseOpcode,
    arg1: &XmmMem,
    arg2: u8,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2610.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmUnaryRmRImm {
        op: pattern0_0.clone(),
        src: pattern1_0.clone(),
        imm: pattern2_0,
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_roundss.
pub fn constructor_x64_roundss<C: Context>(
    ctx: &mut C,
    arg0: &XmmMem,
    arg1: &RoundImm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2617.
    let expr0_0 = SseOpcode::Roundss;
    let expr1_0 = C::encode_round_imm(ctx, pattern1_0);
    let expr2_0 = constructor_xmm_unary_rm_r_imm(ctx, &expr0_0, pattern0_0, expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_roundsd.
pub fn constructor_x64_roundsd<C: Context>(
    ctx: &mut C,
    arg0: &XmmMem,
    arg1: &RoundImm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2622.
    let expr0_0 = SseOpcode::Roundsd;
    let expr1_0 = C::encode_round_imm(ctx, pattern1_0);
    let expr2_0 = constructor_xmm_unary_rm_r_imm(ctx, &expr0_0, pattern0_0, expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_roundps.
pub fn constructor_x64_roundps<C: Context>(
    ctx: &mut C,
    arg0: &XmmMem,
    arg1: &RoundImm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2627.
    let expr0_0 = SseOpcode::Roundps;
    let expr1_0 = C::encode_round_imm(ctx, pattern1_0);
    let expr2_0 = constructor_xmm_unary_rm_r_imm(ctx, &expr0_0, pattern0_0, expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_roundpd.
pub fn constructor_x64_roundpd<C: Context>(
    ctx: &mut C,
    arg0: &XmmMem,
    arg1: &RoundImm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2632.
    let expr0_0 = SseOpcode::Roundpd;
    let expr1_0 = C::encode_round_imm(ctx, pattern1_0);
    let expr2_0 = constructor_xmm_unary_rm_r_imm(ctx, &expr0_0, pattern0_0, expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pmaddwd.
pub fn constructor_x64_pmaddwd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2637.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Pmaddwd;
    let expr2_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: pattern1_0.clone(),
        dst: expr0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_pmaddubsw.
pub fn constructor_x64_pmaddubsw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2646.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pmaddubsw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_insertps.
pub fn constructor_x64_insertps<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &XmmMem,
    arg2: u8,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2651.
    let expr0_0 = SseOpcode::Insertps;
    let expr1_0 = C::xmm_to_reg(ctx, pattern0_0);
    let expr2_0 = C::xmm_mem_to_reg_mem(ctx, pattern1_0);
    let expr3_0 = OperandSize::Size32;
    let expr4_0 = constructor_xmm_rm_r_imm(ctx, &expr0_0, expr1_0, &expr2_0, pattern2_0, &expr3_0)?;
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_pshufd.
pub fn constructor_x64_pshufd<C: Context>(
    ctx: &mut C,
    arg0: &XmmMem,
    arg1: u8,
    arg2: &OperandSize,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2660.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Pshufd;
    let expr2_0 = constructor_writable_xmm_to_r_reg(ctx, expr0_0)?;
    let expr3_0 = C::xmm_mem_to_reg_mem(ctx, pattern0_0);
    let expr4_0 = C::writable_xmm_to_reg(ctx, expr0_0);
    let expr5_0 = MInst::XmmRmRImm {
        op: expr1_0,
        src1: expr2_0,
        src2: expr3_0,
        dst: expr4_0,
        imm: pattern1_0,
        size: pattern2_0.clone(),
    };
    let expr6_0 = C::emit(ctx, &expr5_0);
    let expr7_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr7_0);
}

// Generated as internal constructor for term x64_pshufb.
pub fn constructor_x64_pshufb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2672.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Pshufb;
    let expr2_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: pattern1_0.clone(),
        dst: expr0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_shufps.
pub fn constructor_x64_shufps<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: &XmmMem,
    arg2: u8,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2682.
    let expr0_0 = SseOpcode::Shufps;
    let expr1_0 = C::xmm_to_reg(ctx, pattern0_0);
    let expr2_0 = C::xmm_mem_to_reg_mem(ctx, pattern1_0);
    let expr3_0 = OperandSize::Size32;
    let expr4_0 = constructor_xmm_rm_r_imm(ctx, &expr0_0, expr1_0, &expr2_0, pattern2_0, &expr3_0)?;
    return Some(expr4_0);
}

// Generated as internal constructor for term xmm_unary_rm_r.
pub fn constructor_xmm_unary_rm_r<C: Context>(
    ctx: &mut C,
    arg0: &SseOpcode,
    arg1: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2691.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmUnaryRmR {
        op: pattern0_0.clone(),
        src: pattern1_0.clone(),
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_pabsb.
pub fn constructor_x64_pabsb<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 2698.
    let expr0_0 = SseOpcode::Pabsb;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pabsw.
pub fn constructor_x64_pabsw<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 2703.
    let expr0_0 = SseOpcode::Pabsw;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pabsd.
pub fn constructor_x64_pabsd<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 2708.
    let expr0_0 = SseOpcode::Pabsd;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term xmm_unary_rm_r_evex.
pub fn constructor_xmm_unary_rm_r_evex<C: Context>(
    ctx: &mut C,
    arg0: &Avx512Opcode,
    arg1: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2713.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmUnaryRmREvex {
        op: pattern0_0.clone(),
        src: pattern1_0.clone(),
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_vcvtudq2ps.
pub fn constructor_x64_vcvtudq2ps<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 2720.
    let expr0_0 = Avx512Opcode::Vcvtudq2ps;
    let expr1_0 = constructor_xmm_unary_rm_r_evex(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_vpabsq.
pub fn constructor_x64_vpabsq<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 2725.
    let expr0_0 = Avx512Opcode::Vpabsq;
    let expr1_0 = constructor_xmm_unary_rm_r_evex(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_vpopcntb.
pub fn constructor_x64_vpopcntb<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 2730.
    let expr0_0 = Avx512Opcode::Vpopcntb;
    let expr1_0 = constructor_xmm_unary_rm_r_evex(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term xmm_rm_r_evex.
pub fn constructor_xmm_rm_r_evex<C: Context>(
    ctx: &mut C,
    arg0: &Avx512Opcode,
    arg1: &XmmMem,
    arg2: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2735.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmRmREvex {
        op: pattern0_0.clone(),
        src1: pattern1_0.clone(),
        src2: pattern2_0,
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_vpmullq.
pub fn constructor_x64_vpmullq<C: Context>(ctx: &mut C, arg0: &XmmMem, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2747.
    let expr0_0 = Avx512Opcode::Vpmullq;
    let expr1_0 = constructor_xmm_rm_r_evex(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_vpermi2b.
pub fn constructor_x64_vpermi2b<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: Xmm,
    arg2: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2756.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = Avx512Opcode::Vpermi2b;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmRmREvex3 {
        op: expr1_0,
        src1: expr2_0,
        src2: pattern1_0,
        src3: pattern2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term mul_hi.
pub fn constructor_mul_hi<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: bool,
    arg2: Gpr,
    arg3: &GprMem,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 2769.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::temp_writable_gpr(ctx);
    let expr2_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr3_0 = MInst::MulHi {
        size: expr2_0,
        signed: pattern1_0,
        src1: pattern2_0,
        src2: pattern3_0.clone(),
        dst_lo: expr0_0,
        dst_hi: expr1_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    let expr6_0 = C::writable_gpr_to_gpr(ctx, expr1_0);
    let expr7_0 = constructor_value_gprs(ctx, expr5_0, expr6_0)?;
    return Some(expr7_0);
}

// Generated as internal constructor for term mulhi_u.
pub fn constructor_mulhi_u<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: &GprMem,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2784.
    let expr0_0: bool = false;
    let expr1_0 = constructor_mul_hi(ctx, pattern0_0, expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term xmm_rmi_xmm.
pub fn constructor_xmm_rmi_xmm<C: Context>(
    ctx: &mut C,
    arg0: &SseOpcode,
    arg1: Xmm,
    arg2: &XmmMemImm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2789.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmRmiReg {
        opcode: pattern0_0.clone(),
        src1: pattern1_0,
        src2: pattern2_0.clone(),
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_psllw.
pub fn constructor_x64_psllw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMemImm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2799.
    let expr0_0 = SseOpcode::Psllw;
    let expr1_0 = constructor_xmm_rmi_xmm(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pslld.
pub fn constructor_x64_pslld<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMemImm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2804.
    let expr0_0 = SseOpcode::Pslld;
    let expr1_0 = constructor_xmm_rmi_xmm(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_psllq.
pub fn constructor_x64_psllq<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMemImm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2809.
    let expr0_0 = SseOpcode::Psllq;
    let expr1_0 = constructor_xmm_rmi_xmm(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_psrlw.
pub fn constructor_x64_psrlw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMemImm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2814.
    let expr0_0 = SseOpcode::Psrlw;
    let expr1_0 = constructor_xmm_rmi_xmm(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_psrld.
pub fn constructor_x64_psrld<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMemImm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2819.
    let expr0_0 = SseOpcode::Psrld;
    let expr1_0 = constructor_xmm_rmi_xmm(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_psrlq.
pub fn constructor_x64_psrlq<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMemImm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2824.
    let expr0_0 = SseOpcode::Psrlq;
    let expr1_0 = constructor_xmm_rmi_xmm(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_psraw.
pub fn constructor_x64_psraw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMemImm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2829.
    let expr0_0 = SseOpcode::Psraw;
    let expr1_0 = constructor_xmm_rmi_xmm(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_psrad.
pub fn constructor_x64_psrad<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMemImm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2834.
    let expr0_0 = SseOpcode::Psrad;
    let expr1_0 = constructor_xmm_rmi_xmm(ctx, &expr0_0, pattern0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_pextrb.
pub fn constructor_x64_pextrb<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: u8,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2839.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = SseOpcode::Pextrb;
    let expr2_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr3_0 = C::xmm_to_reg(ctx, pattern1_0);
    let expr4_0 = constructor_xmm_to_reg_mem(ctx, expr3_0)?;
    let expr5_0 = C::xmm_mem_to_reg_mem(ctx, &expr4_0);
    let expr6_0 = C::writable_gpr_to_reg(ctx, expr0_0);
    let expr7_0 = C::lane_type(ctx, pattern0_0);
    let expr8_0 = C::operand_size_of_type_32_64(ctx, expr7_0);
    let expr9_0 = MInst::XmmRmRImm {
        op: expr1_0,
        src1: expr2_0,
        src2: expr5_0,
        dst: expr6_0,
        imm: pattern2_0,
        size: expr8_0,
    };
    let expr10_0 = C::emit(ctx, &expr9_0);
    let expr11_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr11_0);
}

// Generated as internal constructor for term x64_pextrw.
pub fn constructor_x64_pextrw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: u8,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2851.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = SseOpcode::Pextrw;
    let expr2_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr3_0 = C::xmm_to_reg(ctx, pattern1_0);
    let expr4_0 = constructor_xmm_to_reg_mem(ctx, expr3_0)?;
    let expr5_0 = C::xmm_mem_to_reg_mem(ctx, &expr4_0);
    let expr6_0 = C::writable_gpr_to_reg(ctx, expr0_0);
    let expr7_0 = C::lane_type(ctx, pattern0_0);
    let expr8_0 = C::operand_size_of_type_32_64(ctx, expr7_0);
    let expr9_0 = MInst::XmmRmRImm {
        op: expr1_0,
        src1: expr2_0,
        src2: expr5_0,
        dst: expr6_0,
        imm: pattern2_0,
        size: expr8_0,
    };
    let expr10_0 = C::emit(ctx, &expr9_0);
    let expr11_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr11_0);
}

// Generated as internal constructor for term x64_pextrd.
pub fn constructor_x64_pextrd<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: u8,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2863.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = SseOpcode::Pextrd;
    let expr2_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr3_0 = C::xmm_to_reg(ctx, pattern1_0);
    let expr4_0 = constructor_xmm_to_reg_mem(ctx, expr3_0)?;
    let expr5_0 = C::xmm_mem_to_reg_mem(ctx, &expr4_0);
    let expr6_0 = C::writable_gpr_to_reg(ctx, expr0_0);
    let expr7_0 = C::lane_type(ctx, pattern0_0);
    let expr8_0 = C::operand_size_of_type_32_64(ctx, expr7_0);
    let expr9_0 = MInst::XmmRmRImm {
        op: expr1_0,
        src1: expr2_0,
        src2: expr5_0,
        dst: expr6_0,
        imm: pattern2_0,
        size: expr8_0,
    };
    let expr10_0 = C::emit(ctx, &expr9_0);
    let expr11_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr11_0);
}

// Generated as internal constructor for term xmm_to_gpr.
pub fn constructor_xmm_to_gpr<C: Context>(
    ctx: &mut C,
    arg0: &SseOpcode,
    arg1: Xmm,
    arg2: &OperandSize,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2875.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = MInst::XmmToGpr {
        op: pattern0_0.clone(),
        src: pattern1_0,
        dst: expr0_0,
        dst_size: pattern2_0.clone(),
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_pmovmskb.
pub fn constructor_x64_pmovmskb<C: Context>(
    ctx: &mut C,
    arg0: &OperandSize,
    arg1: Xmm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2882.
    let expr0_0 = SseOpcode::Pmovmskb;
    let expr1_0 = constructor_xmm_to_gpr(ctx, &expr0_0, pattern1_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_movmskps.
pub fn constructor_x64_movmskps<C: Context>(
    ctx: &mut C,
    arg0: &OperandSize,
    arg1: Xmm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2887.
    let expr0_0 = SseOpcode::Movmskps;
    let expr1_0 = constructor_xmm_to_gpr(ctx, &expr0_0, pattern1_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_movmskpd.
pub fn constructor_x64_movmskpd<C: Context>(
    ctx: &mut C,
    arg0: &OperandSize,
    arg1: Xmm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2892.
    let expr0_0 = SseOpcode::Movmskpd;
    let expr1_0 = constructor_xmm_to_gpr(ctx, &expr0_0, pattern1_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term gpr_to_xmm.
pub fn constructor_gpr_to_xmm<C: Context>(
    ctx: &mut C,
    arg0: &SseOpcode,
    arg1: &GprMem,
    arg2: &OperandSize,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2897.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::GprToXmm {
        op: pattern0_0.clone(),
        src: pattern1_0.clone(),
        dst: expr0_0,
        src_size: pattern2_0.clone(),
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_not.
pub fn constructor_x64_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2904.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = MInst::Not {
        size: expr1_0,
        src: pattern1_0,
        dst: expr0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_neg.
pub fn constructor_x64_neg<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2912.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr2_0 = MInst::Neg {
        size: expr1_0,
        src: pattern1_0,
        dst: expr0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_neg_paired.
pub fn constructor_x64_neg_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2920.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr2_0 = MInst::Neg {
        size: expr1_0,
        src: pattern1_0,
        dst: expr0_0,
    };
    let expr3_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr4_0 = ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
        inst: expr2_0,
        result: expr3_0,
    };
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_lea.
pub fn constructor_x64_lea<C: Context>(ctx: &mut C, arg0: &SyntheticAmode) -> Option<Gpr> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 2927.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = MInst::LoadEffectiveAddress {
        addr: pattern0_0.clone(),
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_ud2.
pub fn constructor_x64_ud2<C: Context>(ctx: &mut C, arg0: &TrapCode) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 2934.
    let expr0_0 = MInst::Ud2 {
        trap_code: pattern0_0.clone(),
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_hlt.
pub fn constructor_x64_hlt<C: Context>(ctx: &mut C) -> Option<SideEffectNoResult> {
    // Rule at src/isa/x64/inst.isle line 2939.
    let expr0_0 = MInst::Hlt;
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_lzcnt.
pub fn constructor_x64_lzcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2944.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = UnaryRmROpcode::Lzcnt;
    let expr3_0 = C::gpr_to_gpr_mem(ctx, pattern1_0);
    let expr4_0 = MInst::UnaryRmR {
        size: expr1_0,
        op: expr2_0,
        src: expr3_0,
        dst: expr0_0,
    };
    let expr5_0 = C::emit(ctx, &expr4_0);
    let expr6_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr6_0);
}

// Generated as internal constructor for term x64_tzcnt.
pub fn constructor_x64_tzcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2952.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = UnaryRmROpcode::Tzcnt;
    let expr3_0 = C::gpr_to_gpr_mem(ctx, pattern1_0);
    let expr4_0 = MInst::UnaryRmR {
        size: expr1_0,
        op: expr2_0,
        src: expr3_0,
        dst: expr0_0,
    };
    let expr5_0 = C::emit(ctx, &expr4_0);
    let expr6_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr6_0);
}

// Generated as internal constructor for term x64_bsr.
pub fn constructor_x64_bsr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2960.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = UnaryRmROpcode::Bsr;
    let expr3_0 = C::gpr_to_gpr_mem(ctx, pattern1_0);
    let expr4_0 = MInst::UnaryRmR {
        size: expr1_0,
        op: expr2_0,
        src: expr3_0,
        dst: expr0_0,
    };
    let expr5_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr6_0 = ProducesFlags::ProducesFlagsReturnsReg {
        inst: expr4_0,
        result: expr5_0,
    };
    return Some(expr6_0);
}

// Generated as internal constructor for term bsr_or_else.
pub fn constructor_bsr_or_else<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2969.
    let expr0_0 = constructor_x64_bsr(ctx, pattern0_0, pattern1_0)?;
    let expr1_0 = constructor_produces_flags_get_reg(ctx, &expr0_0)?;
    let expr2_0 = C::gpr_new(ctx, expr1_0);
    let expr3_0 = CC::Z;
    let expr4_0 = C::gpr_to_gpr_mem(ctx, pattern2_0);
    let expr5_0 = constructor_cmove(ctx, pattern0_0, &expr3_0, &expr4_0, expr2_0)?;
    let expr6_0 = constructor_produces_flags_ignore(ctx, &expr0_0)?;
    let expr7_0 = constructor_with_flags_reg(ctx, &expr6_0, &expr5_0)?;
    let expr8_0 = C::gpr_new(ctx, expr7_0);
    return Some(expr8_0);
}

// Generated as internal constructor for term x64_bsf.
pub fn constructor_x64_bsf<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 2980.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = UnaryRmROpcode::Bsf;
    let expr3_0 = C::gpr_to_gpr_mem(ctx, pattern1_0);
    let expr4_0 = MInst::UnaryRmR {
        size: expr1_0,
        op: expr2_0,
        src: expr3_0,
        dst: expr0_0,
    };
    let expr5_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    let expr6_0 = ProducesFlags::ProducesFlagsReturnsReg {
        inst: expr4_0,
        result: expr5_0,
    };
    return Some(expr6_0);
}

// Generated as internal constructor for term bsf_or_else.
pub fn constructor_bsf_or_else<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 2989.
    let expr0_0 = constructor_x64_bsf(ctx, pattern0_0, pattern1_0)?;
    let expr1_0 = constructor_produces_flags_get_reg(ctx, &expr0_0)?;
    let expr2_0 = C::gpr_new(ctx, expr1_0);
    let expr3_0 = CC::Z;
    let expr4_0 = C::gpr_to_gpr_mem(ctx, pattern2_0);
    let expr5_0 = constructor_cmove(ctx, pattern0_0, &expr3_0, &expr4_0, expr2_0)?;
    let expr6_0 = constructor_produces_flags_ignore(ctx, &expr0_0)?;
    let expr7_0 = constructor_with_flags_reg(ctx, &expr6_0, &expr5_0)?;
    let expr8_0 = C::gpr_new(ctx, expr7_0);
    return Some(expr8_0);
}

// Generated as internal constructor for term x64_popcnt.
pub fn constructor_x64_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3000.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = UnaryRmROpcode::Popcnt;
    let expr3_0 = C::gpr_to_gpr_mem(ctx, pattern1_0);
    let expr4_0 = MInst::UnaryRmR {
        size: expr1_0,
        op: expr2_0,
        src: expr3_0,
        dst: expr0_0,
    };
    let expr5_0 = C::emit(ctx, &expr4_0);
    let expr6_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr6_0);
}

// Generated as internal constructor for term xmm_min_max_seq.
pub fn constructor_xmm_min_max_seq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: bool,
    arg2: Xmm,
    arg3: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 3008.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr2_0 = MInst::XmmMinMaxSeq {
        size: expr1_0,
        is_min: pattern1_0,
        lhs: pattern2_0,
        rhs: pattern3_0,
        dst: expr0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term x64_minss.
pub fn constructor_x64_minss<C: Context>(ctx: &mut C, arg0: Xmm, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3016.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Minss;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern1_0);
    let expr3_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_minsd.
pub fn constructor_x64_minsd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3023.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Minsd;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern1_0);
    let expr3_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_minps.
pub fn constructor_x64_minps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3031.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Minps;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern1_0);
    let expr3_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_minpd.
pub fn constructor_x64_minpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3038.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Minpd;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern1_0);
    let expr3_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_maxss.
pub fn constructor_x64_maxss<C: Context>(ctx: &mut C, arg0: Xmm, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3045.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Maxss;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern1_0);
    let expr3_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_maxsd.
pub fn constructor_x64_maxsd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3052.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Maxsd;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern1_0);
    let expr3_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_maxps.
pub fn constructor_x64_maxps<C: Context>(ctx: &mut C, arg0: Xmm, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3059.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Maxps;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern1_0);
    let expr3_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_maxpd.
pub fn constructor_x64_maxpd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3066.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Maxpd;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern1_0);
    let expr3_0 = MInst::XmmRmR {
        op: expr1_0,
        src1: pattern0_0,
        src2: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term xmm_rmr_vex.
pub fn constructor_xmm_rmr_vex<C: Context>(
    ctx: &mut C,
    arg0: &AvxOpcode,
    arg1: Xmm,
    arg2: Xmm,
    arg3: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 3074.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = MInst::XmmRmRVex {
        op: pattern0_0.clone(),
        src1: pattern1_0,
        src2: pattern2_0,
        src3: pattern3_0.clone(),
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_vfmadd213ss.
pub fn constructor_x64_vfmadd213ss<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: Xmm,
    arg2: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3087.
    let expr0_0 = AvxOpcode::Vfmadd213ss;
    let expr1_0 = C::xmm_to_xmm_mem(ctx, pattern2_0);
    let expr2_0 = constructor_xmm_rmr_vex(ctx, &expr0_0, pattern0_0, pattern1_0, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_vfmadd213sd.
pub fn constructor_x64_vfmadd213sd<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: Xmm,
    arg2: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3094.
    let expr0_0 = AvxOpcode::Vfmadd213sd;
    let expr1_0 = C::xmm_to_xmm_mem(ctx, pattern2_0);
    let expr2_0 = constructor_xmm_rmr_vex(ctx, &expr0_0, pattern0_0, pattern1_0, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_vfmadd213ps.
pub fn constructor_x64_vfmadd213ps<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: Xmm,
    arg2: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3101.
    let expr0_0 = AvxOpcode::Vfmadd213ps;
    let expr1_0 = C::xmm_to_xmm_mem(ctx, pattern2_0);
    let expr2_0 = constructor_xmm_rmr_vex(ctx, &expr0_0, pattern0_0, pattern1_0, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_vfmadd213pd.
pub fn constructor_x64_vfmadd213pd<C: Context>(
    ctx: &mut C,
    arg0: Xmm,
    arg1: Xmm,
    arg2: Xmm,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3108.
    let expr0_0 = AvxOpcode::Vfmadd213pd;
    let expr1_0 = C::xmm_to_xmm_mem(ctx, pattern2_0);
    let expr2_0 = constructor_xmm_rmr_vex(ctx, &expr0_0, pattern0_0, pattern1_0, &expr1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_sqrtss.
pub fn constructor_x64_sqrtss<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3114.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Sqrtss;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_sqrtsd.
pub fn constructor_x64_sqrtsd<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3121.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Sqrtsd;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_sqrtps.
pub fn constructor_x64_sqrtps<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3128.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Sqrtps;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_sqrtpd.
pub fn constructor_x64_sqrtpd<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3135.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Sqrtpd;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cvtss2sd.
pub fn constructor_x64_cvtss2sd<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3142.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Cvtss2sd;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cvtsd2ss.
pub fn constructor_x64_cvtsd2ss<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3149.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Cvtsd2ss;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cvtdq2ps.
pub fn constructor_x64_cvtdq2ps<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3156.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Cvtdq2ps;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cvtps2pd.
pub fn constructor_x64_cvtps2pd<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3163.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Cvtps2pd;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cvtpd2ps.
pub fn constructor_x64_cvtpd2ps<C: Context>(ctx: &mut C, arg0: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3170.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Cvtpd2ps;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern0_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cvtdq2pd.
pub fn constructor_x64_cvtdq2pd<C: Context>(ctx: &mut C, arg0: Type, arg1: Xmm) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3177.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = SseOpcode::Cvtdq2pd;
    let expr2_0 = C::xmm_to_xmm_mem(ctx, pattern1_0);
    let expr3_0 = MInst::XmmUnaryRmR {
        op: expr1_0,
        src: expr2_0,
        dst: expr0_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cvtsi2ss.
pub fn constructor_x64_cvtsi2ss<C: Context>(ctx: &mut C, arg0: Type, arg1: &GprMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3184.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr2_0 = SseOpcode::Cvtsi2ss;
    let expr3_0 = MInst::GprToXmm {
        op: expr2_0,
        src: pattern1_0.clone(),
        dst: expr0_0,
        src_size: expr1_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cvtsi2sd.
pub fn constructor_x64_cvtsi2sd<C: Context>(ctx: &mut C, arg0: Type, arg1: &GprMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3192.
    let expr0_0 = C::temp_writable_xmm(ctx);
    let expr1_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr2_0 = SseOpcode::Cvtsi2sd;
    let expr3_0 = MInst::GprToXmm {
        op: expr2_0,
        src: pattern1_0.clone(),
        dst: expr0_0,
        src_size: expr1_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_xmm_to_xmm(ctx, expr0_0);
    return Some(expr5_0);
}

// Generated as internal constructor for term x64_cvttps2dq.
pub fn constructor_x64_cvttps2dq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3200.
    let expr0_0 = SseOpcode::Cvttps2dq;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern1_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_cvttpd2dq.
pub fn constructor_x64_cvttpd2dq<C: Context>(ctx: &mut C, arg0: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3205.
    let expr0_0 = SseOpcode::Cvttpd2dq;
    let expr1_0 = constructor_xmm_unary_rm_r(ctx, &expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term cvt_u64_to_float_seq.
pub fn constructor_cvt_u64_to_float_seq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3209.
    let expr0_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr1_0 = C::temp_writable_xmm(ctx);
    let expr2_0 = C::temp_writable_gpr(ctx);
    let expr3_0 = C::temp_writable_gpr(ctx);
    let expr4_0 = MInst::CvtUint64ToFloatSeq {
        dst_size: expr0_0,
        src: pattern1_0,
        dst: expr1_0,
        tmp_gpr1: expr2_0,
        tmp_gpr2: expr3_0,
    };
    let expr5_0 = C::emit(ctx, &expr4_0);
    let expr6_0 = C::writable_xmm_to_xmm(ctx, expr1_0);
    return Some(expr6_0);
}

// Generated as internal constructor for term cvt_float_to_uint_seq.
pub fn constructor_cvt_float_to_uint_seq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: bool,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = C::value_type(ctx, pattern1_0);
    let pattern3_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3218.
    let expr0_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr1_0 = C::raw_operand_size_of_type(ctx, pattern2_0);
    let expr2_0 = C::temp_writable_gpr(ctx);
    let expr3_0 = C::temp_writable_xmm(ctx);
    let expr4_0 = C::temp_writable_xmm(ctx);
    let expr5_0 = C::temp_writable_gpr(ctx);
    let expr6_0 = constructor_put_in_xmm(ctx, pattern1_0)?;
    let expr7_0 = MInst::CvtFloatToUintSeq {
        dst_size: expr0_0,
        src_size: expr1_0,
        is_saturating: pattern3_0,
        src: expr6_0,
        dst: expr2_0,
        tmp_gpr: expr5_0,
        tmp_xmm: expr3_0,
        tmp_xmm2: expr4_0,
    };
    let expr8_0 = C::emit(ctx, &expr7_0);
    let expr9_0 = C::writable_gpr_to_gpr(ctx, expr2_0);
    return Some(expr9_0);
}

// Generated as internal constructor for term cvt_float_to_sint_seq.
pub fn constructor_cvt_float_to_sint_seq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: bool,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = C::value_type(ctx, pattern1_0);
    let pattern3_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3230.
    let expr0_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr1_0 = C::raw_operand_size_of_type(ctx, pattern2_0);
    let expr2_0 = C::temp_writable_gpr(ctx);
    let expr3_0 = C::temp_writable_xmm(ctx);
    let expr4_0 = C::temp_writable_gpr(ctx);
    let expr5_0 = constructor_put_in_xmm(ctx, pattern1_0)?;
    let expr6_0 = MInst::CvtFloatToSintSeq {
        dst_size: expr0_0,
        src_size: expr1_0,
        is_saturating: pattern3_0,
        src: expr5_0,
        dst: expr2_0,
        tmp_gpr: expr4_0,
        tmp_xmm: expr3_0,
    };
    let expr7_0 = C::emit(ctx, &expr6_0);
    let expr8_0 = C::writable_gpr_to_gpr(ctx, expr2_0);
    return Some(expr8_0);
}

// Generated as internal constructor for term x64_pcmpeq.
pub fn constructor_x64_pcmpeq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == I8X16 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3248.
        let expr0_0 = constructor_x64_pcmpeqb(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I16X8 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3249.
        let expr0_0 = constructor_x64_pcmpeqw(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3250.
        let expr0_0 = constructor_x64_pcmpeqd(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3251.
        let expr0_0 = constructor_x64_pcmpeqq(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term x64_pcmpeqb.
pub fn constructor_x64_pcmpeqb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3254.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pcmpeqb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pcmpeqw.
pub fn constructor_x64_pcmpeqw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3256.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pcmpeqw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pcmpeqd.
pub fn constructor_x64_pcmpeqd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3258.
    let expr0_0: Type = I32X4;
    let expr1_0 = SseOpcode::Pcmpeqd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pcmpeqq.
pub fn constructor_x64_pcmpeqq<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3260.
    let expr0_0: Type = I64X2;
    let expr1_0 = SseOpcode::Pcmpeqq;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pcmpgt.
pub fn constructor_x64_pcmpgt<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == I8X16 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3264.
        let expr0_0 = constructor_x64_pcmpgtb(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I16X8 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3265.
        let expr0_0 = constructor_x64_pcmpgtw(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3266.
        let expr0_0 = constructor_x64_pcmpgtd(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == I64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3267.
        let expr0_0 = constructor_x64_pcmpgtq(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term x64_pcmpgtb.
pub fn constructor_x64_pcmpgtb<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3270.
    let expr0_0: Type = I8X16;
    let expr1_0 = SseOpcode::Pcmpgtb;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pcmpgtw.
pub fn constructor_x64_pcmpgtw<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3272.
    let expr0_0: Type = I16X8;
    let expr1_0 = SseOpcode::Pcmpgtw;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pcmpgtd.
pub fn constructor_x64_pcmpgtd<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3274.
    let expr0_0: Type = I32X4;
    let expr1_0 = SseOpcode::Pcmpgtd;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_pcmpgtq.
pub fn constructor_x64_pcmpgtq<C: Context>(ctx: &mut C, arg0: Xmm, arg1: &XmmMem) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3276.
    let expr0_0: Type = I64X2;
    let expr1_0 = SseOpcode::Pcmpgtq;
    let expr2_0 = constructor_xmm_rm_r(ctx, expr0_0, &expr1_0, pattern0_0, pattern1_0)?;
    return Some(expr2_0);
}

// Generated as internal constructor for term alu_rm.
pub fn constructor_alu_rm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &AluRmiROpcode,
    arg2: &Amode,
    arg3: Gpr,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 3280.
    let expr0_0 = C::operand_size_of_type_32_64(ctx, pattern0_0);
    let expr1_0 = C::amode_to_synthetic_amode(ctx, pattern2_0);
    let expr2_0 = MInst::AluRM {
        size: expr0_0,
        op: pattern1_0.clone(),
        src1_dst: expr1_0,
        src2: pattern3_0,
    };
    let expr3_0 = SideEffectNoResult::Inst { inst: expr2_0 };
    return Some(expr3_0);
}

// Generated as internal constructor for term x64_add_mem.
pub fn constructor_x64_add_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Amode,
    arg2: Gpr,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3285.
    let expr0_0 = AluRmiROpcode::Add;
    let expr1_0 = constructor_alu_rm(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_sub_mem.
pub fn constructor_x64_sub_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Amode,
    arg2: Gpr,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3289.
    let expr0_0 = AluRmiROpcode::Sub;
    let expr1_0 = constructor_alu_rm(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_and_mem.
pub fn constructor_x64_and_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Amode,
    arg2: Gpr,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3293.
    let expr0_0 = AluRmiROpcode::And;
    let expr1_0 = constructor_alu_rm(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_or_mem.
pub fn constructor_x64_or_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Amode,
    arg2: Gpr,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3297.
    let expr0_0 = AluRmiROpcode::Or;
    let expr1_0 = constructor_alu_rm(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_xor_mem.
pub fn constructor_x64_xor_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Amode,
    arg2: Gpr,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3301.
    let expr0_0 = AluRmiROpcode::Xor;
    let expr1_0 = constructor_alu_rm(ctx, pattern0_0, &expr0_0, pattern1_0, pattern2_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term trap_if.
pub fn constructor_trap_if<C: Context>(
    ctx: &mut C,
    arg0: &CC,
    arg1: &TrapCode,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3306.
    let expr0_0 = MInst::TrapIf {
        cc: pattern0_0.clone(),
        trap_code: pattern1_0.clone(),
    };
    let expr1_0 = ConsumesFlags::ConsumesFlagsSideEffect { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term trap_if_and.
pub fn constructor_trap_if_and<C: Context>(
    ctx: &mut C,
    arg0: &CC,
    arg1: &CC,
    arg2: &TrapCode,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3311.
    let expr0_0 = MInst::TrapIfAnd {
        cc1: pattern0_0.clone(),
        cc2: pattern1_0.clone(),
        trap_code: pattern2_0.clone(),
    };
    let expr1_0 = ConsumesFlags::ConsumesFlagsSideEffect { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term trap_if_or.
pub fn constructor_trap_if_or<C: Context>(
    ctx: &mut C,
    arg0: &CC,
    arg1: &CC,
    arg2: &TrapCode,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3316.
    let expr0_0 = MInst::TrapIfOr {
        cc1: pattern0_0.clone(),
        cc2: pattern1_0.clone(),
        trap_code: pattern2_0.clone(),
    };
    let expr1_0 = ConsumesFlags::ConsumesFlagsSideEffect { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term trap_if_icmp.
pub fn constructor_trap_if_icmp<C: Context>(
    ctx: &mut C,
    arg0: &IcmpCondResult,
    arg1: &TrapCode,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    if let &IcmpCondResult::Condition {
        producer: ref pattern1_0,
        cc: ref pattern1_1,
    } = pattern0_0
    {
        let pattern2_0 = arg1;
        // Rule at src/isa/x64/inst.isle line 3320.
        let expr0_0 = constructor_trap_if(ctx, pattern1_1, pattern2_0)?;
        let expr1_0 = constructor_with_flags_side_effect(ctx, pattern1_0, &expr0_0)?;
        return Some(expr1_0);
    }
    return None;
}

// Generated as internal constructor for term trap_if_fcmp.
pub fn constructor_trap_if_fcmp<C: Context>(
    ctx: &mut C,
    arg0: &FcmpCondResult,
    arg1: &TrapCode,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &FcmpCondResult::Condition {
            producer: ref pattern1_0,
            cc: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            // Rule at src/isa/x64/inst.isle line 3324.
            let expr0_0 = constructor_trap_if(ctx, pattern1_1, pattern2_0)?;
            let expr1_0 = constructor_with_flags_side_effect(ctx, pattern1_0, &expr0_0)?;
            return Some(expr1_0);
        }
        &FcmpCondResult::AndCondition {
            producer: ref pattern1_0,
            cc1: ref pattern1_1,
            cc2: ref pattern1_2,
        } => {
            let pattern2_0 = arg1;
            // Rule at src/isa/x64/inst.isle line 3326.
            let expr0_0 = constructor_trap_if_and(ctx, pattern1_1, pattern1_2, pattern2_0)?;
            let expr1_0 = constructor_with_flags_side_effect(ctx, pattern1_0, &expr0_0)?;
            return Some(expr1_0);
        }
        &FcmpCondResult::OrCondition {
            producer: ref pattern1_0,
            cc1: ref pattern1_1,
            cc2: ref pattern1_2,
        } => {
            let pattern2_0 = arg1;
            // Rule at src/isa/x64/inst.isle line 3328.
            let expr0_0 = constructor_trap_if_or(ctx, pattern1_1, pattern1_2, pattern2_0)?;
            let expr1_0 = constructor_with_flags_side_effect(ctx, pattern1_0, &expr0_0)?;
            return Some(expr1_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term jmp_known.
pub fn constructor_jmp_known<C: Context>(
    ctx: &mut C,
    arg0: MachLabel,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3335.
    let expr0_0 = MInst::JmpKnown { dst: pattern0_0 };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term jmp_if.
pub fn constructor_jmp_if<C: Context>(
    ctx: &mut C,
    arg0: &CC,
    arg1: MachLabel,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3339.
    let expr0_0 = MInst::JmpIf {
        cc: pattern0_0.clone(),
        taken: pattern1_0,
    };
    let expr1_0 = ConsumesFlags::ConsumesFlagsSideEffect { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term jmp_cond.
pub fn constructor_jmp_cond<C: Context>(
    ctx: &mut C,
    arg0: &CC,
    arg1: MachLabel,
    arg2: MachLabel,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3344.
    let expr0_0 = MInst::JmpCond {
        cc: pattern0_0.clone(),
        taken: pattern1_0,
        not_taken: pattern2_0,
    };
    let expr1_0 = ConsumesFlags::ConsumesFlagsSideEffect { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term jmp_cond_icmp.
pub fn constructor_jmp_cond_icmp<C: Context>(
    ctx: &mut C,
    arg0: &IcmpCondResult,
    arg1: MachLabel,
    arg2: MachLabel,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    if let &IcmpCondResult::Condition {
        producer: ref pattern1_0,
        cc: ref pattern1_1,
    } = pattern0_0
    {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3349.
        let expr0_0 = constructor_jmp_cond(ctx, pattern1_1, pattern2_0, pattern3_0)?;
        let expr1_0 = constructor_with_flags_side_effect(ctx, pattern1_0, &expr0_0)?;
        return Some(expr1_0);
    }
    return None;
}

// Generated as internal constructor for term jmp_cond_fcmp.
pub fn constructor_jmp_cond_fcmp<C: Context>(
    ctx: &mut C,
    arg0: &FcmpCondResult,
    arg1: MachLabel,
    arg2: MachLabel,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &FcmpCondResult::Condition {
            producer: ref pattern1_0,
            cc: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            let pattern3_0 = arg2;
            // Rule at src/isa/x64/inst.isle line 3354.
            let expr0_0 = constructor_jmp_cond(ctx, pattern1_1, pattern2_0, pattern3_0)?;
            let expr1_0 = constructor_with_flags_side_effect(ctx, pattern1_0, &expr0_0)?;
            return Some(expr1_0);
        }
        &FcmpCondResult::AndCondition {
            producer: ref pattern1_0,
            cc1: ref pattern1_1,
            cc2: ref pattern1_2,
        } => {
            let pattern2_0 = arg1;
            let pattern3_0 = arg2;
            // Rule at src/isa/x64/inst.isle line 3356.
            let expr0_0 = C::cc_invert(ctx, pattern1_1);
            let expr1_0 = constructor_jmp_if(ctx, &expr0_0, pattern3_0)?;
            let expr2_0 = C::cc_invert(ctx, pattern1_2);
            let expr3_0 = constructor_jmp_cond(ctx, &expr2_0, pattern3_0, pattern2_0)?;
            let expr4_0 = constructor_consumes_flags_concat(ctx, &expr1_0, &expr3_0)?;
            let expr5_0 = constructor_with_flags_side_effect(ctx, pattern1_0, &expr4_0)?;
            return Some(expr5_0);
        }
        &FcmpCondResult::OrCondition {
            producer: ref pattern1_0,
            cc1: ref pattern1_1,
            cc2: ref pattern1_2,
        } => {
            let pattern2_0 = arg1;
            let pattern3_0 = arg2;
            // Rule at src/isa/x64/inst.isle line 3361.
            let expr0_0 = constructor_jmp_if(ctx, pattern1_1, pattern2_0)?;
            let expr1_0 = constructor_jmp_cond(ctx, pattern1_2, pattern2_0, pattern3_0)?;
            let expr2_0 = constructor_consumes_flags_concat(ctx, &expr0_0, &expr1_0)?;
            let expr3_0 = constructor_with_flags_side_effect(ctx, pattern1_0, &expr2_0)?;
            return Some(expr3_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term jmp_table_seq.
pub fn constructor_jmp_table_seq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: MachLabel,
    arg3: &BoxVecMachLabel,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 3381.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::temp_writable_gpr(ctx);
    let expr2_0 = C::raw_operand_size_of_type(ctx, pattern0_0);
    let expr3_0 = C::jump_table_size(ctx, pattern3_0);
    let expr4_0 = RegMemImm::Imm { simm32: expr3_0 };
    let expr5_0 = C::gpr_mem_imm_new(ctx, &expr4_0);
    let expr6_0 = constructor_x64_cmp(ctx, &expr2_0, &expr5_0, pattern1_0)?;
    let expr7_0 = C::gpr_to_reg(ctx, pattern1_0);
    let expr8_0 = C::writable_gpr_to_reg(ctx, expr0_0);
    let expr9_0 = C::writable_gpr_to_reg(ctx, expr1_0);
    let expr10_0 = MInst::JmpTableSeq {
        idx: expr7_0,
        tmp1: expr8_0,
        tmp2: expr9_0,
        default_target: pattern2_0,
        targets: pattern3_0.clone(),
    };
    let expr11_0 = ConsumesFlags::ConsumesFlagsSideEffect { inst: expr10_0 };
    let expr12_0 = constructor_with_flags_side_effect(ctx, &expr6_0, &expr11_0)?;
    return Some(expr12_0);
}

// Generated as internal constructor for term icmp_cond_result.
pub fn constructor_icmp_cond_result<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &CC,
) -> Option<IcmpCondResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3425.
    let expr0_0 = IcmpCondResult::Condition {
        producer: pattern0_0.clone(),
        cc: pattern1_0.clone(),
    };
    return Some(expr0_0);
}

// Generated as internal constructor for term invert_icmp_cond_result.
pub fn constructor_invert_icmp_cond_result<C: Context>(
    ctx: &mut C,
    arg0: &IcmpCondResult,
) -> Option<IcmpCondResult> {
    let pattern0_0 = arg0;
    if let &IcmpCondResult::Condition {
        producer: ref pattern1_0,
        cc: ref pattern1_1,
    } = pattern0_0
    {
        // Rule at src/isa/x64/inst.isle line 3428.
        let expr0_0 = C::cc_invert(ctx, pattern1_1);
        let expr1_0 = constructor_icmp_cond_result(ctx, pattern1_0, &expr0_0)?;
        return Some(expr1_0);
    }
    return None;
}

// Generated as internal constructor for term lower_icmp_bool.
pub fn constructor_lower_icmp_bool<C: Context>(
    ctx: &mut C,
    arg0: &IcmpCondResult,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    if let &IcmpCondResult::Condition {
        producer: ref pattern1_0,
        cc: ref pattern1_1,
    } = pattern0_0
    {
        // Rule at src/isa/x64/inst.isle line 3433.
        let expr0_0 = constructor_x64_setcc(ctx, pattern1_1)?;
        let expr1_0 = constructor_with_flags(ctx, pattern1_0, &expr0_0)?;
        return Some(expr1_0);
    }
    return None;
}

// Generated as internal constructor for term select_icmp.
pub fn constructor_select_icmp<C: Context>(
    ctx: &mut C,
    arg0: &IcmpCondResult,
    arg1: Value,
    arg2: Value,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    if let &IcmpCondResult::Condition {
        producer: ref pattern1_0,
        cc: ref pattern1_1,
    } = pattern0_0
    {
        let pattern2_0 = arg1;
        let pattern3_0 = C::value_type(ctx, pattern2_0);
        if let Some(pattern4_0) = C::type_register_class(ctx, pattern3_0) {
            if let &RegisterClass::Gpr {
                single_register: pattern5_0,
            } = &pattern4_0
            {
                if pattern5_0 == true {
                    let pattern7_0 = arg2;
                    // Rule at src/isa/x64/inst.isle line 3442.
                    let expr0_0 = constructor_put_in_gpr(ctx, pattern2_0)?;
                    let expr1_0 = C::gpr_to_gpr_mem(ctx, expr0_0);
                    let expr2_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                    let expr3_0 =
                        constructor_cmove(ctx, pattern3_0, pattern1_1, &expr1_0, expr2_0)?;
                    let expr4_0 = constructor_with_flags(ctx, pattern1_0, &expr3_0)?;
                    return Some(expr4_0);
                }
            }
        }
    }
    let pattern0_0 = arg0;
    if let &IcmpCondResult::Condition {
        producer: ref pattern1_0,
        cc: ref pattern1_1,
    } = pattern0_0
    {
        let pattern2_0 = arg1;
        let pattern3_0 = C::value_type(ctx, pattern2_0);
        let pattern4_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3446.
        let expr0_0 =
            constructor_cmove_from_values(ctx, pattern3_0, pattern1_1, pattern2_0, pattern4_0)?;
        let expr1_0 = constructor_with_flags(ctx, pattern1_0, &expr0_0)?;
        return Some(expr1_0);
    }
    return None;
}

// Generated as internal constructor for term emit_cmp.
pub fn constructor_emit_cmp<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: Value,
    arg2: Value,
) -> Option<IcmpCondResult> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &IntCC::Equal => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if pattern3_0 == I128 {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3467.
                let expr0_0 = C::put_in_regs(ctx, pattern2_0);
                let expr1_0: usize = 0i128 as usize;
                let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                let expr3_0 = C::put_in_regs(ctx, pattern2_0);
                let expr4_0: usize = 1i128 as usize;
                let expr5_0 = constructor_value_regs_get_gpr(ctx, expr3_0, expr4_0)?;
                let expr6_0 = C::put_in_regs(ctx, pattern5_0);
                let expr7_0: usize = 0i128 as usize;
                let expr8_0 = constructor_value_regs_get_gpr(ctx, expr6_0, expr7_0)?;
                let expr9_0 = C::put_in_regs(ctx, pattern5_0);
                let expr10_0: usize = 1i128 as usize;
                let expr11_0 = constructor_value_regs_get_gpr(ctx, expr9_0, expr10_0)?;
                let expr12_0 = OperandSize::Size64;
                let expr13_0 = C::gpr_to_gpr_mem_imm(ctx, expr8_0);
                let expr14_0 = constructor_x64_cmp(ctx, &expr12_0, &expr13_0, expr2_0)?;
                let expr15_0 = CC::Z;
                let expr16_0 = constructor_x64_setcc(ctx, &expr15_0)?;
                let expr17_0 = constructor_with_flags_reg(ctx, &expr14_0, &expr16_0)?;
                let expr18_0 = OperandSize::Size64;
                let expr19_0 = C::gpr_to_gpr_mem_imm(ctx, expr11_0);
                let expr20_0 = constructor_x64_cmp(ctx, &expr18_0, &expr19_0, expr5_0)?;
                let expr21_0 = CC::Z;
                let expr22_0 = constructor_x64_setcc(ctx, &expr21_0)?;
                let expr23_0 = constructor_with_flags_reg(ctx, &expr20_0, &expr22_0)?;
                let expr24_0: Type = I64;
                let expr25_0 = C::gpr_new(ctx, expr17_0);
                let expr26_0 = constructor_reg_to_gpr_mem_imm(ctx, expr23_0)?;
                let expr27_0 = constructor_x64_and(ctx, expr24_0, expr25_0, &expr26_0)?;
                let expr28_0 = C::gpr_to_reg(ctx, expr27_0);
                let expr29_0 = OperandSize::Size64;
                let expr30_0: u32 = 1i128 as u32;
                let expr31_0 = RegMemImm::Imm { simm32: expr30_0 };
                let expr32_0 = C::gpr_mem_imm_new(ctx, &expr31_0);
                let expr33_0 = C::gpr_new(ctx, expr28_0);
                let expr34_0 = constructor_x64_test(ctx, &expr29_0, &expr32_0, expr33_0)?;
                let expr35_0 = CC::NZ;
                let expr36_0 = constructor_icmp_cond_result(ctx, &expr34_0, &expr35_0)?;
                return Some(expr36_0);
            }
        }
        &IntCC::NotEqual => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if pattern3_0 == I128 {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3488.
                let expr0_0 = C::put_in_regs(ctx, pattern2_0);
                let expr1_0: usize = 0i128 as usize;
                let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                let expr3_0 = C::put_in_regs(ctx, pattern2_0);
                let expr4_0: usize = 1i128 as usize;
                let expr5_0 = constructor_value_regs_get_gpr(ctx, expr3_0, expr4_0)?;
                let expr6_0 = C::put_in_regs(ctx, pattern5_0);
                let expr7_0: usize = 0i128 as usize;
                let expr8_0 = constructor_value_regs_get_gpr(ctx, expr6_0, expr7_0)?;
                let expr9_0 = C::put_in_regs(ctx, pattern5_0);
                let expr10_0: usize = 1i128 as usize;
                let expr11_0 = constructor_value_regs_get_gpr(ctx, expr9_0, expr10_0)?;
                let expr12_0 = OperandSize::Size64;
                let expr13_0 = C::gpr_to_gpr_mem_imm(ctx, expr8_0);
                let expr14_0 = constructor_x64_cmp(ctx, &expr12_0, &expr13_0, expr2_0)?;
                let expr15_0 = CC::NZ;
                let expr16_0 = constructor_x64_setcc(ctx, &expr15_0)?;
                let expr17_0 = constructor_with_flags_reg(ctx, &expr14_0, &expr16_0)?;
                let expr18_0 = OperandSize::Size64;
                let expr19_0 = C::gpr_to_gpr_mem_imm(ctx, expr11_0);
                let expr20_0 = constructor_x64_cmp(ctx, &expr18_0, &expr19_0, expr5_0)?;
                let expr21_0 = CC::NZ;
                let expr22_0 = constructor_x64_setcc(ctx, &expr21_0)?;
                let expr23_0 = constructor_with_flags_reg(ctx, &expr20_0, &expr22_0)?;
                let expr24_0: Type = I64;
                let expr25_0 = C::gpr_new(ctx, expr17_0);
                let expr26_0 = constructor_reg_to_gpr_mem_imm(ctx, expr23_0)?;
                let expr27_0 = constructor_x64_or(ctx, expr24_0, expr25_0, &expr26_0)?;
                let expr28_0 = C::gpr_to_reg(ctx, expr27_0);
                let expr29_0 = OperandSize::Size64;
                let expr30_0: u32 = 1i128 as u32;
                let expr31_0 = RegMemImm::Imm { simm32: expr30_0 };
                let expr32_0 = C::gpr_mem_imm_new(ctx, &expr31_0);
                let expr33_0 = C::gpr_new(ctx, expr28_0);
                let expr34_0 = constructor_x64_test(ctx, &expr29_0, &expr32_0, expr33_0)?;
                let expr35_0 = CC::NZ;
                let expr36_0 = constructor_icmp_cond_result(ctx, &expr34_0, &expr35_0)?;
                return Some(expr36_0);
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = C::value_type(ctx, pattern1_0);
    if pattern2_0 == I128 {
        let pattern4_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3503.
        let expr0_0 = C::put_in_regs(ctx, pattern1_0);
        let expr1_0: usize = 0i128 as usize;
        let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
        let expr3_0 = C::put_in_regs(ctx, pattern1_0);
        let expr4_0: usize = 1i128 as usize;
        let expr5_0 = constructor_value_regs_get_gpr(ctx, expr3_0, expr4_0)?;
        let expr6_0 = C::put_in_regs(ctx, pattern4_0);
        let expr7_0: usize = 0i128 as usize;
        let expr8_0 = constructor_value_regs_get_gpr(ctx, expr6_0, expr7_0)?;
        let expr9_0 = C::put_in_regs(ctx, pattern4_0);
        let expr10_0: usize = 1i128 as usize;
        let expr11_0 = constructor_value_regs_get_gpr(ctx, expr9_0, expr10_0)?;
        let expr12_0 = OperandSize::Size64;
        let expr13_0 = C::gpr_to_gpr_mem_imm(ctx, expr11_0);
        let expr14_0 = constructor_x64_cmp(ctx, &expr12_0, &expr13_0, expr5_0)?;
        let expr15_0 = C::intcc_without_eq(ctx, pattern0_0);
        let expr16_0 = C::intcc_to_cc(ctx, &expr15_0);
        let expr17_0 = constructor_x64_setcc(ctx, &expr16_0)?;
        let expr18_0 = CC::Z;
        let expr19_0 = constructor_x64_setcc(ctx, &expr18_0)?;
        let expr20_0 = constructor_consumes_flags_concat(ctx, &expr17_0, &expr19_0)?;
        let expr21_0 = constructor_with_flags(ctx, &expr14_0, &expr20_0)?;
        let expr22_0: usize = 0i128 as usize;
        let expr23_0 = C::value_regs_get(ctx, expr21_0, expr22_0);
        let expr24_0: usize = 1i128 as usize;
        let expr25_0 = C::value_regs_get(ctx, expr21_0, expr24_0);
        let expr26_0 = OperandSize::Size64;
        let expr27_0 = C::gpr_to_gpr_mem_imm(ctx, expr8_0);
        let expr28_0 = constructor_x64_cmp(ctx, &expr26_0, &expr27_0, expr2_0)?;
        let expr29_0 = C::intcc_unsigned(ctx, pattern0_0);
        let expr30_0 = C::intcc_to_cc(ctx, &expr29_0);
        let expr31_0 = constructor_x64_setcc(ctx, &expr30_0)?;
        let expr32_0 = constructor_with_flags_reg(ctx, &expr28_0, &expr31_0)?;
        let expr33_0: Type = I64;
        let expr34_0 = C::gpr_new(ctx, expr25_0);
        let expr35_0 = constructor_reg_to_gpr_mem_imm(ctx, expr32_0)?;
        let expr36_0 = constructor_x64_and(ctx, expr33_0, expr34_0, &expr35_0)?;
        let expr37_0 = C::gpr_to_reg(ctx, expr36_0);
        let expr38_0: Type = I64;
        let expr39_0 = C::gpr_new(ctx, expr23_0);
        let expr40_0 = constructor_reg_to_gpr_mem_imm(ctx, expr37_0)?;
        let expr41_0 = constructor_x64_or(ctx, expr38_0, expr39_0, &expr40_0)?;
        let expr42_0 = C::gpr_to_reg(ctx, expr41_0);
        let expr43_0 = OperandSize::Size64;
        let expr44_0: u32 = 1i128 as u32;
        let expr45_0 = RegMemImm::Imm { simm32: expr44_0 };
        let expr46_0 = C::gpr_mem_imm_new(ctx, &expr45_0);
        let expr47_0 = C::gpr_new(ctx, expr42_0);
        let expr48_0 = constructor_x64_test(ctx, &expr43_0, &expr46_0, expr47_0)?;
        let expr49_0 = CC::NZ;
        let expr50_0 = constructor_icmp_cond_result(ctx, &expr48_0, &expr49_0)?;
        return Some(expr50_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::simm32_from_value(ctx, pattern1_0) {
        let pattern3_0 = C::value_type(ctx, pattern1_0);
        let pattern4_0 = arg2;
        // Rule at src/isa/x64/inst.isle line 3461.
        let expr0_0 = C::raw_operand_size_of_type(ctx, pattern3_0);
        let expr1_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
        let expr2_0 = constructor_x64_cmp(ctx, &expr0_0, &pattern2_0, expr1_0)?;
        let expr3_0 = C::intcc_reverse(ctx, pattern0_0);
        let expr4_0 = C::intcc_to_cc(ctx, &expr3_0);
        let expr5_0 = constructor_icmp_cond_result(ctx, &expr2_0, &expr4_0)?;
        return Some(expr5_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = C::value_type(ctx, pattern1_0);
    let pattern3_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3454.
    let expr0_0 = C::raw_operand_size_of_type(ctx, pattern2_0);
    let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern3_0)?;
    let expr2_0 = constructor_put_in_gpr(ctx, pattern1_0)?;
    let expr3_0 = constructor_x64_cmp(ctx, &expr0_0, &expr1_0, expr2_0)?;
    let expr4_0 = C::intcc_to_cc(ctx, pattern0_0);
    let expr5_0 = constructor_icmp_cond_result(ctx, &expr3_0, &expr4_0)?;
    return Some(expr5_0);
}

// Generated as internal constructor for term lower_fcmp_bool.
pub fn constructor_lower_fcmp_bool<C: Context>(
    ctx: &mut C,
    arg0: &FcmpCondResult,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &FcmpCondResult::Condition {
            producer: ref pattern1_0,
            cc: ref pattern1_1,
        } => {
            // Rule at src/isa/x64/inst.isle line 3538.
            let expr0_0 = constructor_x64_setcc(ctx, pattern1_1)?;
            let expr1_0 = constructor_with_flags(ctx, pattern1_0, &expr0_0)?;
            return Some(expr1_0);
        }
        &FcmpCondResult::AndCondition {
            producer: ref pattern1_0,
            cc1: ref pattern1_1,
            cc2: ref pattern1_2,
        } => {
            // Rule at src/isa/x64/inst.isle line 3541.
            let expr0_0 = constructor_x64_setcc(ctx, pattern1_1)?;
            let expr1_0 = constructor_x64_setcc(ctx, pattern1_2)?;
            let expr2_0 = constructor_consumes_flags_concat(ctx, &expr0_0, &expr1_0)?;
            let expr3_0 = constructor_with_flags(ctx, pattern1_0, &expr2_0)?;
            let expr4_0: usize = 0i128 as usize;
            let expr5_0 = constructor_value_regs_get_gpr(ctx, expr3_0, expr4_0)?;
            let expr6_0: usize = 1i128 as usize;
            let expr7_0 = constructor_value_regs_get_gpr(ctx, expr3_0, expr6_0)?;
            let expr8_0: Type = I8;
            let expr9_0 = C::gpr_to_gpr_mem_imm(ctx, expr7_0);
            let expr10_0 = constructor_x64_and(ctx, expr8_0, expr5_0, &expr9_0)?;
            let expr11_0 = C::gpr_to_reg(ctx, expr10_0);
            let expr12_0 = C::value_reg(ctx, expr11_0);
            return Some(expr12_0);
        }
        &FcmpCondResult::OrCondition {
            producer: ref pattern1_0,
            cc1: ref pattern1_1,
            cc2: ref pattern1_2,
        } => {
            // Rule at src/isa/x64/inst.isle line 3550.
            let expr0_0 = constructor_x64_setcc(ctx, pattern1_1)?;
            let expr1_0 = constructor_x64_setcc(ctx, pattern1_2)?;
            let expr2_0 = constructor_consumes_flags_concat(ctx, &expr0_0, &expr1_0)?;
            let expr3_0 = constructor_with_flags(ctx, pattern1_0, &expr2_0)?;
            let expr4_0: usize = 0i128 as usize;
            let expr5_0 = constructor_value_regs_get_gpr(ctx, expr3_0, expr4_0)?;
            let expr6_0: usize = 1i128 as usize;
            let expr7_0 = constructor_value_regs_get_gpr(ctx, expr3_0, expr6_0)?;
            let expr8_0: Type = I8;
            let expr9_0 = C::gpr_to_gpr_mem_imm(ctx, expr7_0);
            let expr10_0 = constructor_x64_or(ctx, expr8_0, expr5_0, &expr9_0)?;
            let expr11_0 = C::gpr_to_reg(ctx, expr10_0);
            let expr12_0 = C::value_reg(ctx, expr11_0);
            return Some(expr12_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term emit_fcmp.
pub fn constructor_emit_fcmp<C: Context>(
    ctx: &mut C,
    arg0: &FloatCC,
    arg1: Value,
    arg2: Value,
) -> Option<FcmpCondResult> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &FloatCC::Equal => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3577.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::NP;
                let expr2_0 = CC::Z;
                let expr3_0 = FcmpCondResult::AndCondition {
                    producer: expr0_0,
                    cc1: expr1_0,
                    cc2: expr2_0,
                };
                return Some(expr3_0);
            }
        }
        &FloatCC::GreaterThan => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3593.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::NBE;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::GreaterThanOrEqual => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3595.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::NB;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::LessThan => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3605.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern2_0, pattern5_0)?;
                let expr1_0 = CC::NBE;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::LessThanOrEqual => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3608.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern2_0, pattern5_0)?;
                let expr1_0 = CC::NB;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::NotEqual => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3580.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::P;
                let expr2_0 = CC::NZ;
                let expr3_0 = FcmpCondResult::OrCondition {
                    producer: expr0_0,
                    cc1: expr1_0,
                    cc2: expr2_0,
                };
                return Some(expr3_0);
            }
        }
        &FloatCC::Ordered => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3585.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::NP;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::OrderedNotEqual => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3589.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::NZ;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::Unordered => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3587.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::P;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::UnorderedOrEqual => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3591.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::Z;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::UnorderedOrGreaterThan => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3611.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern2_0, pattern5_0)?;
                let expr1_0 = CC::B;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::UnorderedOrGreaterThanOrEqual => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3614.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern2_0, pattern5_0)?;
                let expr1_0 = CC::BE;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::UnorderedOrLessThan => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3597.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::B;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        &FloatCC::UnorderedOrLessThanOrEqual => {
            let pattern2_0 = arg1;
            let pattern3_0 = C::value_type(ctx, pattern2_0);
            if let Some(pattern4_0) = C::ty_scalar_float(ctx, pattern3_0) {
                let pattern5_0 = arg2;
                // Rule at src/isa/x64/inst.isle line 3599.
                let expr0_0 = constructor_x64_ucomis(ctx, pattern5_0, pattern2_0)?;
                let expr1_0 = CC::BE;
                let expr2_0 = FcmpCondResult::Condition {
                    producer: expr0_0,
                    cc: expr1_0,
                };
                return Some(expr2_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term x64_mfence.
pub fn constructor_x64_mfence<C: Context>(ctx: &mut C) -> Option<SideEffectNoResult> {
    // Rule at src/isa/x64/inst.isle line 3627.
    let expr0_0 = FenceKind::MFence;
    let expr1_0 = MInst::Fence { kind: expr0_0 };
    let expr2_0 = SideEffectNoResult::Inst { inst: expr1_0 };
    return Some(expr2_0);
}

// Generated as internal constructor for term x64_cmpxchg.
pub fn constructor_x64_cmpxchg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
    arg2: Gpr,
    arg3: &SyntheticAmode,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 3631.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::gpr_to_reg(ctx, pattern2_0);
    let expr2_0 = C::gpr_to_reg(ctx, pattern1_0);
    let expr3_0 = C::writable_gpr_to_reg(ctx, expr0_0);
    let expr4_0 = MInst::LockCmpxchg {
        ty: pattern0_0,
        replacement: expr1_0,
        expected: expr2_0,
        mem: pattern3_0.clone(),
        dst_old: expr3_0,
    };
    let expr5_0 = C::emit(ctx, &expr4_0);
    let expr6_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr6_0);
}

// Generated as internal constructor for term x64_atomic_rmw_seq.
pub fn constructor_x64_atomic_rmw_seq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MachAtomicRmwOp,
    arg2: &SyntheticAmode,
    arg3: Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/x64/inst.isle line 3637.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::temp_writable_gpr(ctx);
    let expr2_0 = C::gpr_to_reg(ctx, pattern3_0);
    let expr3_0 = C::writable_gpr_to_reg(ctx, expr1_0);
    let expr4_0 = C::writable_gpr_to_reg(ctx, expr0_0);
    let expr5_0 = MInst::AtomicRmwSeq {
        ty: pattern0_0,
        op: pattern1_0.clone(),
        mem: pattern2_0.clone(),
        operand: expr2_0,
        temp: expr3_0,
        dst_old: expr4_0,
    };
    let expr6_0 = C::emit(ctx, &expr5_0);
    let expr7_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr7_0);
}

// Generated as internal constructor for term bitcast_xmm_to_gpr.
pub fn constructor_bitcast_xmm_to_gpr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        let pattern2_0 = arg1;
        // Rule at src/isa/x64/inst.isle line 3652.
        let expr0_0 = SseOpcode::Movd;
        let expr1_0 = OperandSize::Size32;
        let expr2_0 = constructor_xmm_to_gpr(ctx, &expr0_0, pattern2_0, &expr1_0)?;
        return Some(expr2_0);
    }
    if pattern0_0 == F64 {
        let pattern2_0 = arg1;
        // Rule at src/isa/x64/inst.isle line 3654.
        let expr0_0 = SseOpcode::Movq;
        let expr1_0 = OperandSize::Size64;
        let expr2_0 = constructor_xmm_to_gpr(ctx, &expr0_0, pattern2_0, &expr1_0)?;
        return Some(expr2_0);
    }
    return None;
}

// Generated as internal constructor for term bitcast_gpr_to_xmm.
pub fn constructor_bitcast_gpr_to_xmm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Gpr,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        // Rule at src/isa/x64/inst.isle line 3658.
        let expr0_0 = SseOpcode::Movd;
        let expr1_0 = C::gpr_to_gpr_mem(ctx, pattern2_0);
        let expr2_0 = OperandSize::Size32;
        let expr3_0 = constructor_gpr_to_xmm(ctx, &expr0_0, &expr1_0, &expr2_0)?;
        return Some(expr3_0);
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        // Rule at src/isa/x64/inst.isle line 3660.
        let expr0_0 = SseOpcode::Movq;
        let expr1_0 = C::gpr_to_gpr_mem(ctx, pattern2_0);
        let expr2_0 = OperandSize::Size64;
        let expr3_0 = constructor_gpr_to_xmm(ctx, &expr0_0, &expr1_0, &expr2_0)?;
        return Some(expr3_0);
    }
    return None;
}

// Generated as internal constructor for term stack_addr_impl.
pub fn constructor_stack_addr_impl<C: Context>(
    ctx: &mut C,
    arg0: StackSlot,
    arg1: Offset32,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3666.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::writable_gpr_to_reg(ctx, expr0_0);
    let expr2_0 = C::abi_stackslot_addr(ctx, expr1_0, pattern0_0, pattern1_0);
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term div_or_rem.
pub fn constructor_div_or_rem<C: Context>(
    ctx: &mut C,
    arg0: &DivOrRemKind,
    arg1: Value,
    arg2: Value,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = C::value_type(ctx, pattern1_0);
    let pattern3_0 = arg2;
    // Rule at src/isa/x64/inst.isle line 3677.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = constructor_put_in_gpr(ctx, pattern1_0)?;
    let expr2_0 = constructor_put_in_gpr(ctx, pattern3_0)?;
    let expr3_0 = C::emit_div_or_rem(ctx, pattern0_0, pattern2_0, expr0_0, expr1_0, expr2_0);
    let expr4_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term read_pinned_gpr.
pub fn constructor_read_pinned_gpr<C: Context>(ctx: &mut C) -> Option<Gpr> {
    // Rule at src/isa/x64/inst.isle line 3685.
    let expr0_0 = C::preg_pinned(ctx);
    let expr1_0 = constructor_mov_from_preg(ctx, expr0_0)?;
    let expr2_0 = C::gpr_new(ctx, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term write_pinned_gpr.
pub fn constructor_write_pinned_gpr<C: Context>(
    ctx: &mut C,
    arg0: Gpr,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3689.
    let expr0_0 = C::preg_pinned(ctx);
    let expr1_0 = constructor_mov_to_preg(ctx, expr0_0, pattern0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term elf_tls_get_addr.
pub fn constructor_elf_tls_get_addr<C: Context>(ctx: &mut C, arg0: ExternalName) -> Option<Gpr> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3737.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = MInst::ElfTlsGetAddr {
        symbol: pattern0_0,
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term macho_tls_get_addr.
pub fn constructor_macho_tls_get_addr<C: Context>(ctx: &mut C, arg0: ExternalName) -> Option<Gpr> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3744.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = MInst::MachOTlsGetAddr {
        symbol: pattern0_0,
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term coff_tls_get_addr.
pub fn constructor_coff_tls_get_addr<C: Context>(ctx: &mut C, arg0: ExternalName) -> Option<Gpr> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3751.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = C::temp_writable_gpr(ctx);
    let expr2_0 = MInst::CoffTlsGetAddr {
        symbol: pattern0_0,
        dst: expr0_0,
        tmp: expr1_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_gpr_to_gpr(ctx, expr0_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term reg_to_xmm_mem.
pub fn constructor_reg_to_xmm_mem<C: Context>(ctx: &mut C, arg0: Reg) -> Option<XmmMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3827.
    let expr0_0 = C::xmm_new(ctx, pattern0_0);
    let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term xmm_to_reg_mem.
pub fn constructor_xmm_to_reg_mem<C: Context>(ctx: &mut C, arg0: Reg) -> Option<XmmMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3830.
    let expr0_0 = C::xmm_new(ctx, pattern0_0);
    let expr1_0 = C::xmm_to_reg(ctx, expr0_0);
    let expr2_0 = RegMem::Reg { reg: expr1_0 };
    let expr3_0 = C::reg_mem_to_xmm_mem(ctx, &expr2_0);
    return Some(expr3_0);
}

// Generated as internal constructor for term writable_gpr_to_r_reg.
pub fn constructor_writable_gpr_to_r_reg<C: Context>(
    ctx: &mut C,
    arg0: WritableGpr,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3834.
    let expr0_0 = C::writable_gpr_to_reg(ctx, pattern0_0);
    let expr1_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term writable_gpr_to_gpr_mem.
pub fn constructor_writable_gpr_to_gpr_mem<C: Context>(
    ctx: &mut C,
    arg0: WritableGpr,
) -> Option<GprMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3837.
    let expr0_0 = C::writable_gpr_to_gpr(ctx, pattern0_0);
    let expr1_0 = C::gpr_to_gpr_mem(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term writable_gpr_to_value_regs.
pub fn constructor_writable_gpr_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableGpr,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3840.
    let expr0_0 = constructor_writable_gpr_to_r_reg(ctx, pattern0_0)?;
    let expr1_0 = C::value_reg(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term writable_xmm_to_r_reg.
pub fn constructor_writable_xmm_to_r_reg<C: Context>(
    ctx: &mut C,
    arg0: WritableXmm,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3843.
    let expr0_0 = C::writable_xmm_to_reg(ctx, pattern0_0);
    let expr1_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term writable_xmm_to_xmm_mem.
pub fn constructor_writable_xmm_to_xmm_mem<C: Context>(
    ctx: &mut C,
    arg0: WritableXmm,
) -> Option<XmmMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3846.
    let expr0_0 = C::writable_xmm_to_xmm(ctx, pattern0_0);
    let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term writable_xmm_to_value_regs.
pub fn constructor_writable_xmm_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableXmm,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3849.
    let expr0_0 = constructor_writable_xmm_to_r_reg(ctx, pattern0_0)?;
    let expr1_0 = C::value_reg(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term synthetic_amode_to_gpr_mem.
pub fn constructor_synthetic_amode_to_gpr_mem<C: Context>(
    ctx: &mut C,
    arg0: &SyntheticAmode,
) -> Option<GprMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3856.
    let expr0_0 = C::synthetic_amode_to_reg_mem(ctx, pattern0_0);
    let expr1_0 = C::reg_mem_to_gpr_mem(ctx, &expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term amode_to_gpr_mem.
pub fn constructor_amode_to_gpr_mem<C: Context>(ctx: &mut C, arg0: &Amode) -> Option<GprMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3854.
    let expr0_0 = C::amode_to_synthetic_amode(ctx, pattern0_0);
    let expr1_0 = constructor_synthetic_amode_to_gpr_mem(ctx, &expr0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term amode_to_xmm_mem.
pub fn constructor_amode_to_xmm_mem<C: Context>(ctx: &mut C, arg0: &Amode) -> Option<XmmMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3859.
    let expr0_0 = C::amode_to_synthetic_amode(ctx, pattern0_0);
    let expr1_0 = constructor_synthetic_amode_to_xmm_mem(ctx, &expr0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term synthetic_amode_to_xmm_mem.
pub fn constructor_synthetic_amode_to_xmm_mem<C: Context>(
    ctx: &mut C,
    arg0: &SyntheticAmode,
) -> Option<XmmMem> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3862.
    let expr0_0 = C::synthetic_amode_to_reg_mem(ctx, pattern0_0);
    let expr1_0 = C::reg_mem_to_xmm_mem(ctx, &expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term mov_from_preg.
pub fn constructor_mov_from_preg<C: Context>(ctx: &mut C, arg0: PReg) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/inst.isle line 3869.
    let expr0_0 = C::temp_writable_gpr(ctx);
    let expr1_0 = MInst::MovFromPReg {
        src: pattern0_0,
        dst: expr0_0,
    };
    let expr2_0 = C::emit(ctx, &expr1_0);
    let expr3_0 = constructor_writable_gpr_to_r_reg(ctx, expr0_0)?;
    return Some(expr3_0);
}

// Generated as internal constructor for term mov_to_preg.
pub fn constructor_mov_to_preg<C: Context>(
    ctx: &mut C,
    arg0: PReg,
    arg1: Gpr,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/inst.isle line 3875.
    let expr0_0 = MInst::MovToPReg {
        src: pattern1_0,
        dst: pattern0_0,
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_rbp.
pub fn constructor_x64_rbp<C: Context>(ctx: &mut C) -> Option<Reg> {
    // Rule at src/isa/x64/inst.isle line 3888.
    let expr0_0 = C::preg_rbp(ctx);
    let expr1_0 = constructor_mov_from_preg(ctx, expr0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term x64_rsp.
pub fn constructor_x64_rsp<C: Context>(ctx: &mut C) -> Option<Reg> {
    // Rule at src/isa/x64/inst.isle line 3892.
    let expr0_0 = C::preg_rsp(ctx);
    let expr1_0 = constructor_mov_from_preg(ctx, expr0_0)?;
    return Some(expr1_0);
}

// Generated as internal constructor for term lower.
pub fn constructor_lower<C: Context>(ctx: &mut C, arg0: Inst) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Band => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 292.
                        let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr1_0: usize = 0i128 as usize;
                        let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                        let expr3_0: usize = 1i128 as usize;
                        let expr4_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr3_0)?;
                        let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr6_0: usize = 0i128 as usize;
                        let expr7_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr6_0)?;
                        let expr8_0: usize = 1i128 as usize;
                        let expr9_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr8_0)?;
                        let expr10_0: Type = I64;
                        let expr11_0 = C::gpr_to_gpr_mem_imm(ctx, expr7_0);
                        let expr12_0 = constructor_x64_and(ctx, expr10_0, expr2_0, &expr11_0)?;
                        let expr13_0: Type = I64;
                        let expr14_0 = C::gpr_to_gpr_mem_imm(ctx, expr9_0);
                        let expr15_0 = constructor_x64_and(ctx, expr13_0, expr4_0, &expr14_0)?;
                        let expr16_0 = constructor_value_gprs(ctx, expr12_0, expr15_0)?;
                        let expr17_0 = C::output(ctx, expr16_0);
                        return Some(expr17_0);
                    }
                    &Opcode::Bor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 362.
                        let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0 = constructor_or_i128(ctx, expr0_0, expr1_0)?;
                        let expr3_0 = C::output(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                    &Opcode::Bxor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 408.
                        let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr1_0: usize = 0i128 as usize;
                        let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                        let expr3_0: usize = 1i128 as usize;
                        let expr4_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr3_0)?;
                        let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr6_0: usize = 0i128 as usize;
                        let expr7_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr6_0)?;
                        let expr8_0: usize = 1i128 as usize;
                        let expr9_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr8_0)?;
                        let expr10_0: Type = I64;
                        let expr11_0 = C::gpr_to_gpr_mem_imm(ctx, expr7_0);
                        let expr12_0 = constructor_x64_xor(ctx, expr10_0, expr2_0, &expr11_0)?;
                        let expr13_0: Type = I64;
                        let expr14_0 = C::gpr_to_gpr_mem_imm(ctx, expr9_0);
                        let expr15_0 = constructor_x64_xor(ctx, expr13_0, expr4_0, &expr14_0)?;
                        let expr16_0 = constructor_value_gprs(ctx, expr12_0, expr15_0)?;
                        let expr17_0 = C::output(ctx, expr16_0);
                        return Some(expr17_0);
                    }
                    _ => {}
                }
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some((pattern3_0, pattern3_1)) = C::multi_lane(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Band => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 286.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                        let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                        let expr2_0 = constructor_sse_and(ctx, pattern2_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Bor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 347.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                        let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                        let expr2_0 = constructor_sse_or(ctx, pattern2_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Bxor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 403.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                        let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                        let expr2_0 = constructor_sse_xor(ctx, pattern2_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    _ => {}
                }
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some(pattern3_0) = C::ty_scalar_float(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Band => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 274.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                        let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                        let expr2_0 = constructor_sse_and(ctx, pattern3_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Bor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 335.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                        let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                        let expr2_0 = constructor_sse_or(ctx, pattern3_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Bxor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 398.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                        let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                        let expr2_0 = constructor_sse_xor(ctx, pattern3_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    _ => {}
                }
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::IaddIfcout = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::sinkable_load(ctx, pattern7_0) {
                            // Rule at src/isa/x64/lower.isle line 162.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr1_0 = constructor_sink_load_to_gpr_mem_imm(ctx, &pattern8_0)?;
                            let expr2_0 = constructor_x64_add(ctx, pattern3_0, expr0_0, &expr1_0)?;
                            let expr3_0 = C::gpr_to_reg(ctx, expr2_0);
                            let expr4_0 = constructor_output_ifcout(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                    }
                }
                &InstructionData::IntAddTrap {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    code: ref pattern5_2,
                } => {
                    if let &Opcode::UaddOverflowTrap = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::sinkable_load(ctx, pattern7_0) {
                            // Rule at src/isa/x64/lower.isle line 1486.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr1_0 = constructor_sink_load_to_gpr_mem_imm(ctx, &pattern8_0)?;
                            let expr2_0 = constructor_x64_add_with_flags_paired(
                                ctx, pattern3_0, expr0_0, &expr1_0,
                            )?;
                            let expr3_0 = CC::B;
                            let expr4_0 = constructor_trap_if(ctx, &expr3_0, pattern5_2)?;
                            let expr5_0 = constructor_with_flags(ctx, &expr2_0, &expr4_0)?;
                            let expr6_0 = C::output(ctx, expr5_0);
                            return Some(expr6_0);
                        }
                    }
                }
                _ => {}
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        if let &InstructionData::Binary {
            opcode: ref pattern4_0,
            args: ref pattern4_1,
        } = &pattern3_0
        {
            match pattern4_0 {
                &Opcode::Band => {
                    let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::simm32_from_value(ctx, pattern6_0) {
                        let mut closure8 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern8_0) = closure8() {
                            // Rule at src/isa/x64/lower.isle line 268.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_1)?;
                            let expr1_0 =
                                constructor_x64_and(ctx, pattern2_0, expr0_0, &pattern7_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
                &Opcode::Bor => {
                    let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::simm32_from_value(ctx, pattern6_0) {
                        let mut closure8 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern8_0) = closure8() {
                            // Rule at src/isa/x64/lower.isle line 329.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_1)?;
                            let expr1_0 =
                                constructor_x64_or(ctx, pattern2_0, expr0_0, &pattern7_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
                &Opcode::Bxor => {
                    let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::simm32_from_value(ctx, pattern6_0) {
                        let mut closure8 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern8_0) = closure8() {
                            // Rule at src/isa/x64/lower.isle line 392.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_1)?;
                            let expr1_0 =
                                constructor_x64_xor(ctx, pattern2_0, expr0_0, &pattern7_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
                _ => {}
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::IaddIfcout = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::sinkable_load(ctx, pattern7_1) {
                            // Rule at src/isa/x64/lower.isle line 158.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 = constructor_sink_load_to_gpr_mem_imm(ctx, &pattern8_0)?;
                            let expr2_0 = constructor_x64_add(ctx, pattern3_0, expr0_0, &expr1_0)?;
                            let expr3_0 = C::gpr_to_reg(ctx, expr2_0);
                            let expr4_0 = constructor_output_ifcout(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                    }
                }
                &InstructionData::IntAddTrap {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    code: ref pattern5_2,
                } => {
                    if let &Opcode::UaddOverflowTrap = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::sinkable_load(ctx, pattern7_1) {
                            // Rule at src/isa/x64/lower.isle line 1480.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 = constructor_sink_load_to_gpr_mem_imm(ctx, &pattern8_0)?;
                            let expr2_0 = constructor_x64_add_with_flags_paired(
                                ctx, pattern3_0, expr0_0, &expr1_0,
                            )?;
                            let expr3_0 = CC::B;
                            let expr4_0 = constructor_trap_if(ctx, &expr3_0, pattern5_2)?;
                            let expr5_0 = constructor_with_flags(ctx, &expr2_0, &expr4_0)?;
                            let expr6_0 = C::output(ctx, expr5_0);
                            return Some(expr6_0);
                        }
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::ty_32_or_64(ctx, pattern2_0) {
            let pattern4_0 = C::use_popcnt(ctx, pattern2_0);
            if pattern4_0 == true {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Unary {
                    opcode: ref pattern7_0,
                    arg: pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Popcnt = pattern7_0 {
                        // Rule at src/isa/x64/lower.isle line 1867.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                        let expr1_0 = constructor_x64_popcnt(ctx, pattern3_0, expr0_0)?;
                        let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        if let &InstructionData::Binary {
            opcode: ref pattern4_0,
            args: ref pattern4_1,
        } = &pattern3_0
        {
            match pattern4_0 {
                &Opcode::Band => {
                    let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::simm32_from_value(ctx, pattern6_1) {
                        let mut closure8 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern8_0) = closure8() {
                            // Rule at src/isa/x64/lower.isle line 264.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                            let expr1_0 =
                                constructor_x64_and(ctx, pattern2_0, expr0_0, &pattern7_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
                &Opcode::Bor => {
                    let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::simm32_from_value(ctx, pattern6_1) {
                        let mut closure8 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern8_0) = closure8() {
                            // Rule at src/isa/x64/lower.isle line 325.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                            let expr1_0 =
                                constructor_x64_or(ctx, pattern2_0, expr0_0, &pattern7_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
                &Opcode::Bxor => {
                    let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::simm32_from_value(ctx, pattern6_1) {
                        let mut closure8 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern8_0) = closure8() {
                            // Rule at src/isa/x64/lower.isle line 388.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                            let expr1_0 =
                                constructor_x64_xor(ctx, pattern2_0, expr0_0, &pattern7_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
                _ => {}
            }
        }
        let pattern3_0 = C::avx512vl_enabled(ctx, pattern2_0);
        if pattern3_0 == true {
            let pattern5_0 = C::avx512dq_enabled(ctx, pattern2_0);
            if pattern5_0 == true {
                if let Some((pattern7_0, pattern7_1)) = C::multi_lane(ctx, pattern2_0) {
                    if pattern7_0 == 64i128 as u32 {
                        if pattern7_1 == 2i128 as u32 {
                            let pattern10_0 = C::inst_data(ctx, pattern0_0);
                            if let &InstructionData::Binary {
                                opcode: ref pattern11_0,
                                args: ref pattern11_1,
                            } = &pattern10_0
                            {
                                if let &Opcode::Imul = pattern11_0 {
                                    let (pattern13_0, pattern13_1) =
                                        C::unpack_value_array_2(ctx, pattern11_1);
                                    // Rule at src/isa/x64/lower.isle line 916.
                                    let expr0_0 = C::put_in_xmm_mem(ctx, pattern13_0);
                                    let expr1_0 = constructor_put_in_xmm(ctx, pattern13_1)?;
                                    let expr2_0 = constructor_x64_vpmullq(ctx, &expr0_0, expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::Unary {
            opcode: ref pattern2_0,
            arg: pattern2_1,
        } => {
            if let &Opcode::ScalarToVector = pattern2_0 {
                if let Some(pattern4_0) = C::sinkable_load(ctx, pattern2_1) {
                    let pattern5_0 = C::value_type(ctx, pattern2_1);
                    if let Some(pattern6_0) = C::ty_64(ctx, pattern5_0) {
                        // Rule at src/isa/x64/lower.isle line 3615.
                        let expr0_0 = constructor_sink_load_to_xmm_mem(ctx, &pattern4_0)?;
                        let expr1_0 = constructor_x64_movsd_load(ctx, &expr0_0)?;
                        let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
            }
        }
        &InstructionData::Shuffle {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            imm: pattern2_2,
        } => {
            if let &Opcode::Shuffle = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                if pattern4_1 == pattern4_0 {
                    if let Some(pattern6_0) = C::vec_mask_from_immediate(ctx, pattern2_2) {
                        // Rule at src/isa/x64/lower.isle line 3525.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                        let expr1_0: Type = I8X16;
                        let expr2_0 = C::shuffle_0_31_mask(ctx, &pattern6_0);
                        let expr3_0 = constructor_x64_xmm_load_const(ctx, expr1_0, expr2_0)?;
                        let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                        let expr5_0 = constructor_x64_pshufb(ctx, expr0_0, &expr4_0)?;
                        let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                }
            }
        }
        &InstructionData::Store {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            if let &Opcode::Store = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::def_inst(ctx, pattern4_0) {
                    if let Some(pattern6_0) = C::first_result(ctx, pattern5_0) {
                        let pattern7_0 = C::value_type(ctx, pattern6_0);
                        if let Some(pattern8_0) = C::ty_32_or_64(ctx, pattern7_0) {
                            let pattern9_0 = C::inst_data(ctx, pattern5_0);
                            if let &InstructionData::Binary {
                                opcode: ref pattern10_0,
                                args: ref pattern10_1,
                            } = &pattern9_0
                            {
                                match pattern10_0 {
                                    &Opcode::Iadd => {
                                        let (pattern12_0, pattern12_1) =
                                            C::unpack_value_array_2(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::sinkable_load(ctx, pattern12_0)
                                        {
                                            if let Some(pattern14_0) = C::def_inst(ctx, pattern12_0)
                                            {
                                                let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                                if let &InstructionData::Load {
                                                    opcode: ref pattern16_0,
                                                    arg: pattern16_1,
                                                    flags: pattern16_2,
                                                    offset: pattern16_3,
                                                } = &pattern15_0
                                                {
                                                    if let &Opcode::Load = pattern16_0 {
                                                        if pattern4_1 == pattern16_1 {
                                                            if pattern2_2 == pattern16_2 {
                                                                if pattern2_3 == pattern16_3 {
                                                                    // Rule at src/isa/x64/lower.isle line 2686.
                                                                    let expr0_0 = C::sink_load(
                                                                        ctx,
                                                                        &pattern13_0,
                                                                    );
                                                                    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
                                                                    let expr2_0 =
                                                                        constructor_to_amode(
                                                                            ctx,
                                                                            pattern16_2,
                                                                            pattern16_1,
                                                                            pattern16_3,
                                                                        )?;
                                                                    let expr3_0 =
                                                                        constructor_put_in_gpr(
                                                                            ctx,
                                                                            pattern12_1,
                                                                        )?;
                                                                    let expr4_0 =
                                                                        constructor_x64_add_mem(
                                                                            ctx, pattern8_0,
                                                                            &expr2_0, expr3_0,
                                                                        )?;
                                                                    let expr5_0 =
                                                                        constructor_side_effect(
                                                                            ctx, &expr4_0,
                                                                        )?;
                                                                    return Some(expr5_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &Opcode::Band => {
                                        let (pattern12_0, pattern12_1) =
                                            C::unpack_value_array_2(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::sinkable_load(ctx, pattern12_0)
                                        {
                                            if let Some(pattern14_0) = C::def_inst(ctx, pattern12_0)
                                            {
                                                let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                                if let &InstructionData::Load {
                                                    opcode: ref pattern16_0,
                                                    arg: pattern16_1,
                                                    flags: pattern16_2,
                                                    offset: pattern16_3,
                                                } = &pattern15_0
                                                {
                                                    if let &Opcode::Load = pattern16_0 {
                                                        if pattern4_1 == pattern16_1 {
                                                            if pattern2_2 == pattern16_2 {
                                                                if pattern2_3 == pattern16_3 {
                                                                    // Rule at src/isa/x64/lower.isle line 2728.
                                                                    let expr0_0 = C::sink_load(
                                                                        ctx,
                                                                        &pattern13_0,
                                                                    );
                                                                    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
                                                                    let expr2_0 =
                                                                        constructor_to_amode(
                                                                            ctx,
                                                                            pattern16_2,
                                                                            pattern16_1,
                                                                            pattern16_3,
                                                                        )?;
                                                                    let expr3_0 =
                                                                        constructor_put_in_gpr(
                                                                            ctx,
                                                                            pattern12_1,
                                                                        )?;
                                                                    let expr4_0 =
                                                                        constructor_x64_and_mem(
                                                                            ctx, pattern8_0,
                                                                            &expr2_0, expr3_0,
                                                                        )?;
                                                                    let expr5_0 =
                                                                        constructor_side_effect(
                                                                            ctx, &expr4_0,
                                                                        )?;
                                                                    return Some(expr5_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &Opcode::Bor => {
                                        let (pattern12_0, pattern12_1) =
                                            C::unpack_value_array_2(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::sinkable_load(ctx, pattern12_0)
                                        {
                                            if let Some(pattern14_0) = C::def_inst(ctx, pattern12_0)
                                            {
                                                let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                                if let &InstructionData::Load {
                                                    opcode: ref pattern16_0,
                                                    arg: pattern16_1,
                                                    flags: pattern16_2,
                                                    offset: pattern16_3,
                                                } = &pattern15_0
                                                {
                                                    if let &Opcode::Load = pattern16_0 {
                                                        if pattern4_1 == pattern16_1 {
                                                            if pattern2_2 == pattern16_2 {
                                                                if pattern2_3 == pattern16_3 {
                                                                    // Rule at src/isa/x64/lower.isle line 2756.
                                                                    let expr0_0 = C::sink_load(
                                                                        ctx,
                                                                        &pattern13_0,
                                                                    );
                                                                    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
                                                                    let expr2_0 =
                                                                        constructor_to_amode(
                                                                            ctx,
                                                                            pattern16_2,
                                                                            pattern16_1,
                                                                            pattern16_3,
                                                                        )?;
                                                                    let expr3_0 =
                                                                        constructor_put_in_gpr(
                                                                            ctx,
                                                                            pattern12_1,
                                                                        )?;
                                                                    let expr4_0 =
                                                                        constructor_x64_or_mem(
                                                                            ctx, pattern8_0,
                                                                            &expr2_0, expr3_0,
                                                                        )?;
                                                                    let expr5_0 =
                                                                        constructor_side_effect(
                                                                            ctx, &expr4_0,
                                                                        )?;
                                                                    return Some(expr5_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &Opcode::Bxor => {
                                        let (pattern12_0, pattern12_1) =
                                            C::unpack_value_array_2(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::sinkable_load(ctx, pattern12_0)
                                        {
                                            if let Some(pattern14_0) = C::def_inst(ctx, pattern12_0)
                                            {
                                                let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                                if let &InstructionData::Load {
                                                    opcode: ref pattern16_0,
                                                    arg: pattern16_1,
                                                    flags: pattern16_2,
                                                    offset: pattern16_3,
                                                } = &pattern15_0
                                                {
                                                    if let &Opcode::Load = pattern16_0 {
                                                        if pattern4_1 == pattern16_1 {
                                                            if pattern2_2 == pattern16_2 {
                                                                if pattern2_3 == pattern16_3 {
                                                                    // Rule at src/isa/x64/lower.isle line 2784.
                                                                    let expr0_0 = C::sink_load(
                                                                        ctx,
                                                                        &pattern13_0,
                                                                    );
                                                                    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
                                                                    let expr2_0 =
                                                                        constructor_to_amode(
                                                                            ctx,
                                                                            pattern16_2,
                                                                            pattern16_1,
                                                                            pattern16_3,
                                                                        )?;
                                                                    let expr3_0 =
                                                                        constructor_put_in_gpr(
                                                                            ctx,
                                                                            pattern12_1,
                                                                        )?;
                                                                    let expr4_0 =
                                                                        constructor_x64_xor_mem(
                                                                            ctx, pattern8_0,
                                                                            &expr2_0, expr3_0,
                                                                        )?;
                                                                    let expr5_0 =
                                                                        constructor_side_effect(
                                                                            ctx, &expr4_0,
                                                                        )?;
                                                                    return Some(expr5_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I8 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::IntCompare {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
                cond: ref pattern5_2,
            } = &pattern4_0
            {
                if let &Opcode::Icmp = pattern5_0 {
                    let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                    if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                        let pattern9_0 = C::inst_data(ctx, pattern8_0);
                        if let &InstructionData::UnaryImm {
                            opcode: ref pattern10_0,
                            imm: pattern10_1,
                        } = &pattern9_0
                        {
                            if let &Opcode::Iconst = pattern10_0 {
                                let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                if pattern12_0 == 0i128 as u64 {
                                    let pattern14_0 = C::value_type(ctx, pattern7_1);
                                    if pattern14_0 == I32 {
                                        match pattern5_2 {
                                            &IntCC::SignedGreaterThan => {
                                                // Rule at src/isa/x64/lower.isle line 1532.
                                                let expr0_0: Type = I32;
                                                let expr1_0 =
                                                    constructor_put_in_gpr(ctx, pattern7_1)?;
                                                let expr2_0: u8 = 31i128 as u8;
                                                let expr3_0 = Imm8Reg::Imm8 { imm: expr2_0 };
                                                let expr4_0 =
                                                    C::imm8_reg_to_imm8_gpr(ctx, &expr3_0);
                                                let expr5_0 = constructor_x64_shr(
                                                    ctx, expr0_0, expr1_0, &expr4_0,
                                                )?;
                                                let expr6_0 = constructor_output_gpr(ctx, expr5_0)?;
                                                return Some(expr6_0);
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                // Rule at src/isa/x64/lower.isle line 1536.
                                                let expr0_0: Type = I32;
                                                let expr1_0: Type = I64;
                                                let expr2_0 =
                                                    constructor_put_in_gpr(ctx, pattern7_1)?;
                                                let expr3_0 =
                                                    constructor_x64_not(ctx, expr1_0, expr2_0)?;
                                                let expr4_0: u8 = 31i128 as u8;
                                                let expr5_0 = Imm8Reg::Imm8 { imm: expr4_0 };
                                                let expr6_0 =
                                                    C::imm8_reg_to_imm8_gpr(ctx, &expr5_0);
                                                let expr7_0 = constructor_x64_shr(
                                                    ctx, expr0_0, expr3_0, &expr6_0,
                                                )?;
                                                let expr8_0 = constructor_output_gpr(ctx, expr7_0)?;
                                                return Some(expr8_0);
                                            }
                                            _ => {}
                                        }
                                    }
                                    if pattern14_0 == I64 {
                                        match pattern5_2 {
                                            &IntCC::SignedGreaterThan => {
                                                // Rule at src/isa/x64/lower.isle line 1516.
                                                let expr0_0: Type = I64;
                                                let expr1_0 =
                                                    constructor_put_in_gpr(ctx, pattern7_1)?;
                                                let expr2_0: u8 = 63i128 as u8;
                                                let expr3_0 = Imm8Reg::Imm8 { imm: expr2_0 };
                                                let expr4_0 =
                                                    C::imm8_reg_to_imm8_gpr(ctx, &expr3_0);
                                                let expr5_0 = constructor_x64_shr(
                                                    ctx, expr0_0, expr1_0, &expr4_0,
                                                )?;
                                                let expr6_0 = constructor_output_gpr(ctx, expr5_0)?;
                                                return Some(expr6_0);
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                // Rule at src/isa/x64/lower.isle line 1520.
                                                let expr0_0: Type = I64;
                                                let expr1_0: Type = I64;
                                                let expr2_0 =
                                                    constructor_put_in_gpr(ctx, pattern7_1)?;
                                                let expr3_0 =
                                                    constructor_x64_not(ctx, expr1_0, expr2_0)?;
                                                let expr4_0: u8 = 63i128 as u8;
                                                let expr5_0 = Imm8Reg::Imm8 { imm: expr4_0 };
                                                let expr6_0 =
                                                    C::imm8_reg_to_imm8_gpr(ctx, &expr5_0);
                                                let expr7_0 = constructor_x64_shr(
                                                    ctx, expr0_0, expr3_0, &expr6_0,
                                                )?;
                                                let expr8_0 = constructor_output_gpr(ctx, expr7_0)?;
                                                return Some(expr8_0);
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                    }
                    let pattern8_0 = C::value_type(ctx, pattern7_0);
                    if pattern8_0 == I32 {
                        if let Some(pattern10_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern11_0 = C::inst_data(ctx, pattern10_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern12_0,
                                imm: pattern12_1,
                            } = &pattern11_0
                            {
                                if let &Opcode::Iconst = pattern12_0 {
                                    let pattern14_0 = C::u64_from_imm64(ctx, pattern12_1);
                                    if pattern14_0 == 0i128 as u64 {
                                        match pattern5_2 {
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                // Rule at src/isa/x64/lower.isle line 1540.
                                                let expr0_0: Type = I32;
                                                let expr1_0: Type = I64;
                                                let expr2_0 =
                                                    constructor_put_in_gpr(ctx, pattern7_0)?;
                                                let expr3_0 =
                                                    constructor_x64_not(ctx, expr1_0, expr2_0)?;
                                                let expr4_0: u8 = 31i128 as u8;
                                                let expr5_0 = Imm8Reg::Imm8 { imm: expr4_0 };
                                                let expr6_0 =
                                                    C::imm8_reg_to_imm8_gpr(ctx, &expr5_0);
                                                let expr7_0 = constructor_x64_shr(
                                                    ctx, expr0_0, expr3_0, &expr6_0,
                                                )?;
                                                let expr8_0 = constructor_output_gpr(ctx, expr7_0)?;
                                                return Some(expr8_0);
                                            }
                                            &IntCC::SignedLessThan => {
                                                // Rule at src/isa/x64/lower.isle line 1528.
                                                let expr0_0: Type = I32;
                                                let expr1_0 =
                                                    constructor_put_in_gpr(ctx, pattern7_0)?;
                                                let expr2_0: u8 = 31i128 as u8;
                                                let expr3_0 = Imm8Reg::Imm8 { imm: expr2_0 };
                                                let expr4_0 =
                                                    C::imm8_reg_to_imm8_gpr(ctx, &expr3_0);
                                                let expr5_0 = constructor_x64_shr(
                                                    ctx, expr0_0, expr1_0, &expr4_0,
                                                )?;
                                                let expr6_0 = constructor_output_gpr(ctx, expr5_0)?;
                                                return Some(expr6_0);
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if pattern8_0 == I64 {
                        if let Some(pattern10_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern11_0 = C::inst_data(ctx, pattern10_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern12_0,
                                imm: pattern12_1,
                            } = &pattern11_0
                            {
                                if let &Opcode::Iconst = pattern12_0 {
                                    let pattern14_0 = C::u64_from_imm64(ctx, pattern12_1);
                                    if pattern14_0 == 0i128 as u64 {
                                        match pattern5_2 {
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                // Rule at src/isa/x64/lower.isle line 1524.
                                                let expr0_0: Type = I64;
                                                let expr1_0: Type = I64;
                                                let expr2_0 =
                                                    constructor_put_in_gpr(ctx, pattern7_0)?;
                                                let expr3_0 =
                                                    constructor_x64_not(ctx, expr1_0, expr2_0)?;
                                                let expr4_0: u8 = 63i128 as u8;
                                                let expr5_0 = Imm8Reg::Imm8 { imm: expr4_0 };
                                                let expr6_0 =
                                                    C::imm8_reg_to_imm8_gpr(ctx, &expr5_0);
                                                let expr7_0 = constructor_x64_shr(
                                                    ctx, expr0_0, expr3_0, &expr6_0,
                                                )?;
                                                let expr8_0 = constructor_output_gpr(ctx, expr7_0)?;
                                                return Some(expr8_0);
                                            }
                                            &IntCC::SignedLessThan => {
                                                // Rule at src/isa/x64/lower.isle line 1512.
                                                let expr0_0: Type = I64;
                                                let expr1_0 =
                                                    constructor_put_in_gpr(ctx, pattern7_0)?;
                                                let expr2_0: u8 = 63i128 as u8;
                                                let expr3_0 = Imm8Reg::Imm8 { imm: expr2_0 };
                                                let expr4_0 =
                                                    C::imm8_reg_to_imm8_gpr(ctx, &expr3_0);
                                                let expr5_0 = constructor_x64_shr(
                                                    ctx, expr0_0, expr1_0, &expr4_0,
                                                )?;
                                                let expr6_0 = constructor_output_gpr(ctx, expr5_0)?;
                                                return Some(expr6_0);
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Imul = pattern5_0 {
                    let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                    // Rule at src/isa/x64/lower.isle line 881.
                    let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                    let expr1_0: usize = 0i128 as usize;
                    let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                    let expr3_0: usize = 1i128 as usize;
                    let expr4_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr3_0)?;
                    let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                    let expr6_0: usize = 0i128 as usize;
                    let expr7_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr6_0)?;
                    let expr8_0: usize = 1i128 as usize;
                    let expr9_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr8_0)?;
                    let expr10_0: Type = I64;
                    let expr11_0 = C::gpr_to_gpr_mem_imm(ctx, expr9_0);
                    let expr12_0 = constructor_x64_mul(ctx, expr10_0, expr2_0, &expr11_0)?;
                    let expr13_0: Type = I64;
                    let expr14_0 = C::gpr_to_gpr_mem_imm(ctx, expr7_0);
                    let expr15_0 = constructor_x64_mul(ctx, expr13_0, expr4_0, &expr14_0)?;
                    let expr16_0: Type = I64;
                    let expr17_0 = C::gpr_to_gpr_mem_imm(ctx, expr15_0);
                    let expr18_0 = constructor_x64_add(ctx, expr16_0, expr12_0, &expr17_0)?;
                    let expr19_0: Type = I64;
                    let expr20_0 = C::gpr_to_gpr_mem(ctx, expr7_0);
                    let expr21_0 = constructor_mulhi_u(ctx, expr19_0, expr2_0, &expr20_0)?;
                    let expr22_0: usize = 0i128 as usize;
                    let expr23_0 = constructor_value_regs_get_gpr(ctx, expr21_0, expr22_0)?;
                    let expr24_0: usize = 1i128 as usize;
                    let expr25_0 = constructor_value_regs_get_gpr(ctx, expr21_0, expr24_0)?;
                    let expr26_0: Type = I64;
                    let expr27_0 = C::gpr_to_gpr_mem_imm(ctx, expr25_0);
                    let expr28_0 = constructor_x64_add(ctx, expr26_0, expr18_0, &expr27_0)?;
                    let expr29_0 = constructor_value_gprs(ctx, expr23_0, expr28_0)?;
                    let expr30_0 = C::output(ctx, expr29_0);
                    return Some(expr30_0);
                }
            }
        }
        if pattern2_0 == F32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::FcvtFromSint = pattern5_0 {
                    let pattern7_0 = C::value_type(ctx, pattern5_1);
                    if pattern7_0 == I8 {
                        // Rule at src/isa/x64/lower.isle line 2970.
                        let expr0_0: Type = I32;
                        let expr1_0: Type = I32;
                        let expr2_0 = ExtendKind::Sign;
                        let expr3_0 =
                            constructor_extend_to_gpr(ctx, pattern5_1, expr1_0, &expr2_0)?;
                        let expr4_0 = C::gpr_to_gpr_mem(ctx, expr3_0);
                        let expr5_0 = constructor_x64_cvtsi2ss(ctx, expr0_0, &expr4_0)?;
                        let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                    if pattern7_0 == I16 {
                        // Rule at src/isa/x64/lower.isle line 2973.
                        let expr0_0: Type = I32;
                        let expr1_0: Type = I32;
                        let expr2_0 = ExtendKind::Sign;
                        let expr3_0 =
                            constructor_extend_to_gpr(ctx, pattern5_1, expr1_0, &expr2_0)?;
                        let expr4_0 = C::gpr_to_gpr_mem(ctx, expr3_0);
                        let expr5_0 = constructor_x64_cvtsi2ss(ctx, expr0_0, &expr4_0)?;
                        let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                }
            }
        }
        if pattern2_0 == F64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::FcvtFromSint = pattern5_0 {
                    let pattern7_0 = C::value_type(ctx, pattern5_1);
                    if pattern7_0 == I8 {
                        // Rule at src/isa/x64/lower.isle line 2979.
                        let expr0_0: Type = I32;
                        let expr1_0: Type = I32;
                        let expr2_0 = ExtendKind::Sign;
                        let expr3_0 =
                            constructor_extend_to_gpr(ctx, pattern5_1, expr1_0, &expr2_0)?;
                        let expr4_0 = C::gpr_to_gpr_mem(ctx, expr3_0);
                        let expr5_0 = constructor_x64_cvtsi2sd(ctx, expr0_0, &expr4_0)?;
                        let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                    if pattern7_0 == I16 {
                        // Rule at src/isa/x64/lower.isle line 2982.
                        let expr0_0: Type = I32;
                        let expr1_0: Type = I32;
                        let expr2_0 = ExtendKind::Sign;
                        let expr3_0 =
                            constructor_extend_to_gpr(ctx, pattern5_1, expr1_0, &expr2_0)?;
                        let expr4_0 = C::gpr_to_gpr_mem(ctx, expr3_0);
                        let expr5_0 = constructor_x64_cvtsi2sd(ctx, expr0_0, &expr4_0)?;
                        let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::IaddIfcout = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::simm32_from_value(ctx, pattern7_0) {
                            // Rule at src/isa/x64/lower.isle line 152.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr1_0 =
                                constructor_x64_add(ctx, pattern3_0, expr0_0, &pattern8_0)?;
                            let expr2_0 = C::gpr_to_reg(ctx, expr1_0);
                            let expr3_0 = constructor_output_ifcout(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                &InstructionData::IntAddTrap {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    code: ref pattern5_2,
                } => {
                    if let &Opcode::UaddOverflowTrap = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::simm32_from_value(ctx, pattern7_0) {
                            // Rule at src/isa/x64/lower.isle line 1472.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr1_0 = constructor_x64_add_with_flags_paired(
                                ctx,
                                pattern3_0,
                                expr0_0,
                                &pattern8_0,
                            )?;
                            let expr2_0 = CC::B;
                            let expr3_0 = constructor_trap_if(ctx, &expr2_0, pattern5_2)?;
                            let expr4_0 = constructor_with_flags(ctx, &expr1_0, &expr3_0)?;
                            let expr5_0 = C::output(ctx, expr4_0);
                            return Some(expr5_0);
                        }
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::ty_32_or_64(ctx, pattern2_0) {
            let pattern4_0 = C::use_lzcnt(ctx, pattern2_0);
            if pattern4_0 == true {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Unary {
                    opcode: ref pattern7_0,
                    arg: pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Clz = pattern7_0 {
                        // Rule at src/isa/x64/lower.isle line 1785.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                        let expr1_0 = constructor_x64_lzcnt(ctx, pattern3_0, expr0_0)?;
                        let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
            }
            if pattern4_0 == false {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Unary {
                    opcode: ref pattern7_0,
                    arg: pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Clz = pattern7_0 {
                        // Rule at src/isa/x64/lower.isle line 1792.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                        let expr1_0 = constructor_do_clz(ctx, pattern3_0, pattern3_0, expr0_0)?;
                        let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
            }
            let pattern4_0 = C::use_bmi1(ctx, pattern2_0);
            if pattern4_0 == true {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Unary {
                    opcode: ref pattern7_0,
                    arg: pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Ctz = pattern7_0 {
                        // Rule at src/isa/x64/lower.isle line 1829.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                        let expr1_0 = constructor_x64_tzcnt(ctx, pattern3_0, expr0_0)?;
                        let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
            }
            if pattern4_0 == false {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Unary {
                    opcode: ref pattern7_0,
                    arg: pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Ctz = pattern7_0 {
                        // Rule at src/isa/x64/lower.isle line 1836.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                        let expr1_0 = constructor_do_ctz(ctx, pattern3_0, pattern3_0, expr0_0)?;
                        let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
            }
        }
        if let Some(pattern3_0) = C::ty_8_or_16(ctx, pattern2_0) {
            let pattern4_0 = C::use_popcnt(ctx, pattern2_0);
            if pattern4_0 == true {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Unary {
                    opcode: ref pattern7_0,
                    arg: pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Popcnt = pattern7_0 {
                        // Rule at src/isa/x64/lower.isle line 1874.
                        let expr0_0: Type = I32;
                        let expr1_0: Type = I32;
                        let expr2_0 = ExtendKind::Zero;
                        let expr3_0 =
                            constructor_extend_to_gpr(ctx, pattern7_1, expr1_0, &expr2_0)?;
                        let expr4_0 = constructor_x64_popcnt(ctx, expr0_0, expr3_0)?;
                        let expr5_0 = constructor_output_gpr(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                }
            }
        }
        if let Some(pattern3_0) = C::ty_scalar_float(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::BinaryImm8 {
                opcode: ref pattern5_0,
                arg: pattern5_1,
                imm: pattern5_2,
            } = &pattern4_0
            {
                if let &Opcode::Extractlane = pattern5_0 {
                    let pattern7_0 = C::u8_from_uimm8(ctx, pattern5_2);
                    if pattern7_0 == 0i128 as u8 {
                        // Rule at src/isa/x64/lower.isle line 3571.
                        let expr0_0 = constructor_output_value(ctx, pattern5_1)?;
                        return Some(expr0_0);
                    }
                }
            }
        }
        if let Some(pattern3_0) = C::type_register_class(ctx, pattern2_0) {
            if let &RegisterClass::Xmm = &pattern3_0 {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::LoadNoOffset {
                    opcode: ref pattern6_0,
                    arg: pattern6_1,
                    flags: pattern6_2,
                } = &pattern5_0
                {
                    if let &Opcode::Bitcast = pattern6_0 {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if let Some(pattern9_0) = C::type_register_class(ctx, pattern8_0) {
                            if let &RegisterClass::Xmm = &pattern9_0 {
                                // Rule at src/isa/x64/lower.isle line 3347.
                                let expr0_0 = constructor_output_value(ctx, pattern6_1)?;
                                return Some(expr0_0);
                            }
                        }
                    }
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        if let &InstructionData::Binary {
            opcode: ref pattern4_0,
            args: ref pattern4_1,
        } = &pattern3_0
        {
            match pattern4_0 {
                &Opcode::Band => {
                    let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::sinkable_load(ctx, pattern6_0) {
                        let mut closure8 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern8_0) = closure8() {
                            // Rule at src/isa/x64/lower.isle line 256.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_1)?;
                            let expr1_0 = constructor_sink_load_to_gpr_mem_imm(ctx, &pattern7_0)?;
                            let expr2_0 = constructor_x64_and(ctx, pattern2_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                &Opcode::Bor => {
                    let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::sinkable_load(ctx, pattern6_0) {
                        let mut closure8 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern8_0) = closure8() {
                            // Rule at src/isa/x64/lower.isle line 318.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_1)?;
                            let expr1_0 = constructor_sink_load_to_gpr_mem_imm(ctx, &pattern7_0)?;
                            let expr2_0 = constructor_x64_or(ctx, pattern2_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                &Opcode::Bxor => {
                    let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::sinkable_load(ctx, pattern6_0) {
                        let mut closure8 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern8_0) = closure8() {
                            // Rule at src/isa/x64/lower.isle line 381.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_1)?;
                            let expr1_0 = constructor_sink_load_to_gpr_mem_imm(ctx, &pattern7_0)?;
                            let expr2_0 = constructor_x64_xor(ctx, pattern2_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                _ => {}
            }
        }
        let pattern3_0 = C::avx512vl_enabled(ctx, pattern2_0);
        if pattern3_0 == true {
            let pattern5_0 = C::avx512f_enabled(ctx, pattern2_0);
            if pattern5_0 == true {
                if pattern2_0 == F32X4 {
                    let pattern8_0 = C::inst_data(ctx, pattern0_0);
                    if let &InstructionData::Unary {
                        opcode: ref pattern9_0,
                        arg: pattern9_1,
                    } = &pattern8_0
                    {
                        if let &Opcode::FcvtFromUint = pattern9_0 {
                            // Rule at src/isa/x64/lower.isle line 3019.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                            let expr1_0 = constructor_x64_vcvtudq2ps(ctx, &expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
            }
            let pattern5_0 = C::avx512vbmi_enabled(ctx, pattern2_0);
            if pattern5_0 == true {
                let pattern7_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Shuffle {
                    opcode: ref pattern8_0,
                    args: ref pattern8_1,
                    imm: pattern8_2,
                } = &pattern7_0
                {
                    if let &Opcode::Shuffle = pattern8_0 {
                        let (pattern10_0, pattern10_1) = C::unpack_value_array_2(ctx, pattern8_1);
                        if let Some(pattern11_0) = C::vec_mask_from_immediate(ctx, pattern8_2) {
                            if let Some((pattern12_0, pattern12_1)) =
                                C::perm_from_mask_with_zeros(ctx, &pattern11_0)
                            {
                                // Rule at src/isa/x64/lower.isle line 3531.
                                let expr0_0: Type = I8X16;
                                let expr1_0 =
                                    constructor_x64_xmm_load_const(ctx, expr0_0, pattern12_1)?;
                                let expr2_0 = constructor_put_in_xmm(ctx, pattern10_1)?;
                                let expr3_0 = constructor_put_in_xmm(ctx, pattern10_0)?;
                                let expr4_0: Type = I8X16;
                                let expr5_0 =
                                    constructor_x64_xmm_load_const(ctx, expr4_0, pattern12_0)?;
                                let expr6_0 =
                                    constructor_x64_vpermi2b(ctx, expr2_0, expr3_0, expr5_0)?;
                                let expr7_0 = C::xmm_to_xmm_mem(ctx, expr6_0);
                                let expr8_0 = constructor_x64_andps(ctx, expr1_0, &expr7_0)?;
                                let expr9_0 = constructor_output_xmm(ctx, expr8_0)?;
                                return Some(expr9_0);
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::Unary {
            opcode: ref pattern2_0,
            arg: pattern2_1,
        } => {
            if let &Opcode::ScalarToVector = pattern2_0 {
                if let Some(pattern4_0) = C::sinkable_load(ctx, pattern2_1) {
                    let pattern5_0 = C::value_type(ctx, pattern2_1);
                    if let Some(pattern6_0) = C::ty_32(ctx, pattern5_0) {
                        // Rule at src/isa/x64/lower.isle line 3613.
                        let expr0_0 = constructor_sink_load_to_xmm_mem(ctx, &pattern4_0)?;
                        let expr1_0 = constructor_x64_movss_load(ctx, &expr0_0)?;
                        let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
            }
        }
        &InstructionData::Store {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            if let &Opcode::Store = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::def_inst(ctx, pattern4_0) {
                    if let Some(pattern6_0) = C::first_result(ctx, pattern5_0) {
                        let pattern7_0 = C::value_type(ctx, pattern6_0);
                        if let Some(pattern8_0) = C::ty_32_or_64(ctx, pattern7_0) {
                            let pattern9_0 = C::inst_data(ctx, pattern5_0);
                            if let &InstructionData::Binary {
                                opcode: ref pattern10_0,
                                args: ref pattern10_1,
                            } = &pattern9_0
                            {
                                match pattern10_0 {
                                    &Opcode::Iadd => {
                                        let (pattern12_0, pattern12_1) =
                                            C::unpack_value_array_2(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::sinkable_load(ctx, pattern12_1)
                                        {
                                            if let Some(pattern14_0) = C::def_inst(ctx, pattern12_1)
                                            {
                                                let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                                if let &InstructionData::Load {
                                                    opcode: ref pattern16_0,
                                                    arg: pattern16_1,
                                                    flags: pattern16_2,
                                                    offset: pattern16_3,
                                                } = &pattern15_0
                                                {
                                                    if let &Opcode::Load = pattern16_0 {
                                                        if pattern4_1 == pattern16_1 {
                                                            if pattern2_2 == pattern16_2 {
                                                                if pattern2_3 == pattern16_3 {
                                                                    // Rule at src/isa/x64/lower.isle line 2700.
                                                                    let expr0_0 = C::sink_load(
                                                                        ctx,
                                                                        &pattern13_0,
                                                                    );
                                                                    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
                                                                    let expr2_0 =
                                                                        constructor_to_amode(
                                                                            ctx,
                                                                            pattern16_2,
                                                                            pattern16_1,
                                                                            pattern16_3,
                                                                        )?;
                                                                    let expr3_0 =
                                                                        constructor_put_in_gpr(
                                                                            ctx,
                                                                            pattern12_0,
                                                                        )?;
                                                                    let expr4_0 =
                                                                        constructor_x64_add_mem(
                                                                            ctx, pattern8_0,
                                                                            &expr2_0, expr3_0,
                                                                        )?;
                                                                    let expr5_0 =
                                                                        constructor_side_effect(
                                                                            ctx, &expr4_0,
                                                                        )?;
                                                                    return Some(expr5_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &Opcode::Isub => {
                                        let (pattern12_0, pattern12_1) =
                                            C::unpack_value_array_2(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::sinkable_load(ctx, pattern12_0)
                                        {
                                            if let Some(pattern14_0) = C::def_inst(ctx, pattern12_0)
                                            {
                                                let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                                if let &InstructionData::Load {
                                                    opcode: ref pattern16_0,
                                                    arg: pattern16_1,
                                                    flags: pattern16_2,
                                                    offset: pattern16_3,
                                                } = &pattern15_0
                                                {
                                                    if let &Opcode::Load = pattern16_0 {
                                                        if pattern4_1 == pattern16_1 {
                                                            if pattern2_2 == pattern16_2 {
                                                                if pattern2_3 == pattern16_3 {
                                                                    // Rule at src/isa/x64/lower.isle line 2714.
                                                                    let expr0_0 = C::sink_load(
                                                                        ctx,
                                                                        &pattern13_0,
                                                                    );
                                                                    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
                                                                    let expr2_0 =
                                                                        constructor_to_amode(
                                                                            ctx,
                                                                            pattern16_2,
                                                                            pattern16_1,
                                                                            pattern16_3,
                                                                        )?;
                                                                    let expr3_0 =
                                                                        constructor_put_in_gpr(
                                                                            ctx,
                                                                            pattern12_1,
                                                                        )?;
                                                                    let expr4_0 =
                                                                        constructor_x64_sub_mem(
                                                                            ctx, pattern8_0,
                                                                            &expr2_0, expr3_0,
                                                                        )?;
                                                                    let expr5_0 =
                                                                        constructor_side_effect(
                                                                            ctx, &expr4_0,
                                                                        )?;
                                                                    return Some(expr5_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &Opcode::Band => {
                                        let (pattern12_0, pattern12_1) =
                                            C::unpack_value_array_2(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::sinkable_load(ctx, pattern12_1)
                                        {
                                            if let Some(pattern14_0) = C::def_inst(ctx, pattern12_1)
                                            {
                                                let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                                if let &InstructionData::Load {
                                                    opcode: ref pattern16_0,
                                                    arg: pattern16_1,
                                                    flags: pattern16_2,
                                                    offset: pattern16_3,
                                                } = &pattern15_0
                                                {
                                                    if let &Opcode::Load = pattern16_0 {
                                                        if pattern4_1 == pattern16_1 {
                                                            if pattern2_2 == pattern16_2 {
                                                                if pattern2_3 == pattern16_3 {
                                                                    // Rule at src/isa/x64/lower.isle line 2742.
                                                                    let expr0_0 = C::sink_load(
                                                                        ctx,
                                                                        &pattern13_0,
                                                                    );
                                                                    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
                                                                    let expr2_0 =
                                                                        constructor_to_amode(
                                                                            ctx,
                                                                            pattern16_2,
                                                                            pattern16_1,
                                                                            pattern16_3,
                                                                        )?;
                                                                    let expr3_0 =
                                                                        constructor_put_in_gpr(
                                                                            ctx,
                                                                            pattern12_0,
                                                                        )?;
                                                                    let expr4_0 =
                                                                        constructor_x64_and_mem(
                                                                            ctx, pattern8_0,
                                                                            &expr2_0, expr3_0,
                                                                        )?;
                                                                    let expr5_0 =
                                                                        constructor_side_effect(
                                                                            ctx, &expr4_0,
                                                                        )?;
                                                                    return Some(expr5_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &Opcode::Bor => {
                                        let (pattern12_0, pattern12_1) =
                                            C::unpack_value_array_2(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::sinkable_load(ctx, pattern12_1)
                                        {
                                            if let Some(pattern14_0) = C::def_inst(ctx, pattern12_1)
                                            {
                                                let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                                if let &InstructionData::Load {
                                                    opcode: ref pattern16_0,
                                                    arg: pattern16_1,
                                                    flags: pattern16_2,
                                                    offset: pattern16_3,
                                                } = &pattern15_0
                                                {
                                                    if let &Opcode::Load = pattern16_0 {
                                                        if pattern4_1 == pattern16_1 {
                                                            if pattern2_2 == pattern16_2 {
                                                                if pattern2_3 == pattern16_3 {
                                                                    // Rule at src/isa/x64/lower.isle line 2770.
                                                                    let expr0_0 = C::sink_load(
                                                                        ctx,
                                                                        &pattern13_0,
                                                                    );
                                                                    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
                                                                    let expr2_0 =
                                                                        constructor_to_amode(
                                                                            ctx,
                                                                            pattern16_2,
                                                                            pattern16_1,
                                                                            pattern16_3,
                                                                        )?;
                                                                    let expr3_0 =
                                                                        constructor_put_in_gpr(
                                                                            ctx,
                                                                            pattern12_0,
                                                                        )?;
                                                                    let expr4_0 =
                                                                        constructor_x64_or_mem(
                                                                            ctx, pattern8_0,
                                                                            &expr2_0, expr3_0,
                                                                        )?;
                                                                    let expr5_0 =
                                                                        constructor_side_effect(
                                                                            ctx, &expr4_0,
                                                                        )?;
                                                                    return Some(expr5_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &Opcode::Bxor => {
                                        let (pattern12_0, pattern12_1) =
                                            C::unpack_value_array_2(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::sinkable_load(ctx, pattern12_1)
                                        {
                                            if let Some(pattern14_0) = C::def_inst(ctx, pattern12_1)
                                            {
                                                let pattern15_0 = C::inst_data(ctx, pattern14_0);
                                                if let &InstructionData::Load {
                                                    opcode: ref pattern16_0,
                                                    arg: pattern16_1,
                                                    flags: pattern16_2,
                                                    offset: pattern16_3,
                                                } = &pattern15_0
                                                {
                                                    if let &Opcode::Load = pattern16_0 {
                                                        if pattern4_1 == pattern16_1 {
                                                            if pattern2_2 == pattern16_2 {
                                                                if pattern2_3 == pattern16_3 {
                                                                    // Rule at src/isa/x64/lower.isle line 2798.
                                                                    let expr0_0 = C::sink_load(
                                                                        ctx,
                                                                        &pattern13_0,
                                                                    );
                                                                    let expr1_0 = constructor_reg_mem_to_reg_mem_imm(ctx, &expr0_0)?;
                                                                    let expr2_0 =
                                                                        constructor_to_amode(
                                                                            ctx,
                                                                            pattern16_2,
                                                                            pattern16_1,
                                                                            pattern16_3,
                                                                        )?;
                                                                    let expr3_0 =
                                                                        constructor_put_in_gpr(
                                                                            ctx,
                                                                            pattern12_0,
                                                                        )?;
                                                                    let expr4_0 =
                                                                        constructor_x64_xor_mem(
                                                                            ctx, pattern8_0,
                                                                            &expr2_0, expr3_0,
                                                                        )?;
                                                                    let expr5_0 =
                                                                        constructor_side_effect(
                                                                            ctx, &expr4_0,
                                                                        )?;
                                                                    return Some(expr5_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::LoadNoOffset {
                opcode: ref pattern5_0,
                arg: pattern5_1,
                flags: pattern5_2,
            } = &pattern4_0
            {
                if let &Opcode::AtomicLoad = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 2835.
                    let expr0_0 = C::zero_offset(ctx);
                    let expr1_0 = constructor_to_amode(ctx, pattern5_2, pattern5_1, expr0_0)?;
                    let expr2_0 = constructor_x64_mov(ctx, &expr1_0)?;
                    let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                    return Some(expr3_0);
                }
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::UnaryImm {
                    opcode: ref pattern5_0,
                    imm: pattern5_1,
                } => {
                    if let &Opcode::Iconst = pattern5_0 {
                        let pattern7_0 = C::u64_from_imm64(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 20.
                        let expr0_0: Type = I64;
                        let expr1_0 = constructor_imm(ctx, expr0_0, pattern7_0)?;
                        let expr2_0: Type = I64;
                        let expr3_0: u64 = 0i128 as u64;
                        let expr4_0 = constructor_imm(ctx, expr2_0, expr3_0)?;
                        let expr5_0 = C::value_regs(ctx, expr1_0, expr4_0);
                        let expr6_0 = C::output(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Iadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 92.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                            let expr3_0: usize = 1i128 as usize;
                            let expr4_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr3_0)?;
                            let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr6_0: usize = 0i128 as usize;
                            let expr7_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr6_0)?;
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr8_0)?;
                            let expr10_0: Type = I64;
                            let expr11_0 = C::gpr_to_gpr_mem_imm(ctx, expr7_0);
                            let expr12_0 = constructor_x64_add_with_flags_paired(
                                ctx, expr10_0, expr2_0, &expr11_0,
                            )?;
                            let expr13_0: Type = I64;
                            let expr14_0 = C::gpr_to_gpr_mem_imm(ctx, expr9_0);
                            let expr15_0 =
                                constructor_x64_adc_paired(ctx, expr13_0, expr4_0, &expr14_0)?;
                            let expr16_0 = constructor_with_flags(ctx, &expr12_0, &expr15_0)?;
                            let expr17_0 = C::output(ctx, expr16_0);
                            return Some(expr17_0);
                        }
                        &Opcode::Isub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 207.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                            let expr3_0: usize = 1i128 as usize;
                            let expr4_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr3_0)?;
                            let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr6_0: usize = 0i128 as usize;
                            let expr7_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr6_0)?;
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = constructor_value_regs_get_gpr(ctx, expr5_0, expr8_0)?;
                            let expr10_0: Type = I64;
                            let expr11_0 = C::gpr_to_gpr_mem_imm(ctx, expr7_0);
                            let expr12_0 = constructor_x64_sub_with_flags_paired(
                                ctx, expr10_0, expr2_0, &expr11_0,
                            )?;
                            let expr13_0: Type = I64;
                            let expr14_0 = C::gpr_to_gpr_mem_imm(ctx, expr9_0);
                            let expr15_0 =
                                constructor_x64_sbb_paired(ctx, expr13_0, expr4_0, &expr14_0)?;
                            let expr16_0 = constructor_with_flags(ctx, &expr12_0, &expr15_0)?;
                            let expr17_0 = C::output(ctx, expr16_0);
                            return Some(expr17_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
            let pattern4_0 = C::use_popcnt(ctx, pattern2_0);
            if pattern4_0 == true {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Unary {
                    opcode: ref pattern7_0,
                    arg: pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Popcnt = pattern7_0 {
                        // Rule at src/isa/x64/lower.isle line 1881.
                        let expr0_0: Type = I64;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0: usize = 0i128 as usize;
                        let expr3_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_x64_popcnt(ctx, expr0_0, expr3_0)?;
                        let expr5_0: Type = I64;
                        let expr6_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr7_0: usize = 1i128 as usize;
                        let expr8_0 = constructor_value_regs_get_gpr(ctx, expr6_0, expr7_0)?;
                        let expr9_0 = constructor_x64_popcnt(ctx, expr5_0, expr8_0)?;
                        let expr10_0: Type = I64;
                        let expr11_0 = C::gpr_to_gpr_mem_imm(ctx, expr9_0);
                        let expr12_0 = constructor_x64_add(ctx, expr10_0, expr4_0, &expr11_0)?;
                        let expr13_0 = C::gpr_to_reg(ctx, expr12_0);
                        let expr14_0: Type = I64;
                        let expr15_0: u64 = 0i128 as u64;
                        let expr16_0 = constructor_imm(ctx, expr14_0, expr15_0)?;
                        let expr17_0 = C::value_regs(ctx, expr13_0, expr16_0);
                        let expr18_0 = C::output(ctx, expr17_0);
                        return Some(expr18_0);
                    }
                }
            }
        }
        if pattern2_0 == F32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::FcvtFromUint => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::fits_in_32(ctx, pattern7_0) {
                                if let Some(pattern9_0) = C::ty_int(ctx, pattern8_0) {
                                    // Rule at src/isa/x64/lower.isle line 2998.
                                    let expr0_0: Type = I64;
                                    let expr1_0: Type = I64;
                                    let expr2_0 = ExtendKind::Zero;
                                    let expr3_0 = constructor_extend_to_gpr(
                                        ctx, pattern5_1, expr1_0, &expr2_0,
                                    )?;
                                    let expr4_0 = C::gpr_to_gpr_mem(ctx, expr3_0);
                                    let expr5_0 = constructor_x64_cvtsi2ss(ctx, expr0_0, &expr4_0)?;
                                    let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                                    return Some(expr6_0);
                                }
                            }
                        }
                        &Opcode::FcvtFromSint => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::ty_int(ctx, pattern7_0) {
                                if let Some(pattern9_0) = C::fits_in_64(ctx, pattern8_0) {
                                    // Rule at src/isa/x64/lower.isle line 2976.
                                    let expr0_0 = constructor_put_in_gpr_mem(ctx, pattern5_1)?;
                                    let expr1_0 =
                                        constructor_x64_cvtsi2ss(ctx, pattern9_0, &expr0_0)?;
                                    let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                    return Some(expr2_0);
                                }
                            }
                        }
                        _ => {}
                    }
                }
                &InstructionData::BinaryImm8 {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    imm: pattern5_2,
                } => {
                    if let &Opcode::Extractlane = pattern5_0 {
                        let pattern7_0 = C::value_type(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::ty_vec128(ctx, pattern7_0) {
                            let pattern9_0 = C::u8_from_uimm8(ctx, pattern5_2);
                            // Rule at src/isa/x64/lower.isle line 3575.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                            let expr1_0 = OperandSize::Size32;
                            let expr2_0 =
                                constructor_x64_pshufd(ctx, &expr0_0, pattern9_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::FcvtFromUint => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::fits_in_32(ctx, pattern7_0) {
                                if let Some(pattern9_0) = C::ty_int(ctx, pattern8_0) {
                                    // Rule at src/isa/x64/lower.isle line 3001.
                                    let expr0_0: Type = I64;
                                    let expr1_0: Type = I64;
                                    let expr2_0 = ExtendKind::Zero;
                                    let expr3_0 = constructor_extend_to_gpr(
                                        ctx, pattern5_1, expr1_0, &expr2_0,
                                    )?;
                                    let expr4_0 = C::gpr_to_gpr_mem(ctx, expr3_0);
                                    let expr5_0 = constructor_x64_cvtsi2sd(ctx, expr0_0, &expr4_0)?;
                                    let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                                    return Some(expr6_0);
                                }
                            }
                        }
                        &Opcode::FcvtFromSint => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::ty_int(ctx, pattern7_0) {
                                if let Some(pattern9_0) = C::fits_in_64(ctx, pattern8_0) {
                                    // Rule at src/isa/x64/lower.isle line 2985.
                                    let expr0_0 = constructor_put_in_gpr_mem(ctx, pattern5_1)?;
                                    let expr1_0 =
                                        constructor_x64_cvtsi2sd(ctx, pattern9_0, &expr0_0)?;
                                    let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                    return Some(expr2_0);
                                }
                            }
                        }
                        _ => {}
                    }
                }
                &InstructionData::BinaryImm8 {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    imm: pattern5_2,
                } => {
                    if let &Opcode::Extractlane = pattern5_0 {
                        let pattern7_0 = C::value_type(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::ty_vec128(ctx, pattern7_0) {
                            let pattern9_0 = C::u8_from_uimm8(ctx, pattern5_2);
                            if pattern9_0 == 1i128 as u8 {
                                // Rule at src/isa/x64/lower.isle line 3580.
                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                                let expr1_0: u8 = 238i128 as u8;
                                let expr2_0 = OperandSize::Size32;
                                let expr3_0 =
                                    constructor_x64_pshufd(ctx, &expr0_0, expr1_0, &expr2_0)?;
                                let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                                return Some(expr4_0);
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == I8X16 {
            let pattern4_0 = C::avx512vl_enabled(ctx, pattern2_0);
            if pattern4_0 == true {
                let pattern6_0 = C::avx512bitalg_enabled(ctx, pattern2_0);
                if pattern6_0 == true {
                    let pattern8_0 = C::inst_data(ctx, pattern0_0);
                    if let &InstructionData::Unary {
                        opcode: ref pattern9_0,
                        arg: pattern9_1,
                    } = &pattern8_0
                    {
                        if let &Opcode::Popcnt = pattern9_0 {
                            // Rule at src/isa/x64/lower.isle line 1973.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                            let expr1_0 = constructor_x64_vpopcntb(ctx, &expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
            }
        }
        if pattern2_0 == I32X4 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::FcvtToUintSat => {
                        let pattern7_0 = C::value_type(ctx, pattern5_1);
                        if pattern7_0 == F32X4 {
                            // Rule at src/isa/x64/lower.isle line 3154.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                            let expr2_0 = constructor_x64_pxor(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_x64_maxps(ctx, expr0_0, expr2_0)?;
                            let expr4_0 = C::xmm_to_xmm_mem(ctx, expr2_0);
                            let expr5_0 = constructor_x64_pcmpeqd(ctx, expr2_0, &expr4_0)?;
                            let expr6_0: u32 = 1i128 as u32;
                            let expr7_0 = RegMemImm::Imm { simm32: expr6_0 };
                            let expr8_0 = constructor_mov_rmi_to_xmm(ctx, &expr7_0)?;
                            let expr9_0 = constructor_x64_psrld(ctx, expr5_0, &expr8_0)?;
                            let expr10_0 = constructor_x64_cvtdq2ps(ctx, expr9_0)?;
                            let expr11_0: Type = F32X4;
                            let expr12_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                            let expr13_0 = constructor_x64_cvttps2dq(ctx, expr11_0, &expr12_0)?;
                            let expr14_0 = C::xmm_to_xmm_mem(ctx, expr10_0);
                            let expr15_0 = constructor_x64_subps(ctx, expr3_0, &expr14_0)?;
                            let expr16_0 = C::xmm_to_xmm_mem(ctx, expr15_0);
                            let expr17_0 = FcmpImm::LessThanOrEqual;
                            let expr18_0 =
                                constructor_x64_cmpps(ctx, expr10_0, &expr16_0, &expr17_0)?;
                            let expr19_0: Type = F32X4;
                            let expr20_0 = C::xmm_to_xmm_mem(ctx, expr15_0);
                            let expr21_0 = constructor_x64_cvttps2dq(ctx, expr19_0, &expr20_0)?;
                            let expr22_0 = C::xmm_to_xmm_mem(ctx, expr18_0);
                            let expr23_0 = constructor_x64_pxor(ctx, expr21_0, &expr22_0)?;
                            let expr24_0 = C::xmm_to_xmm_mem(ctx, expr18_0);
                            let expr25_0 = constructor_x64_pxor(ctx, expr18_0, &expr24_0)?;
                            let expr26_0 = C::xmm_to_xmm_mem(ctx, expr25_0);
                            let expr27_0 = constructor_x64_pmaxsd(ctx, expr23_0, &expr26_0)?;
                            let expr28_0 = C::xmm_to_xmm_mem(ctx, expr13_0);
                            let expr29_0 = constructor_x64_paddd(ctx, expr27_0, &expr28_0)?;
                            let expr30_0 = constructor_output_xmm(ctx, expr29_0)?;
                            return Some(expr30_0);
                        }
                    }
                    &Opcode::FcvtToSintSat => {
                        let pattern7_0 = C::value_type(ctx, pattern5_1);
                        if pattern7_0 == F32X4 {
                            // Rule at src/isa/x64/lower.isle line 3083.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                            let expr2_0 = FcmpImm::Equal;
                            let expr3_0 = constructor_x64_cmpps(ctx, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                            let expr5_0 = constructor_x64_andps(ctx, expr0_0, &expr4_0)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr7_0 = constructor_x64_pxor(ctx, expr3_0, &expr6_0)?;
                            let expr8_0: Type = F32X4;
                            let expr9_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr10_0 = constructor_x64_cvttps2dq(ctx, expr8_0, &expr9_0)?;
                            let expr11_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                            let expr12_0 = constructor_x64_pand(ctx, expr10_0, &expr11_0)?;
                            let expr13_0: u32 = 31i128 as u32;
                            let expr14_0 = RegMemImm::Imm { simm32: expr13_0 };
                            let expr15_0 = constructor_mov_rmi_to_xmm(ctx, &expr14_0)?;
                            let expr16_0 = constructor_x64_psrad(ctx, expr12_0, &expr15_0)?;
                            let expr17_0 = C::xmm_to_xmm_mem(ctx, expr10_0);
                            let expr18_0 = constructor_x64_pxor(ctx, expr16_0, &expr17_0)?;
                            let expr19_0 = constructor_output_xmm(ctx, expr18_0)?;
                            return Some(expr19_0);
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == F32X4 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::FcvtFromUint = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 3046.
                    let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                    let expr1_0: u32 = 16i128 as u32;
                    let expr2_0 = RegMemImm::Imm { simm32: expr1_0 };
                    let expr3_0 = constructor_mov_rmi_to_xmm(ctx, &expr2_0)?;
                    let expr4_0 = constructor_x64_pslld(ctx, expr0_0, &expr3_0)?;
                    let expr5_0: u32 = 16i128 as u32;
                    let expr6_0 = RegMemImm::Imm { simm32: expr5_0 };
                    let expr7_0 = constructor_mov_rmi_to_xmm(ctx, &expr6_0)?;
                    let expr8_0 = constructor_x64_psrld(ctx, expr4_0, &expr7_0)?;
                    let expr9_0 = C::xmm_to_xmm_mem(ctx, expr8_0);
                    let expr10_0 = constructor_x64_psubd(ctx, expr0_0, &expr9_0)?;
                    let expr11_0 = constructor_x64_cvtdq2ps(ctx, expr8_0)?;
                    let expr12_0: u32 = 1i128 as u32;
                    let expr13_0 = RegMemImm::Imm { simm32: expr12_0 };
                    let expr14_0 = constructor_mov_rmi_to_xmm(ctx, &expr13_0)?;
                    let expr15_0 = constructor_x64_psrld(ctx, expr10_0, &expr14_0)?;
                    let expr16_0 = constructor_x64_cvtdq2ps(ctx, expr15_0)?;
                    let expr17_0 = C::xmm_to_xmm_mem(ctx, expr16_0);
                    let expr18_0 = constructor_x64_addps(ctx, expr16_0, &expr17_0)?;
                    let expr19_0 = C::xmm_to_xmm_mem(ctx, expr11_0);
                    let expr20_0 = constructor_x64_addps(ctx, expr18_0, &expr19_0)?;
                    let expr21_0 = constructor_output_xmm(ctx, expr20_0)?;
                    return Some(expr21_0);
                }
            }
        }
        if pattern2_0 == F64X2 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::FcvtFromUint = pattern5_0 {
                    if let Some(pattern7_0) = C::def_inst(ctx, pattern5_1) {
                        let pattern8_0 = C::inst_data(ctx, pattern7_0);
                        if let &InstructionData::Unary {
                            opcode: ref pattern9_0,
                            arg: pattern9_1,
                        } = &pattern8_0
                        {
                            if let &Opcode::UwidenLow = pattern9_0 {
                                let pattern11_0 = C::value_type(ctx, pattern9_1);
                                if pattern11_0 == I32X4 {
                                    // Rule at src/isa/x64/lower.isle line 3011.
                                    let expr0_0: Type = I32X4;
                                    let expr1_0 = C::fcvt_uint_mask_const(ctx);
                                    let expr2_0 =
                                        constructor_x64_xmm_load_const(ctx, expr0_0, expr1_0)?;
                                    let expr3_0 = constructor_put_in_xmm(ctx, pattern9_1)?;
                                    let expr4_0 = C::xmm_to_xmm_mem(ctx, expr2_0);
                                    let expr5_0 = constructor_x64_unpcklps(ctx, expr3_0, &expr4_0)?;
                                    let expr6_0: Type = I32X4;
                                    let expr7_0 = C::fcvt_uint_mask_high_const(ctx);
                                    let expr8_0 =
                                        constructor_x64_xmm_load_const(ctx, expr6_0, expr7_0)?;
                                    let expr9_0 = C::xmm_to_xmm_mem(ctx, expr8_0);
                                    let expr10_0 = constructor_x64_subpd(ctx, expr5_0, &expr9_0)?;
                                    let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                                    return Some(expr11_0);
                                }
                            }
                        }
                    }
                }
            }
        }
        if let Some((pattern3_0, pattern3_1)) = C::multi_lane(ctx, pattern2_0) {
            if pattern3_0 == 16i128 as u32 {
                if pattern3_1 == 8i128 as u32 {
                    let pattern6_0 = C::inst_data(ctx, pattern0_0);
                    if let &InstructionData::Binary {
                        opcode: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &Opcode::Imul = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_value_array_2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::def_inst(ctx, pattern9_0) {
                                let pattern11_0 = C::inst_data(ctx, pattern10_0);
                                if let &InstructionData::Unary {
                                    opcode: ref pattern12_0,
                                    arg: pattern12_1,
                                } = &pattern11_0
                                {
                                    match pattern12_0 {
                                        &Opcode::SwidenLow => {
                                            let pattern14_0 = C::value_type(ctx, pattern12_1);
                                            if let Some((pattern15_0, pattern15_1)) =
                                                C::multi_lane(ctx, pattern14_0)
                                            {
                                                if pattern15_0 == 8i128 as u32 {
                                                    if pattern15_1 == 16i128 as u32 {
                                                        if let Some(pattern18_0) =
                                                            C::def_inst(ctx, pattern9_1)
                                                        {
                                                            let pattern19_0 =
                                                                C::inst_data(ctx, pattern18_0);
                                                            if let &InstructionData::Unary {
                                                                opcode: ref pattern20_0,
                                                                arg: pattern20_1,
                                                            } = &pattern19_0
                                                            {
                                                                if let &Opcode::SwidenLow =
                                                                    pattern20_0
                                                                {
                                                                    let pattern22_0 = C::value_type(
                                                                        ctx,
                                                                        pattern20_1,
                                                                    );
                                                                    if let Some((
                                                                        pattern23_0,
                                                                        pattern23_1,
                                                                    )) = C::multi_lane(
                                                                        ctx,
                                                                        pattern22_0,
                                                                    ) {
                                                                        if pattern23_0
                                                                            == 8i128 as u32
                                                                        {
                                                                            if pattern23_1
                                                                                == 16i128 as u32
                                                                            {
                                                                                // Rule at src/isa/x64/lower.isle line 1004.
                                                                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern12_1);
                                                                                let expr1_0 = constructor_x64_pmovsxbw(ctx, &expr0_0)?;
                                                                                let expr2_0 = C::put_in_xmm_mem(ctx, pattern20_1);
                                                                                let expr3_0 = constructor_x64_pmovsxbw(ctx, &expr2_0)?;
                                                                                let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                                                                                let expr5_0 = constructor_x64_pmullw(ctx, expr1_0, &expr4_0)?;
                                                                                let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                                                                                return Some(
                                                                                    expr6_0,
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::SwidenHigh => {
                                            let pattern14_0 = C::value_type(ctx, pattern12_1);
                                            if let Some((pattern15_0, pattern15_1)) =
                                                C::multi_lane(ctx, pattern14_0)
                                            {
                                                if pattern15_0 == 8i128 as u32 {
                                                    if pattern15_1 == 16i128 as u32 {
                                                        if let Some(pattern18_0) =
                                                            C::def_inst(ctx, pattern9_1)
                                                        {
                                                            let pattern19_0 =
                                                                C::inst_data(ctx, pattern18_0);
                                                            if let &InstructionData::Unary {
                                                                opcode: ref pattern20_0,
                                                                arg: pattern20_1,
                                                            } = &pattern19_0
                                                            {
                                                                if let &Opcode::SwidenHigh =
                                                                    pattern20_0
                                                                {
                                                                    let pattern22_0 = C::value_type(
                                                                        ctx,
                                                                        pattern20_1,
                                                                    );
                                                                    if let Some((
                                                                        pattern23_0,
                                                                        pattern23_1,
                                                                    )) = C::multi_lane(
                                                                        ctx,
                                                                        pattern22_0,
                                                                    ) {
                                                                        if pattern23_0
                                                                            == 8i128 as u32
                                                                        {
                                                                            if pattern23_1
                                                                                == 16i128 as u32
                                                                            {
                                                                                // Rule at src/isa/x64/lower.isle line 964.
                                                                                let expr0_0 = constructor_put_in_xmm(ctx, pattern12_1)?;
                                                                                let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                                                                                let expr2_0: u8 =
                                                                                    8i128 as u8;
                                                                                let expr3_0 = OperandSize::Size32;
                                                                                let expr4_0 = constructor_x64_palignr(ctx, expr0_0, &expr1_0, expr2_0, &expr3_0)?;
                                                                                let expr5_0 = C::xmm_to_xmm_mem(ctx, expr4_0);
                                                                                let expr6_0 = constructor_x64_pmovsxbw(ctx, &expr5_0)?;
                                                                                let expr7_0 = constructor_put_in_xmm(ctx, pattern20_1)?;
                                                                                let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                                                                                let expr9_0: u8 =
                                                                                    8i128 as u8;
                                                                                let expr10_0 = OperandSize::Size32;
                                                                                let expr11_0 = constructor_x64_palignr(ctx, expr7_0, &expr8_0, expr9_0, &expr10_0)?;
                                                                                let expr12_0 = C::xmm_to_xmm_mem(ctx, expr11_0);
                                                                                let expr13_0 = constructor_x64_pmovsxbw(ctx, &expr12_0)?;
                                                                                let expr14_0 = C::xmm_to_xmm_mem(ctx, expr13_0);
                                                                                let expr15_0 = constructor_x64_pmullw(ctx, expr6_0, &expr14_0)?;
                                                                                let expr16_0 = constructor_output_xmm(ctx, expr15_0)?;
                                                                                return Some(
                                                                                    expr16_0,
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::UwidenLow => {
                                            let pattern14_0 = C::value_type(ctx, pattern12_1);
                                            if let Some((pattern15_0, pattern15_1)) =
                                                C::multi_lane(ctx, pattern14_0)
                                            {
                                                if pattern15_0 == 8i128 as u32 {
                                                    if pattern15_1 == 16i128 as u32 {
                                                        if let Some(pattern18_0) =
                                                            C::def_inst(ctx, pattern9_1)
                                                        {
                                                            let pattern19_0 =
                                                                C::inst_data(ctx, pattern18_0);
                                                            if let &InstructionData::Unary {
                                                                opcode: ref pattern20_0,
                                                                arg: pattern20_1,
                                                            } = &pattern19_0
                                                            {
                                                                if let &Opcode::UwidenLow =
                                                                    pattern20_0
                                                                {
                                                                    let pattern22_0 = C::value_type(
                                                                        ctx,
                                                                        pattern20_1,
                                                                    );
                                                                    if let Some((
                                                                        pattern23_0,
                                                                        pattern23_1,
                                                                    )) = C::multi_lane(
                                                                        ctx,
                                                                        pattern22_0,
                                                                    ) {
                                                                        if pattern23_0
                                                                            == 8i128 as u32
                                                                        {
                                                                            if pattern23_1
                                                                                == 16i128 as u32
                                                                            {
                                                                                // Rule at src/isa/x64/lower.isle line 1080.
                                                                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern12_1);
                                                                                let expr1_0 = constructor_x64_pmovzxbw(ctx, &expr0_0)?;
                                                                                let expr2_0 = C::put_in_xmm_mem(ctx, pattern20_1);
                                                                                let expr3_0 = constructor_x64_pmovzxbw(ctx, &expr2_0)?;
                                                                                let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                                                                                let expr5_0 = constructor_x64_pmullw(ctx, expr1_0, &expr4_0)?;
                                                                                let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                                                                                return Some(
                                                                                    expr6_0,
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::UwidenHigh => {
                                            let pattern14_0 = C::value_type(ctx, pattern12_1);
                                            if let Some((pattern15_0, pattern15_1)) =
                                                C::multi_lane(ctx, pattern14_0)
                                            {
                                                if pattern15_0 == 8i128 as u32 {
                                                    if pattern15_1 == 16i128 as u32 {
                                                        if let Some(pattern18_0) =
                                                            C::def_inst(ctx, pattern9_1)
                                                        {
                                                            let pattern19_0 =
                                                                C::inst_data(ctx, pattern18_0);
                                                            if let &InstructionData::Unary {
                                                                opcode: ref pattern20_0,
                                                                arg: pattern20_1,
                                                            } = &pattern19_0
                                                            {
                                                                if let &Opcode::UwidenHigh =
                                                                    pattern20_0
                                                                {
                                                                    let pattern22_0 = C::value_type(
                                                                        ctx,
                                                                        pattern20_1,
                                                                    );
                                                                    if let Some((
                                                                        pattern23_0,
                                                                        pattern23_1,
                                                                    )) = C::multi_lane(
                                                                        ctx,
                                                                        pattern22_0,
                                                                    ) {
                                                                        if pattern23_0
                                                                            == 8i128 as u32
                                                                        {
                                                                            if pattern23_1
                                                                                == 16i128 as u32
                                                                            {
                                                                                // Rule at src/isa/x64/lower.isle line 1040.
                                                                                let expr0_0 = constructor_put_in_xmm(ctx, pattern12_1)?;
                                                                                let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                                                                                let expr2_0: u8 =
                                                                                    8i128 as u8;
                                                                                let expr3_0 = OperandSize::Size32;
                                                                                let expr4_0 = constructor_x64_palignr(ctx, expr0_0, &expr1_0, expr2_0, &expr3_0)?;
                                                                                let expr5_0 = C::xmm_to_xmm_mem(ctx, expr4_0);
                                                                                let expr6_0 = constructor_x64_pmovzxbw(ctx, &expr5_0)?;
                                                                                let expr7_0 = constructor_put_in_xmm(ctx, pattern20_1)?;
                                                                                let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                                                                                let expr9_0: u8 =
                                                                                    8i128 as u8;
                                                                                let expr10_0 = OperandSize::Size32;
                                                                                let expr11_0 = constructor_x64_palignr(ctx, expr7_0, &expr8_0, expr9_0, &expr10_0)?;
                                                                                let expr12_0 = C::xmm_to_xmm_mem(ctx, expr11_0);
                                                                                let expr13_0 = constructor_x64_pmovzxbw(ctx, &expr12_0)?;
                                                                                let expr14_0 = C::xmm_to_xmm_mem(ctx, expr13_0);
                                                                                let expr15_0 = constructor_x64_pmullw(ctx, expr6_0, &expr14_0)?;
                                                                                let expr16_0 = constructor_output_xmm(ctx, expr15_0)?;
                                                                                return Some(
                                                                                    expr16_0,
                                                                                );
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if pattern3_0 == 32i128 as u32 {
                if pattern3_1 == 4i128 as u32 {
                    let pattern6_0 = C::inst_data(ctx, pattern0_0);
                    match &pattern6_0 {
                        &InstructionData::Unary {
                            opcode: ref pattern7_0,
                            arg: pattern7_1,
                        } => {
                            if let &Opcode::Splat = pattern7_0 {
                                let pattern9_0 = C::value_type(ctx, pattern7_1);
                                if let Some(pattern10_0) = C::ty_scalar_float(ctx, pattern9_0) {
                                    // Rule at src/isa/x64/lower.isle line 3635.
                                    let expr0_0: Type = F32X4;
                                    let expr1_0 =
                                        constructor_lower_splat_32x4(ctx, expr0_0, pattern7_1)?;
                                    let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                    return Some(expr2_0);
                                }
                            }
                        }
                        &InstructionData::Binary {
                            opcode: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            if let &Opcode::Imul = pattern7_0 {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_value_array_2(ctx, pattern7_1);
                                if let Some(pattern10_0) = C::def_inst(ctx, pattern9_0) {
                                    let pattern11_0 = C::inst_data(ctx, pattern10_0);
                                    if let &InstructionData::Unary {
                                        opcode: ref pattern12_0,
                                        arg: pattern12_1,
                                    } = &pattern11_0
                                    {
                                        match pattern12_0 {
                                            &Opcode::SwidenLow => {
                                                let pattern14_0 = C::value_type(ctx, pattern12_1);
                                                if let Some((pattern15_0, pattern15_1)) =
                                                    C::multi_lane(ctx, pattern14_0)
                                                {
                                                    if pattern15_0 == 16i128 as u32 {
                                                        if pattern15_1 == 8i128 as u32 {
                                                            if let Some(pattern18_0) =
                                                                C::def_inst(ctx, pattern9_1)
                                                            {
                                                                let pattern19_0 =
                                                                    C::inst_data(ctx, pattern18_0);
                                                                if let &InstructionData::Unary {
                                                                    opcode: ref pattern20_0,
                                                                    arg: pattern20_1,
                                                                } = &pattern19_0
                                                                {
                                                                    if let &Opcode::SwidenLow =
                                                                        pattern20_0
                                                                    {
                                                                        let pattern22_0 =
                                                                            C::value_type(
                                                                                ctx,
                                                                                pattern20_1,
                                                                            );
                                                                        if let Some((
                                                                            pattern23_0,
                                                                            pattern23_1,
                                                                        )) = C::multi_lane(
                                                                            ctx,
                                                                            pattern22_0,
                                                                        ) {
                                                                            if pattern23_0
                                                                                == 16i128 as u32
                                                                            {
                                                                                if pattern23_1
                                                                                    == 8i128 as u32
                                                                                {
                                                                                    // Rule at src/isa/x64/lower.isle line 1014.
                                                                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern12_1)?;
                                                                                    let expr1_0 = constructor_put_in_xmm(ctx, pattern20_1)?;
                                                                                    let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                                                                    let expr3_0 = constructor_x64_pmullw(ctx, expr0_0, &expr2_0)?;
                                                                                    let expr4_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                                                                    let expr5_0 = constructor_x64_pmulhw(ctx, expr0_0, &expr4_0)?;
                                                                                    let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                                                                                    let expr7_0 = constructor_x64_punpcklwd(ctx, expr3_0, &expr6_0)?;
                                                                                    let expr8_0 = constructor_output_xmm(ctx, expr7_0)?;
                                                                                    return Some(
                                                                                        expr8_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::SwidenHigh => {
                                                let pattern14_0 = C::value_type(ctx, pattern12_1);
                                                if let Some((pattern15_0, pattern15_1)) =
                                                    C::multi_lane(ctx, pattern14_0)
                                                {
                                                    if pattern15_0 == 16i128 as u32 {
                                                        if pattern15_1 == 8i128 as u32 {
                                                            if let Some(pattern18_0) =
                                                                C::def_inst(ctx, pattern9_1)
                                                            {
                                                                let pattern19_0 =
                                                                    C::inst_data(ctx, pattern18_0);
                                                                if let &InstructionData::Unary {
                                                                    opcode: ref pattern20_0,
                                                                    arg: pattern20_1,
                                                                } = &pattern19_0
                                                                {
                                                                    if let &Opcode::SwidenHigh =
                                                                        pattern20_0
                                                                    {
                                                                        let pattern22_0 =
                                                                            C::value_type(
                                                                                ctx,
                                                                                pattern20_1,
                                                                            );
                                                                        if let Some((
                                                                            pattern23_0,
                                                                            pattern23_1,
                                                                        )) = C::multi_lane(
                                                                            ctx,
                                                                            pattern22_0,
                                                                        ) {
                                                                            if pattern23_0
                                                                                == 16i128 as u32
                                                                            {
                                                                                if pattern23_1
                                                                                    == 8i128 as u32
                                                                                {
                                                                                    // Rule at src/isa/x64/lower.isle line 978.
                                                                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern12_1)?;
                                                                                    let expr1_0 = constructor_put_in_xmm(ctx, pattern20_1)?;
                                                                                    let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                                                                    let expr3_0 = constructor_x64_pmullw(ctx, expr0_0, &expr2_0)?;
                                                                                    let expr4_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                                                                    let expr5_0 = constructor_x64_pmulhw(ctx, expr0_0, &expr4_0)?;
                                                                                    let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                                                                                    let expr7_0 = constructor_x64_punpckhwd(ctx, expr3_0, &expr6_0)?;
                                                                                    let expr8_0 = constructor_output_xmm(ctx, expr7_0)?;
                                                                                    return Some(
                                                                                        expr8_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::UwidenLow => {
                                                let pattern14_0 = C::value_type(ctx, pattern12_1);
                                                if let Some((pattern15_0, pattern15_1)) =
                                                    C::multi_lane(ctx, pattern14_0)
                                                {
                                                    if pattern15_0 == 16i128 as u32 {
                                                        if pattern15_1 == 8i128 as u32 {
                                                            if let Some(pattern18_0) =
                                                                C::def_inst(ctx, pattern9_1)
                                                            {
                                                                let pattern19_0 =
                                                                    C::inst_data(ctx, pattern18_0);
                                                                if let &InstructionData::Unary {
                                                                    opcode: ref pattern20_0,
                                                                    arg: pattern20_1,
                                                                } = &pattern19_0
                                                                {
                                                                    if let &Opcode::UwidenLow =
                                                                        pattern20_0
                                                                    {
                                                                        let pattern22_0 =
                                                                            C::value_type(
                                                                                ctx,
                                                                                pattern20_1,
                                                                            );
                                                                        if let Some((
                                                                            pattern23_0,
                                                                            pattern23_1,
                                                                        )) = C::multi_lane(
                                                                            ctx,
                                                                            pattern22_0,
                                                                        ) {
                                                                            if pattern23_0
                                                                                == 16i128 as u32
                                                                            {
                                                                                if pattern23_1
                                                                                    == 8i128 as u32
                                                                                {
                                                                                    // Rule at src/isa/x64/lower.isle line 1090.
                                                                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern12_1)?;
                                                                                    let expr1_0 = constructor_put_in_xmm(ctx, pattern20_1)?;
                                                                                    let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                                                                    let expr3_0 = constructor_x64_pmullw(ctx, expr0_0, &expr2_0)?;
                                                                                    let expr4_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                                                                    let expr5_0 = constructor_x64_pmulhuw(ctx, expr0_0, &expr4_0)?;
                                                                                    let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                                                                                    let expr7_0 = constructor_x64_punpcklwd(ctx, expr3_0, &expr6_0)?;
                                                                                    let expr8_0 = constructor_output_xmm(ctx, expr7_0)?;
                                                                                    return Some(
                                                                                        expr8_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::UwidenHigh => {
                                                let pattern14_0 = C::value_type(ctx, pattern12_1);
                                                if let Some((pattern15_0, pattern15_1)) =
                                                    C::multi_lane(ctx, pattern14_0)
                                                {
                                                    if pattern15_0 == 16i128 as u32 {
                                                        if pattern15_1 == 8i128 as u32 {
                                                            if let Some(pattern18_0) =
                                                                C::def_inst(ctx, pattern9_1)
                                                            {
                                                                let pattern19_0 =
                                                                    C::inst_data(ctx, pattern18_0);
                                                                if let &InstructionData::Unary {
                                                                    opcode: ref pattern20_0,
                                                                    arg: pattern20_1,
                                                                } = &pattern19_0
                                                                {
                                                                    if let &Opcode::UwidenHigh =
                                                                        pattern20_0
                                                                    {
                                                                        let pattern22_0 =
                                                                            C::value_type(
                                                                                ctx,
                                                                                pattern20_1,
                                                                            );
                                                                        if let Some((
                                                                            pattern23_0,
                                                                            pattern23_1,
                                                                        )) = C::multi_lane(
                                                                            ctx,
                                                                            pattern22_0,
                                                                        ) {
                                                                            if pattern23_0
                                                                                == 16i128 as u32
                                                                            {
                                                                                if pattern23_1
                                                                                    == 8i128 as u32
                                                                                {
                                                                                    // Rule at src/isa/x64/lower.isle line 1054.
                                                                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern12_1)?;
                                                                                    let expr1_0 = constructor_put_in_xmm(ctx, pattern20_1)?;
                                                                                    let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                                                                    let expr3_0 = constructor_x64_pmullw(ctx, expr0_0, &expr2_0)?;
                                                                                    let expr4_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                                                                    let expr5_0 = constructor_x64_pmulhuw(ctx, expr0_0, &expr4_0)?;
                                                                                    let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                                                                                    let expr7_0 = constructor_x64_punpckhwd(ctx, expr3_0, &expr6_0)?;
                                                                                    let expr8_0 = constructor_output_xmm(ctx, expr7_0)?;
                                                                                    return Some(
                                                                                        expr8_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
            if pattern3_0 == 64i128 as u32 {
                if pattern3_1 == 2i128 as u32 {
                    let pattern6_0 = C::inst_data(ctx, pattern0_0);
                    match &pattern6_0 {
                        &InstructionData::Unary {
                            opcode: ref pattern7_0,
                            arg: pattern7_1,
                        } => {
                            if let &Opcode::Splat = pattern7_0 {
                                let pattern9_0 = C::value_type(ctx, pattern7_1);
                                if let Some(pattern10_0) = C::ty_scalar_float(ctx, pattern9_0) {
                                    // Rule at src/isa/x64/lower.isle line 3648.
                                    let expr0_0: Type = F64X2;
                                    let expr1_0 =
                                        constructor_lower_splat_64x2(ctx, expr0_0, pattern7_1)?;
                                    let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                    return Some(expr2_0);
                                }
                            }
                        }
                        &InstructionData::Binary {
                            opcode: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            if let &Opcode::Imul = pattern7_0 {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_value_array_2(ctx, pattern7_1);
                                if let Some(pattern10_0) = C::def_inst(ctx, pattern9_0) {
                                    let pattern11_0 = C::inst_data(ctx, pattern10_0);
                                    if let &InstructionData::Unary {
                                        opcode: ref pattern12_0,
                                        arg: pattern12_1,
                                    } = &pattern11_0
                                    {
                                        match pattern12_0 {
                                            &Opcode::SwidenLow => {
                                                let pattern14_0 = C::value_type(ctx, pattern12_1);
                                                if let Some((pattern15_0, pattern15_1)) =
                                                    C::multi_lane(ctx, pattern14_0)
                                                {
                                                    if pattern15_0 == 32i128 as u32 {
                                                        if pattern15_1 == 4i128 as u32 {
                                                            if let Some(pattern18_0) =
                                                                C::def_inst(ctx, pattern9_1)
                                                            {
                                                                let pattern19_0 =
                                                                    C::inst_data(ctx, pattern18_0);
                                                                if let &InstructionData::Unary {
                                                                    opcode: ref pattern20_0,
                                                                    arg: pattern20_1,
                                                                } = &pattern19_0
                                                                {
                                                                    if let &Opcode::SwidenLow =
                                                                        pattern20_0
                                                                    {
                                                                        let pattern22_0 =
                                                                            C::value_type(
                                                                                ctx,
                                                                                pattern20_1,
                                                                            );
                                                                        if let Some((
                                                                            pattern23_0,
                                                                            pattern23_1,
                                                                        )) = C::multi_lane(
                                                                            ctx,
                                                                            pattern22_0,
                                                                        ) {
                                                                            if pattern23_0
                                                                                == 32i128 as u32
                                                                            {
                                                                                if pattern23_1
                                                                                    == 4i128 as u32
                                                                                {
                                                                                    // Rule at src/isa/x64/lower.isle line 1026.
                                                                                    let expr0_0 = C::put_in_xmm_mem(ctx, pattern12_1);
                                                                                    let expr1_0: u8 = 80i128 as u8;
                                                                                    let expr2_0 = OperandSize::Size32;
                                                                                    let expr3_0 = constructor_x64_pshufd(ctx, &expr0_0, expr1_0, &expr2_0)?;
                                                                                    let expr4_0 = C::put_in_xmm_mem(ctx, pattern20_1);
                                                                                    let expr5_0: u8 = 80i128 as u8;
                                                                                    let expr6_0 = OperandSize::Size32;
                                                                                    let expr7_0 = constructor_x64_pshufd(ctx, &expr4_0, expr5_0, &expr6_0)?;
                                                                                    let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                                                                                    let expr9_0 = constructor_x64_pmuldq(ctx, expr3_0, &expr8_0)?;
                                                                                    let expr10_0 = constructor_output_xmm(ctx, expr9_0)?;
                                                                                    return Some(
                                                                                        expr10_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::SwidenHigh => {
                                                let pattern14_0 = C::value_type(ctx, pattern12_1);
                                                if let Some((pattern15_0, pattern15_1)) =
                                                    C::multi_lane(ctx, pattern14_0)
                                                {
                                                    if pattern15_0 == 32i128 as u32 {
                                                        if pattern15_1 == 4i128 as u32 {
                                                            if let Some(pattern18_0) =
                                                                C::def_inst(ctx, pattern9_1)
                                                            {
                                                                let pattern19_0 =
                                                                    C::inst_data(ctx, pattern18_0);
                                                                if let &InstructionData::Unary {
                                                                    opcode: ref pattern20_0,
                                                                    arg: pattern20_1,
                                                                } = &pattern19_0
                                                                {
                                                                    if let &Opcode::SwidenHigh =
                                                                        pattern20_0
                                                                    {
                                                                        let pattern22_0 =
                                                                            C::value_type(
                                                                                ctx,
                                                                                pattern20_1,
                                                                            );
                                                                        if let Some((
                                                                            pattern23_0,
                                                                            pattern23_1,
                                                                        )) = C::multi_lane(
                                                                            ctx,
                                                                            pattern22_0,
                                                                        ) {
                                                                            if pattern23_0
                                                                                == 32i128 as u32
                                                                            {
                                                                                if pattern23_1
                                                                                    == 4i128 as u32
                                                                                {
                                                                                    // Rule at src/isa/x64/lower.isle line 990.
                                                                                    let expr0_0 = C::put_in_xmm_mem(ctx, pattern12_1);
                                                                                    let expr1_0: u8 = 250i128 as u8;
                                                                                    let expr2_0 = OperandSize::Size32;
                                                                                    let expr3_0 = constructor_x64_pshufd(ctx, &expr0_0, expr1_0, &expr2_0)?;
                                                                                    let expr4_0 = C::put_in_xmm_mem(ctx, pattern20_1);
                                                                                    let expr5_0: u8 = 250i128 as u8;
                                                                                    let expr6_0 = OperandSize::Size32;
                                                                                    let expr7_0 = constructor_x64_pshufd(ctx, &expr4_0, expr5_0, &expr6_0)?;
                                                                                    let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                                                                                    let expr9_0 = constructor_x64_pmuldq(ctx, expr3_0, &expr8_0)?;
                                                                                    let expr10_0 = constructor_output_xmm(ctx, expr9_0)?;
                                                                                    return Some(
                                                                                        expr10_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::UwidenLow => {
                                                let pattern14_0 = C::value_type(ctx, pattern12_1);
                                                if let Some((pattern15_0, pattern15_1)) =
                                                    C::multi_lane(ctx, pattern14_0)
                                                {
                                                    if pattern15_0 == 32i128 as u32 {
                                                        if pattern15_1 == 4i128 as u32 {
                                                            if let Some(pattern18_0) =
                                                                C::def_inst(ctx, pattern9_1)
                                                            {
                                                                let pattern19_0 =
                                                                    C::inst_data(ctx, pattern18_0);
                                                                if let &InstructionData::Unary {
                                                                    opcode: ref pattern20_0,
                                                                    arg: pattern20_1,
                                                                } = &pattern19_0
                                                                {
                                                                    if let &Opcode::UwidenLow =
                                                                        pattern20_0
                                                                    {
                                                                        let pattern22_0 =
                                                                            C::value_type(
                                                                                ctx,
                                                                                pattern20_1,
                                                                            );
                                                                        if let Some((
                                                                            pattern23_0,
                                                                            pattern23_1,
                                                                        )) = C::multi_lane(
                                                                            ctx,
                                                                            pattern22_0,
                                                                        ) {
                                                                            if pattern23_0
                                                                                == 32i128 as u32
                                                                            {
                                                                                if pattern23_1
                                                                                    == 4i128 as u32
                                                                                {
                                                                                    // Rule at src/isa/x64/lower.isle line 1102.
                                                                                    let expr0_0 = C::put_in_xmm_mem(ctx, pattern12_1);
                                                                                    let expr1_0: u8 = 80i128 as u8;
                                                                                    let expr2_0 = OperandSize::Size32;
                                                                                    let expr3_0 = constructor_x64_pshufd(ctx, &expr0_0, expr1_0, &expr2_0)?;
                                                                                    let expr4_0 = C::put_in_xmm_mem(ctx, pattern20_1);
                                                                                    let expr5_0: u8 = 80i128 as u8;
                                                                                    let expr6_0 = OperandSize::Size32;
                                                                                    let expr7_0 = constructor_x64_pshufd(ctx, &expr4_0, expr5_0, &expr6_0)?;
                                                                                    let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                                                                                    let expr9_0 = constructor_x64_pmuludq(ctx, expr3_0, &expr8_0)?;
                                                                                    let expr10_0 = constructor_output_xmm(ctx, expr9_0)?;
                                                                                    return Some(
                                                                                        expr10_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::UwidenHigh => {
                                                let pattern14_0 = C::value_type(ctx, pattern12_1);
                                                if let Some((pattern15_0, pattern15_1)) =
                                                    C::multi_lane(ctx, pattern14_0)
                                                {
                                                    if pattern15_0 == 32i128 as u32 {
                                                        if pattern15_1 == 4i128 as u32 {
                                                            if let Some(pattern18_0) =
                                                                C::def_inst(ctx, pattern9_1)
                                                            {
                                                                let pattern19_0 =
                                                                    C::inst_data(ctx, pattern18_0);
                                                                if let &InstructionData::Unary {
                                                                    opcode: ref pattern20_0,
                                                                    arg: pattern20_1,
                                                                } = &pattern19_0
                                                                {
                                                                    if let &Opcode::UwidenHigh =
                                                                        pattern20_0
                                                                    {
                                                                        let pattern22_0 =
                                                                            C::value_type(
                                                                                ctx,
                                                                                pattern20_1,
                                                                            );
                                                                        if let Some((
                                                                            pattern23_0,
                                                                            pattern23_1,
                                                                        )) = C::multi_lane(
                                                                            ctx,
                                                                            pattern22_0,
                                                                        ) {
                                                                            if pattern23_0
                                                                                == 32i128 as u32
                                                                            {
                                                                                if pattern23_1
                                                                                    == 4i128 as u32
                                                                                {
                                                                                    // Rule at src/isa/x64/lower.isle line 1066.
                                                                                    let expr0_0 = C::put_in_xmm_mem(ctx, pattern12_1);
                                                                                    let expr1_0: u8 = 250i128 as u8;
                                                                                    let expr2_0 = OperandSize::Size32;
                                                                                    let expr3_0 = constructor_x64_pshufd(ctx, &expr0_0, expr1_0, &expr2_0)?;
                                                                                    let expr4_0 = C::put_in_xmm_mem(ctx, pattern20_1);
                                                                                    let expr5_0: u8 = 250i128 as u8;
                                                                                    let expr6_0 = OperandSize::Size32;
                                                                                    let expr7_0 = constructor_x64_pshufd(ctx, &expr4_0, expr5_0, &expr6_0)?;
                                                                                    let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                                                                                    let expr9_0 = constructor_x64_pmuludq(ctx, expr3_0, &expr8_0)?;
                                                                                    let expr10_0 = constructor_output_xmm(ctx, expr9_0)?;
                                                                                    return Some(
                                                                                        expr10_0,
                                                                                    );
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Ternary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Bitselect = pattern5_0 {
                    let (pattern7_0, pattern7_1, pattern7_2) =
                        C::unpack_value_array_3(ctx, pattern5_1);
                    let mut closure8 = || {
                        let expr0_0 = constructor_all_ones_or_all_zeros(ctx, pattern7_0)?;
                        return Some(expr0_0);
                    };
                    if let Some(pattern8_0) = closure8() {
                        // Rule at src/isa/x64/lower.isle line 1289.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                        let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                        let expr2_0 = constructor_put_in_xmm(ctx, pattern7_2)?;
                        let expr3_0 =
                            constructor_x64_blend(ctx, pattern2_0, expr0_0, &expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    if let &Opcode::Ireduce = pattern5_0 {
                        // Rule at src/isa/x64/lower.isle line 2244.
                        let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                        let expr1_0: usize = 0i128 as usize;
                        let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                        let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::IaddIfcout = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::simm32_from_value(ctx, pattern7_1) {
                            // Rule at src/isa/x64/lower.isle line 148.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 =
                                constructor_x64_add(ctx, pattern3_0, expr0_0, &pattern8_0)?;
                            let expr2_0 = C::gpr_to_reg(ctx, expr1_0);
                            let expr3_0 = constructor_output_ifcout(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                &InstructionData::IntAddTrap {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    code: ref pattern5_2,
                } => {
                    if let &Opcode::UaddOverflowTrap = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::simm32_from_value(ctx, pattern7_1) {
                            // Rule at src/isa/x64/lower.isle line 1466.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 = constructor_x64_add_with_flags_paired(
                                ctx,
                                pattern3_0,
                                expr0_0,
                                &pattern8_0,
                            )?;
                            let expr2_0 = CC::B;
                            let expr3_0 = constructor_trap_if(ctx, &expr2_0, pattern5_2)?;
                            let expr4_0 = constructor_with_flags(ctx, &expr1_0, &expr3_0)?;
                            let expr5_0 = C::output(ctx, expr4_0);
                            return Some(expr5_0);
                        }
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::ty_8_or_16(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Clz => {
                        // Rule at src/isa/x64/lower.isle line 1799.
                        let expr0_0: Type = I32;
                        let expr1_0: Type = I32;
                        let expr2_0 = ExtendKind::Zero;
                        let expr3_0 =
                            constructor_extend_to_gpr(ctx, pattern5_1, expr1_0, &expr2_0)?;
                        let expr4_0 = constructor_do_clz(ctx, expr0_0, pattern3_0, expr3_0)?;
                        let expr5_0 = constructor_output_gpr(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                    &Opcode::Ctz => {
                        // Rule at src/isa/x64/lower.isle line 1843.
                        let expr0_0: Type = I32;
                        let expr1_0: Type = I32;
                        let expr2_0 = ExtendKind::Zero;
                        let expr3_0 =
                            constructor_extend_to_gpr(ctx, pattern5_1, expr1_0, &expr2_0)?;
                        let expr4_0 = constructor_do_ctz(ctx, expr0_0, pattern3_0, expr3_0)?;
                        let expr5_0 = constructor_output_gpr(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::type_register_class(ctx, pattern2_0) {
            if let &RegisterClass::Gpr {
                single_register: pattern4_0,
            } = &pattern3_0
            {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::LoadNoOffset {
                    opcode: ref pattern6_0,
                    arg: pattern6_1,
                    flags: pattern6_2,
                } = &pattern5_0
                {
                    if let &Opcode::Bitcast = pattern6_0 {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if let Some(pattern9_0) = C::type_register_class(ctx, pattern8_0) {
                            if let &RegisterClass::Gpr {
                                single_register: pattern10_0,
                            } = &pattern9_0
                            {
                                // Rule at src/isa/x64/lower.isle line 3343.
                                let expr0_0 = constructor_output_value(ctx, pattern6_1)?;
                                return Some(expr0_0);
                            }
                        }
                    }
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        match &pattern3_0 {
            &InstructionData::Unary {
                opcode: ref pattern4_0,
                arg: pattern4_1,
            } => {
                if let &Opcode::Uextend = pattern4_0 {
                    let pattern6_0 = C::value_type(ctx, pattern4_1);
                    if pattern6_0 == pattern2_0 {
                        // Rule at src/isa/x64/lower.isle line 2137.
                        let expr0_0 = constructor_output_value(ctx, pattern4_1)?;
                        return Some(expr0_0);
                    }
                }
            }
            &InstructionData::Binary {
                opcode: ref pattern4_0,
                args: ref pattern4_1,
            } => {
                match pattern4_0 {
                    &Opcode::Band => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        if let Some(pattern7_0) = C::sinkable_load(ctx, pattern6_1) {
                            let mut closure8 = || {
                                let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern8_0) = closure8() {
                                // Rule at src/isa/x64/lower.isle line 251.
                                let expr0_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                                let expr1_0 =
                                    constructor_sink_load_to_gpr_mem_imm(ctx, &pattern7_0)?;
                                let expr2_0 =
                                    constructor_x64_and(ctx, pattern2_0, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                    }
                    &Opcode::Bor => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        if let Some(pattern7_0) = C::sinkable_load(ctx, pattern6_1) {
                            let mut closure8 = || {
                                let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern8_0) = closure8() {
                                // Rule at src/isa/x64/lower.isle line 313.
                                let expr0_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                                let expr1_0 =
                                    constructor_sink_load_to_gpr_mem_imm(ctx, &pattern7_0)?;
                                let expr2_0 =
                                    constructor_x64_or(ctx, pattern2_0, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                    }
                    &Opcode::Bxor => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        if let Some(pattern7_0) = C::sinkable_load(ctx, pattern6_1) {
                            let mut closure8 = || {
                                let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern8_0) = closure8() {
                                // Rule at src/isa/x64/lower.isle line 376.
                                let expr0_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                                let expr1_0 =
                                    constructor_sink_load_to_gpr_mem_imm(ctx, &pattern7_0)?;
                                let expr2_0 =
                                    constructor_x64_xor(ctx, pattern2_0, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
        let pattern3_0 = C::avx512vl_enabled(ctx, pattern2_0);
        if pattern3_0 == true {
            let pattern5_0 = C::avx512f_enabled(ctx, pattern2_0);
            if pattern5_0 == true {
                if pattern2_0 == I64X2 {
                    let pattern8_0 = C::inst_data(ctx, pattern0_0);
                    if let &InstructionData::Unary {
                        opcode: ref pattern9_0,
                        arg: pattern9_1,
                    } = &pattern8_0
                    {
                        if let &Opcode::Iabs = pattern9_0 {
                            // Rule at src/isa/x64/lower.isle line 1144.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                            let expr1_0 = constructor_x64_vpabsq(ctx, &expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
            }
            let pattern5_0 = C::avx512vbmi_enabled(ctx, pattern2_0);
            if pattern5_0 == true {
                let pattern7_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Shuffle {
                    opcode: ref pattern8_0,
                    args: ref pattern8_1,
                    imm: pattern8_2,
                } = &pattern7_0
                {
                    if let &Opcode::Shuffle = pattern8_0 {
                        let (pattern10_0, pattern10_1) = C::unpack_value_array_2(ctx, pattern8_1);
                        if let Some(pattern11_0) = C::vec_mask_from_immediate(ctx, pattern8_2) {
                            // Rule at src/isa/x64/lower.isle line 3540.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern10_1)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern10_0)?;
                            let expr2_0: Type = I8X16;
                            let expr3_0 = C::perm_from_mask(ctx, &pattern11_0);
                            let expr4_0 = constructor_x64_xmm_load_const(ctx, expr2_0, expr3_0)?;
                            let expr5_0 = constructor_x64_vpermi2b(ctx, expr0_0, expr1_0, expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                    }
                }
            }
        }
        let pattern3_0 = C::use_fma(ctx, pattern2_0);
        if pattern3_0 == true {
            if pattern2_0 == F32 {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Ternary {
                    opcode: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Fma = pattern7_0 {
                        let (pattern9_0, pattern9_1, pattern9_2) =
                            C::unpack_value_array_3(ctx, pattern7_1);
                        // Rule at src/isa/x64/lower.isle line 2529.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                        let expr1_0 = constructor_put_in_xmm(ctx, pattern9_1)?;
                        let expr2_0 = constructor_put_in_xmm(ctx, pattern9_2)?;
                        let expr3_0 = constructor_x64_vfmadd213ss(ctx, expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                }
            }
            if pattern2_0 == F64 {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Ternary {
                    opcode: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Fma = pattern7_0 {
                        let (pattern9_0, pattern9_1, pattern9_2) =
                            C::unpack_value_array_3(ctx, pattern7_1);
                        // Rule at src/isa/x64/lower.isle line 2531.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                        let expr1_0 = constructor_put_in_xmm(ctx, pattern9_1)?;
                        let expr2_0 = constructor_put_in_xmm(ctx, pattern9_2)?;
                        let expr3_0 = constructor_x64_vfmadd213sd(ctx, expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                }
            }
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::Unary {
            opcode: ref pattern2_0,
            arg: pattern2_1,
        } => {
            if let &Opcode::ScalarToVector = pattern2_0 {
                let pattern4_0 = C::value_type(ctx, pattern2_1);
                if let Some(pattern5_0) = C::ty_scalar_float(ctx, pattern4_0) {
                    // Rule at src/isa/x64/lower.isle line 3603.
                    let expr0_0 = constructor_output_value(ctx, pattern2_1)?;
                    return Some(expr0_0);
                }
            }
        }
        &InstructionData::Store {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            if let &Opcode::Store = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if pattern5_0 == F32 {
                    // Rule at src/isa/x64/lower.isle line 2629.
                    let expr0_0 = SseOpcode::Movss;
                    let expr1_0 = constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                    let expr2_0 = C::amode_to_synthetic_amode(ctx, &expr1_0);
                    let expr3_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                    let expr4_0 = constructor_x64_xmm_movrm(ctx, &expr0_0, &expr2_0, expr3_0)?;
                    let expr5_0 = constructor_side_effect(ctx, &expr4_0)?;
                    return Some(expr5_0);
                }
                if pattern5_0 == F64 {
                    // Rule at src/isa/x64/lower.isle line 2637.
                    let expr0_0 = SseOpcode::Movsd;
                    let expr1_0 = constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                    let expr2_0 = C::amode_to_synthetic_amode(ctx, &expr1_0);
                    let expr3_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                    let expr4_0 = constructor_x64_xmm_movrm(ctx, &expr0_0, &expr2_0, expr3_0)?;
                    let expr5_0 = constructor_side_effect(ctx, &expr4_0)?;
                    return Some(expr5_0);
                }
                if pattern5_0 == F32X4 {
                    // Rule at src/isa/x64/lower.isle line 2645.
                    let expr0_0 = SseOpcode::Movups;
                    let expr1_0 = constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                    let expr2_0 = C::amode_to_synthetic_amode(ctx, &expr1_0);
                    let expr3_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                    let expr4_0 = constructor_x64_xmm_movrm(ctx, &expr0_0, &expr2_0, expr3_0)?;
                    let expr5_0 = constructor_side_effect(ctx, &expr4_0)?;
                    return Some(expr5_0);
                }
                if pattern5_0 == F64X2 {
                    // Rule at src/isa/x64/lower.isle line 2653.
                    let expr0_0 = SseOpcode::Movupd;
                    let expr1_0 = constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                    let expr2_0 = C::amode_to_synthetic_amode(ctx, &expr1_0);
                    let expr3_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                    let expr4_0 = constructor_x64_xmm_movrm(ctx, &expr0_0, &expr2_0, expr3_0)?;
                    let expr5_0 = constructor_side_effect(ctx, &expr4_0)?;
                    return Some(expr5_0);
                }
            }
        }
        &InstructionData::IntCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Icmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if pattern5_0 == I64X2 {
                    match pattern2_2 {
                        &IntCC::SignedGreaterThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1600.
                            let expr0_0: Type = I64X2;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                            let expr2_0 = C::put_in_xmm_mem(ctx, pattern4_0);
                            let expr3_0 = constructor_x64_pcmpgt(ctx, expr0_0, expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_vector_all_ones(ctx)?;
                            let expr5_0 = C::xmm_to_xmm_mem(ctx, expr4_0);
                            let expr6_0 = constructor_x64_pxor(ctx, expr3_0, &expr5_0)?;
                            let expr7_0 = constructor_output_xmm(ctx, expr6_0)?;
                            return Some(expr7_0);
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1604.
                            let expr0_0: Type = I64X2;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr2_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr3_0 = constructor_x64_pcmpgt(ctx, expr0_0, expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_vector_all_ones(ctx)?;
                            let expr5_0 = C::xmm_to_xmm_mem(ctx, expr4_0);
                            let expr6_0 = constructor_x64_pxor(ctx, expr3_0, &expr5_0)?;
                            let expr7_0 = constructor_output_xmm(ctx, expr6_0)?;
                            return Some(expr7_0);
                        }
                        _ => {}
                    }
                }
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I8 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Bitrev = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 2024.
                    let expr0_0: Type = I32;
                    let expr1_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                    let expr2_0 = constructor_do_bitrev8(ctx, expr0_0, expr1_0)?;
                    let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                    return Some(expr3_0);
                }
            }
        }
        if pattern2_0 == I16 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Bitrev => {
                        // Rule at src/isa/x64/lower.isle line 2027.
                        let expr0_0: Type = I32;
                        let expr1_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                        let expr2_0 = constructor_do_bitrev16(ctx, expr0_0, expr1_0)?;
                        let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Bswap => {
                        // Rule at src/isa/x64/lower.isle line 2103.
                        let expr0_0: Type = I16;
                        let expr1_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                        let expr2_0: u8 = 8i128 as u8;
                        let expr3_0 = Imm8Reg::Imm8 { imm: expr2_0 };
                        let expr4_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr3_0);
                        let expr5_0 = constructor_x64_rotl(ctx, expr0_0, expr1_0, &expr4_0)?;
                        let expr6_0 = constructor_output_gpr(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Bitrev => {
                            // Rule at src/isa/x64/lower.isle line 2030.
                            let expr0_0: Type = I32;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                            let expr2_0 = constructor_do_bitrev32(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Bswap => {
                            // Rule at src/isa/x64/lower.isle line 2106.
                            let expr0_0: Type = I32;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                            let expr2_0 = constructor_x64_bswap(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::LoadNoOffset {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                } => {
                    if let &Opcode::Bitcast = pattern5_0 {
                        let pattern7_0 = C::value_type(ctx, pattern5_1);
                        if pattern7_0 == F32 {
                            // Rule at src/isa/x64/lower.isle line 3330.
                            let expr0_0: Type = F32;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr2_0 = constructor_bitcast_xmm_to_gpr(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == I64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Bitrev => {
                            // Rule at src/isa/x64/lower.isle line 2033.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                            let expr2_0 = constructor_do_bitrev64(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Bswap => {
                            // Rule at src/isa/x64/lower.isle line 2109.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                            let expr2_0 = constructor_x64_bswap(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Uextend => {
                            if let Some(pattern7_0) = C::def_inst(ctx, pattern5_1) {
                                if let Some(pattern8_0) = C::first_result(ctx, pattern7_0) {
                                    let pattern9_0 = C::value_type(ctx, pattern8_0);
                                    if pattern9_0 == I32 {
                                        let pattern11_0 = C::inst_data(ctx, pattern7_0);
                                        match &pattern11_0 {
                                            &InstructionData::Load {
                                                opcode: ref pattern12_0,
                                                arg: pattern12_1,
                                                flags: pattern12_2,
                                                offset: pattern12_3,
                                            } => {
                                                if let &Opcode::Uload32 = pattern12_0 {
                                                    // Rule at src/isa/x64/lower.isle line 2194.
                                                    let expr0_0 =
                                                        constructor_output_value(ctx, pattern5_1)?;
                                                    return Some(expr0_0);
                                                }
                                            }
                                            &InstructionData::Binary {
                                                opcode: ref pattern12_0,
                                                args: ref pattern12_1,
                                            } => {
                                                match pattern12_0 {
                                                    &Opcode::Iadd => {
                                                        let (pattern14_0, pattern14_1) =
                                                            C::unpack_value_array_2(
                                                                ctx,
                                                                pattern12_1,
                                                            );
                                                        // Rule at src/isa/x64/lower.isle line 2167.
                                                        let expr0_0 = constructor_output_value(
                                                            ctx, pattern5_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    }
                                                    &Opcode::Isub => {
                                                        let (pattern14_0, pattern14_1) =
                                                            C::unpack_value_array_2(
                                                                ctx,
                                                                pattern12_1,
                                                            );
                                                        // Rule at src/isa/x64/lower.isle line 2173.
                                                        let expr0_0 = constructor_output_value(
                                                            ctx, pattern5_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    }
                                                    &Opcode::Imul => {
                                                        let (pattern14_0, pattern14_1) =
                                                            C::unpack_value_array_2(
                                                                ctx,
                                                                pattern12_1,
                                                            );
                                                        // Rule at src/isa/x64/lower.isle line 2176.
                                                        let expr0_0 = constructor_output_value(
                                                            ctx, pattern5_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    }
                                                    &Opcode::IaddIfcout => {
                                                        let (pattern14_0, pattern14_1) =
                                                            C::unpack_value_array_2(
                                                                ctx,
                                                                pattern12_1,
                                                            );
                                                        // Rule at src/isa/x64/lower.isle line 2170.
                                                        let expr0_0 = constructor_output_value(
                                                            ctx, pattern5_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    }
                                                    &Opcode::Band => {
                                                        let (pattern14_0, pattern14_1) =
                                                            C::unpack_value_array_2(
                                                                ctx,
                                                                pattern12_1,
                                                            );
                                                        // Rule at src/isa/x64/lower.isle line 2179.
                                                        let expr0_0 = constructor_output_value(
                                                            ctx, pattern5_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    }
                                                    &Opcode::Bor => {
                                                        let (pattern14_0, pattern14_1) =
                                                            C::unpack_value_array_2(
                                                                ctx,
                                                                pattern12_1,
                                                            );
                                                        // Rule at src/isa/x64/lower.isle line 2182.
                                                        let expr0_0 = constructor_output_value(
                                                            ctx, pattern5_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    }
                                                    &Opcode::Bxor => {
                                                        let (pattern14_0, pattern14_1) =
                                                            C::unpack_value_array_2(
                                                                ctx,
                                                                pattern12_1,
                                                            );
                                                        // Rule at src/isa/x64/lower.isle line 2185.
                                                        let expr0_0 = constructor_output_value(
                                                            ctx, pattern5_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    }
                                                    &Opcode::Ishl => {
                                                        let (pattern14_0, pattern14_1) =
                                                            C::unpack_value_array_2(
                                                                ctx,
                                                                pattern12_1,
                                                            );
                                                        // Rule at src/isa/x64/lower.isle line 2188.
                                                        let expr0_0 = constructor_output_value(
                                                            ctx, pattern5_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    }
                                                    &Opcode::Ushr => {
                                                        let (pattern14_0, pattern14_1) =
                                                            C::unpack_value_array_2(
                                                                ctx,
                                                                pattern12_1,
                                                            );
                                                        // Rule at src/isa/x64/lower.isle line 2191.
                                                        let expr0_0 = constructor_output_value(
                                                            ctx, pattern5_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    }
                                                    _ => {}
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
                &InstructionData::LoadNoOffset {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                } => {
                    if let &Opcode::Bitcast = pattern5_0 {
                        let pattern7_0 = C::value_type(ctx, pattern5_1);
                        if pattern7_0 == F64 {
                            // Rule at src/isa/x64/lower.isle line 3336.
                            let expr0_0: Type = F64;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr2_0 = constructor_bitcast_xmm_to_gpr(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Bnot => {
                            // Rule at src/isa/x64/lower.isle line 1260.
                            let expr0_0 = constructor_i128_not(ctx, pattern5_1)?;
                            let expr1_0 = C::output(ctx, expr0_0);
                            return Some(expr1_0);
                        }
                        &Opcode::Bitrev => {
                            // Rule at src/isa/x64/lower.isle line 2036.
                            let expr0_0: Type = I64;
                            let expr1_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr2_0: usize = 1i128 as usize;
                            let expr3_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_do_bitrev64(ctx, expr0_0, expr3_0)?;
                            let expr5_0 = C::gpr_to_reg(ctx, expr4_0);
                            let expr6_0: Type = I64;
                            let expr7_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr8_0: usize = 0i128 as usize;
                            let expr9_0 = constructor_value_regs_get_gpr(ctx, expr7_0, expr8_0)?;
                            let expr10_0 = constructor_do_bitrev64(ctx, expr6_0, expr9_0)?;
                            let expr11_0 = C::gpr_to_reg(ctx, expr10_0);
                            let expr12_0 = C::value_regs(ctx, expr5_0, expr11_0);
                            let expr13_0 = C::output(ctx, expr12_0);
                            return Some(expr13_0);
                        }
                        &Opcode::Clz => {
                            // Rule at src/isa/x64/lower.isle line 1804.
                            let expr0_0: Type = I64;
                            let expr1_0: Type = I64;
                            let expr2_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr3_0: usize = 1i128 as usize;
                            let expr4_0 = constructor_value_regs_get_gpr(ctx, expr2_0, expr3_0)?;
                            let expr5_0 = constructor_do_clz(ctx, expr0_0, expr1_0, expr4_0)?;
                            let expr6_0: Type = I64;
                            let expr7_0: Type = I64;
                            let expr8_0: Type = I64;
                            let expr9_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr10_0: usize = 0i128 as usize;
                            let expr11_0 = constructor_value_regs_get_gpr(ctx, expr9_0, expr10_0)?;
                            let expr12_0 = constructor_do_clz(ctx, expr7_0, expr8_0, expr11_0)?;
                            let expr13_0: u32 = 64i128 as u32;
                            let expr14_0 = RegMemImm::Imm { simm32: expr13_0 };
                            let expr15_0 = C::gpr_mem_imm_new(ctx, &expr14_0);
                            let expr16_0 = constructor_x64_add(ctx, expr6_0, expr12_0, &expr15_0)?;
                            let expr17_0 = OperandSize::Size64;
                            let expr18_0: u32 = 64i128 as u32;
                            let expr19_0 =
                                constructor_x64_cmp_imm(ctx, &expr17_0, expr18_0, expr5_0)?;
                            let expr20_0: Type = I64;
                            let expr21_0 = CC::NZ;
                            let expr22_0 = C::gpr_to_gpr_mem(ctx, expr5_0);
                            let expr23_0 =
                                constructor_cmove(ctx, expr20_0, &expr21_0, &expr22_0, expr16_0)?;
                            let expr24_0 = constructor_with_flags_reg(ctx, &expr19_0, &expr23_0)?;
                            let expr25_0 = C::gpr_new(ctx, expr24_0);
                            let expr26_0 = C::gpr_to_reg(ctx, expr25_0);
                            let expr27_0: Type = I64;
                            let expr28_0: u64 = 0i128 as u64;
                            let expr29_0 = constructor_imm(ctx, expr27_0, expr28_0)?;
                            let expr30_0 = C::value_regs(ctx, expr26_0, expr29_0);
                            let expr31_0 = C::output(ctx, expr30_0);
                            return Some(expr31_0);
                        }
                        &Opcode::Ctz => {
                            // Rule at src/isa/x64/lower.isle line 1848.
                            let expr0_0: Type = I64;
                            let expr1_0: Type = I64;
                            let expr2_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr3_0: usize = 0i128 as usize;
                            let expr4_0 = constructor_value_regs_get_gpr(ctx, expr2_0, expr3_0)?;
                            let expr5_0 = constructor_do_ctz(ctx, expr0_0, expr1_0, expr4_0)?;
                            let expr6_0: Type = I64;
                            let expr7_0: Type = I64;
                            let expr8_0: Type = I64;
                            let expr9_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr10_0: usize = 1i128 as usize;
                            let expr11_0 = constructor_value_regs_get_gpr(ctx, expr9_0, expr10_0)?;
                            let expr12_0 = constructor_do_ctz(ctx, expr7_0, expr8_0, expr11_0)?;
                            let expr13_0: u32 = 64i128 as u32;
                            let expr14_0 = RegMemImm::Imm { simm32: expr13_0 };
                            let expr15_0 = C::gpr_mem_imm_new(ctx, &expr14_0);
                            let expr16_0 = constructor_x64_add(ctx, expr6_0, expr12_0, &expr15_0)?;
                            let expr17_0 = OperandSize::Size64;
                            let expr18_0: u32 = 64i128 as u32;
                            let expr19_0 =
                                constructor_x64_cmp_imm(ctx, &expr17_0, expr18_0, expr5_0)?;
                            let expr20_0: Type = I64;
                            let expr21_0 = CC::Z;
                            let expr22_0 = C::gpr_to_gpr_mem(ctx, expr16_0);
                            let expr23_0 =
                                constructor_cmove(ctx, expr20_0, &expr21_0, &expr22_0, expr5_0)?;
                            let expr24_0 = constructor_with_flags_reg(ctx, &expr19_0, &expr23_0)?;
                            let expr25_0 = C::gpr_new(ctx, expr24_0);
                            let expr26_0 = C::gpr_to_reg(ctx, expr25_0);
                            let expr27_0: Type = I64;
                            let expr28_0: u64 = 0i128 as u64;
                            let expr29_0 = constructor_imm(ctx, expr27_0, expr28_0)?;
                            let expr30_0 = C::value_regs(ctx, expr26_0, expr29_0);
                            let expr31_0 = C::output(ctx, expr30_0);
                            return Some(expr31_0);
                        }
                        &Opcode::Bswap => {
                            // Rule at src/isa/x64/lower.isle line 2112.
                            let expr0_0: Type = I64;
                            let expr1_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr2_0: usize = 1i128 as usize;
                            let expr3_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_x64_bswap(ctx, expr0_0, expr3_0)?;
                            let expr5_0 = C::gpr_to_reg(ctx, expr4_0);
                            let expr6_0: Type = I64;
                            let expr7_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr8_0: usize = 0i128 as usize;
                            let expr9_0 = constructor_value_regs_get_gpr(ctx, expr7_0, expr8_0)?;
                            let expr10_0 = constructor_x64_bswap(ctx, expr6_0, expr9_0)?;
                            let expr11_0 = C::gpr_to_reg(ctx, expr10_0);
                            let expr12_0 = C::value_regs(ctx, expr5_0, expr11_0);
                            let expr13_0 = C::output(ctx, expr12_0);
                            return Some(expr13_0);
                        }
                        &Opcode::Popcnt => {
                            // Rule at src/isa/x64/lower.isle line 1900.
                            let expr0_0: Type = I64;
                            let expr1_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr2_0: usize = 0i128 as usize;
                            let expr3_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_do_popcnt(ctx, expr0_0, expr3_0)?;
                            let expr5_0: Type = I64;
                            let expr6_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr7_0: usize = 1i128 as usize;
                            let expr8_0 = constructor_value_regs_get_gpr(ctx, expr6_0, expr7_0)?;
                            let expr9_0 = constructor_do_popcnt(ctx, expr5_0, expr8_0)?;
                            let expr10_0: Type = I64;
                            let expr11_0 = C::gpr_to_gpr_mem_imm(ctx, expr9_0);
                            let expr12_0 = constructor_x64_add(ctx, expr10_0, expr4_0, &expr11_0)?;
                            let expr13_0 = C::gpr_to_reg(ctx, expr12_0);
                            let expr14_0: Type = I64;
                            let expr15_0: u64 = 0i128 as u64;
                            let expr16_0 = constructor_imm(ctx, expr14_0, expr15_0)?;
                            let expr17_0 = C::value_regs(ctx, expr13_0, expr16_0);
                            let expr18_0 = C::output(ctx, expr17_0);
                            return Some(expr18_0);
                        }
                        &Opcode::Uextend => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::fits_in_32(ctx, pattern7_0) {
                                // Rule at src/isa/x64/lower.isle line 2145.
                                let expr0_0: Type = I64;
                                let expr1_0 = ExtendKind::Zero;
                                let expr2_0 =
                                    constructor_extend_to_gpr(ctx, pattern5_1, expr0_0, &expr1_0)?;
                                let expr3_0 = C::gpr_to_reg(ctx, expr2_0);
                                let expr4_0: Type = I64;
                                let expr5_0: u64 = 0i128 as u64;
                                let expr6_0 = constructor_imm(ctx, expr4_0, expr5_0)?;
                                let expr7_0 = C::value_regs(ctx, expr3_0, expr6_0);
                                let expr8_0 = C::output(ctx, expr7_0);
                                return Some(expr8_0);
                            }
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Rotl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 764.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = constructor_lo_gpr(ctx, pattern7_1)?;
                            let expr2_0 = constructor_shl_i128(ctx, expr0_0, expr1_0)?;
                            let expr3_0: Type = I64;
                            let expr4_0: Type = I64;
                            let expr5_0: u64 = 128i128 as u64;
                            let expr6_0 = constructor_imm(ctx, expr4_0, expr5_0)?;
                            let expr7_0 = C::gpr_new(ctx, expr6_0);
                            let expr8_0 = C::gpr_to_gpr_mem_imm(ctx, expr1_0);
                            let expr9_0 = constructor_x64_sub(ctx, expr3_0, expr7_0, &expr8_0)?;
                            let expr10_0 = constructor_shr_i128(ctx, expr0_0, expr9_0)?;
                            let expr11_0 = constructor_or_i128(ctx, expr2_0, expr10_0)?;
                            let expr12_0 = C::output(ctx, expr11_0);
                            return Some(expr12_0);
                        }
                        &Opcode::Rotr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 785.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = constructor_lo_gpr(ctx, pattern7_1)?;
                            let expr2_0 = constructor_shr_i128(ctx, expr0_0, expr1_0)?;
                            let expr3_0: Type = I64;
                            let expr4_0: Type = I64;
                            let expr5_0: u64 = 128i128 as u64;
                            let expr6_0 = constructor_imm(ctx, expr4_0, expr5_0)?;
                            let expr7_0 = C::gpr_new(ctx, expr6_0);
                            let expr8_0 = C::gpr_to_gpr_mem_imm(ctx, expr1_0);
                            let expr9_0 = constructor_x64_sub(ctx, expr3_0, expr7_0, &expr8_0)?;
                            let expr10_0 = constructor_shl_i128(ctx, expr0_0, expr9_0)?;
                            let expr11_0 = constructor_or_i128(ctx, expr2_0, expr10_0)?;
                            let expr12_0 = C::output(ctx, expr11_0);
                            return Some(expr12_0);
                        }
                        &Opcode::Ishl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 461.
                            let expr0_0 = constructor_lo_gpr(ctx, pattern7_1)?;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = constructor_shl_i128(ctx, expr1_0, expr0_0)?;
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Ushr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 567.
                            let expr0_0 = constructor_lo_gpr(ctx, pattern7_1)?;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = constructor_shr_i128(ctx, expr1_0, expr0_0)?;
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Sshr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 677.
                            let expr0_0 = constructor_lo_gpr(ctx, pattern7_1)?;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = constructor_sar_i128(ctx, expr1_0, expr0_0)?;
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Sqrt => {
                            // Rule at src/isa/x64/lower.isle line 2307.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_x64_sqrtss(ctx, expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        &Opcode::Fneg => {
                            // Rule at src/isa/x64/lower.isle line 1181.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0: Type = F32;
                            let expr2_0: u64 = 2147483648i128 as u64;
                            let expr3_0 = constructor_imm(ctx, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_reg_to_xmm_mem(ctx, expr3_0)?;
                            let expr5_0 = constructor_x64_xorps(ctx, expr0_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &Opcode::Fabs => {
                            // Rule at src/isa/x64/lower.isle line 1161.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0: Type = F32;
                            let expr2_0: u64 = 2147483647i128 as u64;
                            let expr3_0 = constructor_imm(ctx, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_reg_to_xmm_mem(ctx, expr3_0)?;
                            let expr5_0 = constructor_x64_andps(ctx, expr0_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &Opcode::Fdemote => {
                            // Rule at src/isa/x64/lower.isle line 2325.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_x64_cvtsd2ss(ctx, expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::LoadNoOffset {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                } => {
                    if let &Opcode::Bitcast = pattern5_0 {
                        let pattern7_0 = C::value_type(ctx, pattern5_1);
                        if pattern7_0 == I32 {
                            // Rule at src/isa/x64/lower.isle line 3333.
                            let expr0_0: Type = I32;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                            let expr2_0 = constructor_bitcast_gpr_to_xmm(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                &InstructionData::Load {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                    offset: pattern5_3,
                } => {
                    if let &Opcode::Load = pattern5_0 {
                        // Rule at src/isa/x64/lower.isle line 2572.
                        let expr0_0 =
                            constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                        let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                        let expr2_0 = constructor_x64_movss_load(ctx, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Fadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2264.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_addss(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fsub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2275.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_subss(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2286.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_mulss(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fdiv => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2297.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_divss(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fcopysign => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            let pattern8_0 = C::value_type(ctx, pattern7_0);
                            if pattern8_0 == F32 {
                                // Rule at src/isa/x64/lower.isle line 3352.
                                let expr0_0: Type = F32;
                                let expr1_0: u64 = 2147483648i128 as u64;
                                let expr2_0 = constructor_imm(ctx, expr0_0, expr1_0)?;
                                let expr3_0 = C::xmm_new(ctx, expr2_0);
                                let expr4_0 = C::put_in_xmm_mem(ctx, pattern7_0);
                                let expr5_0 = constructor_x64_andnps(ctx, expr3_0, &expr4_0)?;
                                let expr6_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                                let expr7_0 = constructor_x64_andps(ctx, expr3_0, &expr6_0)?;
                                let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                                let expr9_0 = constructor_x64_orps(ctx, expr5_0, &expr8_0)?;
                                let expr10_0 = constructor_output_xmm(ctx, expr9_0)?;
                                return Some(expr10_0);
                            }
                        }
                        &Opcode::Fmin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2334.
                            let expr0_0: Type = F32;
                            let expr1_0: bool = true;
                            let expr2_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr4_0 = constructor_xmm_min_max_seq(
                                ctx, expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_xmm(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        &Opcode::FminPseudo => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2503.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr2_0 = constructor_x64_minss(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2406.
                            let expr0_0: Type = F32;
                            let expr1_0: bool = false;
                            let expr2_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr4_0 = constructor_xmm_min_max_seq(
                                ctx, expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_xmm(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        &Opcode::FmaxPseudo => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2514.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr2_0 = constructor_x64_maxss(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Ternary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::Fma = pattern5_0 {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 2525.
                        let expr0_0 = LibCall::FmaF32;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = C::put_in_reg(ctx, pattern7_2);
                        let expr4_0 = C::libcall_3(ctx, &expr0_0, expr1_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Sqrt => {
                            // Rule at src/isa/x64/lower.isle line 2309.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_x64_sqrtsd(ctx, expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        &Opcode::Fneg => {
                            // Rule at src/isa/x64/lower.isle line 1184.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0: Type = F64;
                            let expr2_0: u64 = 9223372036854775808i128 as u64;
                            let expr3_0 = constructor_imm(ctx, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_reg_to_xmm_mem(ctx, expr3_0)?;
                            let expr5_0 = constructor_x64_xorpd(ctx, expr0_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &Opcode::Fabs => {
                            // Rule at src/isa/x64/lower.isle line 1164.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0: Type = F64;
                            let expr2_0: u64 = 9223372036854775807i128 as u64;
                            let expr3_0 = constructor_imm(ctx, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_reg_to_xmm_mem(ctx, expr3_0)?;
                            let expr5_0 = constructor_x64_andpd(ctx, expr0_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &Opcode::Fpromote => {
                            // Rule at src/isa/x64/lower.isle line 2317.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_x64_cvtss2sd(ctx, expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::LoadNoOffset {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                } => {
                    if let &Opcode::Bitcast = pattern5_0 {
                        let pattern7_0 = C::value_type(ctx, pattern5_1);
                        if pattern7_0 == I64 {
                            // Rule at src/isa/x64/lower.isle line 3339.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                            let expr2_0 = constructor_bitcast_gpr_to_xmm(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                }
                &InstructionData::Load {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                    offset: pattern5_3,
                } => {
                    if let &Opcode::Load = pattern5_0 {
                        // Rule at src/isa/x64/lower.isle line 2574.
                        let expr0_0 =
                            constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                        let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                        let expr2_0 = constructor_x64_movsd_load(ctx, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Fadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2266.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_addsd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fsub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2277.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_subsd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2288.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_mulsd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fdiv => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2299.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_divsd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fcopysign => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            let pattern8_0 = C::value_type(ctx, pattern7_0);
                            if pattern8_0 == F64 {
                                // Rule at src/isa/x64/lower.isle line 3358.
                                let expr0_0: Type = F64;
                                let expr1_0: u64 = 9223372036854775808i128 as u64;
                                let expr2_0 = constructor_imm(ctx, expr0_0, expr1_0)?;
                                let expr3_0 = C::xmm_new(ctx, expr2_0);
                                let expr4_0 = C::put_in_xmm_mem(ctx, pattern7_0);
                                let expr5_0 = constructor_x64_andnpd(ctx, expr3_0, &expr4_0)?;
                                let expr6_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                                let expr7_0 = constructor_x64_andpd(ctx, expr3_0, &expr6_0)?;
                                let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                                let expr9_0 = constructor_x64_orpd(ctx, expr5_0, &expr8_0)?;
                                let expr10_0 = constructor_output_xmm(ctx, expr9_0)?;
                                return Some(expr10_0);
                            }
                        }
                        &Opcode::Fmin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2336.
                            let expr0_0: Type = F64;
                            let expr1_0: bool = true;
                            let expr2_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr4_0 = constructor_xmm_min_max_seq(
                                ctx, expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_xmm(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        &Opcode::FminPseudo => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2505.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr2_0 = constructor_x64_minsd(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2408.
                            let expr0_0: Type = F64;
                            let expr1_0: bool = false;
                            let expr2_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr4_0 = constructor_xmm_min_max_seq(
                                ctx, expr0_0, expr1_0, expr2_0, expr3_0,
                            )?;
                            let expr5_0 = constructor_output_xmm(ctx, expr4_0)?;
                            return Some(expr5_0);
                        }
                        &Opcode::FmaxPseudo => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2516.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr2_0 = constructor_x64_maxsd(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Ternary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::Fma = pattern5_0 {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 2527.
                        let expr0_0 = LibCall::FmaF64;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = C::put_in_reg(ctx, pattern7_2);
                        let expr4_0 = C::libcall_3(ctx, &expr0_0, expr1_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                        return Some(expr5_0);
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == I8X16 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Ineg => {
                            // Rule at src/isa/x64/lower.isle line 813.
                            let expr0_0: Type = I8X16;
                            let expr1_0: u64 = 0i128 as u64;
                            let expr2_0 = constructor_imm(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::xmm_new(ctx, expr2_0);
                            let expr4_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                            let expr5_0 = constructor_x64_psubb(ctx, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &Opcode::Iabs => {
                            // Rule at src/isa/x64/lower.isle line 1134.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                            let expr1_0 = constructor_x64_pabsb(ctx, &expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        &Opcode::Popcnt => {
                            // Rule at src/isa/x64/lower.isle line 2007.
                            let expr0_0 = C::popcount_4bit_table(ctx);
                            let expr1_0: Type = I8X16;
                            let expr2_0 = C::popcount_low_mask(ctx);
                            let expr3_0 = constructor_x64_xmm_load_const(ctx, expr1_0, expr2_0)?;
                            let expr4_0: Type = I8X16;
                            let expr5_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                            let expr7_0 = constructor_sse_and(ctx, expr4_0, expr5_0, &expr6_0)?;
                            let expr8_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr9_0: u32 = 4i128 as u32;
                            let expr10_0 = RegMemImm::Imm { simm32: expr9_0 };
                            let expr11_0 = constructor_mov_rmi_to_xmm(ctx, &expr10_0)?;
                            let expr12_0 = constructor_x64_psrlw(ctx, expr8_0, &expr11_0)?;
                            let expr13_0: Type = I8X16;
                            let expr14_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                            let expr15_0 = constructor_sse_and(ctx, expr13_0, expr12_0, &expr14_0)?;
                            let expr16_0: Type = I8X16;
                            let expr17_0 = C::popcount_4bit_table(ctx);
                            let expr18_0 = constructor_x64_xmm_load_const(ctx, expr16_0, expr17_0)?;
                            let expr19_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                            let expr20_0 = constructor_x64_pshufb(ctx, expr18_0, &expr19_0)?;
                            let expr21_0 = C::xmm_to_xmm_mem(ctx, expr15_0);
                            let expr22_0 = constructor_x64_pshufb(ctx, expr18_0, &expr21_0)?;
                            let expr23_0 = C::xmm_to_xmm_mem(ctx, expr22_0);
                            let expr24_0 = constructor_x64_paddb(ctx, expr20_0, &expr23_0)?;
                            let expr25_0 = constructor_output_xmm(ctx, expr24_0)?;
                            return Some(expr25_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Smin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1421.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pminsb(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Umin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1443.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pminub(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Smax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1410.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pmaxsb(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Umax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1432.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pmaxub(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Ishl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 473.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_psllw(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr12_0 = constructor_ishl_i8x16_mask(ctx, &expr11_0)?;
                            let expr13_0: Type = I8X16;
                            let expr14_0 = ExtKind::None;
                            let expr15_0 =
                                constructor_x64_load(ctx, expr13_0, &expr12_0, &expr14_0)?;
                            let expr16_0: Type = I8X16;
                            let expr17_0 = RegMem::Reg { reg: expr15_0 };
                            let expr18_0 = C::reg_mem_to_xmm_mem(ctx, &expr17_0);
                            let expr19_0 = constructor_sse_and(ctx, expr16_0, expr10_0, &expr18_0)?;
                            let expr20_0 = constructor_output_xmm(ctx, expr19_0)?;
                            return Some(expr20_0);
                        }
                        &Opcode::Ushr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 577.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_psrlw(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr12_0 = constructor_ushr_i8x16_mask(ctx, &expr11_0)?;
                            let expr13_0: Type = I8X16;
                            let expr14_0 = ExtKind::None;
                            let expr15_0 =
                                constructor_x64_load(ctx, expr13_0, &expr12_0, &expr14_0)?;
                            let expr16_0: Type = I8X16;
                            let expr17_0 = RegMem::Reg { reg: expr15_0 };
                            let expr18_0 = C::reg_mem_to_xmm_mem(ctx, &expr17_0);
                            let expr19_0 = constructor_sse_and(ctx, expr16_0, expr10_0, &expr18_0)?;
                            let expr20_0 = constructor_output_xmm(ctx, expr19_0)?;
                            return Some(expr20_0);
                        }
                        &Opcode::Sshr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            let pattern8_0 = C::value_type(ctx, pattern7_1);
                            // Rule at src/isa/x64/lower.isle line 698.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0: Type = I64;
                            let expr2_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr3_0 = C::shift_mask(ctx, pattern2_0);
                            let expr4_0 = RegMemImm::Imm { simm32: expr3_0 };
                            let expr5_0 = C::gpr_mem_imm_new(ctx, &expr4_0);
                            let expr6_0 = constructor_x64_and(ctx, expr1_0, expr2_0, &expr5_0)?;
                            let expr7_0 = C::gpr_to_reg(ctx, expr6_0);
                            let expr8_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                            let expr9_0 = constructor_x64_punpcklbw(ctx, expr0_0, &expr8_0)?;
                            let expr10_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                            let expr11_0 = constructor_x64_punpckhbw(ctx, expr0_0, &expr10_0)?;
                            let expr12_0 = C::reg_to_reg_mem_imm(ctx, expr7_0);
                            let expr13_0 =
                                constructor_sshr_i8x16_bigger_shift(ctx, pattern8_0, &expr12_0)?;
                            let expr14_0 = constructor_x64_psraw(ctx, expr9_0, &expr13_0)?;
                            let expr15_0 = constructor_x64_psraw(ctx, expr11_0, &expr13_0)?;
                            let expr16_0 = C::xmm_to_xmm_mem(ctx, expr15_0);
                            let expr17_0 = constructor_x64_packsswb(ctx, expr14_0, &expr16_0)?;
                            let expr18_0 = constructor_output_xmm(ctx, expr17_0)?;
                            return Some(expr18_0);
                        }
                        &Opcode::Snarrow => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            let pattern8_0 = C::value_type(ctx, pattern7_0);
                            if pattern8_0 == I16X8 {
                                // Rule at src/isa/x64/lower.isle line 3285.
                                let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                                let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                                let expr2_0 = constructor_x64_packsswb(ctx, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                        &Opcode::Unarrow => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            let pattern8_0 = C::value_type(ctx, pattern7_0);
                            if pattern8_0 == I16X8 {
                                // Rule at src/isa/x64/lower.isle line 3319.
                                let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                                let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                                let expr2_0 = constructor_x64_packuswb(ctx, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == I16X8 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Ineg => {
                            // Rule at src/isa/x64/lower.isle line 816.
                            let expr0_0: Type = I16X8;
                            let expr1_0: u64 = 0i128 as u64;
                            let expr2_0 = constructor_imm(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::xmm_new(ctx, expr2_0);
                            let expr4_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                            let expr5_0 = constructor_x64_psubw(ctx, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &Opcode::Iabs => {
                            // Rule at src/isa/x64/lower.isle line 1137.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                            let expr1_0 = constructor_x64_pabsw(ctx, &expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        &Opcode::SwidenLow => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I8X16 {
                                // Rule at src/isa/x64/lower.isle line 3237.
                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                                let expr1_0 = constructor_x64_pmovsxbw(ctx, &expr0_0)?;
                                let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                return Some(expr2_0);
                            }
                        }
                        &Opcode::SwidenHigh => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I8X16 {
                                // Rule at src/isa/x64/lower.isle line 3248.
                                let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                                let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                                let expr2_0: u8 = 8i128 as u8;
                                let expr3_0 = OperandSize::Size32;
                                let expr4_0 = constructor_x64_palignr(
                                    ctx, expr0_0, &expr1_0, expr2_0, &expr3_0,
                                )?;
                                let expr5_0 = C::xmm_to_xmm_mem(ctx, expr4_0);
                                let expr6_0 = constructor_x64_pmovsxbw(ctx, &expr5_0)?;
                                let expr7_0 = constructor_output_xmm(ctx, expr6_0)?;
                                return Some(expr7_0);
                            }
                        }
                        &Opcode::UwidenLow => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I8X16 {
                                // Rule at src/isa/x64/lower.isle line 3261.
                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                                let expr1_0 = constructor_x64_pmovzxbw(ctx, &expr0_0)?;
                                let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                return Some(expr2_0);
                            }
                        }
                        &Opcode::UwidenHigh => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I8X16 {
                                // Rule at src/isa/x64/lower.isle line 3272.
                                let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                                let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                                let expr2_0: u8 = 8i128 as u8;
                                let expr3_0 = OperandSize::Size32;
                                let expr4_0 = constructor_x64_palignr(
                                    ctx, expr0_0, &expr1_0, expr2_0, &expr3_0,
                                )?;
                                let expr5_0 = C::xmm_to_xmm_mem(ctx, expr4_0);
                                let expr6_0 = constructor_x64_pmovzxbw(ctx, &expr5_0)?;
                                let expr7_0 = constructor_output_xmm(ctx, expr6_0)?;
                                return Some(expr7_0);
                            }
                        }
                        _ => {}
                    }
                }
                &InstructionData::Load {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                    offset: pattern5_3,
                } => {
                    match pattern5_0 {
                        &Opcode::Uload8x8 => {
                            // Rule at src/isa/x64/lower.isle line 2596.
                            let expr0_0 =
                                constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                            let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                            let expr2_0 = constructor_x64_pmovzxbw(ctx, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Sload8x8 => {
                            // Rule at src/isa/x64/lower.isle line 2594.
                            let expr0_0 =
                                constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                            let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                            let expr2_0 = constructor_x64_pmovsxbw(ctx, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Smin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1424.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pminsw(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Umin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1446.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pminuw(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Smax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1413.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pmaxsw(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Umax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1435.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pmaxuw(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Ishl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 517.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_psllw(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                            return Some(expr11_0);
                        }
                        &Opcode::Ushr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 624.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_psrlw(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                            return Some(expr11_0);
                        }
                        &Opcode::Sshr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 727.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_psraw(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                            return Some(expr11_0);
                        }
                        &Opcode::Snarrow => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            let pattern8_0 = C::value_type(ctx, pattern7_0);
                            if pattern8_0 == I32X4 {
                                // Rule at src/isa/x64/lower.isle line 3288.
                                let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                                let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                                let expr2_0 = constructor_x64_packssdw(ctx, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                        &Opcode::Unarrow => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            let pattern8_0 = C::value_type(ctx, pattern7_0);
                            if pattern8_0 == I32X4 {
                                // Rule at src/isa/x64/lower.isle line 3322.
                                let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                                let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                                let expr2_0 = constructor_x64_packusdw(ctx, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                        &Opcode::IaddPairwise => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::Unary {
                                    opcode: ref pattern10_0,
                                    arg: pattern10_1,
                                } = &pattern9_0
                                {
                                    match pattern10_0 {
                                        &Opcode::SwidenLow => {
                                            let pattern12_0 = C::value_type(ctx, pattern10_1);
                                            if pattern12_0 == I8X16 {
                                                if let Some(pattern14_0) =
                                                    C::def_inst(ctx, pattern7_1)
                                                {
                                                    let pattern15_0 =
                                                        C::inst_data(ctx, pattern14_0);
                                                    if let &InstructionData::Unary {
                                                        opcode: ref pattern16_0,
                                                        arg: pattern16_1,
                                                    } = &pattern15_0
                                                    {
                                                        if let &Opcode::SwidenHigh = pattern16_0 {
                                                            if pattern16_1 == pattern10_1 {
                                                                // Rule at src/isa/x64/lower.isle line 3201.
                                                                let expr0_0: Type = I8X16;
                                                                let expr1_0 =
                                                                    C::iadd_pairwise_mul_const_16(
                                                                        ctx,
                                                                    );
                                                                let expr2_0 =
                                                                    constructor_x64_xmm_load_const(
                                                                        ctx, expr0_0, expr1_0,
                                                                    )?;
                                                                let expr3_0 = C::put_in_xmm_mem(
                                                                    ctx,
                                                                    pattern10_1,
                                                                );
                                                                let expr4_0 =
                                                                    constructor_x64_pmaddubsw(
                                                                        ctx, expr2_0, &expr3_0,
                                                                    )?;
                                                                let expr5_0 =
                                                                    constructor_output_xmm(
                                                                        ctx, expr4_0,
                                                                    )?;
                                                                return Some(expr5_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::UwidenLow => {
                                            let pattern12_0 = C::value_type(ctx, pattern10_1);
                                            if pattern12_0 == I8X16 {
                                                if let Some(pattern14_0) =
                                                    C::def_inst(ctx, pattern7_1)
                                                {
                                                    let pattern15_0 =
                                                        C::inst_data(ctx, pattern14_0);
                                                    if let &InstructionData::Unary {
                                                        opcode: ref pattern16_0,
                                                        arg: pattern16_1,
                                                    } = &pattern15_0
                                                    {
                                                        if let &Opcode::UwidenHigh = pattern16_0 {
                                                            if pattern16_1 == pattern10_1 {
                                                                // Rule at src/isa/x64/lower.isle line 3215.
                                                                let expr0_0: Type = I8X16;
                                                                let expr1_0 =
                                                                    C::iadd_pairwise_mul_const_16(
                                                                        ctx,
                                                                    );
                                                                let expr2_0 =
                                                                    constructor_x64_xmm_load_const(
                                                                        ctx, expr0_0, expr1_0,
                                                                    )?;
                                                                let expr3_0 =
                                                                    constructor_put_in_xmm(
                                                                        ctx,
                                                                        pattern10_1,
                                                                    )?;
                                                                let expr4_0 =
                                                                    C::xmm_to_xmm_mem(ctx, expr2_0);
                                                                let expr5_0 =
                                                                    constructor_x64_pmaddubsw(
                                                                        ctx, expr3_0, &expr4_0,
                                                                    )?;
                                                                let expr6_0 =
                                                                    constructor_output_xmm(
                                                                        ctx, expr5_0,
                                                                    )?;
                                                                return Some(expr6_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == I32X4 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Ineg => {
                            // Rule at src/isa/x64/lower.isle line 819.
                            let expr0_0: Type = I32X4;
                            let expr1_0: u64 = 0i128 as u64;
                            let expr2_0 = constructor_imm(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::xmm_new(ctx, expr2_0);
                            let expr4_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                            let expr5_0 = constructor_x64_psubd(ctx, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &Opcode::Iabs => {
                            // Rule at src/isa/x64/lower.isle line 1140.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                            let expr1_0 = constructor_x64_pabsd(ctx, &expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        &Opcode::SwidenLow => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I16X8 {
                                // Rule at src/isa/x64/lower.isle line 3240.
                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                                let expr1_0 = constructor_x64_pmovsxwd(ctx, &expr0_0)?;
                                let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                return Some(expr2_0);
                            }
                        }
                        &Opcode::SwidenHigh => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I16X8 {
                                // Rule at src/isa/x64/lower.isle line 3252.
                                let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                                let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                                let expr2_0: u8 = 8i128 as u8;
                                let expr3_0 = OperandSize::Size32;
                                let expr4_0 = constructor_x64_palignr(
                                    ctx, expr0_0, &expr1_0, expr2_0, &expr3_0,
                                )?;
                                let expr5_0 = C::xmm_to_xmm_mem(ctx, expr4_0);
                                let expr6_0 = constructor_x64_pmovsxwd(ctx, &expr5_0)?;
                                let expr7_0 = constructor_output_xmm(ctx, expr6_0)?;
                                return Some(expr7_0);
                            }
                        }
                        &Opcode::UwidenLow => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I16X8 {
                                // Rule at src/isa/x64/lower.isle line 3264.
                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                                let expr1_0 = constructor_x64_pmovzxwd(ctx, &expr0_0)?;
                                let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                return Some(expr2_0);
                            }
                        }
                        &Opcode::UwidenHigh => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I16X8 {
                                // Rule at src/isa/x64/lower.isle line 3276.
                                let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                                let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                                let expr2_0: u8 = 8i128 as u8;
                                let expr3_0 = OperandSize::Size32;
                                let expr4_0 = constructor_x64_palignr(
                                    ctx, expr0_0, &expr1_0, expr2_0, &expr3_0,
                                )?;
                                let expr5_0 = C::xmm_to_xmm_mem(ctx, expr4_0);
                                let expr6_0 = constructor_x64_pmovzxwd(ctx, &expr5_0)?;
                                let expr7_0 = constructor_output_xmm(ctx, expr6_0)?;
                                return Some(expr7_0);
                            }
                        }
                        _ => {}
                    }
                }
                &InstructionData::Load {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                    offset: pattern5_3,
                } => {
                    match pattern5_0 {
                        &Opcode::Uload16x4 => {
                            // Rule at src/isa/x64/lower.isle line 2600.
                            let expr0_0 =
                                constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                            let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                            let expr2_0 = constructor_x64_pmovzxwd(ctx, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Sload16x4 => {
                            // Rule at src/isa/x64/lower.isle line 2598.
                            let expr0_0 =
                                constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                            let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                            let expr2_0 = constructor_x64_pmovsxwd(ctx, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Smin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1427.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pminsd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Umin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1449.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pminud(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Smax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1416.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pmaxsd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Umax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1438.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pmaxud(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Ishl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 521.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_pslld(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                            return Some(expr11_0);
                        }
                        &Opcode::Ushr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 628.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_psrld(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                            return Some(expr11_0);
                        }
                        &Opcode::Sshr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 731.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_psrad(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                            return Some(expr11_0);
                        }
                        &Opcode::Snarrow => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                if let Some(pattern9_0) = C::first_result(ctx, pattern8_0) {
                                    let pattern10_0 = C::value_type(ctx, pattern9_0);
                                    if pattern10_0 == I64X2 {
                                        let pattern12_0 = C::inst_data(ctx, pattern8_0);
                                        if let &InstructionData::Unary {
                                            opcode: ref pattern13_0,
                                            arg: pattern13_1,
                                        } = &pattern12_0
                                        {
                                            if let &Opcode::FcvtToSintSat = pattern13_0 {
                                                if let Some(pattern15_0) =
                                                    C::def_inst(ctx, pattern7_1)
                                                {
                                                    let pattern16_0 =
                                                        C::inst_data(ctx, pattern15_0);
                                                    if let &InstructionData::UnaryConst {
                                                        opcode: ref pattern17_0,
                                                        constant_handle: pattern17_1,
                                                    } = &pattern16_0
                                                    {
                                                        if let &Opcode::Vconst = pattern17_0 {
                                                            if let Some(pattern19_0) =
                                                                C::u128_from_constant(
                                                                    ctx,
                                                                    pattern17_1,
                                                                )
                                                            {
                                                                if pattern19_0 == 0i128 as u128 {
                                                                    // Rule at src/isa/x64/lower.isle line 3297.
                                                                    let expr0_0 =
                                                                        constructor_put_in_xmm(
                                                                            ctx,
                                                                            pattern13_1,
                                                                        )?;
                                                                    let expr1_0 = C::xmm_to_xmm_mem(
                                                                        ctx, expr0_0,
                                                                    );
                                                                    let expr2_0 = FcmpImm::Equal;
                                                                    let expr3_0 =
                                                                        constructor_x64_cmppd(
                                                                            ctx, expr0_0, &expr1_0,
                                                                            &expr2_0,
                                                                        )?;
                                                                    let expr4_0: Type = F64X2;
                                                                    let expr5_0 =
                                                                        C::snarrow_umax_mask(ctx);
                                                                    let expr6_0 = constructor_x64_xmm_load_const(ctx, expr4_0, expr5_0)?;
                                                                    let expr7_0 = C::xmm_to_xmm_mem(
                                                                        ctx, expr6_0,
                                                                    );
                                                                    let expr8_0 =
                                                                        constructor_x64_andps(
                                                                            ctx, expr3_0, &expr7_0,
                                                                        )?;
                                                                    let expr9_0 =
                                                                        constructor_x64_minpd(
                                                                            ctx, expr0_0, expr8_0,
                                                                        )?;
                                                                    let expr10_0 =
                                                                        C::xmm_to_xmm_mem(
                                                                            ctx, expr9_0,
                                                                        );
                                                                    let expr11_0 =
                                                                        constructor_x64_cvttpd2dq(
                                                                            ctx, &expr10_0,
                                                                        )?;
                                                                    let expr12_0 =
                                                                        constructor_output_xmm(
                                                                            ctx, expr11_0,
                                                                        )?;
                                                                    return Some(expr12_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::IaddPairwise => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::Unary {
                                    opcode: ref pattern10_0,
                                    arg: pattern10_1,
                                } = &pattern9_0
                                {
                                    match pattern10_0 {
                                        &Opcode::SwidenLow => {
                                            let pattern12_0 = C::value_type(ctx, pattern10_1);
                                            if pattern12_0 == I16X8 {
                                                if let Some(pattern14_0) =
                                                    C::def_inst(ctx, pattern7_1)
                                                {
                                                    let pattern15_0 =
                                                        C::inst_data(ctx, pattern14_0);
                                                    if let &InstructionData::Unary {
                                                        opcode: ref pattern16_0,
                                                        arg: pattern16_1,
                                                    } = &pattern15_0
                                                    {
                                                        if let &Opcode::SwidenHigh = pattern16_0 {
                                                            if pattern16_1 == pattern10_1 {
                                                                // Rule at src/isa/x64/lower.isle line 3208.
                                                                let expr0_0: Type = I16X8;
                                                                let expr1_0 =
                                                                    C::iadd_pairwise_mul_const_32(
                                                                        ctx,
                                                                    );
                                                                let expr2_0 =
                                                                    constructor_x64_xmm_load_const(
                                                                        ctx, expr0_0, expr1_0,
                                                                    )?;
                                                                let expr3_0 =
                                                                    constructor_put_in_xmm(
                                                                        ctx,
                                                                        pattern10_1,
                                                                    )?;
                                                                let expr4_0 =
                                                                    C::xmm_to_xmm_mem(ctx, expr2_0);
                                                                let expr5_0 =
                                                                    constructor_x64_pmaddwd(
                                                                        ctx, expr3_0, &expr4_0,
                                                                    )?;
                                                                let expr6_0 =
                                                                    constructor_output_xmm(
                                                                        ctx, expr5_0,
                                                                    )?;
                                                                return Some(expr6_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::UwidenLow => {
                                            let pattern12_0 = C::value_type(ctx, pattern10_1);
                                            if pattern12_0 == I16X8 {
                                                if let Some(pattern14_0) =
                                                    C::def_inst(ctx, pattern7_1)
                                                {
                                                    let pattern15_0 =
                                                        C::inst_data(ctx, pattern14_0);
                                                    if let &InstructionData::Unary {
                                                        opcode: ref pattern16_0,
                                                        arg: pattern16_1,
                                                    } = &pattern15_0
                                                    {
                                                        if let &Opcode::UwidenHigh = pattern16_0 {
                                                            if pattern16_1 == pattern10_1 {
                                                                // Rule at src/isa/x64/lower.isle line 3222.
                                                                let expr0_0: Type = I16X8;
                                                                let expr1_0 =
                                                                    C::iadd_pairwise_xor_const_32(
                                                                        ctx,
                                                                    );
                                                                let expr2_0 =
                                                                    constructor_x64_xmm_load_const(
                                                                        ctx, expr0_0, expr1_0,
                                                                    )?;
                                                                let expr3_0 =
                                                                    constructor_put_in_xmm(
                                                                        ctx,
                                                                        pattern10_1,
                                                                    )?;
                                                                let expr4_0 =
                                                                    C::xmm_to_xmm_mem(ctx, expr2_0);
                                                                let expr5_0 = constructor_x64_pxor(
                                                                    ctx, expr3_0, &expr4_0,
                                                                )?;
                                                                let expr6_0: Type = I16X8;
                                                                let expr7_0 =
                                                                    C::iadd_pairwise_mul_const_32(
                                                                        ctx,
                                                                    );
                                                                let expr8_0 =
                                                                    constructor_x64_xmm_load_const(
                                                                        ctx, expr6_0, expr7_0,
                                                                    )?;
                                                                let expr9_0 =
                                                                    C::xmm_to_xmm_mem(ctx, expr8_0);
                                                                let expr10_0 =
                                                                    constructor_x64_pmaddwd(
                                                                        ctx, expr5_0, &expr9_0,
                                                                    )?;
                                                                let expr11_0: Type = I16X8;
                                                                let expr12_0 =
                                                                    C::iadd_pairwise_addd_const_32(
                                                                        ctx,
                                                                    );
                                                                let expr13_0 =
                                                                    constructor_x64_xmm_load_const(
                                                                        ctx, expr11_0, expr12_0,
                                                                    )?;
                                                                let expr14_0 = C::xmm_to_xmm_mem(
                                                                    ctx, expr13_0,
                                                                );
                                                                let expr15_0 =
                                                                    constructor_x64_paddd(
                                                                        ctx, expr10_0, &expr14_0,
                                                                    )?;
                                                                let expr16_0 =
                                                                    constructor_output_xmm(
                                                                        ctx, expr15_0,
                                                                    )?;
                                                                return Some(expr16_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                        &Opcode::WideningPairwiseDotProductS => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2254.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_pmaddwd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == I64X2 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Ineg => {
                            // Rule at src/isa/x64/lower.isle line 822.
                            let expr0_0: Type = I64X2;
                            let expr1_0: u64 = 0i128 as u64;
                            let expr2_0 = constructor_imm(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = C::xmm_new(ctx, expr2_0);
                            let expr4_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                            let expr5_0 = constructor_x64_psubq(ctx, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &Opcode::Iabs => {
                            // Rule at src/isa/x64/lower.isle line 1154.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0: Type = I64X2;
                            let expr2_0: u64 = 0i128 as u64;
                            let expr3_0 = constructor_imm(ctx, expr1_0, expr2_0)?;
                            let expr4_0 = C::xmm_new(ctx, expr3_0);
                            let expr5_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                            let expr6_0 = constructor_x64_psubq(ctx, expr4_0, &expr5_0)?;
                            let expr7_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                            let expr8_0 =
                                constructor_x64_blendvpd(ctx, expr6_0, &expr7_0, expr6_0)?;
                            let expr9_0 = constructor_output_xmm(ctx, expr8_0)?;
                            return Some(expr9_0);
                        }
                        &Opcode::SwidenLow => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I32X4 {
                                // Rule at src/isa/x64/lower.isle line 3243.
                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                                let expr1_0 = constructor_x64_pmovsxdq(ctx, &expr0_0)?;
                                let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                return Some(expr2_0);
                            }
                        }
                        &Opcode::SwidenHigh => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I32X4 {
                                // Rule at src/isa/x64/lower.isle line 3256.
                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                                let expr1_0: u8 = 238i128 as u8;
                                let expr2_0 = OperandSize::Size32;
                                let expr3_0 =
                                    constructor_x64_pshufd(ctx, &expr0_0, expr1_0, &expr2_0)?;
                                let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                                let expr5_0 = constructor_x64_pmovsxdq(ctx, &expr4_0)?;
                                let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                                return Some(expr6_0);
                            }
                        }
                        &Opcode::UwidenLow => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I32X4 {
                                // Rule at src/isa/x64/lower.isle line 3267.
                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                                let expr1_0 = constructor_x64_pmovzxdq(ctx, &expr0_0)?;
                                let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                return Some(expr2_0);
                            }
                        }
                        &Opcode::UwidenHigh => {
                            let pattern7_0 = C::value_type(ctx, pattern5_1);
                            if pattern7_0 == I32X4 {
                                // Rule at src/isa/x64/lower.isle line 3280.
                                let expr0_0 = C::put_in_xmm_mem(ctx, pattern5_1);
                                let expr1_0: u8 = 238i128 as u8;
                                let expr2_0 = OperandSize::Size32;
                                let expr3_0 =
                                    constructor_x64_pshufd(ctx, &expr0_0, expr1_0, &expr2_0)?;
                                let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                                let expr5_0 = constructor_x64_pmovzxdq(ctx, &expr4_0)?;
                                let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                                return Some(expr6_0);
                            }
                        }
                        _ => {}
                    }
                }
                &InstructionData::Load {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                    offset: pattern5_3,
                } => {
                    match pattern5_0 {
                        &Opcode::Uload32x2 => {
                            // Rule at src/isa/x64/lower.isle line 2604.
                            let expr0_0 =
                                constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                            let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                            let expr2_0 = constructor_x64_pmovzxdq(ctx, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Sload32x2 => {
                            // Rule at src/isa/x64/lower.isle line 2602.
                            let expr0_0 =
                                constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                            let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                            let expr2_0 = constructor_x64_pmovsxdq(ctx, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Ishl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 525.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_psllq(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                            return Some(expr11_0);
                        }
                        &Opcode::Ushr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 632.
                            let expr0_0: Type = I64;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr2_0 = C::shift_mask(ctx, pattern2_0);
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = C::gpr_mem_imm_new(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_and(ctx, expr0_0, expr1_0, &expr4_0)?;
                            let expr6_0 = C::gpr_to_reg(ctx, expr5_0);
                            let expr7_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr8_0 = C::reg_to_reg_mem_imm(ctx, expr6_0);
                            let expr9_0 = constructor_mov_rmi_to_xmm(ctx, &expr8_0)?;
                            let expr10_0 = constructor_x64_psrlq(ctx, expr7_0, &expr9_0)?;
                            let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                            return Some(expr11_0);
                        }
                        &Opcode::Sshr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 743.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0: Type = I64;
                            let expr2_0: u8 = 0i128 as u8;
                            let expr3_0 = constructor_x64_pextrd(ctx, expr1_0, expr0_0, expr2_0)?;
                            let expr4_0: Type = I64;
                            let expr5_0: u8 = 1i128 as u8;
                            let expr6_0 = constructor_x64_pextrd(ctx, expr4_0, expr0_0, expr5_0)?;
                            let expr7_0: Type = I64;
                            let expr8_0 =
                                constructor_put_masked_in_imm8_gpr(ctx, pattern7_1, expr7_0)?;
                            let expr9_0: Type = I64;
                            let expr10_0 = constructor_x64_sar(ctx, expr9_0, expr3_0, &expr8_0)?;
                            let expr11_0: Type = I64;
                            let expr12_0 = constructor_x64_sar(ctx, expr11_0, expr6_0, &expr8_0)?;
                            let expr13_0 = C::gpr_to_gpr_mem(ctx, expr10_0);
                            let expr14_0 = C::gpr_to_gpr_mem(ctx, expr12_0);
                            let expr15_0 =
                                constructor_make_i64x2_from_lanes(ctx, &expr13_0, &expr14_0)?;
                            let expr16_0 = constructor_output_xmm(ctx, expr15_0)?;
                            return Some(expr16_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F32X4 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Sqrt => {
                            // Rule at src/isa/x64/lower.isle line 2311.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_x64_sqrtps(ctx, expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        &Opcode::Fneg => {
                            // Rule at src/isa/x64/lower.isle line 1187.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_vector_all_ones(ctx)?;
                            let expr2_0: u32 = 31i128 as u32;
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = constructor_mov_rmi_to_xmm(ctx, &expr3_0)?;
                            let expr5_0 = constructor_x64_pslld(ctx, expr1_0, &expr4_0)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr7_0 = constructor_x64_xorps(ctx, expr0_0, &expr6_0)?;
                            let expr8_0 = constructor_output_xmm(ctx, expr7_0)?;
                            return Some(expr8_0);
                        }
                        &Opcode::Fabs => {
                            // Rule at src/isa/x64/lower.isle line 1168.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_vector_all_ones(ctx)?;
                            let expr2_0: u32 = 1i128 as u32;
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = constructor_mov_rmi_to_xmm(ctx, &expr3_0)?;
                            let expr5_0 = constructor_x64_psrld(ctx, expr1_0, &expr4_0)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr7_0 = constructor_x64_andps(ctx, expr0_0, &expr6_0)?;
                            let expr8_0 = constructor_output_xmm(ctx, expr7_0)?;
                            return Some(expr8_0);
                        }
                        &Opcode::Fvdemote => {
                            // Rule at src/isa/x64/lower.isle line 2329.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_x64_cvtpd2ps(ctx, expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Load {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                    offset: pattern5_3,
                } => {
                    if let &Opcode::Load = pattern5_0 {
                        // Rule at src/isa/x64/lower.isle line 2576.
                        let expr0_0 =
                            constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                        let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                        let expr2_0 = constructor_x64_movups(ctx, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Fadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2268.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_addps(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fsub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2279.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_subps(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2290.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_mulps(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fdiv => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2301.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_divps(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2351.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr2_0 = constructor_x64_minps(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr4_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr5_0 = constructor_x64_minps(ctx, expr3_0, expr4_0)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr7_0 = constructor_x64_orps(ctx, expr2_0, &expr6_0)?;
                            let expr8_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr9_0 = FcmpImm::Unordered;
                            let expr10_0 = constructor_x64_cmpps(ctx, expr7_0, &expr8_0, &expr9_0)?;
                            let expr11_0 = C::xmm_to_xmm_mem(ctx, expr10_0);
                            let expr12_0 = constructor_x64_orps(ctx, expr7_0, &expr11_0)?;
                            let expr13_0: u32 = 10i128 as u32;
                            let expr14_0 = RegMemImm::Imm { simm32: expr13_0 };
                            let expr15_0 = constructor_mov_rmi_to_xmm(ctx, &expr14_0)?;
                            let expr16_0 = constructor_x64_psrld(ctx, expr10_0, &expr15_0)?;
                            let expr17_0 = C::xmm_to_xmm_mem(ctx, expr12_0);
                            let expr18_0 = constructor_x64_andnps(ctx, expr16_0, &expr17_0)?;
                            let expr19_0 = constructor_output_xmm(ctx, expr18_0)?;
                            return Some(expr19_0);
                        }
                        &Opcode::FminPseudo => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2507.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr2_0 = constructor_x64_minps(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2414.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr2_0 = constructor_x64_maxps(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr4_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr5_0 = constructor_x64_maxps(ctx, expr3_0, expr4_0)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr7_0 = constructor_x64_xorps(ctx, expr2_0, &expr6_0)?;
                            let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                            let expr9_0 = constructor_x64_orps(ctx, expr2_0, &expr8_0)?;
                            let expr10_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                            let expr11_0 = constructor_x64_subps(ctx, expr9_0, &expr10_0)?;
                            let expr12_0 = C::xmm_to_xmm_mem(ctx, expr9_0);
                            let expr13_0 = FcmpImm::Unordered;
                            let expr14_0 =
                                constructor_x64_cmpps(ctx, expr9_0, &expr12_0, &expr13_0)?;
                            let expr15_0: u32 = 10i128 as u32;
                            let expr16_0 = RegMemImm::Imm { simm32: expr15_0 };
                            let expr17_0 = constructor_mov_rmi_to_xmm(ctx, &expr16_0)?;
                            let expr18_0 = constructor_x64_psrld(ctx, expr14_0, &expr17_0)?;
                            let expr19_0 = C::xmm_to_xmm_mem(ctx, expr11_0);
                            let expr20_0 = constructor_x64_andnps(ctx, expr18_0, &expr19_0)?;
                            let expr21_0 = constructor_output_xmm(ctx, expr20_0)?;
                            return Some(expr21_0);
                        }
                        &Opcode::FmaxPseudo => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2518.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr2_0 = constructor_x64_maxps(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F64X2 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Sqrt => {
                            // Rule at src/isa/x64/lower.isle line 2313.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_x64_sqrtpd(ctx, expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        &Opcode::Fneg => {
                            // Rule at src/isa/x64/lower.isle line 1192.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_vector_all_ones(ctx)?;
                            let expr2_0: u32 = 63i128 as u32;
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = constructor_mov_rmi_to_xmm(ctx, &expr3_0)?;
                            let expr5_0 = constructor_x64_psllq(ctx, expr1_0, &expr4_0)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr7_0 = constructor_x64_xorpd(ctx, expr0_0, &expr6_0)?;
                            let expr8_0 = constructor_output_xmm(ctx, expr7_0)?;
                            return Some(expr8_0);
                        }
                        &Opcode::Fabs => {
                            // Rule at src/isa/x64/lower.isle line 1174.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_vector_all_ones(ctx)?;
                            let expr2_0: u32 = 1i128 as u32;
                            let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                            let expr4_0 = constructor_mov_rmi_to_xmm(ctx, &expr3_0)?;
                            let expr5_0 = constructor_x64_psrlq(ctx, expr1_0, &expr4_0)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr7_0 = constructor_x64_andpd(ctx, expr0_0, &expr6_0)?;
                            let expr8_0 = constructor_output_xmm(ctx, expr7_0)?;
                            return Some(expr8_0);
                        }
                        &Opcode::FvpromoteLow => {
                            // Rule at src/isa/x64/lower.isle line 2321.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                            let expr1_0 = constructor_x64_cvtps2pd(ctx, expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Load {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                    offset: pattern5_3,
                } => {
                    if let &Opcode::Load = pattern5_0 {
                        // Rule at src/isa/x64/lower.isle line 2578.
                        let expr0_0 =
                            constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                        let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                        let expr2_0 = constructor_x64_movupd(ctx, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Fadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2270.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_addpd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fsub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2281.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_subpd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2292.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_mulpd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fdiv => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2303.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                            let expr2_0 = constructor_x64_divpd(ctx, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2394.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr2_0 = constructor_x64_minpd(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr4_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr5_0 = constructor_x64_minpd(ctx, expr3_0, expr4_0)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr7_0 = constructor_x64_orpd(ctx, expr2_0, &expr6_0)?;
                            let expr8_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr9_0 = FcmpImm::Unordered;
                            let expr10_0 = constructor_x64_cmppd(ctx, expr2_0, &expr8_0, &expr9_0)?;
                            let expr11_0 = C::xmm_to_xmm_mem(ctx, expr10_0);
                            let expr12_0 = constructor_x64_orpd(ctx, expr7_0, &expr11_0)?;
                            let expr13_0: u32 = 13i128 as u32;
                            let expr14_0 = RegMemImm::Imm { simm32: expr13_0 };
                            let expr15_0 = constructor_mov_rmi_to_xmm(ctx, &expr14_0)?;
                            let expr16_0 = constructor_x64_psrlq(ctx, expr10_0, &expr15_0)?;
                            let expr17_0 = C::xmm_to_xmm_mem(ctx, expr12_0);
                            let expr18_0 = constructor_x64_andnpd(ctx, expr16_0, &expr17_0)?;
                            let expr19_0 = constructor_output_xmm(ctx, expr18_0)?;
                            return Some(expr19_0);
                        }
                        &Opcode::FminPseudo => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2509.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr2_0 = constructor_x64_minpd(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Fmax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2457.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr2_0 = constructor_x64_maxpd(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr4_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr5_0 = constructor_x64_maxpd(ctx, expr3_0, expr4_0)?;
                            let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                            let expr7_0 = constructor_x64_xorpd(ctx, expr2_0, &expr6_0)?;
                            let expr8_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                            let expr9_0 = constructor_x64_orpd(ctx, expr2_0, &expr8_0)?;
                            let expr10_0 = C::xmm_to_xmm_mem(ctx, expr7_0);
                            let expr11_0 = constructor_x64_subpd(ctx, expr9_0, &expr10_0)?;
                            let expr12_0 = C::xmm_to_xmm_mem(ctx, expr9_0);
                            let expr13_0 = FcmpImm::Unordered;
                            let expr14_0 =
                                constructor_x64_cmppd(ctx, expr9_0, &expr12_0, &expr13_0)?;
                            let expr15_0: u32 = 13i128 as u32;
                            let expr16_0 = RegMemImm::Imm { simm32: expr15_0 };
                            let expr17_0 = constructor_mov_rmi_to_xmm(ctx, &expr16_0)?;
                            let expr18_0 = constructor_x64_psrlq(ctx, expr14_0, &expr17_0)?;
                            let expr19_0 = C::xmm_to_xmm_mem(ctx, expr11_0);
                            let expr20_0 = constructor_x64_andnpd(ctx, expr18_0, &expr19_0)?;
                            let expr21_0 = constructor_output_xmm(ctx, expr20_0)?;
                            return Some(expr21_0);
                        }
                        &Opcode::FmaxPseudo => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 2520.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                            let expr2_0 = constructor_x64_maxpd(ctx, expr0_0, expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if let Some((pattern3_0, pattern3_1)) = C::multi_lane(ctx, pattern2_0) {
            if pattern3_0 == 8i128 as u32 {
                if pattern3_1 == 16i128 as u32 {
                    let pattern6_0 = C::inst_data(ctx, pattern0_0);
                    match &pattern6_0 {
                        &InstructionData::Unary {
                            opcode: ref pattern7_0,
                            arg: pattern7_1,
                        } => {
                            if let &Opcode::Splat = pattern7_0 {
                                // Rule at src/isa/x64/lower.isle line 3620.
                                let expr0_0: Type = I8X16;
                                let expr1_0 = constructor_xmm_uninit_value(ctx)?;
                                let expr2_0 = C::put_in_reg_mem(ctx, pattern7_1);
                                let expr3_0: u8 = 0i128 as u8;
                                let expr4_0 = constructor_vec_insert_lane(
                                    ctx, expr0_0, expr1_0, &expr2_0, expr3_0,
                                )?;
                                let expr5_0 = C::xmm_to_xmm_mem(ctx, expr4_0);
                                let expr6_0 = constructor_x64_pxor(ctx, expr4_0, &expr5_0)?;
                                let expr7_0 = C::xmm_to_xmm_mem(ctx, expr6_0);
                                let expr8_0 = constructor_x64_pshufb(ctx, expr4_0, &expr7_0)?;
                                let expr9_0 = constructor_output_xmm(ctx, expr8_0)?;
                                return Some(expr9_0);
                            }
                        }
                        &InstructionData::Binary {
                            opcode: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            match pattern7_0 {
                                &Opcode::AvgRound => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 827.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_pavgb(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::UaddSat => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 117.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_paddusb(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::SaddSat => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 107.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_paddsb(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::UsubSat => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 232.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_psubusb(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::SsubSat => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 222.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_psubsb(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::Iadd => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 75.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_paddb(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::Isub => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 190.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_psubb(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
            }
            if pattern3_0 == 16i128 as u32 {
                if pattern3_1 == 8i128 as u32 {
                    let pattern6_0 = C::inst_data(ctx, pattern0_0);
                    match &pattern6_0 {
                        &InstructionData::Unary {
                            opcode: ref pattern7_0,
                            arg: pattern7_1,
                        } => {
                            if let &Opcode::Splat = pattern7_0 {
                                // Rule at src/isa/x64/lower.isle line 3626.
                                let expr0_0 = C::put_in_reg(ctx, pattern7_1);
                                let expr1_0 = RegMem::Reg { reg: expr0_0 };
                                let expr2_0: Type = I16X8;
                                let expr3_0 = constructor_xmm_uninit_value(ctx)?;
                                let expr4_0: u8 = 0i128 as u8;
                                let expr5_0 = constructor_vec_insert_lane(
                                    ctx, expr2_0, expr3_0, &expr1_0, expr4_0,
                                )?;
                                let expr6_0: Type = I16X8;
                                let expr7_0: u8 = 1i128 as u8;
                                let expr8_0 = constructor_vec_insert_lane(
                                    ctx, expr6_0, expr5_0, &expr1_0, expr7_0,
                                )?;
                                let expr9_0 = C::xmm_to_xmm_mem(ctx, expr8_0);
                                let expr10_0: u8 = 0i128 as u8;
                                let expr11_0 = OperandSize::Size32;
                                let expr12_0 =
                                    constructor_x64_pshufd(ctx, &expr9_0, expr10_0, &expr11_0)?;
                                let expr13_0 = constructor_output_xmm(ctx, expr12_0)?;
                                return Some(expr13_0);
                            }
                        }
                        &InstructionData::Binary {
                            opcode: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            match pattern7_0 {
                                &Opcode::AvgRound => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 831.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_pavgw(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::UaddSat => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 121.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_paddusw(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::SaddSat => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 111.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_paddsw(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::UsubSat => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 236.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_psubusw(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::SsubSat => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 226.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_psubsw(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::Iadd => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 79.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_paddw(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::Isub => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 194.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_psubw(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::Imul => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 908.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_pmullw(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
            }
            if pattern3_0 == 32i128 as u32 {
                if pattern3_1 == 4i128 as u32 {
                    let pattern6_0 = C::inst_data(ctx, pattern0_0);
                    match &pattern6_0 {
                        &InstructionData::Unary {
                            opcode: ref pattern7_0,
                            arg: pattern7_1,
                        } => {
                            if let &Opcode::Splat = pattern7_0 {
                                // Rule at src/isa/x64/lower.isle line 3638.
                                let expr0_0: Type = I32X4;
                                let expr1_0 =
                                    constructor_lower_splat_32x4(ctx, expr0_0, pattern7_1)?;
                                let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                return Some(expr2_0);
                            }
                        }
                        &InstructionData::Binary {
                            opcode: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            match pattern7_0 {
                                &Opcode::Iadd => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 83.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_paddd(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::Isub => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 198.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_psubd(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::Imul => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 911.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_pmulld(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
            }
            if pattern3_0 == 64i128 as u32 {
                if pattern3_1 == 2i128 as u32 {
                    let pattern6_0 = C::inst_data(ctx, pattern0_0);
                    match &pattern6_0 {
                        &InstructionData::Unary {
                            opcode: ref pattern7_0,
                            arg: pattern7_1,
                        } => {
                            if let &Opcode::Splat = pattern7_0 {
                                // Rule at src/isa/x64/lower.isle line 3651.
                                let expr0_0: Type = I64X2;
                                let expr1_0 =
                                    constructor_lower_splat_64x2(ctx, expr0_0, pattern7_1)?;
                                let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                                return Some(expr2_0);
                            }
                        }
                        &InstructionData::Binary {
                            opcode: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            match pattern7_0 {
                                &Opcode::Iadd => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 87.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_paddq(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::Isub => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 202.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = C::put_in_xmm_mem(ctx, pattern9_1);
                                    let expr2_0 = constructor_x64_psubq(ctx, expr0_0, &expr1_0)?;
                                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                                    return Some(expr3_0);
                                }
                                &Opcode::Imul => {
                                    let (pattern9_0, pattern9_1) =
                                        C::unpack_value_array_2(ctx, pattern7_1);
                                    // Rule at src/isa/x64/lower.isle line 942.
                                    let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                                    let expr1_0 = constructor_put_in_xmm(ctx, pattern9_1)?;
                                    let expr2_0: u32 = 32i128 as u32;
                                    let expr3_0 = RegMemImm::Imm { simm32: expr2_0 };
                                    let expr4_0 = constructor_mov_rmi_to_xmm(ctx, &expr3_0)?;
                                    let expr5_0 = constructor_x64_psrlq(ctx, expr0_0, &expr4_0)?;
                                    let expr6_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                    let expr7_0 = constructor_x64_pmuludq(ctx, expr5_0, &expr6_0)?;
                                    let expr8_0: u32 = 32i128 as u32;
                                    let expr9_0 = RegMemImm::Imm { simm32: expr8_0 };
                                    let expr10_0 = constructor_mov_rmi_to_xmm(ctx, &expr9_0)?;
                                    let expr11_0 = constructor_x64_psrlq(ctx, expr1_0, &expr10_0)?;
                                    let expr12_0 = C::xmm_to_xmm_mem(ctx, expr11_0);
                                    let expr13_0 =
                                        constructor_x64_pmuludq(ctx, expr0_0, &expr12_0)?;
                                    let expr14_0 = C::xmm_to_xmm_mem(ctx, expr13_0);
                                    let expr15_0 = constructor_x64_paddq(ctx, expr7_0, &expr14_0)?;
                                    let expr16_0: u32 = 32i128 as u32;
                                    let expr17_0 = RegMemImm::Imm { simm32: expr16_0 };
                                    let expr18_0 = constructor_mov_rmi_to_xmm(ctx, &expr17_0)?;
                                    let expr19_0 = constructor_x64_psllq(ctx, expr15_0, &expr18_0)?;
                                    let expr20_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                                    let expr21_0 =
                                        constructor_x64_pmuludq(ctx, expr0_0, &expr20_0)?;
                                    let expr22_0 = C::xmm_to_xmm_mem(ctx, expr19_0);
                                    let expr23_0 = constructor_x64_paddq(ctx, expr21_0, &expr22_0)?;
                                    let expr24_0 = constructor_output_xmm(ctx, expr23_0)?;
                                    return Some(expr24_0);
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
            }
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Ternary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Bitselect => {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 1275.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                        let expr1_0 = constructor_put_in_xmm(ctx, pattern7_1)?;
                        let expr2_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                        let expr3_0 = constructor_sse_and(ctx, pattern2_0, expr1_0, &expr2_0)?;
                        let expr4_0 = C::put_in_xmm_mem(ctx, pattern7_2);
                        let expr5_0 = constructor_sse_and_not(ctx, pattern2_0, expr0_0, &expr4_0)?;
                        let expr6_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                        let expr7_0 = constructor_sse_or(ctx, pattern2_0, expr5_0, &expr6_0)?;
                        let expr8_0 = constructor_output_xmm(ctx, expr7_0)?;
                        return Some(expr8_0);
                    }
                    &Opcode::Vselect => {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 1309.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern7_0)?;
                        let expr1_0 = C::put_in_xmm_mem(ctx, pattern7_1);
                        let expr2_0 = constructor_put_in_xmm(ctx, pattern7_2)?;
                        let expr3_0 =
                            constructor_x64_blend(ctx, pattern2_0, expr0_0, &expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_32(ctx, pattern2_0) {
            if let Some(pattern4_0) = C::ty_int(ctx, pattern2_0) {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::LoadNoOffset {
                    opcode: ref pattern6_0,
                    arg: pattern6_1,
                    flags: pattern6_2,
                } = &pattern5_0
                {
                    if let &Opcode::AtomicLoad = pattern6_0 {
                        // Rule at src/isa/x64/lower.isle line 2837.
                        let expr0_0 = C::ty_bits_u16(ctx, pattern3_0);
                        let expr1_0: u16 = 64i128 as u16;
                        let expr2_0 = C::ext_mode(ctx, expr0_0, expr1_0);
                        let expr3_0 = C::zero_offset(ctx);
                        let expr4_0 = constructor_to_amode(ctx, pattern6_2, pattern6_1, expr3_0)?;
                        let expr5_0 = constructor_amode_to_gpr_mem(ctx, &expr4_0)?;
                        let expr6_0 = constructor_x64_movzx(ctx, &expr2_0, &expr5_0)?;
                        let expr7_0 = constructor_output_gpr(ctx, expr6_0)?;
                        return Some(expr7_0);
                    }
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            if let Some(pattern4_0) = C::ty_int(ctx, pattern2_0) {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                match &pattern5_0 {
                    &InstructionData::AtomicRmw {
                        opcode: ref pattern6_0,
                        args: ref pattern6_1,
                        flags: pattern6_2,
                        op: ref pattern6_3,
                    } => {
                        if let &Opcode::AtomicRmw = pattern6_0 {
                            let (pattern8_0, pattern8_1) = C::unpack_value_array_2(ctx, pattern6_1);
                            // Rule at src/isa/x64/lower.isle line 2870.
                            let expr0_0 = C::atomic_rmw_op_to_mach_atomic_rmw_op(ctx, pattern6_3);
                            let expr1_0 = C::zero_offset(ctx);
                            let expr2_0 =
                                constructor_to_amode(ctx, pattern6_2, pattern8_0, expr1_0)?;
                            let expr3_0 = C::amode_to_synthetic_amode(ctx, &expr2_0);
                            let expr4_0 = constructor_put_in_gpr(ctx, pattern8_1)?;
                            let expr5_0 = constructor_x64_atomic_rmw_seq(
                                ctx, pattern3_0, &expr0_0, &expr3_0, expr4_0,
                            )?;
                            let expr6_0 = constructor_output_gpr(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                    }
                    &InstructionData::AtomicCas {
                        opcode: ref pattern6_0,
                        args: ref pattern6_1,
                        flags: pattern6_2,
                    } => {
                        if let &Opcode::AtomicCas = pattern6_0 {
                            let (pattern8_0, pattern8_1, pattern8_2) =
                                C::unpack_value_array_3(ctx, pattern6_1);
                            // Rule at src/isa/x64/lower.isle line 2854.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern8_1)?;
                            let expr1_0 = constructor_put_in_gpr(ctx, pattern8_2)?;
                            let expr2_0 = C::zero_offset(ctx);
                            let expr3_0 =
                                constructor_to_amode(ctx, pattern6_2, pattern8_0, expr2_0)?;
                            let expr4_0 = C::amode_to_synthetic_amode(ctx, &expr3_0);
                            let expr5_0 = constructor_x64_cmpxchg(
                                ctx, pattern3_0, expr0_0, expr1_0, &expr4_0,
                            )?;
                            let expr6_0 = constructor_output_gpr(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                    }
                    _ => {}
                }
            }
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::UnaryImm {
                    opcode: ref pattern5_0,
                    imm: pattern5_1,
                } => {
                    if let &Opcode::Iconst = pattern5_0 {
                        let pattern7_0 = C::u64_from_imm64(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 15.
                        let expr0_0 = constructor_imm(ctx, pattern3_0, pattern7_0)?;
                        let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                        return Some(expr1_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::IaddIfcout = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 142.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                        let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern7_1)?;
                        let expr2_0 = constructor_x64_add(ctx, pattern3_0, expr0_0, &expr1_0)?;
                        let expr3_0 = C::gpr_to_reg(ctx, expr2_0);
                        let expr4_0 = constructor_output_ifcout(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                }
                &InstructionData::IntAddTrap {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    code: ref pattern5_2,
                } => {
                    if let &Opcode::UaddOverflowTrap = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 1459.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                        let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern7_1)?;
                        let expr2_0 = constructor_x64_add_with_flags_paired(
                            ctx, pattern3_0, expr0_0, &expr1_0,
                        )?;
                        let expr3_0 = CC::B;
                        let expr4_0 = constructor_trap_if(ctx, &expr3_0, pattern5_2)?;
                        let expr5_0 = constructor_with_flags(ctx, &expr2_0, &expr4_0)?;
                        let expr6_0 = C::output(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::type_register_class(ctx, pattern2_0) {
            if let &RegisterClass::Gpr {
                single_register: pattern4_0,
            } = &pattern3_0
            {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Load {
                    opcode: ref pattern6_0,
                    arg: pattern6_1,
                    flags: pattern6_2,
                    offset: pattern6_3,
                } = &pattern5_0
                {
                    match pattern6_0 {
                        &Opcode::Uload8 => {
                            // Rule at src/isa/x64/lower.isle line 2555.
                            let expr0_0 = ExtMode::BQ;
                            let expr1_0 =
                                constructor_to_amode(ctx, pattern6_2, pattern6_1, pattern6_3)?;
                            let expr2_0 = constructor_amode_to_gpr_mem(ctx, &expr1_0)?;
                            let expr3_0 = constructor_x64_movzx(ctx, &expr0_0, &expr2_0)?;
                            let expr4_0 = constructor_output_gpr(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Sload8 => {
                            // Rule at src/isa/x64/lower.isle line 2557.
                            let expr0_0 = ExtMode::BQ;
                            let expr1_0 =
                                constructor_to_amode(ctx, pattern6_2, pattern6_1, pattern6_3)?;
                            let expr2_0 = constructor_amode_to_gpr_mem(ctx, &expr1_0)?;
                            let expr3_0 = constructor_x64_movsx(ctx, &expr0_0, &expr2_0)?;
                            let expr4_0 = constructor_output_gpr(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Uload16 => {
                            // Rule at src/isa/x64/lower.isle line 2559.
                            let expr0_0 = ExtMode::WQ;
                            let expr1_0 =
                                constructor_to_amode(ctx, pattern6_2, pattern6_1, pattern6_3)?;
                            let expr2_0 = constructor_amode_to_gpr_mem(ctx, &expr1_0)?;
                            let expr3_0 = constructor_x64_movzx(ctx, &expr0_0, &expr2_0)?;
                            let expr4_0 = constructor_output_gpr(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Sload16 => {
                            // Rule at src/isa/x64/lower.isle line 2561.
                            let expr0_0 = ExtMode::WQ;
                            let expr1_0 =
                                constructor_to_amode(ctx, pattern6_2, pattern6_1, pattern6_3)?;
                            let expr2_0 = constructor_amode_to_gpr_mem(ctx, &expr1_0)?;
                            let expr3_0 = constructor_x64_movsx(ctx, &expr0_0, &expr2_0)?;
                            let expr4_0 = constructor_output_gpr(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Uload32 => {
                            // Rule at src/isa/x64/lower.isle line 2563.
                            let expr0_0 = ExtMode::LQ;
                            let expr1_0 =
                                constructor_to_amode(ctx, pattern6_2, pattern6_1, pattern6_3)?;
                            let expr2_0 = constructor_amode_to_gpr_mem(ctx, &expr1_0)?;
                            let expr3_0 = constructor_x64_movzx(ctx, &expr0_0, &expr2_0)?;
                            let expr4_0 = constructor_output_gpr(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Sload32 => {
                            // Rule at src/isa/x64/lower.isle line 2565.
                            let expr0_0 = ExtMode::LQ;
                            let expr1_0 =
                                constructor_to_amode(ctx, pattern6_2, pattern6_1, pattern6_3)?;
                            let expr2_0 = constructor_amode_to_gpr_mem(ctx, &expr1_0)?;
                            let expr3_0 = constructor_x64_movsx(ctx, &expr0_0, &expr2_0)?;
                            let expr4_0 = constructor_output_gpr(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        _ => {}
                    }
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        match &pattern3_0 {
            &InstructionData::NullAry {
                opcode: ref pattern4_0,
            } => {
                if let &Opcode::Null = pattern4_0 {
                    // Rule at src/isa/x64/lower.isle line 37.
                    let expr0_0: u64 = 0i128 as u64;
                    let expr1_0 = constructor_imm(ctx, pattern2_0, expr0_0)?;
                    let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
            }
            &InstructionData::Unary {
                opcode: ref pattern4_0,
                arg: pattern4_1,
            } => {
                match pattern4_0 {
                    &Opcode::Bmask => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/x64/lower.isle line 1238.
                        let expr0_0 = C::put_in_regs(ctx, pattern4_1);
                        let expr1_0 =
                            constructor_lower_bmask(ctx, pattern2_0, pattern6_0, expr0_0)?;
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                    &Opcode::Ireduce => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        if pattern6_0 == pattern2_0 {
                            // Rule at src/isa/x64/lower.isle line 2238.
                            let expr0_0 = constructor_output_value(ctx, pattern4_1)?;
                            return Some(expr0_0);
                        }
                    }
                    &Opcode::Sextend => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/x64/lower.isle line 2230.
                        let expr0_0 =
                            constructor_generic_sextend(ctx, pattern4_1, pattern6_0, pattern2_0)?;
                        return Some(expr0_0);
                    }
                    &Opcode::FcvtToUint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        if let Some(pattern7_0) = C::ty_scalar_float(ctx, pattern6_0) {
                            // Rule at src/isa/x64/lower.isle line 3070.
                            let expr0_0: bool = false;
                            let expr1_0 = constructor_cvt_float_to_uint_seq(
                                ctx, pattern2_0, pattern4_1, expr0_0,
                            )?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    &Opcode::FcvtToSint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        if let Some(pattern7_0) = C::ty_scalar_float(ctx, pattern6_0) {
                            // Rule at src/isa/x64/lower.isle line 3076.
                            let expr0_0: bool = false;
                            let expr1_0 = constructor_cvt_float_to_sint_seq(
                                ctx, pattern2_0, pattern4_1, expr0_0,
                            )?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    &Opcode::FcvtToUintSat => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        if let Some(pattern7_0) = C::ty_scalar_float(ctx, pattern6_0) {
                            // Rule at src/isa/x64/lower.isle line 3073.
                            let expr0_0: bool = true;
                            let expr1_0 = constructor_cvt_float_to_uint_seq(
                                ctx, pattern2_0, pattern4_1, expr0_0,
                            )?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    &Opcode::FcvtToSintSat => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        if let Some(pattern7_0) = C::ty_scalar_float(ctx, pattern6_0) {
                            // Rule at src/isa/x64/lower.isle line 3079.
                            let expr0_0: bool = true;
                            let expr1_0 = constructor_cvt_float_to_sint_seq(
                                ctx, pattern2_0, pattern4_1, expr0_0,
                            )?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    &Opcode::FcvtFromUint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        if pattern6_0 == I64 {
                            // Rule at src/isa/x64/lower.isle line 3004.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern4_1)?;
                            let expr1_0 =
                                constructor_cvt_u64_to_float_seq(ctx, pattern2_0, expr0_0)?;
                            let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::UnaryConst {
                opcode: ref pattern4_0,
                constant_handle: pattern4_1,
            } => {
                if let &Opcode::Vconst = pattern4_0 {
                    // Rule at src/isa/x64/lower.isle line 3515.
                    let expr0_0 = C::const_to_vconst(ctx, pattern4_1);
                    let expr1_0 = constructor_x64_xmm_load_const(ctx, pattern2_0, expr0_0)?;
                    let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
            }
            &InstructionData::Binary {
                opcode: ref pattern4_0,
                args: ref pattern4_1,
            } => {
                match pattern4_0 {
                    &Opcode::Band => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        let mut closure7 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern7_0) = closure7() {
                            // Rule at src/isa/x64/lower.isle line 245.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                            let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern6_1)?;
                            let expr2_0 = constructor_x64_and(ctx, pattern2_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::Bor => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        let mut closure7 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern7_0) = closure7() {
                            // Rule at src/isa/x64/lower.isle line 307.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                            let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern6_1)?;
                            let expr2_0 = constructor_x64_or(ctx, pattern2_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::Bxor => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        let mut closure7 = || {
                            let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                            return Some(expr0_0);
                        };
                        if let Some(pattern7_0) = closure7() {
                            // Rule at src/isa/x64/lower.isle line 370.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                            let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern6_1)?;
                            let expr2_0 = constructor_x64_xor(ctx, pattern2_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::BandNot => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/x64/lower.isle line 1129.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern6_1)?;
                        let expr1_0 = C::put_in_xmm_mem(ctx, pattern6_0);
                        let expr2_0 = constructor_sse_and_not(ctx, pattern2_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    _ => {}
                }
            }
            &InstructionData::Ternary {
                opcode: ref pattern4_0,
                args: ref pattern4_1,
            } => {
                if let &Opcode::Select = pattern4_0 {
                    let (pattern6_0, pattern6_1, pattern6_2) =
                        C::unpack_value_array_3(ctx, pattern4_1);
                    if let Some(pattern7_0) = C::def_inst(ctx, pattern6_0) {
                        let pattern8_0 = C::inst_data(ctx, pattern7_0);
                        match &pattern8_0 {
                            &InstructionData::FloatCompare {
                                opcode: ref pattern9_0,
                                args: ref pattern9_1,
                                cond: ref pattern9_2,
                            } => {
                                if let &Opcode::Fcmp = pattern9_0 {
                                    let (pattern11_0, pattern11_1) =
                                        C::unpack_value_array_2(ctx, pattern9_1);
                                    match pattern9_2 {
                                        &FloatCC::Equal => {
                                            // Rule at src/isa/x64/lower.isle line 1754.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_0,
                                                pattern11_1,
                                            )?;
                                            let expr1_0 = CC::NZ;
                                            let expr2_0 = CC::P;
                                            let expr3_0 = constructor_cmove_or_from_values(
                                                ctx, pattern2_0, &expr1_0, &expr2_0, pattern6_2,
                                                pattern6_1,
                                            )?;
                                            let expr4_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr3_0)?;
                                            let expr5_0 = C::output(ctx, expr4_0);
                                            return Some(expr5_0);
                                        }
                                        &FloatCC::GreaterThan => {
                                            // Rule at src/isa/x64/lower.isle line 1706.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_1,
                                                pattern11_0,
                                            )?;
                                            let expr1_0 = CC::NBE;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        &FloatCC::GreaterThanOrEqual => {
                                            // Rule at src/isa/x64/lower.isle line 1709.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_1,
                                                pattern11_0,
                                            )?;
                                            let expr1_0 = CC::NB;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        &FloatCC::LessThan => {
                                            // Rule at src/isa/x64/lower.isle line 1729.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_0,
                                                pattern11_1,
                                            )?;
                                            let expr1_0 = CC::NBE;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        &FloatCC::LessThanOrEqual => {
                                            // Rule at src/isa/x64/lower.isle line 1732.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_0,
                                                pattern11_1,
                                            )?;
                                            let expr1_0 = CC::NB;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        &FloatCC::NotEqual => {
                                            // Rule at src/isa/x64/lower.isle line 1757.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_0,
                                                pattern11_1,
                                            )?;
                                            let expr1_0 = CC::NZ;
                                            let expr2_0 = CC::P;
                                            let expr3_0 = constructor_cmove_or_from_values(
                                                ctx, pattern2_0, &expr1_0, &expr2_0, pattern6_1,
                                                pattern6_2,
                                            )?;
                                            let expr4_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr3_0)?;
                                            let expr5_0 = C::output(ctx, expr4_0);
                                            return Some(expr5_0);
                                        }
                                        &FloatCC::Ordered => {
                                            // Rule at src/isa/x64/lower.isle line 1700.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_1,
                                                pattern11_0,
                                            )?;
                                            let expr1_0 = CC::NP;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        &FloatCC::Unordered => {
                                            // Rule at src/isa/x64/lower.isle line 1703.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_1,
                                                pattern11_0,
                                            )?;
                                            let expr1_0 = CC::P;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        &FloatCC::UnorderedOrGreaterThan => {
                                            // Rule at src/isa/x64/lower.isle line 1735.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_0,
                                                pattern11_1,
                                            )?;
                                            let expr1_0 = CC::B;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        &FloatCC::UnorderedOrGreaterThanOrEqual => {
                                            // Rule at src/isa/x64/lower.isle line 1738.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_0,
                                                pattern11_1,
                                            )?;
                                            let expr1_0 = CC::BE;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        &FloatCC::UnorderedOrLessThan => {
                                            // Rule at src/isa/x64/lower.isle line 1712.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_1,
                                                pattern11_0,
                                            )?;
                                            let expr1_0 = CC::B;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        &FloatCC::UnorderedOrLessThanOrEqual => {
                                            // Rule at src/isa/x64/lower.isle line 1715.
                                            let expr0_0 = constructor_x64_ucomis(
                                                ctx,
                                                pattern11_1,
                                                pattern11_0,
                                            )?;
                                            let expr1_0 = CC::BE;
                                            let expr2_0 = constructor_cmove_from_values(
                                                ctx, pattern2_0, &expr1_0, pattern6_1, pattern6_2,
                                            )?;
                                            let expr3_0 =
                                                constructor_with_flags(ctx, &expr0_0, &expr2_0)?;
                                            let expr4_0 = C::output(ctx, expr3_0);
                                            return Some(expr4_0);
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            &InstructionData::IntCompare {
                                opcode: ref pattern9_0,
                                args: ref pattern9_1,
                                cond: ref pattern9_2,
                            } => {
                                if let &Opcode::Icmp = pattern9_0 {
                                    let (pattern11_0, pattern11_1) =
                                        C::unpack_value_array_2(ctx, pattern9_1);
                                    let pattern12_0 = C::value_type(ctx, pattern11_0);
                                    if let Some(pattern13_0) = C::fits_in_64(ctx, pattern12_0) {
                                        // Rule at src/isa/x64/lower.isle line 1765.
                                        let expr0_0 = C::raw_operand_size_of_type(ctx, pattern13_0);
                                        let expr1_0 =
                                            constructor_put_in_gpr_mem_imm(ctx, pattern11_1)?;
                                        let expr2_0 = constructor_put_in_gpr(ctx, pattern11_0)?;
                                        let expr3_0 =
                                            constructor_x64_cmp(ctx, &expr0_0, &expr1_0, expr2_0)?;
                                        let expr4_0 = C::intcc_to_cc(ctx, pattern9_2);
                                        let expr5_0 = constructor_cmove_from_values(
                                            ctx, pattern2_0, &expr4_0, pattern6_1, pattern6_2,
                                        )?;
                                        let expr6_0 =
                                            constructor_with_flags(ctx, &expr3_0, &expr5_0)?;
                                        let expr7_0 = C::output(ctx, expr6_0);
                                        return Some(expr7_0);
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            _ => {}
        }
        let pattern3_0 = C::use_fma(ctx, pattern2_0);
        if pattern3_0 == true {
            if pattern2_0 == F32X4 {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Ternary {
                    opcode: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Fma = pattern7_0 {
                        let (pattern9_0, pattern9_1, pattern9_2) =
                            C::unpack_value_array_3(ctx, pattern7_1);
                        // Rule at src/isa/x64/lower.isle line 2533.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                        let expr1_0 = constructor_put_in_xmm(ctx, pattern9_1)?;
                        let expr2_0 = constructor_put_in_xmm(ctx, pattern9_2)?;
                        let expr3_0 = constructor_x64_vfmadd213ps(ctx, expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                }
            }
            if pattern2_0 == F64X2 {
                let pattern6_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::Ternary {
                    opcode: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &Opcode::Fma = pattern7_0 {
                        let (pattern9_0, pattern9_1, pattern9_2) =
                            C::unpack_value_array_3(ctx, pattern7_1);
                        // Rule at src/isa/x64/lower.isle line 2535.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern9_0)?;
                        let expr1_0 = constructor_put_in_xmm(ctx, pattern9_1)?;
                        let expr2_0 = constructor_put_in_xmm(ctx, pattern9_2)?;
                        let expr3_0 = constructor_x64_vfmadd213pd(ctx, expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                }
            }
        }
        let pattern3_0 = C::use_sse41(ctx, pattern2_0);
        if pattern3_0 == true {
            let pattern5_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern6_0,
                arg: pattern6_1,
            } = &pattern5_0
            {
                match pattern6_0 {
                    &Opcode::Ceil => {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if pattern8_0 == F32 {
                            // Rule at src/isa/x64/lower.isle line 3366.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundUp;
                            let expr2_0 = constructor_x64_roundss(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64 {
                            // Rule at src/isa/x64/lower.isle line 3372.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundUp;
                            let expr2_0 = constructor_x64_roundsd(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F32X4 {
                            // Rule at src/isa/x64/lower.isle line 3378.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundUp;
                            let expr2_0 = constructor_x64_roundps(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64X2 {
                            // Rule at src/isa/x64/lower.isle line 3381.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundUp;
                            let expr2_0 = constructor_x64_roundpd(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::Floor => {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if pattern8_0 == F32 {
                            // Rule at src/isa/x64/lower.isle line 3386.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundDown;
                            let expr2_0 = constructor_x64_roundss(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64 {
                            // Rule at src/isa/x64/lower.isle line 3392.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundDown;
                            let expr2_0 = constructor_x64_roundsd(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F32X4 {
                            // Rule at src/isa/x64/lower.isle line 3398.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundDown;
                            let expr2_0 = constructor_x64_roundps(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64X2 {
                            // Rule at src/isa/x64/lower.isle line 3401.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundDown;
                            let expr2_0 = constructor_x64_roundpd(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::Trunc => {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if pattern8_0 == F32 {
                            // Rule at src/isa/x64/lower.isle line 3426.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundZero;
                            let expr2_0 = constructor_x64_roundss(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64 {
                            // Rule at src/isa/x64/lower.isle line 3432.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundZero;
                            let expr2_0 = constructor_x64_roundsd(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F32X4 {
                            // Rule at src/isa/x64/lower.isle line 3438.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundZero;
                            let expr2_0 = constructor_x64_roundps(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64X2 {
                            // Rule at src/isa/x64/lower.isle line 3441.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundZero;
                            let expr2_0 = constructor_x64_roundpd(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::Nearest => {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if pattern8_0 == F32 {
                            // Rule at src/isa/x64/lower.isle line 3406.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundNearest;
                            let expr2_0 = constructor_x64_roundss(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64 {
                            // Rule at src/isa/x64/lower.isle line 3412.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundNearest;
                            let expr2_0 = constructor_x64_roundsd(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F32X4 {
                            // Rule at src/isa/x64/lower.isle line 3418.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundNearest;
                            let expr2_0 = constructor_x64_roundps(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64X2 {
                            // Rule at src/isa/x64/lower.isle line 3421.
                            let expr0_0 = C::put_in_xmm_mem(ctx, pattern6_1);
                            let expr1_0 = RoundImm::RoundNearest;
                            let expr2_0 = constructor_x64_roundpd(ctx, &expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern3_0 == false {
            let pattern5_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern6_0,
                arg: pattern6_1,
            } = &pattern5_0
            {
                match pattern6_0 {
                    &Opcode::Ceil => {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if pattern8_0 == F32 {
                            // Rule at src/isa/x64/lower.isle line 3369.
                            let expr0_0 = LibCall::CeilF32;
                            let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr2_0 = C::libcall_1(ctx, &expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64 {
                            // Rule at src/isa/x64/lower.isle line 3375.
                            let expr0_0 = LibCall::CeilF64;
                            let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr2_0 = C::libcall_1(ctx, &expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::Floor => {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if pattern8_0 == F32 {
                            // Rule at src/isa/x64/lower.isle line 3389.
                            let expr0_0 = LibCall::FloorF32;
                            let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr2_0 = C::libcall_1(ctx, &expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64 {
                            // Rule at src/isa/x64/lower.isle line 3395.
                            let expr0_0 = LibCall::FloorF64;
                            let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr2_0 = C::libcall_1(ctx, &expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::Trunc => {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if pattern8_0 == F32 {
                            // Rule at src/isa/x64/lower.isle line 3429.
                            let expr0_0 = LibCall::TruncF32;
                            let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr2_0 = C::libcall_1(ctx, &expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64 {
                            // Rule at src/isa/x64/lower.isle line 3435.
                            let expr0_0 = LibCall::TruncF64;
                            let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr2_0 = C::libcall_1(ctx, &expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::Nearest => {
                        let pattern8_0 = C::value_type(ctx, pattern6_1);
                        if pattern8_0 == F32 {
                            // Rule at src/isa/x64/lower.isle line 3409.
                            let expr0_0 = LibCall::NearestF32;
                            let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr2_0 = C::libcall_1(ctx, &expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        if pattern8_0 == F64 {
                            // Rule at src/isa/x64/lower.isle line 3415.
                            let expr0_0 = LibCall::NearestF64;
                            let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr2_0 = C::libcall_1(ctx, &expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    _ => {}
                }
            }
        }
        let pattern3_0 = C::tls_model(ctx, pattern2_0);
        match &pattern3_0 {
            &TlsModel::ElfGd => {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::UnaryGlobalValue {
                    opcode: ref pattern6_0,
                    global_value: pattern6_1,
                } = &pattern5_0
                {
                    if let &Opcode::TlsValue = pattern6_0 {
                        if let Some((pattern8_0, pattern8_1, pattern8_2)) =
                            C::symbol_value_data(ctx, pattern6_1)
                        {
                            // Rule at src/isa/x64/lower.isle line 3723.
                            let expr0_0 = constructor_elf_tls_get_addr(ctx, pattern8_0)?;
                            let expr1_0 = constructor_output_gpr(ctx, expr0_0)?;
                            return Some(expr1_0);
                        }
                    }
                }
            }
            &TlsModel::Macho => {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::UnaryGlobalValue {
                    opcode: ref pattern6_0,
                    global_value: pattern6_1,
                } = &pattern5_0
                {
                    if let &Opcode::TlsValue = pattern6_0 {
                        if let Some((pattern8_0, pattern8_1, pattern8_2)) =
                            C::symbol_value_data(ctx, pattern6_1)
                        {
                            // Rule at src/isa/x64/lower.isle line 3726.
                            let expr0_0 = constructor_macho_tls_get_addr(ctx, pattern8_0)?;
                            let expr1_0 = constructor_output_gpr(ctx, expr0_0)?;
                            return Some(expr1_0);
                        }
                    }
                }
            }
            &TlsModel::Coff => {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::UnaryGlobalValue {
                    opcode: ref pattern6_0,
                    global_value: pattern6_1,
                } = &pattern5_0
                {
                    if let &Opcode::TlsValue = pattern6_0 {
                        if let Some((pattern8_0, pattern8_1, pattern8_2)) =
                            C::symbol_value_data(ctx, pattern6_1)
                        {
                            // Rule at src/isa/x64/lower.isle line 3729.
                            let expr0_0 = constructor_coff_tls_get_addr(ctx, pattern8_0)?;
                            let expr1_0 = constructor_output_gpr(ctx, expr0_0)?;
                            return Some(expr1_0);
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::NullAry {
            opcode: ref pattern2_0,
        } => {
            match pattern2_0 {
                &Opcode::Debugtrap => {
                    // Rule at src/isa/x64/lower.isle line 2249.
                    let expr0_0 = constructor_x64_hlt(ctx)?;
                    let expr1_0 = constructor_side_effect(ctx, &expr0_0)?;
                    return Some(expr1_0);
                }
                &Opcode::GetPinnedReg => {
                    // Rule at src/isa/x64/lower.isle line 3505.
                    let expr0_0 = constructor_read_pinned_gpr(ctx)?;
                    let expr1_0 = constructor_output_gpr(ctx, expr0_0)?;
                    return Some(expr1_0);
                }
                &Opcode::GetFramePointer => {
                    // Rule at src/isa/x64/lower.isle line 2884.
                    let expr0_0 = constructor_x64_rbp(ctx)?;
                    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                    return Some(expr1_0);
                }
                &Opcode::GetStackPointer => {
                    // Rule at src/isa/x64/lower.isle line 2887.
                    let expr0_0 = constructor_x64_rsp(ctx)?;
                    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                    return Some(expr1_0);
                }
                &Opcode::GetReturnAddress => {
                    // Rule at src/isa/x64/lower.isle line 2890.
                    let expr0_0: Type = I64;
                    let expr1_0: u32 = 8i128 as u32;
                    let expr2_0 = constructor_x64_rbp(ctx)?;
                    let expr3_0 = C::mem_flags_trusted(ctx);
                    let expr4_0 = Amode::ImmReg {
                        simm32: expr1_0,
                        base: expr2_0,
                        flags: expr3_0,
                    };
                    let expr5_0 = C::amode_to_synthetic_amode(ctx, &expr4_0);
                    let expr6_0 = ExtKind::None;
                    let expr7_0 = constructor_x64_load(ctx, expr0_0, &expr5_0, &expr6_0)?;
                    let expr8_0 = constructor_output_reg(ctx, expr7_0)?;
                    return Some(expr8_0);
                }
                &Opcode::Nop => {
                    // Rule at src/isa/x64/lower.isle line 3783.
                    let expr0_0 = C::invalid_reg(ctx);
                    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                    return Some(expr1_0);
                }
                &Opcode::Fence => {
                    // Rule at src/isa/x64/lower.isle line 2813.
                    let expr0_0 = constructor_x64_mfence(ctx)?;
                    let expr1_0 = constructor_side_effect(ctx, &expr0_0)?;
                    return Some(expr1_0);
                }
                _ => {}
            }
        }
        &InstructionData::Unary {
            opcode: ref pattern2_0,
            arg: pattern2_1,
        } => {
            match pattern2_0 {
                &Opcode::SetPinnedReg => {
                    let pattern4_0 = C::value_type(ctx, pattern2_1);
                    // Rule at src/isa/x64/lower.isle line 3510.
                    let expr0_0 = constructor_put_in_gpr(ctx, pattern2_1)?;
                    let expr1_0 = constructor_write_pinned_gpr(ctx, expr0_0)?;
                    let expr2_0 = constructor_side_effect(ctx, &expr1_0)?;
                    return Some(expr2_0);
                }
                &Opcode::VanyTrue => {
                    // Rule at src/isa/x64/lower.isle line 3664.
                    let expr0_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                    let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                    let expr2_0 = constructor_x64_ptest(ctx, &expr1_0, expr0_0)?;
                    let expr3_0 = CC::NZ;
                    let expr4_0 = constructor_x64_setcc(ctx, &expr3_0)?;
                    let expr5_0 = constructor_with_flags(ctx, &expr2_0, &expr4_0)?;
                    let expr6_0 = C::output(ctx, expr5_0);
                    return Some(expr6_0);
                }
                &Opcode::VallTrue => {
                    let pattern4_0 = C::value_type(ctx, pattern2_1);
                    // Rule at src/isa/x64/lower.isle line 3670.
                    let expr0_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                    let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                    let expr2_0 = constructor_x64_pxor(ctx, expr0_0, &expr1_0)?;
                    let expr3_0 = constructor_vec_int_type(ctx, pattern4_0)?;
                    let expr4_0 = C::xmm_to_xmm_mem(ctx, expr2_0);
                    let expr5_0 = constructor_x64_pcmpeq(ctx, expr3_0, expr0_0, &expr4_0)?;
                    let expr6_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                    let expr7_0 = constructor_x64_ptest(ctx, &expr6_0, expr5_0)?;
                    let expr8_0 = CC::Z;
                    let expr9_0 = constructor_x64_setcc(ctx, &expr8_0)?;
                    let expr10_0 = constructor_with_flags(ctx, &expr7_0, &expr9_0)?;
                    let expr11_0 = C::output(ctx, expr10_0);
                    return Some(expr11_0);
                }
                &Opcode::VhighBits => {
                    let pattern4_0 = C::value_type(ctx, pattern2_1);
                    if let Some((pattern5_0, pattern5_1)) = C::multi_lane(ctx, pattern4_0) {
                        if pattern5_0 == 8i128 as u32 {
                            if pattern5_1 == 16i128 as u32 {
                                // Rule at src/isa/x64/lower.isle line 3687.
                                let expr0_0 = OperandSize::Size32;
                                let expr1_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                                let expr2_0 = constructor_x64_pmovmskb(ctx, &expr0_0, expr1_0)?;
                                let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                        if pattern5_0 == 16i128 as u32 {
                            if pattern5_1 == 8i128 as u32 {
                                // Rule at src/isa/x64/lower.isle line 3702.
                                let expr0_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                                let expr1_0 = C::xmm_to_xmm_mem(ctx, expr0_0);
                                let expr2_0 = constructor_x64_packsswb(ctx, expr0_0, &expr1_0)?;
                                let expr3_0 = OperandSize::Size32;
                                let expr4_0 = constructor_x64_pmovmskb(ctx, &expr3_0, expr2_0)?;
                                let expr5_0: Type = I64;
                                let expr6_0: u8 = 8i128 as u8;
                                let expr7_0 = Imm8Reg::Imm8 { imm: expr6_0 };
                                let expr8_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr7_0);
                                let expr9_0 = constructor_x64_shr(ctx, expr5_0, expr4_0, &expr8_0)?;
                                let expr10_0 = constructor_output_gpr(ctx, expr9_0)?;
                                return Some(expr10_0);
                            }
                        }
                        if pattern5_0 == 32i128 as u32 {
                            if pattern5_1 == 4i128 as u32 {
                                // Rule at src/isa/x64/lower.isle line 3690.
                                let expr0_0 = OperandSize::Size32;
                                let expr1_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                                let expr2_0 = constructor_x64_movmskps(ctx, &expr0_0, expr1_0)?;
                                let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                        if pattern5_0 == 64i128 as u32 {
                            if pattern5_1 == 2i128 as u32 {
                                // Rule at src/isa/x64/lower.isle line 3693.
                                let expr0_0 = OperandSize::Size32;
                                let expr1_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                                let expr2_0 = constructor_x64_movmskpd(ctx, &expr0_0, expr1_0)?;
                                let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                    }
                }
                &Opcode::IsNull => {
                    let pattern4_0 = C::value_type(ctx, pattern2_1);
                    if pattern4_0 == R64 {
                        // Rule at src/isa/x64/lower.isle line 2120.
                        let expr0_0 = OperandSize::Size64;
                        let expr1_0: u32 = 0i128 as u32;
                        let expr2_0 = constructor_put_in_gpr(ctx, pattern2_1)?;
                        let expr3_0 = constructor_x64_cmp_imm(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = CC::Z;
                        let expr5_0 = constructor_x64_setcc(ctx, &expr4_0)?;
                        let expr6_0 = constructor_with_flags(ctx, &expr3_0, &expr5_0)?;
                        let expr7_0 = C::output(ctx, expr6_0);
                        return Some(expr7_0);
                    }
                }
                &Opcode::IsInvalid => {
                    let pattern4_0 = C::value_type(ctx, pattern2_1);
                    if pattern4_0 == R64 {
                        // Rule at src/isa/x64/lower.isle line 2128.
                        let expr0_0 = OperandSize::Size64;
                        let expr1_0: u32 = 4294967295i128 as u32;
                        let expr2_0 = constructor_put_in_gpr(ctx, pattern2_1)?;
                        let expr3_0 = constructor_x64_cmp_imm(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = CC::Z;
                        let expr5_0 = constructor_x64_setcc(ctx, &expr4_0)?;
                        let expr6_0 = constructor_with_flags(ctx, &expr3_0, &expr5_0)?;
                        let expr7_0 = C::output(ctx, expr6_0);
                        return Some(expr7_0);
                    }
                }
                &Opcode::ScalarToVector => {
                    let pattern4_0 = C::value_type(ctx, pattern2_1);
                    // Rule at src/isa/x64/lower.isle line 3608.
                    let expr0_0 = constructor_put_in_gpr(ctx, pattern2_1)?;
                    let expr1_0 = constructor_bitcast_gpr_to_xmm(ctx, pattern4_0, expr0_0)?;
                    let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
                &Opcode::FcvtFromSint => {
                    let pattern4_0 = C::value_type(ctx, pattern2_1);
                    if pattern4_0 == I32X4 {
                        // Rule at src/isa/x64/lower.isle line 2988.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                        let expr1_0 = constructor_x64_cvtdq2ps(ctx, expr0_0)?;
                        let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
                &Opcode::FcvtLowFromSint => {
                    let pattern4_0 = C::value_type(ctx, pattern2_1);
                    // Rule at src/isa/x64/lower.isle line 2993.
                    let expr0_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                    let expr1_0 = constructor_x64_cvtdq2pd(ctx, pattern4_0, expr0_0)?;
                    let expr2_0 = constructor_output_xmm(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
                &Opcode::Isplit => {
                    let pattern4_0 = C::value_type(ctx, pattern2_1);
                    if pattern4_0 == I128 {
                        // Rule at src/isa/x64/lower.isle line 3715.
                        let expr0_0 = C::put_in_regs(ctx, pattern2_1);
                        let expr1_0: usize = 0i128 as usize;
                        let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                        let expr3_0: usize = 1i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr0_0, expr3_0);
                        let expr5_0 = C::value_reg(ctx, expr2_0);
                        let expr6_0 = C::value_reg(ctx, expr4_0);
                        let expr7_0 = C::output_pair(ctx, expr5_0, expr6_0);
                        return Some(expr7_0);
                    }
                }
                _ => {}
            }
        }
        &InstructionData::BinaryImm8 {
            opcode: ref pattern2_0,
            arg: pattern2_1,
            imm: pattern2_2,
        } => {
            if let &Opcode::Extractlane = pattern2_0 {
                let pattern4_0 = C::value_type(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::multi_lane(ctx, pattern4_0) {
                    if pattern5_0 == 8i128 as u32 {
                        if pattern5_1 == 16i128 as u32 {
                            let pattern8_0 = C::u8_from_uimm8(ctx, pattern2_2);
                            // Rule at src/isa/x64/lower.isle line 3585.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                            let expr1_0 =
                                constructor_x64_pextrb(ctx, pattern4_0, expr0_0, pattern8_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    if pattern5_0 == 16i128 as u32 {
                        if pattern5_1 == 8i128 as u32 {
                            let pattern8_0 = C::u8_from_uimm8(ctx, pattern2_2);
                            // Rule at src/isa/x64/lower.isle line 3588.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                            let expr1_0 =
                                constructor_x64_pextrw(ctx, pattern4_0, expr0_0, pattern8_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    if pattern5_0 == 32i128 as u32 {
                        if pattern5_1 == 4i128 as u32 {
                            let pattern8_0 = C::u8_from_uimm8(ctx, pattern2_2);
                            // Rule at src/isa/x64/lower.isle line 3591.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                            let expr1_0 =
                                constructor_x64_pextrd(ctx, pattern4_0, expr0_0, pattern8_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    if pattern5_0 == 64i128 as u32 {
                        if pattern5_1 == 2i128 as u32 {
                            let pattern8_0 = C::u8_from_uimm8(ctx, pattern2_2);
                            // Rule at src/isa/x64/lower.isle line 3594.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern2_1)?;
                            let expr1_0 =
                                constructor_x64_pextrd(ctx, pattern4_0, expr0_0, pattern8_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                }
            }
        }
        &InstructionData::MultiAry {
            opcode: ref pattern2_0,
            args: pattern2_1,
        } => {
            if let &Opcode::Return = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                // Rule at src/isa/x64/lower.isle line 1500.
                let expr0_0: usize = 0i128 as usize;
                let expr1_0 = C::value_slice_len(ctx, pattern4_0);
                let expr2_0 = C::range(ctx, expr0_0, expr1_0);
                let expr3_0 = constructor_lower_return(ctx, expr2_0, pattern4_0)?;
                return Some(expr3_0);
            }
        }
        &InstructionData::Call {
            opcode: ref pattern2_0,
            args: pattern2_1,
            func_ref: pattern2_2,
        } => {
            if let &Opcode::Call = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                let (pattern5_0, pattern5_1, pattern5_2) = C::func_ref_data(ctx, pattern2_2);
                // Rule at src/isa/x64/lower.isle line 2876.
                let expr0_0 = C::gen_call(ctx, pattern5_0, pattern5_1, pattern5_2, pattern4_0);
                return Some(expr0_0);
            }
        }
        &InstructionData::CallIndirect {
            opcode: ref pattern2_0,
            args: pattern2_1,
            sig_ref: pattern2_2,
        } => {
            if let &Opcode::CallIndirect = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    // Rule at src/isa/x64/lower.isle line 2879.
                    let expr0_0 = C::gen_call_indirect(ctx, pattern2_2, pattern5_0, pattern5_1);
                    return Some(expr0_0);
                }
            }
        }
        &InstructionData::FuncAddr {
            opcode: ref pattern2_0,
            func_ref: pattern2_1,
        } => {
            if let &Opcode::FuncAddr = pattern2_0 {
                let (pattern4_0, pattern4_1, pattern4_2) = C::func_ref_data(ctx, pattern2_1);
                // Rule at src/isa/x64/lower.isle line 2818.
                let expr0_0: i64 = 0i128 as i64;
                let expr1_0 = constructor_load_ext_name(ctx, pattern4_1, expr0_0)?;
                let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                return Some(expr2_0);
            }
        }
        &InstructionData::UnaryGlobalValue {
            opcode: ref pattern2_0,
            global_value: pattern2_1,
        } => {
            if let &Opcode::SymbolValue = pattern2_0 {
                if let Some((pattern4_0, pattern4_1, pattern4_2)) =
                    C::symbol_value_data(ctx, pattern2_1)
                {
                    // Rule at src/isa/x64/lower.isle line 2823.
                    let expr0_0 = constructor_load_ext_name(ctx, pattern4_0, pattern4_2)?;
                    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                    return Some(expr1_0);
                }
            }
        }
        &InstructionData::UnaryIeee32 {
            opcode: ref pattern2_0,
            imm: pattern2_1,
        } => {
            if let &Opcode::F32const = pattern2_0 {
                let pattern4_0 = C::u64_from_ieee32(ctx, pattern2_1);
                // Rule at src/isa/x64/lower.isle line 27.
                let expr0_0: Type = F32;
                let expr1_0 = constructor_imm(ctx, expr0_0, pattern4_0)?;
                let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                return Some(expr2_0);
            }
        }
        &InstructionData::UnaryIeee64 {
            opcode: ref pattern2_0,
            imm: pattern2_1,
        } => {
            if let &Opcode::F64const = pattern2_0 {
                let pattern4_0 = C::u64_from_ieee64(ctx, pattern2_1);
                // Rule at src/isa/x64/lower.isle line 32.
                let expr0_0: Type = F64;
                let expr1_0 = constructor_imm(ctx, expr0_0, pattern4_0)?;
                let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                return Some(expr2_0);
            }
        }
        &InstructionData::StackLoad {
            opcode: ref pattern2_0,
            stack_slot: pattern2_1,
            offset: pattern2_2,
        } => {
            if let &Opcode::StackAddr = pattern2_0 {
                // Rule at src/isa/x64/lower.isle line 3446.
                let expr0_0 = constructor_stack_addr_impl(ctx, pattern2_1, pattern2_2)?;
                let expr1_0 = constructor_output_gpr(ctx, expr0_0)?;
                return Some(expr1_0);
            }
        }
        &InstructionData::Trap {
            opcode: ref pattern2_0,
            code: ref pattern2_1,
        } => {
            match pattern2_0 {
                &Opcode::Trap => {
                    // Rule at src/isa/x64/lower.isle line 1454.
                    let expr0_0 = constructor_x64_ud2(ctx, pattern2_1)?;
                    let expr1_0 = constructor_side_effect(ctx, &expr0_0)?;
                    return Some(expr1_0);
                }
                &Opcode::ResumableTrap => {
                    // Rule at src/isa/x64/lower.isle line 1494.
                    let expr0_0 = constructor_x64_ud2(ctx, pattern2_1)?;
                    let expr1_0 = constructor_side_effect(ctx, &expr0_0)?;
                    return Some(expr1_0);
                }
                _ => {}
            }
        }
        &InstructionData::Binary {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
        } => {
            match pattern2_0 {
                &Opcode::Swizzle => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/x64/lower.isle line 3560.
                    let expr0_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                    let expr1_0: Type = I8X16;
                    let expr2_0 = C::swizzle_zero_mask(ctx);
                    let expr3_0 = constructor_x64_xmm_load_const(ctx, expr1_0, expr2_0)?;
                    let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                    let expr5_0 = constructor_x64_paddusb(ctx, expr0_0, &expr4_0)?;
                    let expr6_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                    let expr7_0 = C::xmm_to_xmm_mem(ctx, expr5_0);
                    let expr8_0 = constructor_x64_pshufb(ctx, expr6_0, &expr7_0)?;
                    let expr9_0 = constructor_output_xmm(ctx, expr8_0)?;
                    return Some(expr9_0);
                }
                &Opcode::Umulhi => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    if pattern5_0 == I16 {
                        // Rule at src/isa/x64/lower.isle line 3471.
                        let expr0_0: Type = I16;
                        let expr1_0: bool = false;
                        let expr2_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                        let expr3_0 = constructor_put_in_gpr_mem(ctx, pattern4_1)?;
                        let expr4_0 = constructor_mul_hi(ctx, expr0_0, expr1_0, expr2_0, &expr3_0)?;
                        let expr5_0: usize = 1i128 as usize;
                        let expr6_0 = constructor_value_regs_get_gpr(ctx, expr4_0, expr5_0)?;
                        let expr7_0 = constructor_output_gpr(ctx, expr6_0)?;
                        return Some(expr7_0);
                    }
                    if pattern5_0 == I32 {
                        // Rule at src/isa/x64/lower.isle line 3476.
                        let expr0_0: Type = I32;
                        let expr1_0: bool = false;
                        let expr2_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                        let expr3_0 = constructor_put_in_gpr_mem(ctx, pattern4_1)?;
                        let expr4_0 = constructor_mul_hi(ctx, expr0_0, expr1_0, expr2_0, &expr3_0)?;
                        let expr5_0: usize = 1i128 as usize;
                        let expr6_0 = constructor_value_regs_get_gpr(ctx, expr4_0, expr5_0)?;
                        let expr7_0 = constructor_output_gpr(ctx, expr6_0)?;
                        return Some(expr7_0);
                    }
                    if pattern5_0 == I64 {
                        // Rule at src/isa/x64/lower.isle line 3481.
                        let expr0_0: Type = I64;
                        let expr1_0: bool = false;
                        let expr2_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                        let expr3_0 = constructor_put_in_gpr_mem(ctx, pattern4_1)?;
                        let expr4_0 = constructor_mul_hi(ctx, expr0_0, expr1_0, expr2_0, &expr3_0)?;
                        let expr5_0: usize = 1i128 as usize;
                        let expr6_0 = constructor_value_regs_get_gpr(ctx, expr4_0, expr5_0)?;
                        let expr7_0 = constructor_output_gpr(ctx, expr6_0)?;
                        return Some(expr7_0);
                    }
                }
                &Opcode::Smulhi => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    if pattern5_0 == I16 {
                        // Rule at src/isa/x64/lower.isle line 3488.
                        let expr0_0: Type = I16;
                        let expr1_0: bool = true;
                        let expr2_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                        let expr3_0 = constructor_put_in_gpr_mem(ctx, pattern4_1)?;
                        let expr4_0 = constructor_mul_hi(ctx, expr0_0, expr1_0, expr2_0, &expr3_0)?;
                        let expr5_0: usize = 1i128 as usize;
                        let expr6_0 = constructor_value_regs_get_gpr(ctx, expr4_0, expr5_0)?;
                        let expr7_0 = constructor_output_gpr(ctx, expr6_0)?;
                        return Some(expr7_0);
                    }
                    if pattern5_0 == I32 {
                        // Rule at src/isa/x64/lower.isle line 3493.
                        let expr0_0: Type = I32;
                        let expr1_0: bool = true;
                        let expr2_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                        let expr3_0 = constructor_put_in_gpr_mem(ctx, pattern4_1)?;
                        let expr4_0 = constructor_mul_hi(ctx, expr0_0, expr1_0, expr2_0, &expr3_0)?;
                        let expr5_0: usize = 1i128 as usize;
                        let expr6_0 = constructor_value_regs_get_gpr(ctx, expr4_0, expr5_0)?;
                        let expr7_0 = constructor_output_gpr(ctx, expr6_0)?;
                        return Some(expr7_0);
                    }
                    if pattern5_0 == I64 {
                        // Rule at src/isa/x64/lower.isle line 3498.
                        let expr0_0: Type = I64;
                        let expr1_0: bool = true;
                        let expr2_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                        let expr3_0 = constructor_put_in_gpr_mem(ctx, pattern4_1)?;
                        let expr4_0 = constructor_mul_hi(ctx, expr0_0, expr1_0, expr2_0, &expr3_0)?;
                        let expr5_0: usize = 1i128 as usize;
                        let expr6_0 = constructor_value_regs_get_gpr(ctx, expr4_0, expr5_0)?;
                        let expr7_0 = constructor_output_gpr(ctx, expr6_0)?;
                        return Some(expr7_0);
                    }
                }
                &Opcode::SqmulRoundSat => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    if pattern5_0 == I16X8 {
                        // Rule at src/isa/x64/lower.isle line 3734.
                        let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                        let expr1_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                        let expr2_0: Type = I16X8;
                        let expr3_0 = C::sqmul_round_sat_mask(ctx);
                        let expr4_0 = constructor_x64_xmm_load_const(ctx, expr2_0, expr3_0)?;
                        let expr5_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                        let expr6_0 = constructor_x64_pmulhrsw(ctx, expr0_0, &expr5_0)?;
                        let expr7_0 = C::xmm_to_xmm_mem(ctx, expr6_0);
                        let expr8_0 = constructor_x64_pcmpeqw(ctx, expr4_0, &expr7_0)?;
                        let expr9_0 = C::xmm_to_xmm_mem(ctx, expr8_0);
                        let expr10_0 = constructor_x64_pxor(ctx, expr6_0, &expr9_0)?;
                        let expr11_0 = constructor_output_xmm(ctx, expr10_0)?;
                        return Some(expr11_0);
                    }
                }
                &Opcode::Udiv => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    // Rule at src/isa/x64/lower.isle line 3451.
                    let expr0_0 = DivOrRemKind::UnsignedDiv;
                    let expr1_0 = constructor_div_or_rem(ctx, &expr0_0, pattern4_0, pattern4_1)?;
                    let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
                &Opcode::Sdiv => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    // Rule at src/isa/x64/lower.isle line 3456.
                    let expr0_0 = DivOrRemKind::SignedDiv;
                    let expr1_0 = constructor_div_or_rem(ctx, &expr0_0, pattern4_0, pattern4_1)?;
                    let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
                &Opcode::Urem => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    // Rule at src/isa/x64/lower.isle line 3461.
                    let expr0_0 = DivOrRemKind::UnsignedRem;
                    let expr1_0 = constructor_div_or_rem(ctx, &expr0_0, pattern4_0, pattern4_1)?;
                    let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
                &Opcode::Srem => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    // Rule at src/isa/x64/lower.isle line 3466.
                    let expr0_0 = DivOrRemKind::SignedRem;
                    let expr1_0 = constructor_div_or_rem(ctx, &expr0_0, pattern4_0, pattern4_1)?;
                    let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
                &Opcode::Uunarrow => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    if let Some(pattern5_0) = C::def_inst(ctx, pattern4_0) {
                        let pattern6_0 = C::inst_data(ctx, pattern5_0);
                        if let &InstructionData::Unary {
                            opcode: ref pattern7_0,
                            arg: pattern7_1,
                        } = &pattern6_0
                        {
                            if let &Opcode::FcvtToUintSat = pattern7_0 {
                                let pattern9_0 = C::value_type(ctx, pattern7_1);
                                if pattern9_0 == F64X2 {
                                    if let Some(pattern11_0) = C::def_inst(ctx, pattern4_1) {
                                        let pattern12_0 = C::inst_data(ctx, pattern11_0);
                                        if let &InstructionData::UnaryConst {
                                            opcode: ref pattern13_0,
                                            constant_handle: pattern13_1,
                                        } = &pattern12_0
                                        {
                                            if let &Opcode::Vconst = pattern13_0 {
                                                if let Some(pattern15_0) =
                                                    C::u128_from_constant(ctx, pattern13_1)
                                                {
                                                    if pattern15_0 == 0i128 as u128 {
                                                        // Rule at src/isa/x64/lower.isle line 3757.
                                                        let expr0_0 = constructor_put_in_xmm(
                                                            ctx, pattern7_1,
                                                        )?;
                                                        let expr1_0 =
                                                            C::xmm_to_xmm_mem(ctx, expr0_0);
                                                        let expr2_0 = constructor_x64_xorpd(
                                                            ctx, expr0_0, &expr1_0,
                                                        )?;
                                                        let expr3_0 = constructor_x64_maxpd(
                                                            ctx, expr0_0, expr2_0,
                                                        )?;
                                                        let expr4_0: Type = F64X2;
                                                        let expr5_0 = C::uunarrow_umax_mask(ctx);
                                                        let expr6_0 =
                                                            constructor_x64_xmm_load_const(
                                                                ctx, expr4_0, expr5_0,
                                                            )?;
                                                        let expr7_0 = constructor_x64_minpd(
                                                            ctx, expr3_0, expr6_0,
                                                        )?;
                                                        let expr8_0 =
                                                            C::xmm_to_xmm_mem(ctx, expr7_0);
                                                        let expr9_0 = RoundImm::RoundZero;
                                                        let expr10_0 = constructor_x64_roundpd(
                                                            ctx, &expr8_0, &expr9_0,
                                                        )?;
                                                        let expr11_0: Type = F64X2;
                                                        let expr12_0 = C::uunarrow_uint_mask(ctx);
                                                        let expr13_0 =
                                                            constructor_x64_xmm_load_const(
                                                                ctx, expr11_0, expr12_0,
                                                            )?;
                                                        let expr14_0 =
                                                            C::xmm_to_xmm_mem(ctx, expr13_0);
                                                        let expr15_0 = constructor_x64_addpd(
                                                            ctx, expr10_0, &expr14_0,
                                                        )?;
                                                        let expr16_0 =
                                                            C::xmm_to_xmm_mem(ctx, expr2_0);
                                                        let expr17_0: u8 = 136i128 as u8;
                                                        let expr18_0 = constructor_x64_shufps(
                                                            ctx, expr15_0, &expr16_0, expr17_0,
                                                        )?;
                                                        let expr19_0 =
                                                            constructor_output_xmm(ctx, expr18_0)?;
                                                        return Some(expr19_0);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                &Opcode::Iconcat => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    if pattern5_0 == I64 {
                        // Rule at src/isa/x64/lower.isle line 3710.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 = C::value_regs(ctx, expr0_0, expr1_0);
                        let expr3_0 = C::output(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                }
                _ => {}
            }
        }
        &InstructionData::Shuffle {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            imm: pattern2_2,
        } => {
            if let &Opcode::Shuffle = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::vec_mask_from_immediate(ctx, pattern2_2) {
                    // Rule at src/isa/x64/lower.isle line 3547.
                    let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                    let expr1_0: Type = I8X16;
                    let expr2_0 = C::shuffle_0_15_mask(ctx, &pattern5_0);
                    let expr3_0 = constructor_x64_xmm_load_const(ctx, expr1_0, expr2_0)?;
                    let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                    let expr5_0 = constructor_x64_pshufb(ctx, expr0_0, &expr4_0)?;
                    let expr6_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                    let expr7_0: Type = I8X16;
                    let expr8_0 = C::shuffle_16_31_mask(ctx, &pattern5_0);
                    let expr9_0 = constructor_x64_xmm_load_const(ctx, expr7_0, expr8_0)?;
                    let expr10_0 = C::xmm_to_xmm_mem(ctx, expr9_0);
                    let expr11_0 = constructor_x64_pshufb(ctx, expr6_0, &expr10_0)?;
                    let expr12_0 = C::xmm_to_xmm_mem(ctx, expr11_0);
                    let expr13_0 = constructor_x64_por(ctx, expr5_0, &expr12_0)?;
                    let expr14_0 = constructor_output_xmm(ctx, expr13_0)?;
                    return Some(expr14_0);
                }
            }
        }
        &InstructionData::StoreNoOffset {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
        } => {
            if let &Opcode::AtomicStore = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if let Some(pattern6_0) = C::fits_in_64(ctx, pattern5_0) {
                    if let Some(pattern7_0) = C::ty_int(ctx, pattern5_0) {
                        // Rule at src/isa/x64/lower.isle line 2845.
                        let expr0_0 = C::zero_offset(ctx);
                        let expr1_0 = constructor_to_amode(ctx, pattern2_2, pattern4_1, expr0_0)?;
                        let expr2_0 = C::amode_to_synthetic_amode(ctx, &expr1_0);
                        let expr3_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                        let expr4_0 = constructor_x64_movrm(ctx, pattern6_0, &expr2_0, expr3_0)?;
                        let expr5_0 = constructor_x64_mfence(ctx)?;
                        let expr6_0 = constructor_side_effect_concat(ctx, &expr4_0, &expr5_0)?;
                        let expr7_0 = constructor_side_effect(ctx, &expr6_0)?;
                        return Some(expr7_0);
                    }
                }
            }
        }
        &InstructionData::Store {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            match pattern2_0 {
                &Opcode::Store => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    if pattern5_0 == I128 {
                        // Rule at src/isa/x64/lower.isle line 2669.
                        let expr0_0 = C::put_in_regs(ctx, pattern4_0);
                        let expr1_0: usize = 0i128 as usize;
                        let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                        let expr3_0: usize = 1i128 as usize;
                        let expr4_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr3_0)?;
                        let expr5_0 =
                            constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                        let expr6_0: u32 = 8i128 as u32;
                        let expr7_0 = C::amode_offset(ctx, &expr5_0, expr6_0);
                        let expr8_0: Type = I64;
                        let expr9_0 = C::amode_to_synthetic_amode(ctx, &expr5_0);
                        let expr10_0 = constructor_x64_movrm(ctx, expr8_0, &expr9_0, expr2_0)?;
                        let expr11_0: Type = I64;
                        let expr12_0 = C::amode_to_synthetic_amode(ctx, &expr7_0);
                        let expr13_0 = constructor_x64_movrm(ctx, expr11_0, &expr12_0, expr4_0)?;
                        let expr14_0 = constructor_side_effect_concat(ctx, &expr10_0, &expr13_0)?;
                        let expr15_0 = constructor_side_effect(ctx, &expr14_0)?;
                        return Some(expr15_0);
                    }
                }
                &Opcode::Istore8 => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/x64/lower.isle line 2618.
                    let expr0_0: Type = I8;
                    let expr1_0 = constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                    let expr2_0 = C::amode_to_synthetic_amode(ctx, &expr1_0);
                    let expr3_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                    let expr4_0 = constructor_x64_movrm(ctx, expr0_0, &expr2_0, expr3_0)?;
                    let expr5_0 = constructor_side_effect(ctx, &expr4_0)?;
                    return Some(expr5_0);
                }
                &Opcode::Istore16 => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/x64/lower.isle line 2621.
                    let expr0_0: Type = I16;
                    let expr1_0 = constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                    let expr2_0 = C::amode_to_synthetic_amode(ctx, &expr1_0);
                    let expr3_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                    let expr4_0 = constructor_x64_movrm(ctx, expr0_0, &expr2_0, expr3_0)?;
                    let expr5_0 = constructor_side_effect(ctx, &expr4_0)?;
                    return Some(expr5_0);
                }
                &Opcode::Istore32 => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/x64/lower.isle line 2624.
                    let expr0_0: Type = I32;
                    let expr1_0 = constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                    let expr2_0 = C::amode_to_synthetic_amode(ctx, &expr1_0);
                    let expr3_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                    let expr4_0 = constructor_x64_movrm(ctx, expr0_0, &expr2_0, expr3_0)?;
                    let expr5_0 = constructor_side_effect(ctx, &expr4_0)?;
                    return Some(expr5_0);
                }
                _ => {}
            }
        }
        &InstructionData::TernaryImm8 {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            imm: pattern2_2,
        } => {
            if let &Opcode::Insertlane = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                let pattern6_0 = C::u8_from_uimm8(ctx, pattern2_2);
                // Rule at src/isa/x64/lower.isle line 1318.
                let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                let expr1_0 = C::put_in_reg_mem(ctx, pattern4_1);
                let expr2_0 =
                    constructor_vec_insert_lane(ctx, pattern5_0, expr0_0, &expr1_0, pattern6_0)?;
                let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                return Some(expr3_0);
            }
        }
        &InstructionData::FloatCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Fcmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if let Some(pattern6_0) = C::ty_vec128(ctx, pattern5_0) {
                    match pattern2_2 {
                        &FloatCC::Equal => {
                            // Rule at src/isa/x64/lower.isle line 1640.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 = FcmpImm::Equal;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::GreaterThan => {
                            // Rule at src/isa/x64/lower.isle line 1660.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_0);
                            let expr2_0 = FcmpImm::LessThan;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::GreaterThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1662.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_0);
                            let expr2_0 = FcmpImm::LessThanOrEqual;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::LessThan => {
                            // Rule at src/isa/x64/lower.isle line 1644.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 = FcmpImm::LessThan;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::LessThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1646.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 = FcmpImm::LessThanOrEqual;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::NotEqual => {
                            // Rule at src/isa/x64/lower.isle line 1642.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 = FcmpImm::NotEqual;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::Ordered => {
                            // Rule at src/isa/x64/lower.isle line 1648.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 = FcmpImm::Ordered;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::Unordered => {
                            // Rule at src/isa/x64/lower.isle line 1650.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 = FcmpImm::Unordered;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::UnorderedOrGreaterThan => {
                            // Rule at src/isa/x64/lower.isle line 1652.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 = FcmpImm::UnorderedOrGreaterThan;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::UnorderedOrGreaterThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1654.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 = FcmpImm::UnorderedOrGreaterThanOrEqual;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::UnorderedOrLessThan => {
                            // Rule at src/isa/x64/lower.isle line 1664.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_0);
                            let expr2_0 = FcmpImm::UnorderedOrGreaterThan;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &FloatCC::UnorderedOrLessThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1666.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_0);
                            let expr2_0 = FcmpImm::UnorderedOrGreaterThanOrEqual;
                            let expr3_0 =
                                constructor_x64_cmpp(ctx, pattern6_0, expr0_0, &expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        _ => {}
                    }
                }
            }
        }
        &InstructionData::IntCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Icmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if let Some(pattern6_0) = C::ty_vec128(ctx, pattern5_0) {
                    match pattern2_2 {
                        &IntCC::Equal => {
                            // Rule at src/isa/x64/lower.isle line 1548.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 =
                                constructor_x64_pcmpeq(ctx, pattern6_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &IntCC::NotEqual => {
                            // Rule at src/isa/x64/lower.isle line 1553.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 =
                                constructor_x64_pcmpeq(ctx, pattern6_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_vector_all_ones(ctx)?;
                            let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
                            let expr5_0 = constructor_x64_pxor(ctx, expr2_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &IntCC::SignedGreaterThan => {
                            // Rule at src/isa/x64/lower.isle line 1560.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 =
                                constructor_x64_pcmpgt(ctx, pattern6_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &IntCC::SignedGreaterThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1585.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 =
                                constructor_x64_pmaxs(ctx, pattern6_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr4_0 = C::xmm_to_xmm_mem(ctx, expr2_0);
                            let expr5_0 =
                                constructor_x64_pcmpeq(ctx, pattern6_0, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &IntCC::SignedLessThan => {
                            // Rule at src/isa/x64/lower.isle line 1562.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_0);
                            let expr2_0 =
                                constructor_x64_pcmpgt(ctx, pattern6_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1588.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 =
                                constructor_x64_pmins(ctx, pattern6_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr4_0 = C::xmm_to_xmm_mem(ctx, expr2_0);
                            let expr5_0 =
                                constructor_x64_pcmpeq(ctx, pattern6_0, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &IntCC::UnsignedGreaterThan => {
                            // Rule at src/isa/x64/lower.isle line 1564.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                            let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                            let expr3_0 =
                                constructor_x64_pmaxu(ctx, pattern6_0, expr0_0, &expr2_0)?;
                            let expr4_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                            let expr5_0 =
                                constructor_x64_pcmpeq(ctx, pattern6_0, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_vector_all_ones(ctx)?;
                            let expr7_0 = C::xmm_to_xmm_mem(ctx, expr6_0);
                            let expr8_0 = constructor_x64_pxor(ctx, expr5_0, &expr7_0)?;
                            let expr9_0 = constructor_output_xmm(ctx, expr8_0)?;
                            return Some(expr9_0);
                        }
                        &IntCC::UnsignedGreaterThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1591.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 =
                                constructor_x64_pmaxu(ctx, pattern6_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr4_0 = C::xmm_to_xmm_mem(ctx, expr2_0);
                            let expr5_0 =
                                constructor_x64_pcmpeq(ctx, pattern6_0, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        &IntCC::UnsignedLessThan => {
                            // Rule at src/isa/x64/lower.isle line 1574.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = constructor_put_in_xmm(ctx, pattern4_1)?;
                            let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                            let expr3_0 =
                                constructor_x64_pminu(ctx, pattern6_0, expr0_0, &expr2_0)?;
                            let expr4_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                            let expr5_0 =
                                constructor_x64_pcmpeq(ctx, pattern6_0, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_vector_all_ones(ctx)?;
                            let expr7_0 = C::xmm_to_xmm_mem(ctx, expr6_0);
                            let expr8_0 = constructor_x64_pxor(ctx, expr5_0, &expr7_0)?;
                            let expr9_0 = constructor_output_xmm(ctx, expr8_0)?;
                            return Some(expr9_0);
                        }
                        &IntCC::UnsignedLessThanOrEqual => {
                            // Rule at src/isa/x64/lower.isle line 1594.
                            let expr0_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr1_0 = C::put_in_xmm_mem(ctx, pattern4_1);
                            let expr2_0 =
                                constructor_x64_pminu(ctx, pattern6_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                            let expr4_0 = C::xmm_to_xmm_mem(ctx, expr2_0);
                            let expr5_0 =
                                constructor_x64_pcmpeq(ctx, pattern6_0, expr3_0, &expr4_0)?;
                            let expr6_0 = constructor_output_xmm(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                        _ => {}
                    }
                }
            }
        }
        &InstructionData::Ternary {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
        } => {
            if let &Opcode::SelectSpectreGuard = pattern2_0 {
                let (pattern4_0, pattern4_1, pattern4_2) = C::unpack_value_array_3(ctx, pattern2_1);
                if let Some(pattern5_0) = C::def_inst(ctx, pattern4_0) {
                    let pattern6_0 = C::inst_data(ctx, pattern5_0);
                    if let &InstructionData::IntCompare {
                        opcode: ref pattern7_0,
                        args: ref pattern7_1,
                        cond: ref pattern7_2,
                    } = &pattern6_0
                    {
                        if let &Opcode::Icmp = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_value_array_2(ctx, pattern7_1);
                            // Rule at src/isa/x64/lower.isle line 2965.
                            let expr0_0 =
                                constructor_emit_cmp(ctx, pattern7_2, pattern9_0, pattern9_1)?;
                            let expr1_0 =
                                constructor_select_icmp(ctx, &expr0_0, pattern4_1, pattern4_2)?;
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                    }
                }
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Uextend = pattern5_0 {
                    let pattern7_0 = C::value_type(ctx, pattern5_1);
                    if let Some(pattern8_0) = C::fits_in_32(ctx, pattern7_0) {
                        // Rule at src/isa/x64/lower.isle line 2149.
                        let expr0_0: Type = I64;
                        let expr1_0 = ExtendKind::Zero;
                        let expr2_0 =
                            constructor_extend_to_gpr(ctx, pattern5_1, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                }
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Uextend = pattern5_0 {
                    let pattern7_0 = C::value_type(ctx, pattern5_1);
                    if pattern7_0 == I64 {
                        // Rule at src/isa/x64/lower.isle line 2141.
                        let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                        let expr1_0: Type = I64;
                        let expr2_0: u64 = 0i128 as u64;
                        let expr3_0 = constructor_imm(ctx, expr1_0, expr2_0)?;
                        let expr4_0 = C::value_regs(ctx, expr0_0, expr3_0);
                        let expr5_0 = C::output(ctx, expr4_0);
                        return Some(expr5_0);
                    }
                }
            }
        }
        if let Some((pattern3_0, pattern3_1)) = C::multi_lane(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Bnot = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 1270.
                    let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                    let expr1_0 = constructor_vector_all_ones(ctx)?;
                    let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                    let expr3_0 = constructor_sse_xor(ctx, pattern2_0, expr0_0, &expr2_0)?;
                    let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                    return Some(expr4_0);
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    if let &Opcode::Ineg = pattern5_0 {
                        // Rule at src/isa/x64/lower.isle line 799.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                        let expr1_0 = constructor_x64_neg(ctx, pattern3_0, expr0_0)?;
                        let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Smin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1402.
                            let expr0_0 = CC::L;
                            let expr1_0 = constructor_cmp_and_choose(
                                ctx, pattern3_0, &expr0_0, pattern7_0, pattern7_1,
                            )?;
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Umin => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1396.
                            let expr0_0 = CC::B;
                            let expr1_0 = constructor_cmp_and_choose(
                                ctx, pattern3_0, &expr0_0, pattern7_0, pattern7_1,
                            )?;
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Smax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1405.
                            let expr0_0 = CC::NL;
                            let expr1_0 = constructor_cmp_and_choose(
                                ctx, pattern3_0, &expr0_0, pattern7_0, pattern7_1,
                            )?;
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Umax => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 1399.
                            let expr0_0 = CC::NB;
                            let expr1_0 = constructor_cmp_and_choose(
                                ctx, pattern3_0, &expr0_0, pattern7_0, pattern7_1,
                            )?;
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Iadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::sinkable_load(ctx, pattern7_0) {
                                // Rule at src/isa/x64/lower.isle line 67.
                                let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                                let expr1_0 =
                                    constructor_sink_load_to_gpr_mem_imm(ctx, &pattern8_0)?;
                                let expr2_0 =
                                    constructor_x64_add(ctx, pattern3_0, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                        &Opcode::Isub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::sinkable_load(ctx, pattern7_1) {
                                // Rule at src/isa/x64/lower.isle line 183.
                                let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                                let expr1_0 =
                                    constructor_sink_load_to_gpr_mem_imm(ctx, &pattern8_0)?;
                                let expr2_0 =
                                    constructor_x64_sub(ctx, pattern3_0, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                        &Opcode::Imul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::sinkable_load(ctx, pattern7_0) {
                                // Rule at src/isa/x64/lower.isle line 861.
                                let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                                let expr1_0 =
                                    constructor_sink_load_to_gpr_mem_imm(ctx, &pattern8_0)?;
                                let expr2_0 =
                                    constructor_x64_mul(ctx, pattern3_0, expr0_0, &expr1_0)?;
                                let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                                return Some(expr3_0);
                            }
                        }
                        &Opcode::Rotl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 758.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 =
                                constructor_put_masked_in_imm8_gpr(ctx, pattern7_1, pattern3_0)?;
                            let expr2_0 = constructor_x64_rotl(ctx, pattern3_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Rotr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 779.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 =
                                constructor_put_masked_in_imm8_gpr(ctx, pattern7_1, pattern3_0)?;
                            let expr2_0 = constructor_x64_rotr(ctx, pattern3_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Ishl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 422.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 =
                                constructor_put_masked_in_imm8_gpr(ctx, pattern7_1, pattern3_0)?;
                            let expr2_0 = constructor_x64_shl(ctx, pattern3_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                        &Opcode::Ushr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 533.
                            let expr0_0 = ExtendKind::Zero;
                            let expr1_0 =
                                constructor_extend_to_gpr(ctx, pattern7_0, pattern3_0, &expr0_0)?;
                            let expr2_0 =
                                constructor_put_masked_in_imm8_gpr(ctx, pattern7_1, pattern3_0)?;
                            let expr3_0 = constructor_x64_shr(ctx, pattern3_0, expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_gpr(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Sshr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/x64/lower.isle line 640.
                            let expr0_0 = ExtendKind::Sign;
                            let expr1_0 =
                                constructor_extend_to_gpr(ctx, pattern7_0, pattern3_0, &expr0_0)?;
                            let expr2_0 =
                                constructor_put_masked_in_imm8_gpr(ctx, pattern7_1, pattern3_0)?;
                            let expr3_0 = constructor_x64_sar(ctx, pattern3_0, expr1_0, &expr2_0)?;
                            let expr4_0 = constructor_output_gpr(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::ty_32_or_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Popcnt = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 1890.
                    let expr0_0 = constructor_put_in_gpr(ctx, pattern5_1)?;
                    let expr1_0 = constructor_do_popcnt(ctx, pattern3_0, expr0_0)?;
                    let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
            }
        }
        if let Some(pattern3_0) = C::ty_int_ref_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Load {
                opcode: ref pattern5_0,
                arg: pattern5_1,
                flags: pattern5_2,
                offset: pattern5_3,
            } = &pattern4_0
            {
                if let &Opcode::Load = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 2550.
                    let expr0_0 = constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                    let expr1_0 = constructor_x64_mov(ctx, &expr0_0)?;
                    let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        if let &InstructionData::Ternary {
            opcode: ref pattern4_0,
            args: ref pattern4_1,
        } = &pattern3_0
        {
            if let &Opcode::Select = pattern4_0 {
                let (pattern6_0, pattern6_1, pattern6_2) = C::unpack_value_array_3(ctx, pattern4_1);
                let pattern7_0 = C::value_type(ctx, pattern6_0);
                if let Some(pattern8_0) = C::fits_in_64(ctx, pattern7_0) {
                    // Rule at src/isa/x64/lower.isle line 1772.
                    let expr0_0 = C::raw_operand_size_of_type(ctx, pattern8_0);
                    let expr1_0 = constructor_put_in_gpr(ctx, pattern6_0)?;
                    let expr2_0 = C::gpr_to_gpr_mem_imm(ctx, expr1_0);
                    let expr3_0 = constructor_x64_test(ctx, &expr0_0, &expr2_0, expr1_0)?;
                    let expr4_0 = CC::NZ;
                    let expr5_0 = constructor_cmove_from_values(
                        ctx, pattern2_0, &expr4_0, pattern6_1, pattern6_2,
                    )?;
                    let expr6_0 = constructor_with_flags(ctx, &expr3_0, &expr5_0)?;
                    let expr7_0 = C::output(ctx, expr6_0);
                    return Some(expr7_0);
                }
            }
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::Store {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            if let &Opcode::Store = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if let Some(pattern6_0) = C::ty_vec128_int(ctx, pattern5_0) {
                    // Rule at src/isa/x64/lower.isle line 2661.
                    let expr0_0 = SseOpcode::Movdqu;
                    let expr1_0 = constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                    let expr2_0 = C::amode_to_synthetic_amode(ctx, &expr1_0);
                    let expr3_0 = constructor_put_in_xmm(ctx, pattern4_0)?;
                    let expr4_0 = constructor_x64_xmm_movrm(ctx, &expr0_0, &expr2_0, expr3_0)?;
                    let expr5_0 = constructor_side_effect(ctx, &expr4_0)?;
                    return Some(expr5_0);
                }
            }
        }
        &InstructionData::FloatCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Fcmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if let Some(pattern6_0) = C::ty_scalar_float(ctx, pattern5_0) {
                    // Rule at src/isa/x64/lower.isle line 1633.
                    let expr0_0 = constructor_emit_fcmp(ctx, pattern2_2, pattern4_0, pattern4_1)?;
                    let expr1_0 = constructor_lower_fcmp_bool(ctx, &expr0_0)?;
                    let expr2_0 = C::output(ctx, expr1_0);
                    return Some(expr2_0);
                }
            }
        }
        &InstructionData::IntCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Icmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if pattern5_0 == I128 {
                    // Rule at src/isa/x64/lower.isle line 1508.
                    let expr0_0 = constructor_emit_cmp(ctx, pattern2_2, pattern4_0, pattern4_1)?;
                    let expr1_0 = constructor_lower_icmp_bool(ctx, &expr0_0)?;
                    let expr2_0 = C::output(ctx, expr1_0);
                    return Some(expr2_0);
                }
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Ineg = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 802.
                    let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                    let expr1_0: usize = 0i128 as usize;
                    let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
                    let expr3_0: usize = 1i128 as usize;
                    let expr4_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr3_0)?;
                    let expr5_0: Type = I64;
                    let expr6_0 = constructor_x64_neg_paired(ctx, expr5_0, expr2_0)?;
                    let expr7_0: Type = I64;
                    let expr8_0: Type = I64;
                    let expr9_0: u64 = 0i128 as u64;
                    let expr10_0 = constructor_imm(ctx, expr8_0, expr9_0)?;
                    let expr11_0 = C::gpr_new(ctx, expr10_0);
                    let expr12_0 = C::gpr_to_gpr_mem_imm(ctx, expr4_0);
                    let expr13_0 = constructor_x64_sbb_paired(ctx, expr7_0, expr11_0, &expr12_0)?;
                    let expr14_0 = constructor_with_flags(ctx, &expr6_0, &expr13_0)?;
                    let expr15_0 = C::output(ctx, expr14_0);
                    return Some(expr15_0);
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_32(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Uextend = pattern5_0 {
                    let pattern7_0 = C::value_type(ctx, pattern5_1);
                    if let Some(pattern8_0) = C::fits_in_32(ctx, pattern7_0) {
                        // Rule at src/isa/x64/lower.isle line 2153.
                        let expr0_0: Type = I32;
                        let expr1_0 = ExtendKind::Zero;
                        let expr2_0 =
                            constructor_extend_to_gpr(ctx, pattern5_1, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::sinkable_load(ctx, pattern7_1) {
                            // Rule at src/isa/x64/lower.isle line 61.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 = constructor_sink_load_to_gpr_mem_imm(ctx, &pattern8_0)?;
                            let expr2_0 = constructor_x64_add(ctx, pattern3_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    &Opcode::Isub => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::simm32_from_value(ctx, pattern7_1) {
                            // Rule at src/isa/x64/lower.isle line 178.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 =
                                constructor_x64_sub(ctx, pattern3_0, expr0_0, &pattern8_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    &Opcode::Imul => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::sinkable_load(ctx, pattern7_1) {
                            // Rule at src/isa/x64/lower.isle line 855.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 = constructor_sink_load_to_gpr_mem_imm(ctx, &pattern8_0)?;
                            let expr2_0 = constructor_x64_mul(ctx, pattern3_0, expr0_0, &expr1_0)?;
                            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                            return Some(expr3_0);
                        }
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::ty_8_or_16(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Popcnt = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 1895.
                    let expr0_0: Type = I32;
                    let expr1_0: Type = I32;
                    let expr2_0 = ExtendKind::Zero;
                    let expr3_0 = constructor_extend_to_gpr(ctx, pattern5_1, expr1_0, &expr2_0)?;
                    let expr4_0 = constructor_do_popcnt(ctx, expr0_0, expr3_0)?;
                    let expr5_0 = constructor_output_gpr(ctx, expr4_0)?;
                    return Some(expr5_0);
                }
            }
        }
        if let Some(pattern3_0) = C::ty_vec128(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Load {
                opcode: ref pattern5_0,
                arg: pattern5_1,
                flags: pattern5_2,
                offset: pattern5_3,
            } = &pattern4_0
            {
                if let &Opcode::Load = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 2580.
                    let expr0_0 = constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                    let expr1_0 = constructor_amode_to_xmm_mem(ctx, &expr0_0)?;
                    let expr2_0 = constructor_x64_movdqu(ctx, &expr1_0)?;
                    let expr3_0 = constructor_output_xmm(ctx, expr2_0)?;
                    return Some(expr3_0);
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        if let &InstructionData::Unary {
            opcode: ref pattern4_0,
            arg: pattern4_1,
        } = &pattern3_0
        {
            if let &Opcode::Bnot = pattern4_0 {
                let mut closure6 = || {
                    let expr0_0 = C::ty_int_ref_scalar_64(ctx, pattern2_0)?;
                    return Some(expr0_0);
                };
                if let Some(pattern6_0) = closure6() {
                    // Rule at src/isa/x64/lower.isle line 1245.
                    let expr0_0 = constructor_put_in_gpr(ctx, pattern4_1)?;
                    let expr1_0 = constructor_x64_not(ctx, pattern2_0, expr0_0)?;
                    let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
            }
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::Store {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            if let &Opcode::Store = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if let Some(pattern6_0) = C::type_register_class(ctx, pattern5_0) {
                    if let &RegisterClass::Gpr {
                        single_register: pattern7_0,
                    } = &pattern6_0
                    {
                        // Rule at src/isa/x64/lower.isle line 2610.
                        let expr0_0 =
                            constructor_to_amode(ctx, pattern2_2, pattern4_1, pattern2_3)?;
                        let expr1_0 = C::amode_to_synthetic_amode(ctx, &expr0_0);
                        let expr2_0 = constructor_put_in_gpr(ctx, pattern4_0)?;
                        let expr3_0 = constructor_x64_movrm(ctx, pattern5_0, &expr1_0, expr2_0)?;
                        let expr4_0 = constructor_side_effect(ctx, &expr3_0)?;
                        return Some(expr4_0);
                    }
                }
            }
        }
        &InstructionData::IntCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Icmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if let Some(pattern6_0) = C::fits_in_64(ctx, pattern5_0) {
                    // Rule at src/isa/x64/lower.isle line 1505.
                    let expr0_0 = constructor_emit_cmp(ctx, pattern2_2, pattern4_0, pattern4_1)?;
                    let expr1_0 = constructor_lower_icmp_bool(ctx, &expr0_0)?;
                    let expr2_0 = C::output(ctx, expr1_0);
                    return Some(expr2_0);
                }
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Load {
                opcode: ref pattern5_0,
                arg: pattern5_1,
                flags: pattern5_2,
                offset: pattern5_3,
            } = &pattern4_0
            {
                if let &Opcode::Load = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 2584.
                    let expr0_0 = constructor_to_amode(ctx, pattern5_2, pattern5_1, pattern5_3)?;
                    let expr1_0: u32 = 8i128 as u32;
                    let expr2_0 = C::amode_offset(ctx, &expr0_0, expr1_0);
                    let expr3_0 = constructor_x64_mov(ctx, &expr0_0)?;
                    let expr4_0 = constructor_x64_mov(ctx, &expr2_0)?;
                    let expr5_0 = C::value_regs(ctx, expr3_0, expr4_0);
                    let expr6_0 = C::output(ctx, expr5_0);
                    return Some(expr6_0);
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::simm32_from_value(ctx, pattern7_0) {
                            // Rule at src/isa/x64/lower.isle line 55.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr1_0 =
                                constructor_x64_add(ctx, pattern3_0, expr0_0, &pattern8_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    &Opcode::Isub => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 173.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                        let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern7_1)?;
                        let expr2_0 = constructor_x64_sub(ctx, pattern3_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Imul => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::simm32_from_value(ctx, pattern7_1) {
                            // Rule at src/isa/x64/lower.isle line 845.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 =
                                constructor_x64_mul(ctx, pattern3_0, expr0_0, &pattern8_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::ty_scalar_float(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Bnot = pattern5_0 {
                    // Rule at src/isa/x64/lower.isle line 1265.
                    let expr0_0 = constructor_put_in_xmm(ctx, pattern5_1)?;
                    let expr1_0 = constructor_vector_all_ones(ctx)?;
                    let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
                    let expr3_0 = constructor_sse_xor(ctx, pattern3_0, expr0_0, &expr2_0)?;
                    let expr4_0 = constructor_output_xmm(ctx, expr3_0)?;
                    return Some(expr4_0);
                }
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some(pattern3_0) = C::fits_in_32(ctx, pattern2_0) {
            if let Some(pattern4_0) = C::type_register_class(ctx, pattern2_0) {
                if let &RegisterClass::Gpr {
                    single_register: pattern5_0,
                } = &pattern4_0
                {
                    let pattern6_0 = C::inst_data(ctx, pattern0_0);
                    if let &InstructionData::Load {
                        opcode: ref pattern7_0,
                        arg: pattern7_1,
                        flags: pattern7_2,
                        offset: pattern7_3,
                    } = &pattern6_0
                    {
                        if let &Opcode::Load = pattern7_0 {
                            // Rule at src/isa/x64/lower.isle line 2546.
                            let expr0_0 = C::ty_bits_u16(ctx, pattern3_0);
                            let expr1_0: u16 = 64i128 as u16;
                            let expr2_0 = C::ext_mode(ctx, expr0_0, expr1_0);
                            let expr3_0 =
                                constructor_to_amode(ctx, pattern7_2, pattern7_1, pattern7_3)?;
                            let expr4_0 = constructor_amode_to_gpr_mem(ctx, &expr3_0)?;
                            let expr5_0 = constructor_x64_movzx(ctx, &expr2_0, &expr4_0)?;
                            let expr6_0 = constructor_output_gpr(ctx, expr5_0)?;
                            return Some(expr6_0);
                        }
                    }
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::simm32_from_value(ctx, pattern7_1) {
                            // Rule at src/isa/x64/lower.isle line 51.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                            let expr1_0 =
                                constructor_x64_add(ctx, pattern3_0, expr0_0, &pattern8_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    &Opcode::Imul => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::simm32_from_value(ctx, pattern7_0) {
                            // Rule at src/isa/x64/lower.isle line 849.
                            let expr0_0 = constructor_put_in_gpr(ctx, pattern7_1)?;
                            let expr1_0 =
                                constructor_x64_mul(ctx, pattern3_0, expr0_0, &pattern8_0)?;
                            let expr2_0 = constructor_output_gpr(ctx, expr1_0)?;
                            return Some(expr2_0);
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 45.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                        let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern7_1)?;
                        let expr2_0 = constructor_x64_add(ctx, pattern3_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    &Opcode::Imul => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/x64/lower.isle line 840.
                        let expr0_0 = constructor_put_in_gpr(ctx, pattern7_0)?;
                        let expr1_0 = constructor_put_in_gpr_mem_imm(ctx, pattern7_1)?;
                        let expr2_0 = constructor_x64_mul(ctx, pattern3_0, expr0_0, &expr1_0)?;
                        let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
                        return Some(expr3_0);
                    }
                    _ => {}
                }
            }
        }
    }
    return None;
}

// Generated as internal constructor for term lower_branch.
pub fn constructor_lower_branch<C: Context>(
    ctx: &mut C,
    arg0: Inst,
    arg1: &MachLabelSlice,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    if let &InstructionData::Branch {
        opcode: ref pattern2_0,
        args: pattern2_1,
        destination: pattern2_2,
    } = &pattern1_0
    {
        match pattern2_0 {
            &Opcode::Brz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    if let Some(pattern6_0) = C::def_inst(ctx, pattern5_0) {
                        let pattern7_0 = C::inst_data(ctx, pattern6_0);
                        match &pattern7_0 {
                            &InstructionData::FloatCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Fcmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = arg1;
                                    if let Some((pattern12_0, pattern12_1)) =
                                        C::two_targets(ctx, pattern11_0)
                                    {
                                        // Rule at src/isa/x64/lower.isle line 2906.
                                        let expr0_0 = C::floatcc_inverse(ctx, pattern8_2);
                                        let expr1_0 = constructor_emit_fcmp(
                                            ctx,
                                            &expr0_0,
                                            pattern10_0,
                                            pattern10_1,
                                        )?;
                                        let expr2_0 = constructor_jmp_cond_fcmp(
                                            ctx,
                                            &expr1_0,
                                            pattern12_0,
                                            pattern12_1,
                                        )?;
                                        let expr3_0 = constructor_side_effect(ctx, &expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                            &InstructionData::IntCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Icmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = arg1;
                                    if let Some((pattern12_0, pattern12_1)) =
                                        C::two_targets(ctx, pattern11_0)
                                    {
                                        // Rule at src/isa/x64/lower.isle line 2902.
                                        let expr0_0 = constructor_emit_cmp(
                                            ctx,
                                            pattern8_2,
                                            pattern10_0,
                                            pattern10_1,
                                        )?;
                                        let expr1_0 =
                                            constructor_invert_icmp_cond_result(ctx, &expr0_0)?;
                                        let expr2_0 = constructor_jmp_cond_icmp(
                                            ctx,
                                            &expr1_0,
                                            pattern12_0,
                                            pattern12_1,
                                        )?;
                                        let expr3_0 = constructor_side_effect(ctx, &expr2_0)?;
                                        return Some(expr3_0);
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            &Opcode::Brnz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    if let Some(pattern6_0) = C::def_inst(ctx, pattern5_0) {
                        let pattern7_0 = C::inst_data(ctx, pattern6_0);
                        match &pattern7_0 {
                            &InstructionData::FloatCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Fcmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = arg1;
                                    if let Some((pattern12_0, pattern12_1)) =
                                        C::two_targets(ctx, pattern11_0)
                                    {
                                        // Rule at src/isa/x64/lower.isle line 2922.
                                        let expr0_0 = constructor_emit_fcmp(
                                            ctx,
                                            pattern8_2,
                                            pattern10_0,
                                            pattern10_1,
                                        )?;
                                        let expr1_0 = constructor_jmp_cond_fcmp(
                                            ctx,
                                            &expr0_0,
                                            pattern12_0,
                                            pattern12_1,
                                        )?;
                                        let expr2_0 = constructor_side_effect(ctx, &expr1_0)?;
                                        return Some(expr2_0);
                                    }
                                }
                            }
                            &InstructionData::IntCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Icmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = arg1;
                                    if let Some((pattern12_0, pattern12_1)) =
                                        C::two_targets(ctx, pattern11_0)
                                    {
                                        // Rule at src/isa/x64/lower.isle line 2919.
                                        let expr0_0 = constructor_emit_cmp(
                                            ctx,
                                            pattern8_2,
                                            pattern10_0,
                                            pattern10_1,
                                        )?;
                                        let expr1_0 = constructor_jmp_cond_icmp(
                                            ctx,
                                            &expr0_0,
                                            pattern12_0,
                                            pattern12_1,
                                        )?;
                                        let expr2_0 = constructor_side_effect(ctx, &expr1_0)?;
                                        return Some(expr2_0);
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    if let &InstructionData::Branch {
        opcode: ref pattern2_0,
        args: pattern2_1,
        destination: pattern2_2,
    } = &pattern1_0
    {
        match pattern2_0 {
            &Opcode::Brz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    let pattern6_0 = C::value_type(ctx, pattern5_0);
                    if pattern6_0 == I128 {
                        let pattern8_0 = arg1;
                        if let Some((pattern9_0, pattern9_1)) = C::two_targets(ctx, pattern8_0) {
                            // Rule at src/isa/x64/lower.isle line 2910.
                            let expr0_0 = CC::NZ;
                            let expr1_0 = C::put_in_regs(ctx, pattern5_0);
                            let expr2_0 = constructor_cmp_zero_i128(ctx, &expr0_0, expr1_0)?;
                            let expr3_0 =
                                constructor_jmp_cond_icmp(ctx, &expr2_0, pattern9_0, pattern9_1)?;
                            let expr4_0 = constructor_side_effect(ctx, &expr3_0)?;
                            return Some(expr4_0);
                        }
                    }
                }
            }
            &Opcode::Brnz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    let pattern6_0 = C::value_type(ctx, pattern5_0);
                    if pattern6_0 == I128 {
                        let pattern8_0 = arg1;
                        if let Some((pattern9_0, pattern9_1)) = C::two_targets(ctx, pattern8_0) {
                            // Rule at src/isa/x64/lower.isle line 2926.
                            let expr0_0 = CC::Z;
                            let expr1_0 = C::put_in_regs(ctx, pattern5_0);
                            let expr2_0 = constructor_cmp_zero_i128(ctx, &expr0_0, expr1_0)?;
                            let expr3_0 =
                                constructor_jmp_cond_icmp(ctx, &expr2_0, pattern9_0, pattern9_1)?;
                            let expr4_0 = constructor_side_effect(ctx, &expr3_0)?;
                            return Some(expr4_0);
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::BranchTable {
            opcode: ref pattern2_0,
            arg: pattern2_1,
            destination: pattern2_2,
            table: pattern2_3,
        } => {
            if let &Opcode::BrTable = pattern2_0 {
                let pattern4_0 = C::value_type(ctx, pattern2_1);
                let pattern5_0 = arg1;
                if let Some((pattern6_0, pattern6_1)) = C::jump_table_targets(ctx, pattern5_0) {
                    // Rule at src/isa/x64/lower.isle line 2960.
                    let expr0_0 = constructor_put_in_gpr(ctx, pattern2_1)?;
                    let expr1_0 = constructor_jmp_table_seq(
                        ctx,
                        pattern4_0,
                        expr0_0,
                        pattern6_0,
                        &pattern6_1,
                    )?;
                    let expr2_0 = constructor_side_effect(ctx, &expr1_0)?;
                    return Some(expr2_0);
                }
            }
        }
        &InstructionData::Branch {
            opcode: ref pattern2_0,
            args: pattern2_1,
            destination: pattern2_2,
        } => {
            match pattern2_0 {
                &Opcode::Brz => {
                    let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                    if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                        let pattern6_0 = C::value_type(ctx, pattern5_0);
                        if let Some(()) = C::ty_int_bool_or_ref(ctx, pattern6_0) {
                            let pattern8_0 = arg1;
                            if let Some((pattern9_0, pattern9_1)) = C::two_targets(ctx, pattern8_0)
                            {
                                // Rule at src/isa/x64/lower.isle line 2913.
                                let expr0_0 = constructor_cmp_zero_int_bool_ref(ctx, pattern5_0)?;
                                let expr1_0 = CC::Z;
                                let expr2_0 =
                                    constructor_jmp_cond(ctx, &expr1_0, pattern9_0, pattern9_1)?;
                                let expr3_0 =
                                    constructor_with_flags_side_effect(ctx, &expr0_0, &expr2_0)?;
                                let expr4_0 = constructor_side_effect(ctx, &expr3_0)?;
                                return Some(expr4_0);
                            }
                        }
                    }
                }
                &Opcode::Brnz => {
                    let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                    if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                        let pattern6_0 = C::value_type(ctx, pattern5_0);
                        if let Some(()) = C::ty_int_bool_or_ref(ctx, pattern6_0) {
                            let pattern8_0 = arg1;
                            if let Some((pattern9_0, pattern9_1)) = C::two_targets(ctx, pattern8_0)
                            {
                                // Rule at src/isa/x64/lower.isle line 2929.
                                let expr0_0 = constructor_cmp_zero_int_bool_ref(ctx, pattern5_0)?;
                                let expr1_0 = CC::NZ;
                                let expr2_0 =
                                    constructor_jmp_cond(ctx, &expr1_0, pattern9_0, pattern9_1)?;
                                let expr3_0 =
                                    constructor_with_flags_side_effect(ctx, &expr0_0, &expr2_0)?;
                                let expr4_0 = constructor_side_effect(ctx, &expr3_0)?;
                                return Some(expr4_0);
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::Jump {
            opcode: ref pattern2_0,
            args: pattern2_1,
            destination: pattern2_2,
        } => {
            if let &Opcode::Jump = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                let pattern5_0 = arg1;
                if let Some(pattern6_0) = C::single_target(ctx, pattern5_0) {
                    // Rule at src/isa/x64/lower.isle line 2897.
                    let expr0_0 = constructor_jmp_known(ctx, pattern6_0)?;
                    let expr1_0 = constructor_side_effect(ctx, &expr0_0)?;
                    return Some(expr1_0);
                }
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term output_ifcout.
pub fn constructor_output_ifcout<C: Context>(ctx: &mut C, arg0: Reg) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/lower.isle line 138.
    let expr0_0 = C::value_reg(ctx, pattern0_0);
    let expr1_0 = C::value_regs_invalid(ctx);
    let expr2_0 = C::output_pair(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term sse_and.
pub fn constructor_sse_and<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 282.
        let expr0_0 = constructor_x64_andps(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == F64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 283.
        let expr0_0 = constructor_x64_andpd(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == F32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 280.
        let expr0_0 = constructor_x64_andps(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == F64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 281.
        let expr0_0 = constructor_x64_andpd(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::multi_lane(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 284.
        let expr0_0 = constructor_x64_pand(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term sse_or.
pub fn constructor_sse_or<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 343.
        let expr0_0 = constructor_x64_orps(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == F64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 344.
        let expr0_0 = constructor_x64_orpd(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == F32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 341.
        let expr0_0 = constructor_x64_orps(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == F64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 342.
        let expr0_0 = constructor_x64_orpd(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::multi_lane(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 345.
        let expr0_0 = constructor_x64_por(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term or_i128.
pub fn constructor_or_i128<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/lower.isle line 354.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = constructor_value_regs_get_gpr(ctx, pattern0_0, expr0_0)?;
    let expr2_0: usize = 1i128 as usize;
    let expr3_0 = constructor_value_regs_get_gpr(ctx, pattern0_0, expr2_0)?;
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = constructor_value_regs_get_gpr(ctx, pattern1_0, expr4_0)?;
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = constructor_value_regs_get_gpr(ctx, pattern1_0, expr6_0)?;
    let expr8_0: Type = I64;
    let expr9_0 = C::gpr_to_gpr_mem_imm(ctx, expr5_0);
    let expr10_0 = constructor_x64_or(ctx, expr8_0, expr1_0, &expr9_0)?;
    let expr11_0: Type = I64;
    let expr12_0 = C::gpr_to_gpr_mem_imm(ctx, expr7_0);
    let expr13_0 = constructor_x64_or(ctx, expr11_0, expr3_0, &expr12_0)?;
    let expr14_0 = constructor_value_gprs(ctx, expr10_0, expr13_0)?;
    return Some(expr14_0);
}

// Generated as internal constructor for term shl_i128.
pub fn constructor_shl_i128<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: Gpr,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/lower.isle line 428.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = constructor_value_regs_get_gpr(ctx, pattern0_0, expr0_0)?;
    let expr2_0: usize = 1i128 as usize;
    let expr3_0 = constructor_value_regs_get_gpr(ctx, pattern0_0, expr2_0)?;
    let expr4_0: Type = I64;
    let expr5_0 = C::gpr_to_imm8_gpr(ctx, pattern1_0);
    let expr6_0 = constructor_x64_shl(ctx, expr4_0, expr1_0, &expr5_0)?;
    let expr7_0: Type = I64;
    let expr8_0 = C::gpr_to_imm8_gpr(ctx, pattern1_0);
    let expr9_0 = constructor_x64_shl(ctx, expr7_0, expr3_0, &expr8_0)?;
    let expr10_0: Type = I64;
    let expr11_0: Type = I64;
    let expr12_0: Type = I64;
    let expr13_0: u64 = 64i128 as u64;
    let expr14_0 = constructor_imm(ctx, expr12_0, expr13_0)?;
    let expr15_0 = C::gpr_new(ctx, expr14_0);
    let expr16_0 = C::gpr_to_gpr_mem_imm(ctx, pattern1_0);
    let expr17_0 = constructor_x64_sub(ctx, expr11_0, expr15_0, &expr16_0)?;
    let expr18_0 = C::gpr_to_imm8_gpr(ctx, expr17_0);
    let expr19_0 = constructor_x64_shr(ctx, expr10_0, expr1_0, &expr18_0)?;
    let expr20_0: Type = I64;
    let expr21_0: u64 = 0i128 as u64;
    let expr22_0 = constructor_imm(ctx, expr20_0, expr21_0)?;
    let expr23_0 = C::gpr_new(ctx, expr22_0);
    let expr24_0 = OperandSize::Size64;
    let expr25_0: u32 = 127i128 as u32;
    let expr26_0 = RegMemImm::Imm { simm32: expr25_0 };
    let expr27_0 = C::gpr_mem_imm_new(ctx, &expr26_0);
    let expr28_0 = constructor_x64_test(ctx, &expr24_0, &expr27_0, pattern1_0)?;
    let expr29_0: Type = I64;
    let expr30_0 = CC::Z;
    let expr31_0 = C::gpr_to_gpr_mem(ctx, expr23_0);
    let expr32_0 = constructor_cmove(ctx, expr29_0, &expr30_0, &expr31_0, expr19_0)?;
    let expr33_0 = constructor_with_flags_reg(ctx, &expr28_0, &expr32_0)?;
    let expr34_0 = C::gpr_new(ctx, expr33_0);
    let expr35_0: Type = I64;
    let expr36_0 = C::gpr_to_gpr_mem_imm(ctx, expr9_0);
    let expr37_0 = constructor_x64_or(ctx, expr35_0, expr34_0, &expr36_0)?;
    let expr38_0 = OperandSize::Size64;
    let expr39_0: u32 = 64i128 as u32;
    let expr40_0 = RegMemImm::Imm { simm32: expr39_0 };
    let expr41_0 = C::gpr_mem_imm_new(ctx, &expr40_0);
    let expr42_0 = constructor_x64_test(ctx, &expr38_0, &expr41_0, pattern1_0)?;
    let expr43_0: Type = I64;
    let expr44_0 = CC::Z;
    let expr45_0 = C::gpr_to_gpr_mem(ctx, expr6_0);
    let expr46_0 = constructor_cmove(ctx, expr43_0, &expr44_0, &expr45_0, expr23_0)?;
    let expr47_0: Type = I64;
    let expr48_0 = CC::Z;
    let expr49_0 = C::gpr_to_gpr_mem(ctx, expr37_0);
    let expr50_0 = constructor_cmove(ctx, expr47_0, &expr48_0, &expr49_0, expr6_0)?;
    let expr51_0 = constructor_consumes_flags_concat(ctx, &expr46_0, &expr50_0)?;
    let expr52_0 = constructor_with_flags(ctx, &expr42_0, &expr51_0)?;
    return Some(expr52_0);
}

// Generated as internal constructor for term ishl_i8x16_mask.
pub fn constructor_ishl_i8x16_mask<C: Context>(
    ctx: &mut C,
    arg0: &RegMemImm,
) -> Option<SyntheticAmode> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &RegMemImm::Imm { simm32: pattern1_0 } => {
            // Rule at src/isa/x64/lower.isle line 493.
            let expr0_0 = C::ishl_i8x16_mask_for_const(ctx, pattern1_0);
            return Some(expr0_0);
        }
        &RegMemImm::Reg { reg: pattern1_0 } => {
            // Rule at src/isa/x64/lower.isle line 502.
            let expr0_0 = C::ishl_i8x16_mask_table(ctx);
            let expr1_0 = constructor_x64_lea(ctx, &expr0_0)?;
            let expr2_0: Type = I64;
            let expr3_0 = C::gpr_new(ctx, pattern1_0);
            let expr4_0: u8 = 4i128 as u8;
            let expr5_0 = C::imm8_to_imm8_gpr(ctx, expr4_0);
            let expr6_0 = constructor_x64_shl(ctx, expr2_0, expr3_0, &expr5_0)?;
            let expr7_0: u32 = 0i128 as u32;
            let expr8_0: u8 = 0i128 as u8;
            let expr9_0 = C::amode_imm_reg_reg_shift(ctx, expr7_0, expr1_0, expr6_0, expr8_0);
            let expr10_0 = C::amode_to_synthetic_amode(ctx, &expr9_0);
            return Some(expr10_0);
        }
        &RegMemImm::Mem {
            addr: ref pattern1_0,
        } => {
            // Rule at src/isa/x64/lower.isle line 512.
            let expr0_0: Type = I64;
            let expr1_0 = ExtKind::None;
            let expr2_0 = constructor_x64_load(ctx, expr0_0, pattern1_0, &expr1_0)?;
            let expr3_0 = RegMemImm::Reg { reg: expr2_0 };
            let expr4_0 = constructor_ishl_i8x16_mask(ctx, &expr3_0)?;
            return Some(expr4_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term shr_i128.
pub fn constructor_shr_i128<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: Gpr,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/lower.isle line 540.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = constructor_value_regs_get_gpr(ctx, pattern0_0, expr0_0)?;
    let expr2_0: usize = 1i128 as usize;
    let expr3_0 = constructor_value_regs_get_gpr(ctx, pattern0_0, expr2_0)?;
    let expr4_0: Type = I64;
    let expr5_0 = C::gpr_to_imm8_gpr(ctx, pattern1_0);
    let expr6_0 = constructor_x64_shr(ctx, expr4_0, expr1_0, &expr5_0)?;
    let expr7_0: Type = I64;
    let expr8_0 = C::gpr_to_imm8_gpr(ctx, pattern1_0);
    let expr9_0 = constructor_x64_shr(ctx, expr7_0, expr3_0, &expr8_0)?;
    let expr10_0: Type = I64;
    let expr11_0: Type = I64;
    let expr12_0: Type = I64;
    let expr13_0: u64 = 64i128 as u64;
    let expr14_0 = constructor_imm(ctx, expr12_0, expr13_0)?;
    let expr15_0 = C::gpr_new(ctx, expr14_0);
    let expr16_0 = C::gpr_to_gpr_mem_imm(ctx, pattern1_0);
    let expr17_0 = constructor_x64_sub(ctx, expr11_0, expr15_0, &expr16_0)?;
    let expr18_0 = C::gpr_to_imm8_gpr(ctx, expr17_0);
    let expr19_0 = constructor_x64_shl(ctx, expr10_0, expr3_0, &expr18_0)?;
    let expr20_0 = OperandSize::Size64;
    let expr21_0: u32 = 127i128 as u32;
    let expr22_0 = RegMemImm::Imm { simm32: expr21_0 };
    let expr23_0 = C::gpr_mem_imm_new(ctx, &expr22_0);
    let expr24_0 = constructor_x64_test(ctx, &expr20_0, &expr23_0, pattern1_0)?;
    let expr25_0: Type = I64;
    let expr26_0 = CC::Z;
    let expr27_0: Type = I64;
    let expr28_0: u64 = 0i128 as u64;
    let expr29_0 = constructor_imm(ctx, expr27_0, expr28_0)?;
    let expr30_0 = C::reg_to_gpr_mem(ctx, expr29_0);
    let expr31_0 = constructor_cmove(ctx, expr25_0, &expr26_0, &expr30_0, expr19_0)?;
    let expr32_0 = constructor_with_flags_reg(ctx, &expr24_0, &expr31_0)?;
    let expr33_0 = C::gpr_new(ctx, expr32_0);
    let expr34_0: Type = I64;
    let expr35_0 = C::gpr_to_gpr_mem_imm(ctx, expr6_0);
    let expr36_0 = constructor_x64_or(ctx, expr34_0, expr33_0, &expr35_0)?;
    let expr37_0 = OperandSize::Size64;
    let expr38_0: u32 = 64i128 as u32;
    let expr39_0 = RegMemImm::Imm { simm32: expr38_0 };
    let expr40_0 = C::gpr_mem_imm_new(ctx, &expr39_0);
    let expr41_0 = constructor_x64_test(ctx, &expr37_0, &expr40_0, pattern1_0)?;
    let expr42_0: Type = I64;
    let expr43_0 = CC::Z;
    let expr44_0 = C::gpr_to_gpr_mem(ctx, expr36_0);
    let expr45_0 = constructor_cmove(ctx, expr42_0, &expr43_0, &expr44_0, expr9_0)?;
    let expr46_0: Type = I64;
    let expr47_0 = CC::Z;
    let expr48_0 = C::gpr_to_gpr_mem(ctx, expr9_0);
    let expr49_0: Type = I64;
    let expr50_0: u64 = 0i128 as u64;
    let expr51_0 = constructor_imm(ctx, expr49_0, expr50_0)?;
    let expr52_0 = C::gpr_new(ctx, expr51_0);
    let expr53_0 = constructor_cmove(ctx, expr46_0, &expr47_0, &expr48_0, expr52_0)?;
    let expr54_0 = constructor_consumes_flags_concat(ctx, &expr45_0, &expr53_0)?;
    let expr55_0 = constructor_with_flags(ctx, &expr41_0, &expr54_0)?;
    return Some(expr55_0);
}

// Generated as internal constructor for term ushr_i8x16_mask.
pub fn constructor_ushr_i8x16_mask<C: Context>(
    ctx: &mut C,
    arg0: &RegMemImm,
) -> Option<SyntheticAmode> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &RegMemImm::Imm { simm32: pattern1_0 } => {
            // Rule at src/isa/x64/lower.isle line 599.
            let expr0_0 = C::ushr_i8x16_mask_for_const(ctx, pattern1_0);
            return Some(expr0_0);
        }
        &RegMemImm::Reg { reg: pattern1_0 } => {
            // Rule at src/isa/x64/lower.isle line 608.
            let expr0_0 = C::ushr_i8x16_mask_table(ctx);
            let expr1_0 = constructor_x64_lea(ctx, &expr0_0)?;
            let expr2_0: Type = I64;
            let expr3_0 = C::gpr_new(ctx, pattern1_0);
            let expr4_0: u8 = 4i128 as u8;
            let expr5_0 = C::imm8_to_imm8_gpr(ctx, expr4_0);
            let expr6_0 = constructor_x64_shl(ctx, expr2_0, expr3_0, &expr5_0)?;
            let expr7_0: u32 = 0i128 as u32;
            let expr8_0: u8 = 0i128 as u8;
            let expr9_0 = C::amode_imm_reg_reg_shift(ctx, expr7_0, expr1_0, expr6_0, expr8_0);
            let expr10_0 = C::amode_to_synthetic_amode(ctx, &expr9_0);
            return Some(expr10_0);
        }
        &RegMemImm::Mem {
            addr: ref pattern1_0,
        } => {
            // Rule at src/isa/x64/lower.isle line 619.
            let expr0_0: Type = I64;
            let expr1_0 = ExtKind::None;
            let expr2_0 = constructor_x64_load(ctx, expr0_0, pattern1_0, &expr1_0)?;
            let expr3_0 = RegMemImm::Reg { reg: expr2_0 };
            let expr4_0 = constructor_ushr_i8x16_mask(ctx, &expr3_0)?;
            return Some(expr4_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term sar_i128.
pub fn constructor_sar_i128<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: Gpr,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/lower.isle line 647.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = constructor_value_regs_get_gpr(ctx, pattern0_0, expr0_0)?;
    let expr2_0: usize = 1i128 as usize;
    let expr3_0 = constructor_value_regs_get_gpr(ctx, pattern0_0, expr2_0)?;
    let expr4_0: Type = I64;
    let expr5_0 = C::gpr_to_imm8_gpr(ctx, pattern1_0);
    let expr6_0 = constructor_x64_shr(ctx, expr4_0, expr1_0, &expr5_0)?;
    let expr7_0: Type = I64;
    let expr8_0 = C::gpr_to_imm8_gpr(ctx, pattern1_0);
    let expr9_0 = constructor_x64_sar(ctx, expr7_0, expr3_0, &expr8_0)?;
    let expr10_0: Type = I64;
    let expr11_0: Type = I64;
    let expr12_0: Type = I64;
    let expr13_0: u64 = 64i128 as u64;
    let expr14_0 = constructor_imm(ctx, expr12_0, expr13_0)?;
    let expr15_0 = C::gpr_new(ctx, expr14_0);
    let expr16_0 = C::gpr_to_gpr_mem_imm(ctx, pattern1_0);
    let expr17_0 = constructor_x64_sub(ctx, expr11_0, expr15_0, &expr16_0)?;
    let expr18_0 = C::gpr_to_imm8_gpr(ctx, expr17_0);
    let expr19_0 = constructor_x64_shl(ctx, expr10_0, expr3_0, &expr18_0)?;
    let expr20_0 = OperandSize::Size64;
    let expr21_0: u32 = 127i128 as u32;
    let expr22_0 = RegMemImm::Imm { simm32: expr21_0 };
    let expr23_0 = C::gpr_mem_imm_new(ctx, &expr22_0);
    let expr24_0 = constructor_x64_test(ctx, &expr20_0, &expr23_0, pattern1_0)?;
    let expr25_0: Type = I64;
    let expr26_0 = CC::Z;
    let expr27_0: Type = I64;
    let expr28_0: u64 = 0i128 as u64;
    let expr29_0 = constructor_imm(ctx, expr27_0, expr28_0)?;
    let expr30_0 = C::reg_to_gpr_mem(ctx, expr29_0);
    let expr31_0 = constructor_cmove(ctx, expr25_0, &expr26_0, &expr30_0, expr19_0)?;
    let expr32_0 = constructor_with_flags_reg(ctx, &expr24_0, &expr31_0)?;
    let expr33_0 = C::gpr_new(ctx, expr32_0);
    let expr34_0: Type = I64;
    let expr35_0 = C::gpr_to_gpr_mem_imm(ctx, expr33_0);
    let expr36_0 = constructor_x64_or(ctx, expr34_0, expr6_0, &expr35_0)?;
    let expr37_0: Type = I64;
    let expr38_0: u8 = 63i128 as u8;
    let expr39_0 = C::imm8_to_imm8_gpr(ctx, expr38_0);
    let expr40_0 = constructor_x64_sar(ctx, expr37_0, expr3_0, &expr39_0)?;
    let expr41_0 = OperandSize::Size64;
    let expr42_0: u32 = 64i128 as u32;
    let expr43_0 = RegMemImm::Imm { simm32: expr42_0 };
    let expr44_0 = C::gpr_mem_imm_new(ctx, &expr43_0);
    let expr45_0 = constructor_x64_test(ctx, &expr41_0, &expr44_0, pattern1_0)?;
    let expr46_0: Type = I64;
    let expr47_0 = CC::Z;
    let expr48_0 = C::gpr_to_gpr_mem(ctx, expr36_0);
    let expr49_0 = constructor_cmove(ctx, expr46_0, &expr47_0, &expr48_0, expr9_0)?;
    let expr50_0: Type = I64;
    let expr51_0 = CC::Z;
    let expr52_0 = C::gpr_to_gpr_mem(ctx, expr9_0);
    let expr53_0 = constructor_cmove(ctx, expr50_0, &expr51_0, &expr52_0, expr40_0)?;
    let expr54_0 = constructor_consumes_flags_concat(ctx, &expr49_0, &expr53_0)?;
    let expr55_0 = constructor_with_flags(ctx, &expr45_0, &expr54_0)?;
    return Some(expr55_0);
}

// Generated as internal constructor for term sshr_i8x16_bigger_shift.
pub fn constructor_sshr_i8x16_bigger_shift<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &RegMemImm,
) -> Option<XmmMemImm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    match pattern1_0 {
        &RegMemImm::Imm { simm32: pattern2_0 } => {
            // Rule at src/isa/x64/lower.isle line 713.
            let expr0_0: u32 = 8i128 as u32;
            let expr1_0 = C::u32_add(ctx, pattern2_0, expr0_0);
            let expr2_0 = RegMemImm::Imm { simm32: expr1_0 };
            let expr3_0 = C::xmm_mem_imm_new(ctx, &expr2_0);
            return Some(expr3_0);
        }
        &RegMemImm::Reg { reg: pattern2_0 } => {
            // Rule at src/isa/x64/lower.isle line 715.
            let expr0_0 = C::gpr_new(ctx, pattern2_0);
            let expr1_0: u32 = 8i128 as u32;
            let expr2_0 = RegMemImm::Imm { simm32: expr1_0 };
            let expr3_0 = C::gpr_mem_imm_new(ctx, &expr2_0);
            let expr4_0 = constructor_x64_add(ctx, pattern0_0, expr0_0, &expr3_0)?;
            let expr5_0 = C::gpr_to_reg(ctx, expr4_0);
            let expr6_0 = RegMemImm::Reg { reg: expr5_0 };
            let expr7_0 = constructor_mov_rmi_to_xmm(ctx, &expr6_0)?;
            return Some(expr7_0);
        }
        &RegMemImm::Mem {
            addr: ref pattern2_0,
        } => {
            // Rule at src/isa/x64/lower.isle line 719.
            let expr0_0: u64 = 8i128 as u64;
            let expr1_0 = constructor_imm(ctx, pattern0_0, expr0_0)?;
            let expr2_0 = C::gpr_new(ctx, expr1_0);
            let expr3_0 = C::gpr_mem_imm_new(ctx, pattern1_0);
            let expr4_0 = constructor_x64_add(ctx, pattern0_0, expr2_0, &expr3_0)?;
            let expr5_0 = C::gpr_to_reg(ctx, expr4_0);
            let expr6_0 = RegMemImm::Reg { reg: expr5_0 };
            let expr7_0 = constructor_mov_rmi_to_xmm(ctx, &expr6_0)?;
            return Some(expr7_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term sse_and_not.
pub fn constructor_sse_and_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &XmmMem,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == F32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 1118.
        let expr0_0 = constructor_x64_andnps(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    if pattern0_0 == F64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 1119.
        let expr0_0 = constructor_x64_andnpd(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    let pattern0_0 = arg0;
    if let Some((pattern1_0, pattern1_1)) = C::multi_lane(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 1120.
        let expr0_0 = constructor_x64_pandn(ctx, pattern2_0, pattern3_0)?;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term lower_bmask.
pub fn constructor_lower_bmask<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: ValueRegs,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    if pattern0_0 == I128 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/x64/lower.isle line 1230.
        let expr0_0: Type = I64;
        let expr1_0 = constructor_lower_bmask(ctx, expr0_0, pattern2_0, pattern3_0)?;
        let expr2_0: usize = 0i128 as usize;
        let expr3_0 = constructor_value_regs_get_gpr(ctx, expr1_0, expr2_0)?;
        let expr4_0 = C::gpr_to_reg(ctx, expr3_0);
        let expr5_0 = C::gpr_to_reg(ctx, expr3_0);
        let expr6_0 = C::value_regs(ctx, expr4_0, expr5_0);
        return Some(expr6_0);
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        if pattern2_0 == I128 {
            let pattern4_0 = arg2;
            // Rule at src/isa/x64/lower.isle line 1222.
            let expr0_0: usize = 0i128 as usize;
            let expr1_0 = constructor_value_regs_get_gpr(ctx, pattern4_0, expr0_0)?;
            let expr2_0: usize = 1i128 as usize;
            let expr3_0 = constructor_value_regs_get_gpr(ctx, pattern4_0, expr2_0)?;
            let expr4_0: Type = I64;
            let expr5_0 = C::gpr_to_gpr_mem_imm(ctx, expr3_0);
            let expr6_0 = constructor_x64_or(ctx, expr4_0, expr1_0, &expr5_0)?;
            let expr7_0: Type = I64;
            let expr8_0 = C::gpr_to_reg(ctx, expr6_0);
            let expr9_0 = C::value_reg(ctx, expr8_0);
            let expr10_0 = constructor_lower_bmask(ctx, pattern1_0, expr7_0, expr9_0)?;
            return Some(expr10_0);
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = arg2;
            // Rule at src/isa/x64/lower.isle line 1211.
            let expr0_0: usize = 0i128 as usize;
            let expr1_0 = constructor_value_regs_get_gpr(ctx, pattern4_0, expr0_0)?;
            let expr2_0 = constructor_x64_neg_paired(ctx, pattern3_0, expr1_0)?;
            let expr3_0 = C::gpr_to_gpr_mem_imm(ctx, expr1_0);
            let expr4_0 = constructor_x64_sbb_paired(ctx, pattern1_0, expr1_0, &expr3_0)?;
            let expr5_0 = constructor_with_flags(ctx, &expr2_0, &expr4_0)?;
            let expr6_0: usize = 1i128 as usize;
            let expr7_0 = C::value_regs_get(ctx, expr5_0, expr6_0);
            let expr8_0 = C::value_reg(ctx, expr7_0);
            return Some(expr8_0);
        }
    }
    return None;
}

// Generated as internal constructor for term i128_not.
pub fn constructor_i128_not<C: Context>(ctx: &mut C, arg0: Value) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/lower.isle line 1253.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr1_0)?;
    let expr3_0: usize = 1i128 as usize;
    let expr4_0 = constructor_value_regs_get_gpr(ctx, expr0_0, expr3_0)?;
    let expr5_0: Type = I64;
    let expr6_0 = constructor_x64_not(ctx, expr5_0, expr2_0)?;
    let expr7_0: Type = I64;
    let expr8_0 = constructor_x64_not(ctx, expr7_0, expr4_0)?;
    let expr9_0 = constructor_value_gprs(ctx, expr6_0, expr8_0)?;
    return Some(expr9_0);
}

// Generated as internal constructor for term all_ones_or_all_zeros.
pub fn constructor_all_ones_or_all_zeros<C: Context>(ctx: &mut C, arg0: Value) -> Option<bool> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::def_inst(ctx, pattern0_0) {
        let pattern2_0 = C::inst_data(ctx, pattern1_0);
        match &pattern2_0 {
            &InstructionData::UnaryConst {
                opcode: ref pattern3_0,
                constant_handle: pattern3_1,
            } => {
                if let &Opcode::Vconst = pattern3_0 {
                    if let Some(()) = C::vconst_all_ones_or_all_zeros(ctx, pattern3_1) {
                        // Rule at src/isa/x64/lower.isle line 1302.
                        let expr0_0: bool = true;
                        return Some(expr0_0);
                    }
                }
            }
            &InstructionData::FloatCompare {
                opcode: ref pattern3_0,
                args: ref pattern3_1,
                cond: ref pattern3_2,
            } => {
                if let &Opcode::Fcmp = pattern3_0 {
                    let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                    let pattern6_0 = C::value_type(ctx, pattern0_0);
                    if let Some((pattern7_0, pattern7_1)) = C::multi_lane(ctx, pattern6_0) {
                        // Rule at src/isa/x64/lower.isle line 1301.
                        let expr0_0: bool = true;
                        return Some(expr0_0);
                    }
                }
            }
            &InstructionData::IntCompare {
                opcode: ref pattern3_0,
                args: ref pattern3_1,
                cond: ref pattern3_2,
            } => {
                if let &Opcode::Icmp = pattern3_0 {
                    let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                    let pattern6_0 = C::value_type(ctx, pattern0_0);
                    if let Some((pattern7_0, pattern7_1)) = C::multi_lane(ctx, pattern6_0) {
                        // Rule at src/isa/x64/lower.isle line 1300.
                        let expr0_0: bool = true;
                        return Some(expr0_0);
                    }
                }
            }
            _ => {}
        }
    }
    return None;
}

// Generated as internal constructor for term vec_insert_lane.
pub fn constructor_vec_insert_lane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Xmm,
    arg2: &RegMem,
    arg3: u8,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    if pattern0_0 == F64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        if let &RegMem::Reg { reg: pattern4_0 } = pattern3_0 {
            let pattern5_0 = arg3;
            if pattern5_0 == 0i128 as u8 {
                // Rule at src/isa/x64/lower.isle line 1367.
                let expr0_0 = constructor_reg_to_xmm_mem(ctx, pattern4_0)?;
                let expr1_0 = constructor_x64_movsd_regmove(ctx, pattern2_0, &expr0_0)?;
                return Some(expr1_0);
            }
        }
    }
    let pattern0_0 = arg0;
    if pattern0_0 == I8X16 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        // Rule at src/isa/x64/lower.isle line 1329.
        let expr0_0 = C::reg_mem_to_gpr_mem(ctx, pattern3_0);
        let expr1_0 = constructor_x64_pinsrb(ctx, pattern2_0, &expr0_0, pattern4_0)?;
        return Some(expr1_0);
    }
    if pattern0_0 == I16X8 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        // Rule at src/isa/x64/lower.isle line 1333.
        let expr0_0 = C::reg_mem_to_gpr_mem(ctx, pattern3_0);
        let expr1_0 = constructor_x64_pinsrw(ctx, pattern2_0, &expr0_0, pattern4_0)?;
        return Some(expr1_0);
    }
    if pattern0_0 == I32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        // Rule at src/isa/x64/lower.isle line 1337.
        let expr0_0 = C::reg_mem_to_gpr_mem(ctx, pattern3_0);
        let expr1_0 = OperandSize::Size32;
        let expr2_0 = constructor_x64_pinsrd(ctx, pattern2_0, &expr0_0, pattern4_0, &expr1_0)?;
        return Some(expr2_0);
    }
    if pattern0_0 == I64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        // Rule at src/isa/x64/lower.isle line 1341.
        let expr0_0 = C::reg_mem_to_gpr_mem(ctx, pattern3_0);
        let expr1_0 = OperandSize::Size64;
        let expr2_0 = constructor_x64_pinsrd(ctx, pattern2_0, &expr0_0, pattern4_0, &expr1_0)?;
        return Some(expr2_0);
    }
    if pattern0_0 == F32X4 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        // Rule at src/isa/x64/lower.isle line 1345.
        let expr0_0 = C::reg_mem_to_xmm_mem(ctx, pattern3_0);
        let expr1_0 = C::sse_insertps_lane_imm(ctx, pattern4_0);
        let expr2_0 = constructor_x64_insertps(ctx, pattern2_0, &expr0_0, expr1_0)?;
        return Some(expr2_0);
    }
    if pattern0_0 == F64X2 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        if pattern4_0 == 0i128 as u8 {
            // Rule at src/isa/x64/lower.isle line 1369.
            let expr0_0 = C::reg_mem_to_xmm_mem(ctx, pattern3_0);
            let expr1_0 = constructor_x64_movsd_load(ctx, &expr0_0)?;
            let expr2_0 = C::xmm_to_xmm_mem(ctx, expr1_0);
            let expr3_0 = constructor_x64_movsd_regmove(ctx, pattern2_0, &expr2_0)?;
            return Some(expr3_0);
        }
        if pattern4_0 == 1i128 as u8 {
            // Rule at src/isa/x64/lower.isle line 1377.
            let expr0_0 = C::reg_mem_to_xmm_mem(ctx, pattern3_0);
            let expr1_0 = constructor_x64_movlhps(ctx, pattern2_0, &expr0_0)?;
            return Some(expr1_0);
        }
    }
    return None;
}

// Generated as internal constructor for term cmp_and_choose.
pub fn constructor_cmp_and_choose<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &CC,
    arg2: Value,
    arg3: Value,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        // Rule at src/isa/x64/lower.isle line 1385.
        let expr0_0 = C::raw_operand_size_of_type(ctx, pattern1_0);
        let expr1_0 = C::put_in_reg(ctx, pattern3_0);
        let expr2_0 = C::put_in_reg(ctx, pattern4_0);
        let expr3_0 = constructor_reg_to_gpr_mem_imm(ctx, expr1_0)?;
        let expr4_0 = C::gpr_new(ctx, expr2_0);
        let expr5_0 = constructor_x64_cmp(ctx, &expr0_0, &expr3_0, expr4_0)?;
        let expr6_0 = C::reg_to_gpr_mem(ctx, expr2_0);
        let expr7_0 = C::gpr_new(ctx, expr1_0);
        let expr8_0 = constructor_cmove(ctx, pattern1_0, pattern2_0, &expr6_0, expr7_0)?;
        let expr9_0 = constructor_with_flags_reg(ctx, &expr5_0, &expr8_0)?;
        let expr10_0 = C::value_reg(ctx, expr9_0);
        return Some(expr10_0);
    }
    return None;
}

// Generated as internal constructor for term do_clz.
pub fn constructor_do_clz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/lower.isle line 1819.
    let expr0_0: Type = I64;
    let expr1_0: i64 = -1i128 as i64;
    let expr2_0 = constructor_imm_i64(ctx, expr0_0, expr1_0)?;
    let expr3_0 = C::gpr_new(ctx, expr2_0);
    let expr4_0 = constructor_bsr_or_else(ctx, pattern0_0, pattern2_0, expr3_0)?;
    let expr5_0 = C::gpr_to_reg(ctx, expr4_0);
    let expr6_0 = C::ty_bits_u64(ctx, pattern1_0);
    let expr7_0: u64 = 1i128 as u64;
    let expr8_0 = C::u64_sub(ctx, expr6_0, expr7_0)?;
    let expr9_0 = constructor_imm(ctx, pattern0_0, expr8_0)?;
    let expr10_0 = C::gpr_new(ctx, expr9_0);
    let expr11_0 = constructor_reg_to_gpr_mem_imm(ctx, expr5_0)?;
    let expr12_0 = constructor_x64_sub(ctx, pattern0_0, expr10_0, &expr11_0)?;
    return Some(expr12_0);
}

// Generated as internal constructor for term do_ctz.
pub fn constructor_do_ctz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: Gpr,
) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/x64/lower.isle line 1862.
    let expr0_0: Type = I64;
    let expr1_0 = C::ty_bits_u64(ctx, pattern1_0);
    let expr2_0 = constructor_imm(ctx, expr0_0, expr1_0)?;
    let expr3_0 = C::gpr_new(ctx, expr2_0);
    let expr4_0 = constructor_bsf_or_else(ctx, pattern0_0, pattern2_0, expr3_0)?;
    return Some(expr4_0);
}

// Generated as internal constructor for term do_popcnt.
pub fn constructor_do_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        // Rule at src/isa/x64/lower.isle line 1953.
        let expr0_0: Type = I32;
        let expr1_0: u8 = 1i128 as u8;
        let expr2_0 = Imm8Reg::Imm8 { imm: expr1_0 };
        let expr3_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr2_0);
        let expr4_0 = constructor_x64_shr(ctx, expr0_0, pattern2_0, &expr3_0)?;
        let expr5_0: Type = I32;
        let expr6_0: u64 = 2004318071i128 as u64;
        let expr7_0 = constructor_imm(ctx, expr5_0, expr6_0)?;
        let expr8_0 = C::gpr_new(ctx, expr7_0);
        let expr9_0: Type = I32;
        let expr10_0 = C::gpr_to_gpr_mem_imm(ctx, expr8_0);
        let expr11_0 = constructor_x64_and(ctx, expr9_0, expr4_0, &expr10_0)?;
        let expr12_0: Type = I32;
        let expr13_0 = C::gpr_to_gpr_mem_imm(ctx, expr11_0);
        let expr14_0 = constructor_x64_sub(ctx, expr12_0, pattern2_0, &expr13_0)?;
        let expr15_0: Type = I32;
        let expr16_0: u8 = 1i128 as u8;
        let expr17_0 = Imm8Reg::Imm8 { imm: expr16_0 };
        let expr18_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr17_0);
        let expr19_0 = constructor_x64_shr(ctx, expr15_0, expr11_0, &expr18_0)?;
        let expr20_0: Type = I32;
        let expr21_0 = C::gpr_to_gpr_mem_imm(ctx, expr8_0);
        let expr22_0 = constructor_x64_and(ctx, expr20_0, expr19_0, &expr21_0)?;
        let expr23_0: Type = I32;
        let expr24_0 = C::gpr_to_gpr_mem_imm(ctx, expr22_0);
        let expr25_0 = constructor_x64_sub(ctx, expr23_0, expr14_0, &expr24_0)?;
        let expr26_0: Type = I32;
        let expr27_0: u8 = 1i128 as u8;
        let expr28_0 = Imm8Reg::Imm8 { imm: expr27_0 };
        let expr29_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr28_0);
        let expr30_0 = constructor_x64_shr(ctx, expr26_0, expr22_0, &expr29_0)?;
        let expr31_0: Type = I32;
        let expr32_0 = C::gpr_to_gpr_mem_imm(ctx, expr8_0);
        let expr33_0 = constructor_x64_and(ctx, expr31_0, expr30_0, &expr32_0)?;
        let expr34_0: Type = I32;
        let expr35_0 = C::gpr_to_gpr_mem_imm(ctx, expr33_0);
        let expr36_0 = constructor_x64_sub(ctx, expr34_0, expr25_0, &expr35_0)?;
        let expr37_0: Type = I32;
        let expr38_0: Type = I32;
        let expr39_0: u8 = 4i128 as u8;
        let expr40_0 = Imm8Reg::Imm8 { imm: expr39_0 };
        let expr41_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr40_0);
        let expr42_0 = constructor_x64_shr(ctx, expr38_0, expr36_0, &expr41_0)?;
        let expr43_0 = C::gpr_to_gpr_mem_imm(ctx, expr36_0);
        let expr44_0 = constructor_x64_add(ctx, expr37_0, expr42_0, &expr43_0)?;
        let expr45_0: Type = I32;
        let expr46_0: u32 = 252645135i128 as u32;
        let expr47_0 = RegMemImm::Imm { simm32: expr46_0 };
        let expr48_0 = C::gpr_mem_imm_new(ctx, &expr47_0);
        let expr49_0 = constructor_x64_and(ctx, expr45_0, expr44_0, &expr48_0)?;
        let expr50_0: Type = I32;
        let expr51_0: u32 = 16843009i128 as u32;
        let expr52_0 = RegMemImm::Imm { simm32: expr51_0 };
        let expr53_0 = C::gpr_mem_imm_new(ctx, &expr52_0);
        let expr54_0 = constructor_x64_mul(ctx, expr50_0, expr49_0, &expr53_0)?;
        let expr55_0: Type = I32;
        let expr56_0: u8 = 24i128 as u8;
        let expr57_0 = Imm8Reg::Imm8 { imm: expr56_0 };
        let expr58_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr57_0);
        let expr59_0 = constructor_x64_shr(ctx, expr55_0, expr54_0, &expr58_0)?;
        return Some(expr59_0);
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        // Rule at src/isa/x64/lower.isle line 1910.
        let expr0_0: Type = I64;
        let expr1_0: u8 = 1i128 as u8;
        let expr2_0 = Imm8Reg::Imm8 { imm: expr1_0 };
        let expr3_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr2_0);
        let expr4_0 = constructor_x64_shr(ctx, expr0_0, pattern2_0, &expr3_0)?;
        let expr5_0: Type = I64;
        let expr6_0: u64 = 8608480567731124087i128 as u64;
        let expr7_0 = constructor_imm(ctx, expr5_0, expr6_0)?;
        let expr8_0 = C::gpr_new(ctx, expr7_0);
        let expr9_0: Type = I64;
        let expr10_0 = C::gpr_to_gpr_mem_imm(ctx, expr8_0);
        let expr11_0 = constructor_x64_and(ctx, expr9_0, expr4_0, &expr10_0)?;
        let expr12_0: Type = I64;
        let expr13_0 = C::gpr_to_gpr_mem_imm(ctx, expr11_0);
        let expr14_0 = constructor_x64_sub(ctx, expr12_0, pattern2_0, &expr13_0)?;
        let expr15_0: Type = I64;
        let expr16_0: u8 = 1i128 as u8;
        let expr17_0 = Imm8Reg::Imm8 { imm: expr16_0 };
        let expr18_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr17_0);
        let expr19_0 = constructor_x64_shr(ctx, expr15_0, expr11_0, &expr18_0)?;
        let expr20_0: Type = I64;
        let expr21_0 = C::gpr_to_gpr_mem_imm(ctx, expr8_0);
        let expr22_0 = constructor_x64_and(ctx, expr20_0, expr19_0, &expr21_0)?;
        let expr23_0: Type = I64;
        let expr24_0 = C::gpr_to_gpr_mem_imm(ctx, expr22_0);
        let expr25_0 = constructor_x64_sub(ctx, expr23_0, expr14_0, &expr24_0)?;
        let expr26_0: Type = I64;
        let expr27_0: u8 = 1i128 as u8;
        let expr28_0 = Imm8Reg::Imm8 { imm: expr27_0 };
        let expr29_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr28_0);
        let expr30_0 = constructor_x64_shr(ctx, expr26_0, expr22_0, &expr29_0)?;
        let expr31_0: Type = I64;
        let expr32_0 = C::gpr_to_gpr_mem_imm(ctx, expr8_0);
        let expr33_0 = constructor_x64_and(ctx, expr31_0, expr30_0, &expr32_0)?;
        let expr34_0: Type = I64;
        let expr35_0 = C::gpr_to_gpr_mem_imm(ctx, expr33_0);
        let expr36_0 = constructor_x64_sub(ctx, expr34_0, expr25_0, &expr35_0)?;
        let expr37_0: Type = I64;
        let expr38_0: Type = I64;
        let expr39_0: u8 = 4i128 as u8;
        let expr40_0 = Imm8Reg::Imm8 { imm: expr39_0 };
        let expr41_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr40_0);
        let expr42_0 = constructor_x64_shr(ctx, expr38_0, expr36_0, &expr41_0)?;
        let expr43_0 = C::gpr_to_gpr_mem_imm(ctx, expr36_0);
        let expr44_0 = constructor_x64_add(ctx, expr37_0, expr42_0, &expr43_0)?;
        let expr45_0: Type = I64;
        let expr46_0: u64 = 1085102592571150095i128 as u64;
        let expr47_0 = constructor_imm(ctx, expr45_0, expr46_0)?;
        let expr48_0 = C::gpr_new(ctx, expr47_0);
        let expr49_0: Type = I64;
        let expr50_0 = C::gpr_to_gpr_mem_imm(ctx, expr48_0);
        let expr51_0 = constructor_x64_and(ctx, expr49_0, expr44_0, &expr50_0)?;
        let expr52_0: Type = I64;
        let expr53_0: u64 = 72340172838076673i128 as u64;
        let expr54_0 = constructor_imm(ctx, expr52_0, expr53_0)?;
        let expr55_0 = C::gpr_new(ctx, expr54_0);
        let expr56_0: Type = I64;
        let expr57_0 = C::gpr_to_gpr_mem_imm(ctx, expr55_0);
        let expr58_0 = constructor_x64_mul(ctx, expr56_0, expr51_0, &expr57_0)?;
        let expr59_0: Type = I64;
        let expr60_0: u8 = 56i128 as u8;
        let expr61_0 = Imm8Reg::Imm8 { imm: expr60_0 };
        let expr62_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr61_0);
        let expr63_0 = constructor_x64_shr(ctx, expr59_0, expr58_0, &expr62_0)?;
        return Some(expr63_0);
    }
    return None;
}

// Generated as internal constructor for term do_bitrev8.
pub fn constructor_do_bitrev8<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/lower.isle line 2042.
    let expr0_0 = C::ty_mask(ctx, pattern0_0);
    let expr1_0: u64 = 6148914691236517205i128 as u64;
    let expr2_0 = C::u64_and(ctx, expr0_0, expr1_0)?;
    let expr3_0 = constructor_imm(ctx, pattern0_0, expr2_0)?;
    let expr4_0 = C::gpr_new(ctx, expr3_0);
    let expr5_0 = C::gpr_to_gpr_mem_imm(ctx, expr4_0);
    let expr6_0 = constructor_x64_and(ctx, pattern0_0, pattern1_0, &expr5_0)?;
    let expr7_0: u8 = 1i128 as u8;
    let expr8_0 = Imm8Reg::Imm8 { imm: expr7_0 };
    let expr9_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr8_0);
    let expr10_0 = constructor_x64_shr(ctx, pattern0_0, pattern1_0, &expr9_0)?;
    let expr11_0 = C::gpr_to_gpr_mem_imm(ctx, expr4_0);
    let expr12_0 = constructor_x64_and(ctx, pattern0_0, expr10_0, &expr11_0)?;
    let expr13_0: u8 = 1i128 as u8;
    let expr14_0 = Imm8Reg::Imm8 { imm: expr13_0 };
    let expr15_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr14_0);
    let expr16_0 = constructor_x64_shl(ctx, pattern0_0, expr6_0, &expr15_0)?;
    let expr17_0 = C::gpr_to_gpr_mem_imm(ctx, expr12_0);
    let expr18_0 = constructor_x64_or(ctx, pattern0_0, expr16_0, &expr17_0)?;
    let expr19_0: u64 = 3689348814741910323i128 as u64;
    let expr20_0 = C::u64_and(ctx, expr0_0, expr19_0)?;
    let expr21_0 = constructor_imm(ctx, pattern0_0, expr20_0)?;
    let expr22_0 = C::gpr_new(ctx, expr21_0);
    let expr23_0 = C::gpr_to_gpr_mem_imm(ctx, expr22_0);
    let expr24_0 = constructor_x64_and(ctx, pattern0_0, expr18_0, &expr23_0)?;
    let expr25_0: u8 = 2i128 as u8;
    let expr26_0 = Imm8Reg::Imm8 { imm: expr25_0 };
    let expr27_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr26_0);
    let expr28_0 = constructor_x64_shr(ctx, pattern0_0, expr18_0, &expr27_0)?;
    let expr29_0 = C::gpr_to_gpr_mem_imm(ctx, expr22_0);
    let expr30_0 = constructor_x64_and(ctx, pattern0_0, expr28_0, &expr29_0)?;
    let expr31_0: u8 = 2i128 as u8;
    let expr32_0 = Imm8Reg::Imm8 { imm: expr31_0 };
    let expr33_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr32_0);
    let expr34_0 = constructor_x64_shl(ctx, pattern0_0, expr24_0, &expr33_0)?;
    let expr35_0 = C::gpr_to_gpr_mem_imm(ctx, expr30_0);
    let expr36_0 = constructor_x64_or(ctx, pattern0_0, expr34_0, &expr35_0)?;
    let expr37_0: u64 = 1085102592571150095i128 as u64;
    let expr38_0 = C::u64_and(ctx, expr0_0, expr37_0)?;
    let expr39_0 = constructor_imm(ctx, pattern0_0, expr38_0)?;
    let expr40_0 = C::gpr_new(ctx, expr39_0);
    let expr41_0 = C::gpr_to_gpr_mem_imm(ctx, expr40_0);
    let expr42_0 = constructor_x64_and(ctx, pattern0_0, expr36_0, &expr41_0)?;
    let expr43_0: u8 = 4i128 as u8;
    let expr44_0 = Imm8Reg::Imm8 { imm: expr43_0 };
    let expr45_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr44_0);
    let expr46_0 = constructor_x64_shr(ctx, pattern0_0, expr36_0, &expr45_0)?;
    let expr47_0 = C::gpr_to_gpr_mem_imm(ctx, expr40_0);
    let expr48_0 = constructor_x64_and(ctx, pattern0_0, expr46_0, &expr47_0)?;
    let expr49_0: u8 = 4i128 as u8;
    let expr50_0 = Imm8Reg::Imm8 { imm: expr49_0 };
    let expr51_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr50_0);
    let expr52_0 = constructor_x64_shl(ctx, pattern0_0, expr42_0, &expr51_0)?;
    let expr53_0 = C::gpr_to_gpr_mem_imm(ctx, expr48_0);
    let expr54_0 = constructor_x64_or(ctx, pattern0_0, expr52_0, &expr53_0)?;
    return Some(expr54_0);
}

// Generated as internal constructor for term do_bitrev16.
pub fn constructor_do_bitrev16<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/lower.isle line 2065.
    let expr0_0 = constructor_do_bitrev8(ctx, pattern0_0, pattern1_0)?;
    let expr1_0 = C::ty_mask(ctx, pattern0_0);
    let expr2_0: u64 = 71777214294589695i128 as u64;
    let expr3_0 = C::u64_and(ctx, expr1_0, expr2_0)?;
    let expr4_0 = constructor_imm(ctx, pattern0_0, expr3_0)?;
    let expr5_0 = C::gpr_new(ctx, expr4_0);
    let expr6_0 = C::gpr_to_gpr_mem_imm(ctx, expr5_0);
    let expr7_0 = constructor_x64_and(ctx, pattern0_0, expr0_0, &expr6_0)?;
    let expr8_0: u8 = 8i128 as u8;
    let expr9_0 = Imm8Reg::Imm8 { imm: expr8_0 };
    let expr10_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr9_0);
    let expr11_0 = constructor_x64_shr(ctx, pattern0_0, expr0_0, &expr10_0)?;
    let expr12_0 = C::gpr_to_gpr_mem_imm(ctx, expr5_0);
    let expr13_0 = constructor_x64_and(ctx, pattern0_0, expr11_0, &expr12_0)?;
    let expr14_0: u8 = 8i128 as u8;
    let expr15_0 = Imm8Reg::Imm8 { imm: expr14_0 };
    let expr16_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr15_0);
    let expr17_0 = constructor_x64_shl(ctx, pattern0_0, expr7_0, &expr16_0)?;
    let expr18_0 = C::gpr_to_gpr_mem_imm(ctx, expr13_0);
    let expr19_0 = constructor_x64_or(ctx, pattern0_0, expr17_0, &expr18_0)?;
    return Some(expr19_0);
}

// Generated as internal constructor for term do_bitrev32.
pub fn constructor_do_bitrev32<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/lower.isle line 2077.
    let expr0_0 = constructor_do_bitrev16(ctx, pattern0_0, pattern1_0)?;
    let expr1_0 = C::ty_mask(ctx, pattern0_0);
    let expr2_0: u64 = 281470681808895i128 as u64;
    let expr3_0 = C::u64_and(ctx, expr1_0, expr2_0)?;
    let expr4_0 = constructor_imm(ctx, pattern0_0, expr3_0)?;
    let expr5_0 = C::gpr_new(ctx, expr4_0);
    let expr6_0 = C::gpr_to_gpr_mem_imm(ctx, expr5_0);
    let expr7_0 = constructor_x64_and(ctx, pattern0_0, expr0_0, &expr6_0)?;
    let expr8_0: u8 = 16i128 as u8;
    let expr9_0 = Imm8Reg::Imm8 { imm: expr8_0 };
    let expr10_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr9_0);
    let expr11_0 = constructor_x64_shr(ctx, pattern0_0, expr0_0, &expr10_0)?;
    let expr12_0 = C::gpr_to_gpr_mem_imm(ctx, expr5_0);
    let expr13_0 = constructor_x64_and(ctx, pattern0_0, expr11_0, &expr12_0)?;
    let expr14_0: u8 = 16i128 as u8;
    let expr15_0 = Imm8Reg::Imm8 { imm: expr14_0 };
    let expr16_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr15_0);
    let expr17_0 = constructor_x64_shl(ctx, pattern0_0, expr7_0, &expr16_0)?;
    let expr18_0 = C::gpr_to_gpr_mem_imm(ctx, expr13_0);
    let expr19_0 = constructor_x64_or(ctx, pattern0_0, expr17_0, &expr18_0)?;
    return Some(expr19_0);
}

// Generated as internal constructor for term do_bitrev64.
pub fn constructor_do_bitrev64<C: Context>(ctx: &mut C, arg0: Type, arg1: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        // Rule at src/isa/x64/lower.isle line 2089.
        let expr0_0 = constructor_do_bitrev32(ctx, pattern0_0, pattern2_0)?;
        let expr1_0: u64 = 4294967295i128 as u64;
        let expr2_0 = constructor_imm(ctx, pattern0_0, expr1_0)?;
        let expr3_0 = C::gpr_new(ctx, expr2_0);
        let expr4_0 = C::gpr_to_gpr_mem_imm(ctx, expr3_0);
        let expr5_0 = constructor_x64_and(ctx, pattern0_0, expr0_0, &expr4_0)?;
        let expr6_0: u8 = 32i128 as u8;
        let expr7_0 = Imm8Reg::Imm8 { imm: expr6_0 };
        let expr8_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr7_0);
        let expr9_0 = constructor_x64_shr(ctx, pattern0_0, expr0_0, &expr8_0)?;
        let expr10_0: u8 = 32i128 as u8;
        let expr11_0 = Imm8Reg::Imm8 { imm: expr10_0 };
        let expr12_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr11_0);
        let expr13_0 = constructor_x64_shl(ctx, pattern0_0, expr5_0, &expr12_0)?;
        let expr14_0 = C::gpr_to_gpr_mem_imm(ctx, expr9_0);
        let expr15_0 = constructor_x64_or(ctx, pattern0_0, expr13_0, &expr14_0)?;
        return Some(expr15_0);
    }
    return None;
}

// Generated as internal constructor for term generic_sextend.
pub fn constructor_generic_sextend<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Type,
    arg2: Type,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if pattern2_0 == pattern1_0 {
        // Rule at src/isa/x64/lower.isle line 2203.
        let expr0_0 = constructor_output_value(ctx, pattern0_0)?;
        return Some(expr0_0);
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if pattern1_0 == I64 {
        let pattern3_0 = arg2;
        if pattern3_0 == I128 {
            // Rule at src/isa/x64/lower.isle line 2213.
            let expr0_0 = C::put_in_reg(ctx, pattern0_0);
            let expr1_0 = constructor_put_in_gpr(ctx, pattern0_0)?;
            let expr2_0 = constructor_spread_sign_bit(ctx, expr1_0)?;
            let expr3_0 = C::gpr_to_reg(ctx, expr2_0);
            let expr4_0 = C::value_regs(ctx, expr0_0, expr3_0);
            let expr5_0 = C::output(ctx, expr4_0);
            return Some(expr5_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::fits_in_32(ctx, pattern1_0) {
        let pattern3_0 = arg2;
        if pattern3_0 == I128 {
            // Rule at src/isa/x64/lower.isle line 2217.
            let expr0_0: Type = I64;
            let expr1_0 = ExtendKind::Sign;
            let expr2_0 = constructor_extend_to_gpr(ctx, pattern0_0, expr0_0, &expr1_0)?;
            let expr3_0 = constructor_spread_sign_bit(ctx, expr2_0)?;
            let expr4_0 = C::gpr_to_reg(ctx, expr2_0);
            let expr5_0 = C::gpr_to_reg(ctx, expr3_0);
            let expr6_0 = C::value_regs(ctx, expr4_0, expr5_0);
            let expr7_0 = C::output(ctx, expr6_0);
            return Some(expr7_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::fits_in_32(ctx, pattern1_0) {
        let pattern3_0 = arg2;
        if pattern3_0 == I64 {
            // Rule at src/isa/x64/lower.isle line 2223.
            let expr0_0: Type = I64;
            let expr1_0 = ExtendKind::Sign;
            let expr2_0 = constructor_extend_to_gpr(ctx, pattern0_0, expr0_0, &expr1_0)?;
            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
            return Some(expr3_0);
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::fits_in_32(ctx, pattern1_0) {
        let pattern3_0 = arg2;
        if let Some(pattern4_0) = C::fits_in_32(ctx, pattern3_0) {
            // Rule at src/isa/x64/lower.isle line 2227.
            let expr0_0: Type = I32;
            let expr1_0 = ExtendKind::Sign;
            let expr2_0 = constructor_extend_to_gpr(ctx, pattern0_0, expr0_0, &expr1_0)?;
            let expr3_0 = constructor_output_gpr(ctx, expr2_0)?;
            return Some(expr3_0);
        }
    }
    return None;
}

// Generated as internal constructor for term spread_sign_bit.
pub fn constructor_spread_sign_bit<C: Context>(ctx: &mut C, arg0: Gpr) -> Option<Gpr> {
    let pattern0_0 = arg0;
    // Rule at src/isa/x64/lower.isle line 2209.
    let expr0_0: Type = I64;
    let expr1_0: u8 = 63i128 as u8;
    let expr2_0 = Imm8Reg::Imm8 { imm: expr1_0 };
    let expr3_0 = C::imm8_reg_to_imm8_gpr(ctx, &expr2_0);
    let expr4_0 = constructor_x64_sar(ctx, expr0_0, pattern0_0, &expr3_0)?;
    return Some(expr4_0);
}

// Generated as internal constructor for term cmp_zero_i128.
pub fn constructor_cmp_zero_i128<C: Context>(
    ctx: &mut C,
    arg0: &CC,
    arg1: ValueRegs,
) -> Option<IcmpCondResult> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::cc_nz_or_z(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        // Rule at src/isa/x64/lower.isle line 2942.
        let expr0_0: usize = 0i128 as usize;
        let expr1_0 = constructor_value_regs_get_gpr(ctx, pattern2_0, expr0_0)?;
        let expr2_0: usize = 1i128 as usize;
        let expr3_0 = constructor_value_regs_get_gpr(ctx, pattern2_0, expr2_0)?;
        let expr4_0 = OperandSize::Size64;
        let expr5_0: u32 = 0i128 as u32;
        let expr6_0 = RegMemImm::Imm { simm32: expr5_0 };
        let expr7_0 = C::gpr_mem_imm_new(ctx, &expr6_0);
        let expr8_0 = constructor_x64_cmp(ctx, &expr4_0, &expr7_0, expr1_0)?;
        let expr9_0 = CC::Z;
        let expr10_0 = constructor_x64_setcc(ctx, &expr9_0)?;
        let expr11_0 = constructor_with_flags_reg(ctx, &expr8_0, &expr10_0)?;
        let expr12_0 = C::gpr_new(ctx, expr11_0);
        let expr13_0 = OperandSize::Size64;
        let expr14_0: u32 = 0i128 as u32;
        let expr15_0 = RegMemImm::Imm { simm32: expr14_0 };
        let expr16_0 = C::gpr_mem_imm_new(ctx, &expr15_0);
        let expr17_0 = constructor_x64_cmp(ctx, &expr13_0, &expr16_0, expr3_0)?;
        let expr18_0 = CC::Z;
        let expr19_0 = constructor_x64_setcc(ctx, &expr18_0)?;
        let expr20_0 = constructor_with_flags_reg(ctx, &expr17_0, &expr19_0)?;
        let expr21_0 = C::gpr_new(ctx, expr20_0);
        let expr22_0 = OperandSize::Size8;
        let expr23_0 = C::gpr_to_gpr_mem_imm(ctx, expr12_0);
        let expr24_0 = constructor_x64_test(ctx, &expr22_0, &expr23_0, expr21_0)?;
        let expr25_0 = constructor_icmp_cond_result(ctx, &expr24_0, &pattern1_0)?;
        return Some(expr25_0);
    }
    return None;
}

// Generated as internal constructor for term cmp_zero_int_bool_ref.
pub fn constructor_cmp_zero_int_bool_ref<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    let pattern1_0 = C::value_type(ctx, pattern0_0);
    // Rule at src/isa/x64/lower.isle line 2953.
    let expr0_0 = C::raw_operand_size_of_type(ctx, pattern1_0);
    let expr1_0 = constructor_put_in_gpr(ctx, pattern0_0)?;
    let expr2_0 = C::gpr_to_gpr_mem_imm(ctx, expr1_0);
    let expr3_0 = constructor_x64_test(ctx, &expr0_0, &expr2_0, expr1_0)?;
    return Some(expr3_0);
}

// Generated as internal constructor for term lower_splat_32x4.
pub fn constructor_lower_splat_32x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/lower.isle line 3642.
    let expr0_0 = C::put_in_reg_mem(ctx, pattern1_0);
    let expr1_0 = constructor_xmm_uninit_value(ctx)?;
    let expr2_0: u8 = 0i128 as u8;
    let expr3_0 = constructor_vec_insert_lane(ctx, pattern0_0, expr1_0, &expr0_0, expr2_0)?;
    let expr4_0 = C::xmm_to_xmm_mem(ctx, expr3_0);
    let expr5_0: u8 = 0i128 as u8;
    let expr6_0 = OperandSize::Size32;
    let expr7_0 = constructor_x64_pshufd(ctx, &expr4_0, expr5_0, &expr6_0)?;
    return Some(expr7_0);
}

// Generated as internal constructor for term lower_splat_64x2.
pub fn constructor_lower_splat_64x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Option<Xmm> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/x64/lower.isle line 3655.
    let expr0_0 = C::put_in_reg(ctx, pattern1_0);
    let expr1_0 = RegMem::Reg { reg: expr0_0 };
    let expr2_0 = constructor_xmm_uninit_value(ctx)?;
    let expr3_0: u8 = 0i128 as u8;
    let expr4_0 = constructor_vec_insert_lane(ctx, pattern0_0, expr2_0, &expr1_0, expr3_0)?;
    let expr5_0: u8 = 1i128 as u8;
    let expr6_0 = constructor_vec_insert_lane(ctx, pattern0_0, expr4_0, &expr1_0, expr5_0)?;
    return Some(expr6_0);
}
